From be69ceed8c41fe683199361cd8c5e925114e318c Mon Sep 17 00:00:00 2001
From: Li Zhanchao <lizc1023@thundersoft.com>
Date: Sun, 4 Dec 2016 16:06:59 +0800
Subject: [PATCH 2/2] input:touchscreen: support ctp ofilm s3501

Add CTP O-FILM@MCF-055-5514@S3501 driver

Change-Id: I00834e2da271018d3b2f6863b53f703209f7e2c4
Signed-off-by: Li Zhanchao <lizc1023@thundersoft.com>
---
 drivers/input/touchscreen/synaptics_dsx/Kconfig    |    2 +-
 .../input/touchscreen/synaptics_dsx_2.6/Makefile   |   10 +-
 .../synaptics_dsx_2.6/synaptics_dsx_core.c         | 4558 ++++++++++---------
 .../synaptics_dsx_2.6/synaptics_dsx_core.h         |  341 +-
 .../synaptics_dsx_2.6/synaptics_dsx_fw_update.c    | 4559 +++++---------------
 .../synaptics_dsx_2.6/synaptics_dsx_i2c.c          |  699 ++-
 .../synaptics_dsx_2.6/synaptics_dsx_rmi_dev.c      |  409 +-
 .../synaptics_dsx_2.6/synaptics_dsx_spi.c          |  345 +-
 8 files changed, 3756 insertions(+), 7167 deletions(-)

diff --git a/drivers/input/touchscreen/synaptics_dsx/Kconfig b/drivers/input/touchscreen/synaptics_dsx/Kconfig
index 86263fd..5a33e4c 100644
--- a/drivers/input/touchscreen/synaptics_dsx/Kconfig
+++ b/drivers/input/touchscreen/synaptics_dsx/Kconfig
@@ -3,7 +3,7 @@
 #
 menuconfig TOUCHSCREEN_SYNAPTICS_DSX_v21
 	bool "Synaptics DSX touchscreen"
-	default y
+	default n
 	help
 	  Say Y here if you have a Synaptics DSX touchscreen connected
 	  to your system.
diff --git a/drivers/input/touchscreen/synaptics_dsx_2.6/Makefile b/drivers/input/touchscreen/synaptics_dsx_2.6/Makefile
index e5e7215..9eb3beb 100644
--- a/drivers/input/touchscreen/synaptics_dsx_2.6/Makefile
+++ b/drivers/input/touchscreen/synaptics_dsx_2.6/Makefile
@@ -10,8 +10,8 @@ obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI_HID_I2C_v26) += synaptics_dsx_rmi_hid
 obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_CORE_v26) += synaptics_dsx_core.o
 obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI_DEV_v26) += synaptics_dsx_rmi_dev.o
 obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_FW_UPDATE_v26) += synaptics_dsx_fw_update.o
-obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_TEST_REPORTING_v26) += synaptics_dsx_test_reporting.o
-obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_PROXIMITY_v26) += synaptics_dsx_proximity.o
-obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_ACTIVE_PEN_v26) += synaptics_dsx_active_pen.o
-obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_GESTURE_v26) += synaptics_dsx_gesture.o
-obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_VIDEO_v26) += synaptics_dsx_video.o
+#obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_TEST_REPORTING_v26) += synaptics_dsx_test_reporting.o
+#obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_PROXIMITY_v26) += synaptics_dsx_proximity.o
+#obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_ACTIVE_PEN_v26) += synaptics_dsx_active_pen.o
+#obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_GESTURE_v26) += synaptics_dsx_gesture.o
+#obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_VIDEO_v26) += synaptics_dsx_video.o
diff --git a/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_core.c b/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_core.c
index f50371c..de1836f 100644
--- a/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_core.c
+++ b/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_core.c
@@ -1,10 +1,11 @@
 /*
  * Synaptics DSX touchscreen driver
  *
- * Copyright (C) 2012-2015 Synaptics Incorporated. All rights reserved.
+ * Copyright (C) 2012-2016 Synaptics Incorporated
  *
- * Copyright (C) 2012 Alexandra Chin <alexandra.chin@tw.synaptics.com>
- * Copyright (C) 2012 Scott Lin <scott.lin@tw.synaptics.com>
+ * Copyright (C) 2012-2016 Alexandra Chin <alexandra.chin@tw.synaptics.com>
+ * Copyright (C) 2012-2016 Scott Lin <scott.lin@tw.synaptics.com>
+ * Copyright (c) 2014-2016, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -15,20 +16,6 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  * GNU General Public License for more details.
- *
- * INFORMATION CONTAINED IN THIS DOCUMENT IS PROVIDED "AS-IS," AND SYNAPTICS
- * EXPRESSLY DISCLAIMS ALL EXPRESS AND IMPLIED WARRANTIES, INCLUDING ANY
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE,
- * AND ANY WARRANTIES OF NON-INFRINGEMENT OF ANY INTELLECTUAL PROPERTY RIGHTS.
- * IN NO EVENT SHALL SYNAPTICS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES ARISING OUT OF OR IN CONNECTION
- * WITH THE USE OF THE INFORMATION CONTAINED IN THIS DOCUMENT, HOWEVER CAUSED
- * AND BASED ON ANY THEORY OF LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * NEGLIGENCE OR OTHER TORTIOUS ACTION, AND EVEN IF SYNAPTICS WAS ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE. IF A TRIBUNAL OF COMPETENT JURISDICTION DOES
- * NOT PERMIT THE DISCLAIMER OF DIRECT DAMAGES OR ANY OTHER DAMAGES, SYNAPTICS'
- * TOTAL CUMULATIVE LIABILITY TO ANY PARTY SHALL NOT EXCEED ONE HUNDRED U.S.
- * DOLLARS.
  */
 
 #include <linux/kernel.h>
@@ -40,37 +27,41 @@
 #include <linux/gpio.h>
 #include <linux/platform_device.h>
 #include <linux/regulator/consumer.h>
-#include <linux/input/synaptics_dsx_v2_6.h>
+#include <linux/input/synaptics_dsx_v2.h>
 #include "synaptics_dsx_core.h"
+
 #ifdef KERNEL_ABOVE_2_6_38
 #include <linux/input/mt.h>
 #endif
+#if defined(CONFIG_SECURE_TOUCH_SYNAPTICS_DSX_V26)
+#include <linux/errno.h>
+#endif
 
-#define INPUT_PHYS_NAME "synaptics_dsx/touch_input"
-#define STYLUS_PHYS_NAME "synaptics_dsx/stylus"
-
-#define VIRTUAL_KEY_MAP_FILE_NAME "virtualkeys." PLATFORM_DRIVER_NAME
+#define INPUT_PHYS_NAME "synaptics_dsx/input0"
+#define DEBUGFS_DIR_NAME "ts_debug"
+#define RMI4_INFO_MAX_LEN 200
+#define RMI4_STORE_TS_INFO(buf, id, rev, max_tch, fw_ver) \
+			snprintf(buf, RMI4_INFO_MAX_LEN, \
+					"controller\t= synaptics\n" \
+					"model\t\t= %d rev %d\n" \
+					"max_touches\t= %d\n" \
+					"fw_vkey_support\t= NO\n" \
+					"fw_ver\t\t= %d\n", id, \
+					rev, max_tch, fw_ver)
 
 #ifdef KERNEL_ABOVE_2_6_38
 #define TYPE_B_PROTOCOL
 #endif
 
-#define WAKEUP_GESTURE false
-
 #define NO_0D_WHILE_2D
 #define REPORT_2D_Z
 #define REPORT_2D_W
-/*
-#define REPORT_2D_PRESSURE
-*/
 
 #define F12_DATA_15_WORKAROUND
 
+/*
 #define IGNORE_FN_INIT_FAILURE
-
-#define FB_READY_RESET
-#define FB_READY_WAIT_MS 100
-#define FB_READY_TIMEOUT_S 30
+*/
 
 #define RPT_TYPE (1 << 0)
 #define RPT_X_LSB (1 << 1)
@@ -82,17 +73,16 @@
 #define RPT_WY (1 << 7)
 #define RPT_DEFAULT (RPT_TYPE | RPT_X_LSB | RPT_X_MSB | RPT_Y_LSB | RPT_Y_MSB)
 
-#define REBUILD_WORK_DELAY_MS 500 /* ms */
-
-#define EXP_FN_WORK_DELAY_MS 500 /* ms */
+#define EXP_FN_WORK_DELAY_MS 1000 /* ms */
 #define MAX_F11_TOUCH_WIDTH 15
-#define MAX_F12_TOUCH_WIDTH 255
-#define MAX_F12_TOUCH_PRESSURE 255
 
 #define CHECK_STATUS_TIMEOUT_MS 100
 
 #define F01_STD_QUERY_LEN 21
 #define F01_BUID_ID_OFFSET 18
+#define F11_STD_QUERY_LEN 9
+#define F11_STD_CTRL_LEN 10
+#define F11_STD_DATA_LEN 12
 
 #define STATUS_NO_ERROR 0x00
 #define STATUS_RESET_OCCURRED 0x01
@@ -108,31 +98,44 @@
 #define NO_SLEEP_ON (1 << 2)
 #define CONFIGURED (1 << 7)
 
-#define F11_CONTINUOUS_MODE 0x00
-#define F11_WAKEUP_GESTURE_MODE 0x04
-#define F12_CONTINUOUS_MODE 0x00
-#define F12_WAKEUP_GESTURE_MODE 0x02
-#define F12_UDG_DETECT 0x0f
+#define SYNA_F11_MAX		4096
+#define SYNA_F12_MAX		65536
+
+#define SYNA_S332U_PACKAGE_ID		332
+#define SYNA_S332U_PACKAGE_ID_REV		85
+
+static int synaptics_rmi4_f12_set_enables(struct synaptics_rmi4_data *rmi4_data,
+		unsigned short ctrl28);
 
-static int synaptics_rmi4_check_status(struct synaptics_rmi4_data *rmi4_data,
-		bool *was_in_bl_mode);
 static int synaptics_rmi4_free_fingers(struct synaptics_rmi4_data *rmi4_data);
-static int synaptics_rmi4_reset_device(struct synaptics_rmi4_data *rmi4_data,
-		bool rebuild);
+static int synaptics_rmi4_reinit_device(struct synaptics_rmi4_data *rmi4_data);
+static int synaptics_rmi4_reset_device(struct synaptics_rmi4_data *rmi4_data);
 
-#ifdef CONFIG_FB
-static void synaptics_rmi4_fb_notify_resume_work(struct work_struct *work);
-static int synaptics_rmi4_fb_notifier_cb(struct notifier_block *self,
-		unsigned long event, void *data);
-#endif
+static ssize_t synaptics_rmi4_full_pm_cycle_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
 
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#ifndef CONFIG_FB
-#define USE_EARLYSUSPEND
-#endif
-#endif
+static ssize_t synaptics_rmi4_full_pm_cycle_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t synaptics_rmi4_enable_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t synaptics_rmi4_enable_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t synaptics_rmi4_mt_protocol_type_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static ssize_t synaptics_rmi4_ts_info_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+static void synaptics_rmi4_sensor_sleep(struct synaptics_rmi4_data *rmi4_data);
+static void synaptics_rmi4_sensor_wake(struct synaptics_rmi4_data *rmi4_data);
+static int synaptics_rmi4_irq_enable(struct synaptics_rmi4_data *rmi4_data,
+		bool enable);
 
-#ifdef USE_EARLYSUSPEND
+#if defined(CONFIG_FB)
+static int fb_notifier_callback(struct notifier_block *self,
+				unsigned long event, void *data);
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
 static void synaptics_rmi4_early_suspend(struct early_suspend *h);
 
 static void synaptics_rmi4_late_resume(struct early_suspend *h);
@@ -145,6 +148,12 @@ static int synaptics_rmi4_resume(struct device *dev);
 static ssize_t synaptics_rmi4_f01_reset_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t count);
 
+static ssize_t synaptics_rmi4_set_abs_x_axis(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
+static ssize_t synaptics_rmi4_set_abs_y_axis(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+
 static ssize_t synaptics_rmi4_f01_productinfo_show(struct device *dev,
 		struct device_attribute *attr, char *buf);
 
@@ -160,31 +169,19 @@ static ssize_t synaptics_rmi4_0dbutton_show(struct device *dev,
 static ssize_t synaptics_rmi4_0dbutton_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t count);
 
-static ssize_t synaptics_rmi4_suspend_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count);
-
-static ssize_t synaptics_rmi4_wake_gesture_show(struct device *dev,
-		struct device_attribute *attr, char *buf);
-
-static ssize_t synaptics_rmi4_wake_gesture_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count);
-
-static ssize_t synaptics_rmi4_virtual_key_map_show(struct kobject *kobj,
-		struct kobj_attribute *attr, char *buf);
+static irqreturn_t synaptics_rmi4_irq(int irq, void *data);
 
 #if defined(CONFIG_SECURE_TOUCH_SYNAPTICS_DSX_V26)
-static ssize_t synaptics_rmi4_secure_touch_enable_show(struct device *dev,
+static ssize_t synaptics_secure_touch_enable_show(struct device *dev,
 		struct device_attribute *attr, char *buf);
 
-static ssize_t synaptics_rmi4_secure_touch_enable_store(struct device *dev,
+static ssize_t synaptics_secure_touch_enable_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t count);
 
-static ssize_t synaptics_rmi4_secure_touch_show(struct device *dev,
+static ssize_t synaptics_secure_touch_show(struct device *dev,
 		struct device_attribute *attr, char *buf);
 #endif
 
-static irqreturn_t synaptics_rmi4_irq(int irq, void *data);
-
 struct synaptics_rmi4_f01_device_status {
 	union {
 		struct {
@@ -197,152 +194,6 @@ struct synaptics_rmi4_f01_device_status {
 	};
 };
 
-struct synaptics_rmi4_f11_query_0_5 {
-	union {
-		struct {
-			/* query 0 */
-			unsigned char f11_query0_b0__2:3;
-			unsigned char has_query_9:1;
-			unsigned char has_query_11:1;
-			unsigned char has_query_12:1;
-			unsigned char has_query_27:1;
-			unsigned char has_query_28:1;
-
-			/* query 1 */
-			unsigned char num_of_fingers:3;
-			unsigned char has_rel:1;
-			unsigned char has_abs:1;
-			unsigned char has_gestures:1;
-			unsigned char has_sensitibity_adjust:1;
-			unsigned char f11_query1_b7:1;
-
-			/* query 2 */
-			unsigned char num_of_x_electrodes;
-
-			/* query 3 */
-			unsigned char num_of_y_electrodes;
-
-			/* query 4 */
-			unsigned char max_electrodes:7;
-			unsigned char f11_query4_b7:1;
-
-			/* query 5 */
-			unsigned char abs_data_size:2;
-			unsigned char has_anchored_finger:1;
-			unsigned char has_adj_hyst:1;
-			unsigned char has_dribble:1;
-			unsigned char has_bending_correction:1;
-			unsigned char has_large_object_suppression:1;
-			unsigned char has_jitter_filter:1;
-		} __packed;
-		unsigned char data[6];
-	};
-};
-
-struct synaptics_rmi4_f11_query_7_8 {
-	union {
-		struct {
-			/* query 7 */
-			unsigned char has_single_tap:1;
-			unsigned char has_tap_and_hold:1;
-			unsigned char has_double_tap:1;
-			unsigned char has_early_tap:1;
-			unsigned char has_flick:1;
-			unsigned char has_press:1;
-			unsigned char has_pinch:1;
-			unsigned char has_chiral_scroll:1;
-
-			/* query 8 */
-			unsigned char has_palm_detect:1;
-			unsigned char has_rotate:1;
-			unsigned char has_touch_shapes:1;
-			unsigned char has_scroll_zones:1;
-			unsigned char individual_scroll_zones:1;
-			unsigned char has_multi_finger_scroll:1;
-			unsigned char has_multi_finger_scroll_edge_motion:1;
-			unsigned char has_multi_finger_scroll_inertia:1;
-		} __packed;
-		unsigned char data[2];
-	};
-};
-
-struct synaptics_rmi4_f11_query_9 {
-	union {
-		struct {
-			unsigned char has_pen:1;
-			unsigned char has_proximity:1;
-			unsigned char has_large_object_sensitivity:1;
-			unsigned char has_suppress_on_large_object_detect:1;
-			unsigned char has_two_pen_thresholds:1;
-			unsigned char has_contact_geometry:1;
-			unsigned char has_pen_hover_discrimination:1;
-			unsigned char has_pen_hover_and_edge_filters:1;
-		} __packed;
-		unsigned char data[1];
-	};
-};
-
-struct synaptics_rmi4_f11_query_12 {
-	union {
-		struct {
-			unsigned char has_small_object_detection:1;
-			unsigned char has_small_object_detection_tuning:1;
-			unsigned char has_8bit_w:1;
-			unsigned char has_2d_adjustable_mapping:1;
-			unsigned char has_general_information_2:1;
-			unsigned char has_physical_properties:1;
-			unsigned char has_finger_limit:1;
-			unsigned char has_linear_cofficient_2:1;
-		} __packed;
-		unsigned char data[1];
-	};
-};
-
-struct synaptics_rmi4_f11_query_27 {
-	union {
-		struct {
-			unsigned char f11_query27_b0:1;
-			unsigned char has_pen_position_correction:1;
-			unsigned char has_pen_jitter_filter_coefficient:1;
-			unsigned char has_group_decomposition:1;
-			unsigned char has_wakeup_gesture:1;
-			unsigned char has_small_finger_correction:1;
-			unsigned char has_data_37:1;
-			unsigned char f11_query27_b7:1;
-		} __packed;
-		unsigned char data[1];
-	};
-};
-
-struct synaptics_rmi4_f11_ctrl_6_9 {
-	union {
-		struct {
-			unsigned char sensor_max_x_pos_7_0;
-			unsigned char sensor_max_x_pos_11_8:4;
-			unsigned char f11_ctrl7_b4__7:4;
-			unsigned char sensor_max_y_pos_7_0;
-			unsigned char sensor_max_y_pos_11_8:4;
-			unsigned char f11_ctrl9_b4__7:4;
-		} __packed;
-		unsigned char data[4];
-	};
-};
-
-struct synaptics_rmi4_f11_data_1_5 {
-	union {
-		struct {
-			unsigned char x_position_11_4;
-			unsigned char y_position_11_4;
-			unsigned char x_position_3_0:4;
-			unsigned char y_position_3_0:4;
-			unsigned char wx:4;
-			unsigned char wy:4;
-			unsigned char z;
-		} __packed;
-		unsigned char data[5];
-	};
-};
-
 struct synaptics_rmi4_f12_query_5 {
 	union {
 		struct {
@@ -416,18 +267,8 @@ struct synaptics_rmi4_f12_query_8 {
 				unsigned char data14_is_present:1;
 				unsigned char data15_is_present:1;
 			} __packed;
-			struct {
-				unsigned char data16_is_present:1;
-				unsigned char data17_is_present:1;
-				unsigned char data18_is_present:1;
-				unsigned char data19_is_present:1;
-				unsigned char data20_is_present:1;
-				unsigned char data21_is_present:1;
-				unsigned char data22_is_present:1;
-				unsigned char data23_is_present:1;
-			} __packed;
 		};
-		unsigned char data[4];
+		unsigned char data[3];
 	};
 };
 
@@ -456,54 +297,10 @@ struct synaptics_rmi4_f12_ctrl_8 {
 struct synaptics_rmi4_f12_ctrl_23 {
 	union {
 		struct {
-			unsigned char finger_enable:1;
-			unsigned char active_stylus_enable:1;
-			unsigned char palm_enable:1;
-			unsigned char unclassified_object_enable:1;
-			unsigned char hovering_finger_enable:1;
-			unsigned char gloved_finger_enable:1;
-			unsigned char f12_ctr23_00_b6__7:2;
+			unsigned char obj_type_enable;
 			unsigned char max_reported_objects;
-			unsigned char f12_ctr23_02_b0:1;
-			unsigned char report_active_stylus_as_finger:1;
-			unsigned char report_palm_as_finger:1;
-			unsigned char report_unclassified_object_as_finger:1;
-			unsigned char report_hovering_finger_as_finger:1;
-			unsigned char report_gloved_finger_as_finger:1;
-			unsigned char report_narrow_object_swipe_as_finger:1;
-			unsigned char report_handedge_as_finger:1;
-			unsigned char cover_enable:1;
-			unsigned char stylus_enable:1;
-			unsigned char eraser_enable:1;
-			unsigned char small_object_enable:1;
-			unsigned char f12_ctr23_03_b4__7:4;
-			unsigned char report_cover_as_finger:1;
-			unsigned char report_stylus_as_finger:1;
-			unsigned char report_eraser_as_finger:1;
-			unsigned char report_small_object_as_finger:1;
-			unsigned char f12_ctr23_04_b4__7:4;
-		};
-		unsigned char data[5];
-	};
-};
-
-struct synaptics_rmi4_f12_ctrl_31 {
-	union {
-		struct {
-			unsigned char max_x_coord_lsb;
-			unsigned char max_x_coord_msb;
-			unsigned char max_y_coord_lsb;
-			unsigned char max_y_coord_msb;
-			unsigned char rx_pitch_lsb;
-			unsigned char rx_pitch_msb;
-			unsigned char rx_clip_low;
-			unsigned char rx_clip_high;
-			unsigned char wedge_clip_low;
-			unsigned char wedge_clip_high;
-			unsigned char num_of_p;
-			unsigned char num_of_q;
 		};
-		unsigned char data[12];
+		unsigned char data[2];
 	};
 };
 
@@ -526,10 +323,7 @@ struct synaptics_rmi4_f1a_query {
 	union {
 		struct {
 			unsigned char max_button_count:3;
-			unsigned char f1a_query0_b3__4:2;
-			unsigned char has_query4:1;
-			unsigned char has_query3:1;
-			unsigned char has_query2:1;
+			unsigned char reserved:5;
 			unsigned char has_general_control:1;
 			unsigned char has_interrupt_enable:1;
 			unsigned char has_multibutton_select:1;
@@ -543,18 +337,6 @@ struct synaptics_rmi4_f1a_query {
 	};
 };
 
-struct synaptics_rmi4_f1a_query_4 {
-	union {
-		struct {
-			unsigned char has_ctrl19:1;
-			unsigned char f1a_query4_b1__4:4;
-			unsigned char has_ctrl24:1;
-			unsigned char f1a_query4_b6__7:2;
-		} __packed;
-		unsigned char data[1];
-	};
-};
-
 struct synaptics_rmi4_f1a_control_0 {
 	union {
 		struct {
@@ -606,174 +388,454 @@ struct synaptics_rmi4_exp_fn_data {
 
 static struct synaptics_rmi4_exp_fn_data exp_data;
 
-static struct synaptics_dsx_button_map *vir_button_map;
-
 static struct device_attribute attrs[] = {
-	__ATTR(reset, S_IWUSR | S_IWGRP,
+	__ATTR(full_pm_cycle, (S_IRUGO | S_IWUSR | S_IWGRP),
+			synaptics_rmi4_full_pm_cycle_show,
+			synaptics_rmi4_full_pm_cycle_store),
+	__ATTR(reset, (S_IWUSR | S_IWGRP),
 			NULL,
 			synaptics_rmi4_f01_reset_store),
+	__ATTR(set_abs_x_axis, (S_IWUSR | S_IWGRP),
+			NULL,
+			synaptics_rmi4_set_abs_x_axis),
+	__ATTR(set_abs_y_axis, (S_IWUSR | S_IWGRP),
+			NULL,
+			synaptics_rmi4_set_abs_y_axis),
 	__ATTR(productinfo, S_IRUGO,
 			synaptics_rmi4_f01_productinfo_show,
-			NULL),
+			synaptics_rmi4_store_error),
 	__ATTR(buildid, S_IRUGO,
 			synaptics_rmi4_f01_buildid_show,
-			NULL),
+			synaptics_rmi4_store_error),
 	__ATTR(flashprog, S_IRUGO,
 			synaptics_rmi4_f01_flashprog_show,
-			NULL),
+			synaptics_rmi4_store_error),
 	__ATTR(0dbutton, (S_IRUGO | S_IWUSR | S_IWGRP),
 			synaptics_rmi4_0dbutton_show,
 			synaptics_rmi4_0dbutton_store),
-	__ATTR(suspend, S_IWUSR | S_IWGRP,
-			NULL,
-			synaptics_rmi4_suspend_store),
-	__ATTR(wake_gesture, (S_IRUGO | S_IWUSR | S_IWGRP),
-			synaptics_rmi4_wake_gesture_show,
-			synaptics_rmi4_wake_gesture_store),
+	__ATTR(enable, (S_IRUGO | S_IWUSR | S_IWGRP),
+			synaptics_rmi4_enable_show,
+			synaptics_rmi4_enable_store),
+	__ATTR(mt_protocol_type, S_IRUGO,
+			synaptics_rmi4_mt_protocol_type_show,
+			NULL),
+	__ATTR(ts_info, S_IRUGO,
+			synaptics_rmi4_ts_info_show,
+			NULL),
 #if defined(CONFIG_SECURE_TOUCH_SYNAPTICS_DSX_V26)
 	__ATTR(secure_touch_enable, (S_IRUGO | S_IWUSR | S_IWGRP),
-			synaptics_rmi4_secure_touch_enable_show,
-			synaptics_rmi4_secure_touch_enable_store),
+			synaptics_secure_touch_enable_show,
+			synaptics_secure_touch_enable_store),
 	__ATTR(secure_touch, S_IRUGO ,
-			synaptics_rmi4_secure_touch_show,
+			synaptics_secure_touch_show,
 			NULL),
 #endif
 };
 
-static struct kobj_attribute virtual_key_map_attr = {
+#define MAX_BUF_SIZE	256
+#define VKEY_VER_CODE	"0x01"
+
+#define HEIGHT_SCALE_NUM 8
+#define HEIGHT_SCALE_DENOM 10
+
+/* numerator and denomenator for border equations */
+#define BORDER_ADJUST_NUM 3
+#define BORDER_ADJUST_DENOM 4
+
+static struct kobject *vkey_kobj;
+static char *vkey_buf;
+
+static ssize_t vkey_show(struct kobject  *obj,
+	struct kobj_attribute *attr, char *buf)
+{
+	strlcpy(buf, vkey_buf, MAX_BUF_SIZE);
+	return strnlen(buf, MAX_BUF_SIZE);
+}
+
+static struct kobj_attribute vkey_obj_attr = {
 	.attr = {
-		.name = VIRTUAL_KEY_MAP_FILE_NAME,
 		.mode = S_IRUGO,
+		.name = "virtualkeys."PLATFORM_DRIVER_NAME,
 	},
-	.show = synaptics_rmi4_virtual_key_map_show,
+	.show = vkey_show,
 };
 
-#if defined(CONFIG_SECURE_TOUCH_SYNAPTICS_DSX_V26)
-static void synaptics_secure_touch_init(struct synaptics_rmi4_data *data)
+static struct attribute *vkey_attr[] = {
+	&vkey_obj_attr.attr,
+	NULL,
+};
+
+static struct attribute_group vkey_grp = {
+	.attrs = vkey_attr,
+};
+/**
+ * synaptics_rmi4_release_all()
+ *
+ * Called by synaptics_rmi4_suspend()
+ *
+ * Release all touch data during the touch device switch to suspend state.
+ */
+
+static void synaptics_rmi4_release_all(struct synaptics_rmi4_data *rmi4_data)
 {
-	data->st_initialized = 0;
-	init_completion(&data->st_powerdown);
-	init_completion(&data->st_irq_processed);
+	int finger;
+	int max_num_fingers = rmi4_data->num_of_fingers;
 
-	/* Get clocks */
-	data->core_clk = devm_clk_get(data->pdev->dev.parent, "core_clk");
-	if (IS_ERR(data->core_clk)) {
-		dev_warn(data->pdev->dev.parent,
-			"%s: error on clk_get(core_clk): %ld\n", __func__,
-			PTR_ERR(data->core_clk));
-		data->core_clk = NULL;
+	for (finger = 0; finger < max_num_fingers; finger++) {
+		input_mt_slot(rmi4_data->input_dev, finger);
+		input_mt_report_slot_state(rmi4_data->input_dev,
+				MT_TOOL_FINGER, 0);
 	}
 
-	data->iface_clk = devm_clk_get(data->pdev->dev.parent, "iface_clk");
-	if (IS_ERR(data->iface_clk)) {
-		dev_warn(data->pdev->dev.parent,
-			"%s: error on clk_get(iface_clk): %ld\n", __func__,
-			PTR_ERR(data->iface_clk));
-		data->iface_clk = NULL;
+	input_report_key(rmi4_data->input_dev, BTN_TOUCH, 0);
+	input_report_key(rmi4_data->input_dev,
+			BTN_TOOL_FINGER, 0);
+
+	input_sync(rmi4_data->input_dev);
+}
+
+/***************add  sysfy 20150820****************************/
+static bool synaptics_rmi4_debug_addr_is_valid(int addr)
+{
+	if (addr < 0 || addr > 0xFFFF) {
+		pr_err("synaptics_rmi4 reg address is invalid: 0x%x\n", addr);
+		return false;
 	}
 
-	data->st_initialized = 1;
+	return true;
 }
+static int debug_dump_info(struct seq_file *m, void *v)
+{
+	struct synaptics_rmi4_data *data = m->private;
 
-static void synaptics_secure_touch_notify(struct synaptics_rmi4_data *rmi4_data)
+	seq_printf(m, "%s\n", data->ts_info);
+
+	return 0;
+}
+
+static int debugfs_dump_info_open(struct inode *inode, struct file *file)
 {
-	sysfs_notify(&rmi4_data->input_dev->dev.kobj, NULL, "secure_touch");
+	return single_open(file, debug_dump_info, inode->i_private);
 }
 
-static irqreturn_t synaptics_filter_interrupt(
-	struct synaptics_rmi4_data *rmi4_data)
+static const struct file_operations debug_dump_info_fops = {
+	.owner = THIS_MODULE,
+	.open = debugfs_dump_info_open,
+	.read = seq_read,
+	.release = single_release,
+};
+
+static ssize_t synaptics_rmi4_enable_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
 {
-	if (atomic_read(&rmi4_data->st_enabled)) {
-		if (atomic_cmpxchg(&rmi4_data->st_pending_irqs, 0, 1) == 0) {
-			reinit_completion(&rmi4_data->st_irq_processed);
-			synaptics_secure_touch_notify(rmi4_data);
-			wait_for_completion_interruptible(
-				&rmi4_data->st_irq_processed);
-		}
-		return IRQ_HANDLED;
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+
+	if (rmi4_data->suspended) {
+		dev_info(rmi4_data->pdev->dev.parent, "Already in suspend state\n");
+		return snprintf(buf, 4, "%s\n", "0");
 	}
-	return IRQ_NONE;
+
+	return snprintf(buf, 4, "%s\n", rmi4_data->enable ? "1" : "0");
 }
 
-/*
- * 'blocking' variable will have value 'true' when we want to prevent the driver
- * from accessing the xPU/SMMU protected HW resources while the session is
- * active.
- */
-static void synaptics_secure_touch_stop(struct synaptics_rmi4_data *rmi4_data,
-					bool blocking)
+
+static ssize_t synaptics_rmi4_enable_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
 {
-	if (atomic_read(&rmi4_data->st_enabled)) {
-		atomic_set(&rmi4_data->st_pending_irqs, -1);
-		synaptics_secure_touch_notify(rmi4_data);
-		if (blocking)
-			wait_for_completion_interruptible(
-				&rmi4_data->st_powerdown);
+	struct synaptics_rmi4_data *data = dev_get_drvdata(dev);
+	unsigned long val;
+	int rc;
+
+	if (count > 2)
+		return -EINVAL;
+
+	if (data->suspended) {
+		dev_info(data->pdev->dev.parent, "Already in suspend state\n");
+		goto no_operation;
+	}
+
+	rc = kstrtoul(buf, 10, &val);
+	if (rc != 0)
+		return rc;
+
+	if (val) {
+		synaptics_rmi4_sensor_wake(data);
+		data->touch_stopped = false;
+		synaptics_rmi4_irq_enable(data, true);
+
+		data->enable = true;
+	} else {
+		if (!data->sensor_sleep) {
+			data->touch_stopped = true;
+			synaptics_rmi4_irq_enable(data, false);
+			synaptics_rmi4_sensor_sleep(data);
+		}
+
+		synaptics_rmi4_release_all(data);
+		data->enable = false;
 	}
+no_operation:
+	return count;
 }
 
-#else
-static void synaptics_secure_touch_init(struct synaptics_rmi4_data *rmi4_data)
+static ssize_t synaptics_rmi4_mt_protocol_type_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
 {
+	return snprintf(buf, 16, "%s\n", "MT Protocol B");
 }
 
-static irqreturn_t synaptics_filter_interrupt(
-				struct synaptics_rmi4_data *rmi4_data)
+static ssize_t synaptics_rmi4_ts_info_show(struct device *dev,
+		 struct device_attribute *attr, char *buf)
 {
-	return IRQ_NONE;
+	struct synaptics_rmi4_data *data = dev_get_drvdata(dev);
+
+	return snprintf(buf, RMI4_INFO_MAX_LEN, "%s\n", data->ts_info);
 }
 
-static void synaptics_secure_touch_stop(struct synaptics_rmi4_data *rmi4_data,
-					bool blocking)
+/********************debug*************************/
+static void synaptics_rmi4_update_ts_info(struct synaptics_rmi4_data *rmi4_data)
 {
+	unsigned char pkg_id[4];
+	unsigned int build_id;
+	struct synaptics_rmi4_device_info *rmi;
+	/* read device package id */
+	synaptics_rmi4_reg_read(rmi4_data,
+			rmi4_data->f01_query_base_addr + 17,
+			pkg_id,
+			sizeof(pkg_id));
+	rmi = &(rmi4_data->rmi4_mod_info);
+
+	build_id = (unsigned int)rmi->build_id[0] +
+		(unsigned int)rmi->build_id[1] * 0x100 +
+		(unsigned int)rmi->build_id[2] * 0x10000;
+
+	RMI4_STORE_TS_INFO(rmi4_data->ts_info, pkg_id[1] << 8 | pkg_id[0],
+			pkg_id[3] << 8 | pkg_id[2], rmi4_data->num_of_fingers,
+			build_id);
 }
-#endif
 
-#if defined(CONFIG_SECURE_TOUCH_SYNAPTICS_DSX_V26)
-static ssize_t synaptics_rmi4_secure_touch_enable_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
+static int synaptics_rmi4_debug_data_set(void *_data, u64 val)
 {
-	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+	struct synaptics_rmi4_data *data = _data;
 
-	return scnprintf(buf, PAGE_SIZE, "%d",
-			atomic_read(&rmi4_data->st_enabled));
+	mutex_lock(&data->input_dev->mutex);
+
+	if (synaptics_rmi4_debug_addr_is_valid(data->addr))
+		dev_info(data->pdev->dev.parent,
+				"Writing into synaptics_rmi4 registers not supported\n");
+
+	mutex_unlock(&data->input_dev->mutex);
+
+	return 0;
 }
-/*
- * Accept only "0" and "1" valid values.
- * "0" will reset the st_enabled flag, then wake up the reading process and
- * the interrupt handler.
- * The bus driver is notified via pm_runtime that it is not required to stay
- * awake anymore.
- * It will also make sure the queue of events is emptied in the controller,
- * in case a touch happened in between the secure touch being disabled and
- * the local ISR being ungated.
- * "1" will set the st_enabled flag and clear the st_pending_irqs flag.
- * The bus driver is requested via pm_runtime to stay awake.
- */
-static ssize_t synaptics_rmi4_secure_touch_enable_store(struct device *dev,
-				    struct device_attribute *attr,
-				    const char *buf, size_t count)
+
+static int synaptics_rmi4_debug_data_get(void *_data, u64 *val)
 {
-	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
-	unsigned long value;
-	int err = 0;
+	struct synaptics_rmi4_data *data = _data;
+	int rc;
+	unsigned char reg;
+
+	mutex_lock(&data->input_dev->mutex);
+
+	if (synaptics_rmi4_debug_addr_is_valid(data->addr)) {
+		rc = synaptics_rmi4_reg_read(data, data->addr,
+						&reg, sizeof(reg));
+		if (rc < 0)
+			dev_err(data->pdev->dev.parent,
+					"synaptics_rmi4 read register 0x%x failed (%d)\n",
+					data->addr, rc);
+		else
+			*val = reg;
+	}
 
-	if (count > 2)
-		return -EINVAL;
+	mutex_unlock(&data->input_dev->mutex);
 
-	err = kstrtoul(buf, 10, &value);
-	if (err != 0)
-		return err;
+	return 0;
+}
 
-	if (!rmi4_data->st_initialized)
-		return -EIO;
+DEFINE_SIMPLE_ATTRIBUTE(debug_data_fops, synaptics_rmi4_debug_data_get,
+			synaptics_rmi4_debug_data_set, "0x%02llX\n");
 
-	err = count;
+static int synaptics_rmi4_debug_addr_set(void *_data, u64 val)
+{
+	struct synaptics_rmi4_data *data = _data;
 
-	switch (value) {
-	case 0:
-		if (atomic_read(&rmi4_data->st_enabled) == 0)
-			break;
+	if (synaptics_rmi4_debug_addr_is_valid(val)) {
+		mutex_lock(&data->input_dev->mutex);
+		data->addr = val;
+		mutex_unlock(&data->input_dev->mutex);
+	}
+
+	return 0;
+}
+
+static int synaptics_rmi4_debug_addr_get(void *_data, u64 *val)
+{
+	struct synaptics_rmi4_data *data = _data;
+
+	mutex_lock(&data->input_dev->mutex);
+
+	if (synaptics_rmi4_debug_addr_is_valid(data->addr))
+		*val = data->addr;
+
+	mutex_unlock(&data->input_dev->mutex);
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(debug_addr_fops, synaptics_rmi4_debug_addr_get,
+		synaptics_rmi4_debug_addr_set, "0x%04llX\n");
+
+static int synaptics_rmi4_debug_suspend_set(void *_data, u64 val)
+{
+	struct synaptics_rmi4_data *rmi4_data = _data;
+
+	if (val)
+		synaptics_rmi4_suspend(&rmi4_data->input_dev->dev);
+	else
+		synaptics_rmi4_resume(&rmi4_data->input_dev->dev);
+
+	return 0;
+}
+
+static int synaptics_rmi4_debug_suspend_get(void *_data, u64 *val)
+{
+	struct synaptics_rmi4_data *rmi4_data = _data;
+
+	*val = rmi4_data->suspended;
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(debug_suspend_fops, synaptics_rmi4_debug_suspend_get,
+			synaptics_rmi4_debug_suspend_set, "%lld\n");
+
+#if defined(CONFIG_SECURE_TOUCH_SYNAPTICS_DSX_V26)
+static void synaptics_secure_touch_init(struct synaptics_rmi4_data *data)
+{
+	int ret = 0;
+
+	data->st_initialized = 0;
+	init_completion(&data->st_powerdown);
+	init_completion(&data->st_irq_processed);
+	/* Get clocks */
+	data->core_clk = clk_get(data->pdev->dev.parent, "core_clk");
+	if (IS_ERR(data->core_clk)) {
+		ret = PTR_ERR(data->core_clk);
+		dev_err(data->pdev->dev.parent,
+			"%s: error on clk_get(core_clk):%d\n", __func__, ret);
+		return;
+	}
+
+	data->iface_clk = clk_get(data->pdev->dev.parent, "iface_clk");
+	if (IS_ERR(data->iface_clk)) {
+		ret = PTR_ERR(data->iface_clk);
+		dev_err(data->pdev->dev.parent,
+			"%s: error on clk_get(iface_clk):%d\n", __func__, ret);
+		goto err_iface_clk;
+	}
+
+	data->st_initialized = 1;
+	return;
+
+err_iface_clk:
+		clk_put(data->core_clk);
+		data->core_clk = NULL;
+}
+static void synaptics_secure_touch_notify(struct synaptics_rmi4_data *rmi4_data)
+{
+	sysfs_notify(&rmi4_data->input_dev->dev.kobj, NULL, "secure_touch");
+}
+static irqreturn_t synaptics_filter_interrupt(
+	struct synaptics_rmi4_data *rmi4_data)
+{
+	if (atomic_read(&rmi4_data->st_enabled)) {
+		if (atomic_cmpxchg(&rmi4_data->st_pending_irqs, 0, 1) == 0) {
+			reinit_completion(&rmi4_data->st_irq_processed);
+			synaptics_secure_touch_notify(rmi4_data);
+			wait_for_completion_interruptible(
+				&rmi4_data->st_irq_processed);
+		}
+		return IRQ_HANDLED;
+	}
+	return IRQ_NONE;
+}
+static void synaptics_secure_touch_stop(
+	struct synaptics_rmi4_data *rmi4_data,
+	int blocking)
+{
+	if (atomic_read(&rmi4_data->st_enabled)) {
+		atomic_set(&rmi4_data->st_pending_irqs, -1);
+		synaptics_secure_touch_notify(rmi4_data);
+		if (blocking)
+			wait_for_completion_interruptible(
+				&rmi4_data->st_powerdown);
+	}
+}
+#else
+static void synaptics_secure_touch_init(struct synaptics_rmi4_data *rmi4_data)
+{
+}
+static irqreturn_t synaptics_filter_interrupt(
+	struct synaptics_rmi4_data *rmi4_data)
+{
+	return IRQ_NONE;
+}
+static void synaptics_secure_touch_stop(
+	struct synaptics_rmi4_data *rmi4_data,
+	int blocking)
+{
+}
+#endif
+
+#if defined(CONFIG_SECURE_TOUCH_SYNAPTICS_DSX_V26)
+static ssize_t synaptics_secure_touch_enable_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+
+	return scnprintf(
+		buf,
+		PAGE_SIZE,
+		"%d",
+		atomic_read(&rmi4_data->st_enabled));
+}
+/*
+ * Accept only "0" and "1" valid values.
+ * "0" will reset the st_enabled flag, then wake up the reading process and
+ * the interrupt handler.
+ * The bus driver is notified via pm_runtime that it is not required to stay
+ * awake anymore.
+ * It will also make sure the queue of events is emptied in the controller,
+ * in case a touch happened in between the secure touch being disabled and
+ * the local ISR being ungated.
+ * "1" will set the st_enabled flag and clear the st_pending_irqs flag.
+ * The bus driver is requested via pm_runtime to stay awake.
+ */
+static ssize_t synaptics_secure_touch_enable_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+	unsigned long value;
+	int err = 0;
+
+	if (count > 2)
+		return -EINVAL;
+
+	err = kstrtoul(buf, 10, &value);
+	if (err != 0)
+		return err;
+
+	if (!rmi4_data->st_initialized)
+		return -EIO;
+
+	err = count;
+
+	switch (value) {
+	case 0:
+		if (atomic_read(&rmi4_data->st_enabled) == 0)
+			break;
 
 		synaptics_rmi4_bus_put(rmi4_data);
 		atomic_set(&rmi4_data->st_enabled, 0);
@@ -825,7 +887,7 @@ static ssize_t synaptics_rmi4_secure_touch_enable_store(struct device *dev,
  * - st_pending_irqs is 0 (only remaining case left) if the pending interrupt
  *   has been processed, so the interrupt handler can be allowed to continue.
  */
-static ssize_t synaptics_rmi4_secure_touch_show(struct device *dev,
+static ssize_t synaptics_secure_touch_show(struct device *dev,
 				    struct device_attribute *attr, char *buf)
 {
 	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
@@ -847,6 +909,65 @@ static ssize_t synaptics_rmi4_secure_touch_show(struct device *dev,
 }
 #endif
 
+static ssize_t synaptics_rmi4_full_pm_cycle_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%u\n",
+			rmi4_data->full_pm_cycle);
+}
+
+static ssize_t synaptics_rmi4_full_pm_cycle_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int input;
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+
+	if (kstrtouint(buf, 10, &input) != 1)
+		return -EINVAL;
+
+	rmi4_data->full_pm_cycle = input > 0 ? 1 : 0;
+
+	return count;
+}
+
+static ssize_t synaptics_rmi4_set_abs_x_axis(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int input;
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+
+	if (kstrtouint(buf, 10, &input) != 1)
+		return -EINVAL;
+
+	if (input == 0)
+		return -EINVAL;
+
+	input_set_abs_params(rmi4_data->input_dev, ABS_MT_POSITION_X,
+			0, input, 0, 0);
+
+	return count;
+}
+
+static ssize_t synaptics_rmi4_set_abs_y_axis(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int input;
+	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+
+	if (kstrtouint(buf, 10, &input) != 1)
+		return -EINVAL;
+
+	if (input == 0)
+		return -EINVAL;
+
+	input_set_abs_params(rmi4_data->input_dev, ABS_MT_POSITION_Y,
+			0, input, 0, 0);
+
+	return count;
+}
+
 static ssize_t synaptics_rmi4_f01_reset_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t count)
 {
@@ -854,13 +975,13 @@ static ssize_t synaptics_rmi4_f01_reset_store(struct device *dev,
 	unsigned int reset;
 	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
 
-	if (sscanf(buf, "%u", &reset) != 1)
+	if (kstrtouint(buf, 10, &reset) != 1)
 		return -EINVAL;
 
 	if (reset != 1)
 		return -EINVAL;
 
-	retval = synaptics_rmi4_reset_device(rmi4_data, false);
+	retval = synaptics_rmi4_reset_device(rmi4_data);
 	if (retval < 0) {
 		dev_err(rmi4_data->pdev->dev.parent,
 				"%s: Failed to issue reset command, error = %d\n",
@@ -934,7 +1055,7 @@ static ssize_t synaptics_rmi4_0dbutton_store(struct device *dev,
 
 	rmi = &(rmi4_data->rmi4_mod_info);
 
-	if (sscanf(buf, "%u", &input) != 1)
+	if (kstrtouint(buf, 10, &input) != 1)
 		return -EINVAL;
 
 	input = input > 0 ? 1 : 0;
@@ -975,71 +1096,17 @@ static ssize_t synaptics_rmi4_0dbutton_store(struct device *dev,
 	return count;
 }
 
-static ssize_t synaptics_rmi4_suspend_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	unsigned int input;
-
-	if (sscanf(buf, "%u", &input) != 1)
-		return -EINVAL;
-
-	if (input == 1)
-		synaptics_rmi4_suspend(dev);
-	else if (input == 0)
-		synaptics_rmi4_resume(dev);
-	else
-		return -EINVAL;
-
-	return count;
-}
-
-static ssize_t synaptics_rmi4_wake_gesture_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
-
-	return snprintf(buf, PAGE_SIZE, "%u\n",
-			rmi4_data->enable_wakeup_gesture);
-}
-
-static ssize_t synaptics_rmi4_wake_gesture_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	unsigned int input;
-	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
-
-	if (sscanf(buf, "%u", &input) != 1)
-		return -EINVAL;
-
-	input = input > 0 ? 1 : 0;
-
-	if (rmi4_data->f11_wakeup_gesture || rmi4_data->f12_wakeup_gesture)
-		rmi4_data->enable_wakeup_gesture = input;
-
-	return count;
-}
-
-static ssize_t synaptics_rmi4_virtual_key_map_show(struct kobject *kobj,
-		struct kobj_attribute *attr, char *buf)
-{
-	int ii;
-	int cnt;
-	int count = 0;
-
-	for (ii = 0; ii < vir_button_map->nbuttons; ii++) {
-		cnt = snprintf(buf, PAGE_SIZE - count, "0x01:%d:%d:%d:%d:%d\n",
-				vir_button_map->map[ii * 5 + 0],
-				vir_button_map->map[ii * 5 + 1],
-				vir_button_map->map[ii * 5 + 2],
-				vir_button_map->map[ii * 5 + 3],
-				vir_button_map->map[ii * 5 + 4]);
-		buf += cnt;
-		count += cnt;
-	}
-
-	return count;
-}
-
+ /**
+ * synaptics_rmi4_f11_abs_report()
+ *
+ * Called by synaptics_rmi4_report_touch() when valid Function $11
+ * finger data has been detected.
+ *
+ * This function reads the Function $11 data registers, determines the
+ * status of each finger supported by the Function, processes any
+ * necessary coordinate manipulation, reports the finger data to
+ * the input subsystem, and returns the number of fingers detected.
+ */
 static int synaptics_rmi4_f11_abs_report(struct synaptics_rmi4_data *rmi4_data,
 		struct synaptics_rmi4_fn *fhandler)
 {
@@ -1051,8 +1118,9 @@ static int synaptics_rmi4_f11_abs_report(struct synaptics_rmi4_data *rmi4_data,
 	unsigned char num_of_finger_status_regs;
 	unsigned char finger_shift;
 	unsigned char finger_status;
+	unsigned char data_reg_blk_size;
 	unsigned char finger_status_reg[3];
-	unsigned char detected_gestures;
+	unsigned char data[F11_STD_DATA_LEN];
 	unsigned short data_addr;
 	unsigned short data_offset;
 	int x;
@@ -1060,8 +1128,6 @@ static int synaptics_rmi4_f11_abs_report(struct synaptics_rmi4_data *rmi4_data,
 	int wx;
 	int wy;
 	int temp;
-	struct synaptics_rmi4_f11_data_1_5 data;
-	struct synaptics_rmi4_f11_extra_data *extra_data;
 
 	/*
 	 * The number of finger status registers is determined by the
@@ -1072,27 +1138,7 @@ static int synaptics_rmi4_f11_abs_report(struct synaptics_rmi4_data *rmi4_data,
 	fingers_supported = fhandler->num_of_data_points;
 	num_of_finger_status_regs = (fingers_supported + 3) / 4;
 	data_addr = fhandler->full_addr.data_base;
-
-	extra_data = (struct synaptics_rmi4_f11_extra_data *)fhandler->extra;
-
-	if (rmi4_data->suspend && rmi4_data->enable_wakeup_gesture) {
-		retval = synaptics_rmi4_reg_read(rmi4_data,
-				data_addr + extra_data->data38_offset,
-				&detected_gestures,
-				sizeof(detected_gestures));
-		if (retval < 0)
-			return 0;
-
-		if (detected_gestures) {
-			input_report_key(rmi4_data->input_dev, KEY_WAKEUP, 1);
-			input_sync(rmi4_data->input_dev);
-			input_report_key(rmi4_data->input_dev, KEY_WAKEUP, 0);
-			input_sync(rmi4_data->input_dev);
-			rmi4_data->suspend = false;
-		}
-
-		return 0;
-	}
+	data_reg_blk_size = fhandler->size_of_data_register_block;
 
 	retval = synaptics_rmi4_reg_read(rmi4_data,
 			data_addr,
@@ -1101,8 +1147,6 @@ static int synaptics_rmi4_f11_abs_report(struct synaptics_rmi4_data *rmi4_data,
 	if (retval < 0)
 		return 0;
 
-	mutex_lock(&(rmi4_data->rmi4_report_mutex));
-
 	for (finger = 0; finger < fingers_supported; finger++) {
 		reg_index = finger / 4;
 		finger_shift = (finger % 4) * 2;
@@ -1125,20 +1169,18 @@ static int synaptics_rmi4_f11_abs_report(struct synaptics_rmi4_data *rmi4_data,
 		if (finger_status) {
 			data_offset = data_addr +
 					num_of_finger_status_regs +
-					(finger * sizeof(data.data));
+					(finger * data_reg_blk_size);
 			retval = synaptics_rmi4_reg_read(rmi4_data,
 					data_offset,
-					data.data,
-					sizeof(data.data));
-			if (retval < 0) {
-				touch_count = 0;
-				goto exit;
-			}
+					data,
+					data_reg_blk_size);
+			if (retval < 0)
+				return 0;
 
-			x = (data.x_position_11_4 << 4) | data.x_position_3_0;
-			y = (data.y_position_11_4 << 4) | data.y_position_3_0;
-			wx = data.wx;
-			wy = data.wy;
+			x = (data[0] << 4) | (data[2] & MASK_4BIT);
+			y = (data[1] << 4) | ((data[2] >> 4) & MASK_4BIT);
+			wx = (data[3] & MASK_4BIT);
+			wy = (data[3] >> 4) & MASK_4BIT;
 
 			if (rmi4_data->hw_if->board_data->swap_axes) {
 				temp = x;
@@ -1173,7 +1215,12 @@ static int synaptics_rmi4_f11_abs_report(struct synaptics_rmi4_data *rmi4_data,
 #endif
 
 			dev_dbg(rmi4_data->pdev->dev.parent,
-					"%s: Finger %d: status = 0x%02x, x = %d, y = %d, wx = %d, wy = %d\n",
+					"%s: Finger %d:\n"
+					"status = 0x%02x\n"
+					"x = %d\n"
+					"y = %d\n"
+					"wx = %d\n"
+					"wy = %d\n",
 					__func__, finger,
 					finger_status,
 					x, y, wx, wy);
@@ -1194,39 +1241,40 @@ static int synaptics_rmi4_f11_abs_report(struct synaptics_rmi4_data *rmi4_data,
 
 	input_sync(rmi4_data->input_dev);
 
-exit:
-	mutex_unlock(&(rmi4_data->rmi4_report_mutex));
-
 	return touch_count;
 }
 
+ /**
+ * synaptics_rmi4_f12_abs_report()
+ *
+ * Called by synaptics_rmi4_report_touch() when valid Function $12
+ * finger data has been detected.
+ *
+ * This function reads the Function $12 data registers, determines the
+ * status of each finger supported by the Function, processes any
+ * necessary coordinate manipulation, reports the finger data to
+ * the input subsystem, and returns the number of fingers detected.
+ */
 static int synaptics_rmi4_f12_abs_report(struct synaptics_rmi4_data *rmi4_data,
 		struct synaptics_rmi4_fn *fhandler)
 {
 	int retval;
 	unsigned char touch_count = 0; /* number of touch points */
-	unsigned char index;
 	unsigned char finger;
 	unsigned char fingers_to_process;
 	unsigned char finger_status;
 	unsigned char size_of_2d_data;
-	unsigned char gesture_type;
 	unsigned short data_addr;
 	int x;
 	int y;
 	int wx;
 	int wy;
 	int temp;
-#ifdef REPORT_2D_PRESSURE
-	int pressure;
-#endif
 	struct synaptics_rmi4_f12_extra_data *extra_data;
 	struct synaptics_rmi4_f12_finger_data *data;
 	struct synaptics_rmi4_f12_finger_data *finger_data;
-	static unsigned char finger_presence;
-	static unsigned char stylus_presence;
 #ifdef F12_DATA_15_WORKAROUND
-	static unsigned char objects_already_present;
+	static unsigned char fingers_already_present;
 #endif
 
 	fingers_to_process = fhandler->num_of_data_points;
@@ -1234,26 +1282,6 @@ static int synaptics_rmi4_f12_abs_report(struct synaptics_rmi4_data *rmi4_data,
 	extra_data = (struct synaptics_rmi4_f12_extra_data *)fhandler->extra;
 	size_of_2d_data = sizeof(struct synaptics_rmi4_f12_finger_data);
 
-	if (rmi4_data->suspend && rmi4_data->enable_wakeup_gesture) {
-		retval = synaptics_rmi4_reg_read(rmi4_data,
-				data_addr + extra_data->data4_offset,
-				rmi4_data->gesture_detection,
-				sizeof(rmi4_data->gesture_detection));
-		if (retval < 0)
-			return 0;
-
-		gesture_type = rmi4_data->gesture_detection[0];
-
-		if (gesture_type && gesture_type != F12_UDG_DETECT) {
-			input_report_key(rmi4_data->input_dev, KEY_WAKEUP, 1);
-			input_sync(rmi4_data->input_dev);
-			input_report_key(rmi4_data->input_dev, KEY_WAKEUP, 0);
-			input_sync(rmi4_data->input_dev);
-			rmi4_data->suspend = false;
-		}
-
-		return 0;
-	}
 
 	/* Determine the total number of fingers to process */
 	if (extra_data->data15_size) {
@@ -1265,35 +1293,37 @@ static int synaptics_rmi4_f12_abs_report(struct synaptics_rmi4_data *rmi4_data,
 			return 0;
 
 		/* Start checking from the highest bit */
-		index = extra_data->data15_size - 1; /* Highest byte */
-		finger = (fingers_to_process - 1) % 8; /* Highest bit */
-		do {
-			if (extra_data->data15_data[index] & (1 << finger))
-				break;
-
-			if (finger) {
-				finger--;
-			} else if (index > 0) {
-				index--; /* Move to the next lower byte */
-				finger = 7;
-			}
+		temp = extra_data->data15_size - 1; /* Highest byte */
+		if ((temp >= 0) && (fingers_to_process > 0) &&
+		    (temp < ((F12_FINGERS_TO_SUPPORT + 7) / 8))) {
+			finger = (fingers_to_process - 1) % 8; /* Highest bit */
+			do {
+				if (extra_data->data15_data[temp]
+					& (1 << finger))
+					break;
 
-			fingers_to_process--;
-		} while (fingers_to_process);
+				if (finger) {
+					finger--;
+				} else {
+					/* Move to the next lower byte */
+					temp--;
+					finger = 7;
+				}
 
+				fingers_to_process--;
+			} while (fingers_to_process && (temp >= 0));
+		}
 		dev_dbg(rmi4_data->pdev->dev.parent,
 			"%s: Number of fingers to process = %d\n",
 			__func__, fingers_to_process);
 	}
 
 #ifdef F12_DATA_15_WORKAROUND
-	fingers_to_process = max(fingers_to_process, objects_already_present);
+	fingers_to_process = max(fingers_to_process, fingers_already_present);
 #endif
 
 	if (!fingers_to_process) {
 		synaptics_rmi4_free_fingers(rmi4_data);
-		finger_presence = 0;
-		stylus_presence = 0;
 		return 0;
 	}
 
@@ -1306,59 +1336,41 @@ static int synaptics_rmi4_f12_abs_report(struct synaptics_rmi4_data *rmi4_data,
 
 	data = (struct synaptics_rmi4_f12_finger_data *)fhandler->data;
 
-#ifdef REPORT_2D_PRESSURE
-	if (rmi4_data->report_pressure) {
-		retval = synaptics_rmi4_reg_read(rmi4_data,
-				data_addr + extra_data->data23_offset,
-				extra_data->data23_data,
-				fingers_to_process);
-		if (retval < 0)
-			return 0;
-	}
-#endif
-
-	mutex_lock(&(rmi4_data->rmi4_report_mutex));
-
 	for (finger = 0; finger < fingers_to_process; finger++) {
 		finger_data = data + finger;
 		finger_status = finger_data->object_type_and_status;
 
+		if (finger_status == F12_FINGER_STATUS) {
+#ifdef TYPE_B_PROTOCOL
+			input_mt_slot(rmi4_data->input_dev, finger);
+			input_mt_report_slot_state(rmi4_data->input_dev,
+					MT_TOOL_FINGER, 1);
+#endif
+
 #ifdef F12_DATA_15_WORKAROUND
-		objects_already_present = finger + 1;
+			fingers_already_present = finger + 1;
 #endif
 
-		x = (finger_data->x_msb << 8) | (finger_data->x_lsb);
-		y = (finger_data->y_msb << 8) | (finger_data->y_lsb);
+			x = (finger_data->x_msb << 8) | (finger_data->x_lsb);
+			y = (finger_data->y_msb << 8) | (finger_data->y_lsb);
 #ifdef REPORT_2D_W
-		wx = finger_data->wx;
-		wy = finger_data->wy;
+			wx = finger_data->wx;
+			wy = finger_data->wy;
 #endif
 
-		if (rmi4_data->hw_if->board_data->swap_axes) {
-			temp = x;
-			x = y;
-			y = temp;
-			temp = wx;
-			wx = wy;
-			wy = temp;
-		}
-
-		if (rmi4_data->hw_if->board_data->x_flip)
-			x = rmi4_data->sensor_max_x - x;
-		if (rmi4_data->hw_if->board_data->y_flip)
-			y = rmi4_data->sensor_max_y - y;
+			if (rmi4_data->hw_if->board_data->swap_axes) {
+				temp = x;
+				x = y;
+				y = temp;
+				temp = wx;
+				wx = wy;
+				wy = temp;
+			}
 
-		switch (finger_status) {
-		case F12_FINGER_STATUS:
-		case F12_GLOVED_FINGER_STATUS:
-			/* Stylus has priority over fingers */
-			if (stylus_presence)
-				break;
-#ifdef TYPE_B_PROTOCOL
-			input_mt_slot(rmi4_data->input_dev, finger);
-			input_mt_report_slot_state(rmi4_data->input_dev,
-					MT_TOOL_FINGER, 1);
-#endif
+			if (rmi4_data->hw_if->board_data->x_flip)
+				x = rmi4_data->sensor_max_x - x;
+			if (rmi4_data->hw_if->board_data->y_flip)
+				y = rmi4_data->sensor_max_y - y;
 
 			input_report_key(rmi4_data->input_dev,
 					BTN_TOUCH, 1);
@@ -1369,94 +1381,37 @@ static int synaptics_rmi4_f12_abs_report(struct synaptics_rmi4_data *rmi4_data,
 			input_report_abs(rmi4_data->input_dev,
 					ABS_MT_POSITION_Y, y);
 #ifdef REPORT_2D_W
-			if (rmi4_data->wedge_sensor) {
-				input_report_abs(rmi4_data->input_dev,
-						ABS_MT_TOUCH_MAJOR, wx);
-				input_report_abs(rmi4_data->input_dev,
-						ABS_MT_TOUCH_MINOR, wx);
-			} else {
-				input_report_abs(rmi4_data->input_dev,
-						ABS_MT_TOUCH_MAJOR,
-						max(wx, wy));
-				input_report_abs(rmi4_data->input_dev,
-						ABS_MT_TOUCH_MINOR,
-						min(wx, wy));
-			}
-#endif
-#ifdef REPORT_2D_PRESSURE
-			if (rmi4_data->report_pressure) {
-				pressure = extra_data->data23_data[finger];
-				input_report_abs(rmi4_data->input_dev,
-						ABS_MT_PRESSURE, pressure);
-			}
+			input_report_abs(rmi4_data->input_dev,
+					ABS_MT_TOUCH_MAJOR, max(wx, wy));
+			input_report_abs(rmi4_data->input_dev,
+					ABS_MT_TOUCH_MINOR, min(wx, wy));
 #endif
 #ifndef TYPE_B_PROTOCOL
 			input_mt_sync(rmi4_data->input_dev);
 #endif
 
 			dev_dbg(rmi4_data->pdev->dev.parent,
-					"%s: Finger %d: status = 0x%02x, x = %d, y = %d, wx = %d, wy = %d\n",
+					"%s: Finger %d:\n"
+					"status = 0x%02x\n"
+					"x = %d\n"
+					"y = %d\n"
+					"wx = %d\n"
+					"wy = %d\n",
 					__func__, finger,
 					finger_status,
 					x, y, wx, wy);
 
-			finger_presence = 1;
-			touch_count++;
-			break;
-		case F12_PALM_STATUS:
-			dev_dbg(rmi4_data->pdev->dev.parent,
-					"%s: Finger %d: x = %d, y = %d, wx = %d, wy = %d\n",
-					__func__, finger,
-					x, y, wx, wy);
-			break;
-		case F12_STYLUS_STATUS:
-		case F12_ERASER_STATUS:
-			if (!rmi4_data->stylus_enable)
-				break;
-			/* Stylus has priority over fingers */
-			if (finger_presence) {
-				mutex_unlock(&(rmi4_data->rmi4_report_mutex));
-				synaptics_rmi4_free_fingers(rmi4_data);
-				mutex_lock(&(rmi4_data->rmi4_report_mutex));
-				finger_presence = 0;
-			}
-			if (stylus_presence) {/* Allow one stylus at a timee */
-				if (finger + 1 != stylus_presence)
-					break;
-			}
-			input_report_key(rmi4_data->stylus_dev,
-					BTN_TOUCH, 1);
-			if (finger_status == F12_STYLUS_STATUS) {
-				input_report_key(rmi4_data->stylus_dev,
-						BTN_TOOL_PEN, 1);
-			} else {
-				input_report_key(rmi4_data->stylus_dev,
-						BTN_TOOL_RUBBER, 1);
-			}
-			input_report_abs(rmi4_data->stylus_dev,
-					ABS_X, x);
-			input_report_abs(rmi4_data->stylus_dev,
-					ABS_Y, y);
-			input_sync(rmi4_data->stylus_dev);
-
-			stylus_presence = finger + 1;
 			touch_count++;
-			break;
-		default:
+		} else {
 #ifdef TYPE_B_PROTOCOL
 			input_mt_slot(rmi4_data->input_dev, finger);
 			input_mt_report_slot_state(rmi4_data->input_dev,
 					MT_TOOL_FINGER, 0);
 #endif
-			break;
 		}
 	}
 
 	if (touch_count == 0) {
-		finger_presence = 0;
-#ifdef F12_DATA_15_WORKAROUND
-		objects_already_present = 0;
-#endif
 		input_report_key(rmi4_data->input_dev,
 				BTN_TOUCH, 0);
 		input_report_key(rmi4_data->input_dev,
@@ -1464,25 +1419,10 @@ static int synaptics_rmi4_f12_abs_report(struct synaptics_rmi4_data *rmi4_data,
 #ifndef TYPE_B_PROTOCOL
 		input_mt_sync(rmi4_data->input_dev);
 #endif
-
-		if (rmi4_data->stylus_enable) {
-			stylus_presence = 0;
-			input_report_key(rmi4_data->stylus_dev,
-					BTN_TOUCH, 0);
-			input_report_key(rmi4_data->stylus_dev,
-					BTN_TOOL_PEN, 0);
-			if (rmi4_data->eraser_enable) {
-				input_report_key(rmi4_data->stylus_dev,
-						BTN_TOOL_RUBBER, 0);
-			}
-			input_sync(rmi4_data->stylus_dev);
-		}
 	}
 
 	input_sync(rmi4_data->input_dev);
 
-	mutex_unlock(&(rmi4_data->rmi4_report_mutex));
-
 	return touch_count;
 }
 
@@ -1527,8 +1467,6 @@ static void synaptics_rmi4_f1a_report(struct synaptics_rmi4_data *rmi4_data,
 
 	data = f1a->button_data_buffer;
 
-	mutex_lock(&(rmi4_data->rmi4_report_mutex));
-
 	for (button = 0; button < f1a->valid_button_count; button++) {
 		index = button / 8;
 		shift = button % 8;
@@ -1584,12 +1522,17 @@ static void synaptics_rmi4_f1a_report(struct synaptics_rmi4_data *rmi4_data,
 
 	if (touch_count)
 		input_sync(rmi4_data->input_dev);
-
-	mutex_unlock(&(rmi4_data->rmi4_report_mutex));
-
-	return;
 }
 
+ /**
+ * synaptics_rmi4_report_touch()
+ *
+ * Called by synaptics_rmi4_sensor_report().
+ *
+ * This function calls the appropriate finger data reporting function
+ * based on the function handler it receives and returns the number of
+ * fingers detected.
+ */
 static void synaptics_rmi4_report_touch(struct synaptics_rmi4_data *rmi4_data,
 		struct synaptics_rmi4_fn *fhandler)
 {
@@ -1624,17 +1567,22 @@ static void synaptics_rmi4_report_touch(struct synaptics_rmi4_data *rmi4_data,
 	default:
 		break;
 	}
-
-	return;
 }
 
-static void synaptics_rmi4_sensor_report(struct synaptics_rmi4_data *rmi4_data,
-		bool report)
+ /**
+ * synaptics_rmi4_sensor_report()
+ *
+ * Called by synaptics_rmi4_irq().
+ *
+ * This function determines the interrupt source(s) from the sensor
+ * and calls synaptics_rmi4_report_touch() with the appropriate
+ * function handler for each function with valid data inputs.
+ */
+static void synaptics_rmi4_sensor_report(struct synaptics_rmi4_data *rmi4_data)
 {
 	int retval;
 	unsigned char data[MAX_INTR_REGISTERS + 1];
 	unsigned char *intr = &data[1];
-	bool was_in_bl_mode;
 	struct synaptics_rmi4_f01_device_status status;
 	struct synaptics_rmi4_fn *fhandler;
 	struct synaptics_rmi4_exp_fhandler *exp_fhandler;
@@ -1642,11 +1590,6 @@ static void synaptics_rmi4_sensor_report(struct synaptics_rmi4_data *rmi4_data,
 
 	rmi = &(rmi4_data->rmi4_mod_info);
 
-	if (rmi4_data->stay_awake) {
-		msleep(30);
-		return;
-	}
-
 	/*
 	 * Get interrupt status information from F01 Data1 register to
 	 * determine the source(s) that are flagging the interrupt.
@@ -1663,32 +1606,16 @@ static void synaptics_rmi4_sensor_report(struct synaptics_rmi4_data *rmi4_data,
 	}
 
 	status.data[0] = data[0];
-	if (status.status_code == STATUS_CRC_IN_PROGRESS) {
-		retval = synaptics_rmi4_check_status(rmi4_data,
-				&was_in_bl_mode);
-		if (retval < 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to check status\n",
-					__func__);
-			return;
-		}
-		retval = synaptics_rmi4_reg_read(rmi4_data,
-				rmi4_data->f01_data_base_addr,
-				status.data,
-				sizeof(status.data));
+	if (status.unconfigured && !status.flash_prog) {
+		pr_notice("%s: spontaneous reset detected\n", __func__);
+		retval = synaptics_rmi4_reinit_device(rmi4_data);
 		if (retval < 0) {
 			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to read device status\n",
+					"%s: Failed to reinit device\n",
 					__func__);
-			return;
 		}
-	}
-	if (status.unconfigured && !status.flash_prog) {
-		pr_notice("%s: spontaneous reset detected\n", __func__);
-	}
-
-	if (!report)
 		return;
+	}
 
 	/*
 	 * Traverse the function handler list and service the source(s)
@@ -1716,86 +1643,60 @@ static void synaptics_rmi4_sensor_report(struct synaptics_rmi4_data *rmi4_data,
 		}
 	}
 	mutex_unlock(&exp_data.mutex);
-
-	return;
 }
 
+ /**
+ * synaptics_rmi4_irq()
+ *
+ * Called by the kernel when an interrupt occurs (when the sensor
+ * asserts the attention irq).
+ *
+ * This function is the ISR thread and handles the acquisition
+ * and the reporting of finger data when the presence of fingers
+ * is detected.
+ */
 static irqreturn_t synaptics_rmi4_irq(int irq, void *data)
 {
 	struct synaptics_rmi4_data *rmi4_data = data;
-	const struct synaptics_dsx_board_data *bdata =
-			rmi4_data->hw_if->board_data;
 
 	if (IRQ_HANDLED == synaptics_filter_interrupt(data))
 		return IRQ_HANDLED;
 
-	if (gpio_get_value(bdata->irq_gpio) != bdata->irq_on_state)
-		goto exit;
-
-	synaptics_rmi4_sensor_report(rmi4_data, true);
+	synaptics_rmi4_sensor_report(rmi4_data);
 
-exit:
 	return IRQ_HANDLED;
 }
 
-static int synaptics_rmi4_int_enable(struct synaptics_rmi4_data *rmi4_data,
-		bool enable)
-{
-	int retval = 0;
-	unsigned char ii;
-	unsigned char zero = 0x00;
-	unsigned char *intr_mask;
-	unsigned short intr_addr;
-
-	intr_mask = rmi4_data->intr_mask;
-
-	for (ii = 0; ii < rmi4_data->num_of_intr_regs; ii++) {
-		if (intr_mask[ii] != 0x00) {
-			intr_addr = rmi4_data->f01_ctrl_base_addr + 1 + ii;
-			if (enable) {
-				retval = synaptics_rmi4_reg_write(rmi4_data,
-						intr_addr,
-						&(intr_mask[ii]),
-						sizeof(intr_mask[ii]));
-				if (retval < 0)
-					return retval;
-			} else {
-				retval = synaptics_rmi4_reg_write(rmi4_data,
-						intr_addr,
-						&zero,
-						sizeof(zero));
-				if (retval < 0)
-					return retval;
-			}
-		}
-	}
-
-	return retval;
-}
-
+ /**
+ * synaptics_rmi4_irq_enable()
+ *
+ * Called by synaptics_rmi4_probe() and the power management functions
+ * in this driver and also exported to other expansion Function modules
+ * such as rmi_dev.
+ *
+ * This function handles the enabling and disabling of the attention
+ * irq including the setting up of the ISR thread.
+ */
 static int synaptics_rmi4_irq_enable(struct synaptics_rmi4_data *rmi4_data,
-		bool enable, bool attn_only)
+		bool enable)
 {
 	int retval = 0;
+	unsigned char intr_status[MAX_INTR_REGISTERS];
 	const struct synaptics_dsx_board_data *bdata =
 			rmi4_data->hw_if->board_data;
 
-	if (attn_only) {
-		retval = synaptics_rmi4_int_enable(rmi4_data, enable);
-		return retval;
-	}
-
 	if (enable) {
 		if (rmi4_data->irq_enabled)
 			return retval;
 
-		retval = synaptics_rmi4_int_enable(rmi4_data, false);
+		/* Clear interrupts first */
+		retval = synaptics_rmi4_reg_read(rmi4_data,
+				rmi4_data->f01_data_base_addr + 1,
+				intr_status,
+				rmi4_data->num_of_intr_regs);
 		if (retval < 0)
 			return retval;
 
-		/* Process and clear interrupts */
-		synaptics_rmi4_sensor_report(rmi4_data, false);
-
 		retval = request_threaded_irq(rmi4_data->irq, NULL,
 				synaptics_rmi4_irq, bdata->irq_flags,
 				PLATFORM_DRIVER_NAME, rmi4_data);
@@ -1806,10 +1707,6 @@ static int synaptics_rmi4_irq_enable(struct synaptics_rmi4_data *rmi4_data,
 			return retval;
 		}
 
-		retval = synaptics_rmi4_int_enable(rmi4_data, true);
-		if (retval < 0)
-			return retval;
-
 		rmi4_data->irq_enabled = true;
 	} else {
 		if (rmi4_data->irq_enabled) {
@@ -1837,11 +1734,10 @@ static void synaptics_rmi4_set_intr_mask(struct synaptics_rmi4_fn *fhandler,
 	intr_offset = intr_count % 8;
 	fhandler->intr_mask = 0;
 	for (ii = intr_offset;
-			ii < (fd->intr_src_count + intr_offset);
+			ii < ((fd->intr_src_count & MASK_3BIT) +
+			intr_offset);
 			ii++)
 		fhandler->intr_mask |= 1 << ii;
-
-	return;
 }
 
 static int synaptics_rmi4_f01_init(struct synaptics_rmi4_data *rmi4_data,
@@ -1864,63 +1760,67 @@ static int synaptics_rmi4_f01_init(struct synaptics_rmi4_data *rmi4_data,
 	return 0;
 }
 
-static int synaptics_rmi4_f11_init(struct synaptics_rmi4_data *rmi4_data,
-		struct synaptics_rmi4_fn *fhandler,
-		struct synaptics_rmi4_fn_desc *fd,
-		unsigned int intr_count)
+ /**
+  * synaptics_rmi4_f11_set_coords()
+  *
+  * Set panel resolution for f11 to match display resolution.
+  *
+  */
+static int synaptics_rmi4_f11_set_coords(struct synaptics_rmi4_data *rmi4_data,
+			struct synaptics_rmi4_fn *fhandler)
 {
 	int retval;
-	int temp;
-	unsigned char offset;
-	unsigned char fingers_supported;
-	struct synaptics_rmi4_f11_extra_data *extra_data;
-	struct synaptics_rmi4_f11_query_0_5 query_0_5;
-	struct synaptics_rmi4_f11_query_7_8 query_7_8;
-	struct synaptics_rmi4_f11_query_9 query_9;
-	struct synaptics_rmi4_f11_query_12 query_12;
-	struct synaptics_rmi4_f11_query_27 query_27;
-	struct synaptics_rmi4_f11_ctrl_6_9 control_6_9;
+	unsigned char control[F11_STD_CTRL_LEN];
 	const struct synaptics_dsx_board_data *bdata =
-				rmi4_data->hw_if->board_data;
+			rmi4_data->hw_if->board_data;
 
-	fhandler->fn_number = fd->fn_number;
-	fhandler->num_of_data_sources = fd->intr_src_count;
-	fhandler->extra = kmalloc(sizeof(*extra_data), GFP_KERNEL);
-	if (!fhandler->extra) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to alloc mem for fhandler->extra\n",
-				__func__);
-		return -ENOMEM;
+	if (!rmi4_data->update_coords) {
+		dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: No need to update panel resolution\n", __func__);
+		return 0;
 	}
-	extra_data = (struct synaptics_rmi4_f11_extra_data *)fhandler->extra;
 
 	retval = synaptics_rmi4_reg_read(rmi4_data,
-			fhandler->full_addr.query_base,
-			query_0_5.data,
-			sizeof(query_0_5.data));
+			fhandler->full_addr.ctrl_base,
+			control,
+			sizeof(control));
 	if (retval < 0)
 		return retval;
 
-	/* Maximum number of fingers supported */
-	if (query_0_5.num_of_fingers <= 4)
-		fhandler->num_of_data_points = query_0_5.num_of_fingers + 1;
-	else if (query_0_5.num_of_fingers == 5)
-		fhandler->num_of_data_points = 10;
-
-	rmi4_data->num_of_fingers = fhandler->num_of_data_points;
+	/* Maximum x and y */
+	rmi4_data->sensor_max_x = ((control[6] & MASK_8BIT) << 0) |
+			((control[7] & MASK_4BIT) << 8);
+	rmi4_data->sensor_max_y = ((control[8] & MASK_8BIT) << 0) |
+			((control[9] & MASK_4BIT) << 8);
+
+	if (bdata->panel_maxx && bdata->panel_maxy &&
+		(rmi4_data->sensor_max_x != bdata->panel_maxx ||
+			rmi4_data->sensor_max_y != bdata->panel_maxy)) {
+		if (bdata->panel_maxx > SYNA_F11_MAX ||
+				bdata->panel_maxy > SYNA_F11_MAX) {
+			dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Invalid panel resolution\n", __func__);
+			return -EINVAL;
+		}
 
-	retval = synaptics_rmi4_reg_read(rmi4_data,
-			fhandler->full_addr.ctrl_base + 6,
-			control_6_9.data,
-			sizeof(control_6_9.data));
-	if (retval < 0)
-		return retval;
+		rmi4_data->sensor_max_x = bdata->panel_maxx;
+		rmi4_data->sensor_max_y = bdata->panel_maxy;
+		control[6] = rmi4_data->sensor_max_x & MASK_8BIT;
+		control[7] = (rmi4_data->sensor_max_x >> 8) & MASK_4BIT;
+		control[8] = rmi4_data->sensor_max_y & MASK_8BIT;
+		control[9] = (rmi4_data->sensor_max_y >> 8) & MASK_4BIT;
+
+		retval = synaptics_rmi4_reg_write(rmi4_data,
+				fhandler->full_addr.ctrl_base,
+				control,
+				sizeof(control));
+		if (retval < 0)
+			return retval;
+		rmi4_data->update_coords = true;
+	} else {
+		rmi4_data->update_coords = false;
+	}
 
-	/* Maximum x and y */
-	rmi4_data->sensor_max_x = control_6_9.sensor_max_x_pos_7_0 |
-			(control_6_9.sensor_max_x_pos_11_8 << 8);
-	rmi4_data->sensor_max_y = control_6_9.sensor_max_y_pos_7_0 |
-			(control_6_9.sensor_max_y_pos_11_8 << 8);
 	dev_dbg(rmi4_data->pdev->dev.parent,
 			"%s: Function %02x max x = %d max y = %d\n",
 			__func__, fhandler->fn_number,
@@ -1929,176 +1829,59 @@ static int synaptics_rmi4_f11_init(struct synaptics_rmi4_data *rmi4_data,
 
 	rmi4_data->max_touch_width = MAX_F11_TOUCH_WIDTH;
 
-	if (bdata->swap_axes) {
-		temp = rmi4_data->sensor_max_x;
-		rmi4_data->sensor_max_x = rmi4_data->sensor_max_y;
-		rmi4_data->sensor_max_y = temp;
-	}
-
-	synaptics_rmi4_set_intr_mask(fhandler, fd, intr_count);
-
-	fhandler->data = NULL;
-
-	offset = sizeof(query_0_5.data);
-
-	/* query 6 */
-	if (query_0_5.has_rel)
-		offset += 1;
-
-	/* queries 7 8 */
-	if (query_0_5.has_gestures) {
-		retval = synaptics_rmi4_reg_read(rmi4_data,
-				fhandler->full_addr.query_base + offset,
-				query_7_8.data,
-				sizeof(query_7_8.data));
-		if (retval < 0)
-			return retval;
-
-		offset += sizeof(query_7_8.data);
-	}
-
-	/* query 9 */
-	if (query_0_5.has_query_9) {
-		retval = synaptics_rmi4_reg_read(rmi4_data,
-				fhandler->full_addr.query_base + offset,
-				query_9.data,
-				sizeof(query_9.data));
-		if (retval < 0)
-			return retval;
-
-		offset += sizeof(query_9.data);
-	}
-
-	/* query 10 */
-	if (query_0_5.has_gestures && query_7_8.has_touch_shapes)
-		offset += 1;
-
-	/* query 11 */
-	if (query_0_5.has_query_11)
-		offset += 1;
-
-	/* query 12 */
-	if (query_0_5.has_query_12) {
-		retval = synaptics_rmi4_reg_read(rmi4_data,
-				fhandler->full_addr.query_base + offset,
-				query_12.data,
-				sizeof(query_12.data));
-		if (retval < 0)
-			return retval;
-
-		offset += sizeof(query_12.data);
-	}
+	return 0;
+}
 
-	/* query 13 */
-	if (query_0_5.has_jitter_filter)
-		offset += 1;
+ /**
+  * synaptics_rmi4_f11_init()
+  *
+  * Called by synaptics_rmi4_query_device().
+  *
+  * This function parses information from the Function 11 registers
+  * and determines the number of fingers supported, x and y data ranges,
+  * offset to the associated interrupt status register, interrupt bit
+  * mask, and gathers finger data acquisition capabilities from the query
+  * registers.
+  */
+static int synaptics_rmi4_f11_init(struct synaptics_rmi4_data *rmi4_data,
+		struct synaptics_rmi4_fn *fhandler,
+		struct synaptics_rmi4_fn_desc *fd,
+		unsigned int intr_count)
+{
+	int retval;
+	unsigned char abs_data_size;
+	unsigned char abs_data_blk_size;
+	unsigned char query[F11_STD_QUERY_LEN];
 
-	/* query 14 */
-	if (query_0_5.has_query_12 && query_12.has_general_information_2)
-		offset += 1;
+	fhandler->fn_number = fd->fn_number;
+	fhandler->num_of_data_sources = fd->intr_src_count;
 
-	/* queries 15 16 17 18 19 20 21 22 23 24 25 26*/
-	if (query_0_5.has_query_12 && query_12.has_physical_properties)
-		offset += 12;
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			fhandler->full_addr.query_base,
+			query,
+			sizeof(query));
+	if (retval < 0)
+		return retval;
 
-	/* query 27 */
-	if (query_0_5.has_query_27) {
-		retval = synaptics_rmi4_reg_read(rmi4_data,
-				fhandler->full_addr.query_base + offset,
-				query_27.data,
-				sizeof(query_27.data));
-		if (retval < 0)
-			return retval;
+	/* Maximum number of fingers supported */
+	if ((query[1] & MASK_3BIT) <= 4)
+		fhandler->num_of_data_points = (query[1] & MASK_3BIT) + 1;
+	else if ((query[1] & MASK_3BIT) == 5)
+		fhandler->num_of_data_points = 10;
 
-		rmi4_data->f11_wakeup_gesture = query_27.has_wakeup_gesture;
-	}
+	rmi4_data->num_of_fingers = fhandler->num_of_data_points;
 
-	if (!rmi4_data->f11_wakeup_gesture)
+	retval = synaptics_rmi4_f11_set_coords(rmi4_data, fhandler);
+	if (retval < 0)
 		return retval;
 
-	/* data 0 */
-	fingers_supported = fhandler->num_of_data_points;
-	offset = (fingers_supported + 3) / 4;
-
-	/* data 1 2 3 4 5 */
-	offset += 5 * fingers_supported;
-
-	/* data 6 7 */
-	if (query_0_5.has_rel)
-		offset += 2 * fingers_supported;
-
-	/* data 8 */
-	if (query_0_5.has_gestures && query_7_8.data[0])
-		offset += 1;
-
-	/* data 9 */
-	if (query_0_5.has_gestures && (query_7_8.data[0] || query_7_8.data[1]))
-		offset += 1;
-
-	/* data 10 */
-	if (query_0_5.has_gestures &&
-			(query_7_8.has_pinch || query_7_8.has_flick))
-		offset += 1;
-
-	/* data 11 12 */
-	if (query_0_5.has_gestures &&
-			(query_7_8.has_flick || query_7_8.has_rotate))
-		offset += 2;
-
-	/* data 13 */
-	if (query_0_5.has_gestures && query_7_8.has_touch_shapes)
-		offset += (fingers_supported + 3) / 4;
-
-	/* data 14 15 */
-	if (query_0_5.has_gestures &&
-			(query_7_8.has_scroll_zones ||
-			query_7_8.has_multi_finger_scroll ||
-			query_7_8.has_chiral_scroll))
-		offset += 2;
-
-	/* data 16 17 */
-	if (query_0_5.has_gestures &&
-			(query_7_8.has_scroll_zones &&
-			query_7_8.individual_scroll_zones))
-		offset += 2;
-
-	/* data 18 19 20 21 22 23 24 25 26 27 */
-	if (query_0_5.has_query_9 && query_9.has_contact_geometry)
-		offset += 10 * fingers_supported;
-
-	/* data 28 */
-	if (query_0_5.has_bending_correction ||
-			query_0_5.has_large_object_suppression)
-		offset += 1;
-
-	/* data 29 30 31 */
-	if (query_0_5.has_query_9 && query_9.has_pen_hover_discrimination)
-		offset += 3;
-
-	/* data 32 */
-	if (query_0_5.has_query_12 &&
-			query_12.has_small_object_detection_tuning)
-		offset += 1;
-
-	/* data 33 34 */
-	if (query_0_5.has_query_27 && query_27.f11_query27_b0)
-		offset += 2;
-
-	/* data 35 */
-	if (query_0_5.has_query_12 && query_12.has_8bit_w)
-		offset += fingers_supported;
-
-	/* data 36 */
-	if (query_0_5.has_bending_correction)
-		offset += 1;
-
-	/* data 37 */
-	if (query_0_5.has_query_27 && query_27.has_data_37)
-		offset += 1;
-
-	/* data 38 */
-	if (query_0_5.has_query_27 && query_27.has_wakeup_gesture)
-		extra_data->data38_offset = offset;
+	synaptics_rmi4_set_intr_mask(fhandler, fd, intr_count);
+
+	abs_data_size = query[5] & MASK_2BIT;
+	abs_data_blk_size = 3 + (2 * (abs_data_size == 0 ? 1 : 0));
+	fhandler->size_of_data_register_block = abs_data_blk_size;
+	fhandler->data = NULL;
+	fhandler->extra = NULL;
 
 	return retval;
 }
@@ -2122,326 +1905,235 @@ static int synaptics_rmi4_f12_set_enables(struct synaptics_rmi4_data *rmi4_data,
 	return retval;
 }
 
-static int synaptics_rmi4_f12_ctrl_sub(struct synaptics_rmi4_data *rmi4_data,
-		struct synaptics_rmi4_fn *fhandler,
-		struct synaptics_rmi4_f12_query_5 *query_5,
-		unsigned char ctrlreg, unsigned char subpacket)
+ /**
+  * synaptics_rmi4_f12_set_coords()
+  *
+  * Set panel resolution for f12 to match display resolution.
+  *
+  */
+static int synaptics_rmi4_f12_set_coords(struct synaptics_rmi4_data *rmi4_data,
+			struct synaptics_rmi4_fn *fhandler)
 {
-	int retval;
-	unsigned char cnt;
-	unsigned char regnum;
-	unsigned char bitnum;
-	unsigned char q5_index;
-	unsigned char q6_index;
-	unsigned char offset;
-	unsigned char max_ctrlreg;
-	unsigned char *query_6;
-
-	max_ctrlreg = (sizeof(query_5->data) - 1) * 8 - 1;
-
-	if (ctrlreg > max_ctrlreg) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Control register number (%d) over limit\n",
-				__func__, ctrlreg);
-		return -EINVAL;
-	}
 
-	q5_index = ctrlreg / 8 + 1;
-	bitnum = ctrlreg % 8;
-	if ((query_5->data[q5_index] & (1 << bitnum)) == 0x00) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Control %d is not present\n",
-				__func__, ctrlreg);
-		return -EINVAL;
-	}
+	const struct synaptics_dsx_board_data *bdata =
+			rmi4_data->hw_if->board_data;
+	struct synaptics_rmi4_f12_query_5 query_5;
+	struct synaptics_rmi4_f12_ctrl_8 ctrl_8;
+	unsigned char ctrl_8_offset;
+	int retval;
 
-	query_6 = kmalloc(query_5->size_of_query6, GFP_KERNEL);
-	if (!query_6) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to alloc mem for query 6\n",
-				__func__);
-		return -ENOMEM;
+	if (!rmi4_data->update_coords) {
+		dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: No need to update panel resolution\n", __func__);
+		return 0;
 	}
 
 	retval = synaptics_rmi4_reg_read(rmi4_data,
-			fhandler->full_addr.query_base + 6,
-			query_6,
-			query_5->size_of_query6);
+			fhandler->full_addr.query_base + 5,
+			query_5.data,
+			sizeof(query_5.data));
 	if (retval < 0)
-		goto exit;
-
-	q6_index = 0;
+		return retval;
 
-	for (regnum = 0; regnum < ctrlreg; regnum++) {
-		q5_index = regnum / 8 + 1;
-		bitnum = regnum % 8;
-		if ((query_5->data[q5_index] & (1 << bitnum)) == 0x00)
-			continue;
+	ctrl_8_offset = query_5.ctrl0_is_present +
+			query_5.ctrl1_is_present +
+			query_5.ctrl2_is_present +
+			query_5.ctrl3_is_present +
+			query_5.ctrl4_is_present +
+			query_5.ctrl5_is_present +
+			query_5.ctrl6_is_present +
+			query_5.ctrl7_is_present;
 
-		if (query_6[q6_index] == 0x00)
-			q6_index += 3;
-		else
-			q6_index++;
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			fhandler->full_addr.ctrl_base + ctrl_8_offset,
+			ctrl_8.data,
+			sizeof(ctrl_8.data));
+	if (retval < 0)
+		return retval;
 
-		while (query_6[q6_index] & ~MASK_7BIT)
-			q6_index++;
+	/* Maximum x and y */
+	rmi4_data->sensor_max_x =
+			((unsigned short)ctrl_8.max_x_coord_lsb << 0) |
+			((unsigned short)ctrl_8.max_x_coord_msb << 8);
+	rmi4_data->sensor_max_y =
+			((unsigned short)ctrl_8.max_y_coord_lsb << 0) |
+			((unsigned short)ctrl_8.max_y_coord_msb << 8);
+
+	if (bdata->panel_maxx && bdata->panel_maxy &&
+		(rmi4_data->sensor_max_x != bdata->panel_maxx ||
+			rmi4_data->sensor_max_y != bdata->panel_maxy)) {
+
+		if (bdata->panel_maxx > SYNA_F12_MAX ||
+				bdata->panel_maxy > SYNA_F12_MAX) {
+			dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Invalid panel resolution\n", __func__);
+			retval = -EINVAL;
+			return retval;
+		}
 
-		q6_index++;
-	}
+		rmi4_data->sensor_max_x = bdata->panel_maxx;
+		rmi4_data->sensor_max_y = bdata->panel_maxy;
+		ctrl_8.max_x_coord_lsb = rmi4_data->sensor_max_x & MASK_8BIT;
+		ctrl_8.max_x_coord_msb = (rmi4_data->sensor_max_x >> 8) &
+								MASK_4BIT;
+		ctrl_8.max_y_coord_lsb = rmi4_data->sensor_max_y & MASK_8BIT;
+		ctrl_8.max_y_coord_msb = (rmi4_data->sensor_max_y >> 8) &
+								MASK_4BIT;
 
-	cnt = 0;
-	q6_index++;
-	offset = subpacket / 7;
-	bitnum = subpacket % 7;
-
-	do {
-		if (cnt == offset) {
-			if (query_6[q6_index + cnt] & (1 << bitnum))
-				retval = 1;
-			else
-				retval = 0;
-			goto exit;
-		}
-		cnt++;
-	} while (query_6[q6_index + cnt - 1] & ~MASK_7BIT);
+		retval = synaptics_rmi4_reg_write(rmi4_data,
+				fhandler->full_addr.ctrl_base + ctrl_8_offset,
+				ctrl_8.data,
+				sizeof(ctrl_8.data));
+		if (retval < 0)
+			return retval;
+		rmi4_data->update_coords = true;
+	} else {
+		rmi4_data->update_coords = false;
+	}
 
-	retval = 0;
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Function %02x max x = %d max y = %d\n",
+			__func__, fhandler->fn_number,
+			rmi4_data->sensor_max_x,
+			rmi4_data->sensor_max_y);
 
-exit:
-	kfree(query_6);
+	rmi4_data->num_of_rx = ctrl_8.num_of_rx;
+	rmi4_data->num_of_tx = ctrl_8.num_of_tx;
+	rmi4_data->max_touch_width = max(rmi4_data->num_of_rx,
+			rmi4_data->num_of_tx);
 
-	return retval;
+	return 0;
 }
 
+ /**
+  * synaptics_rmi4_f12_init()
+  *
+  * Called by synaptics_rmi4_query_device().
+  *
+  * This function parses information from the Function 12 registers and
+  * determines the number of fingers supported, offset to the data1
+  * register, x and y data ranges, offset to the associated interrupt
+  * status register, interrupt bit mask, and allocates memory resources
+  * for finger data acquisition.
+  */
 static int synaptics_rmi4_f12_init(struct synaptics_rmi4_data *rmi4_data,
 		struct synaptics_rmi4_fn *fhandler,
 		struct synaptics_rmi4_fn_desc *fd,
 		unsigned int intr_count)
 {
-	int retval = 0;
-	int temp;
-	unsigned char subpacket;
-	unsigned char ctrl_23_size;
+	int retval;
 	unsigned char size_of_2d_data;
 	unsigned char size_of_query8;
 	unsigned char ctrl_8_offset;
-	unsigned char ctrl_20_offset;
 	unsigned char ctrl_23_offset;
 	unsigned char ctrl_28_offset;
-	unsigned char ctrl_31_offset;
 	unsigned char num_of_fingers;
 	struct synaptics_rmi4_f12_extra_data *extra_data;
-	struct synaptics_rmi4_f12_query_5 *query_5 = NULL;
-	struct synaptics_rmi4_f12_query_8 *query_8 = NULL;
-	struct synaptics_rmi4_f12_ctrl_8 *ctrl_8 = NULL;
-	struct synaptics_rmi4_f12_ctrl_23 *ctrl_23 = NULL;
-	struct synaptics_rmi4_f12_ctrl_31 *ctrl_31 = NULL;
-	const struct synaptics_dsx_board_data *bdata =
-				rmi4_data->hw_if->board_data;
+	struct synaptics_rmi4_f12_query_5 query_5;
+	struct synaptics_rmi4_f12_query_8 query_8;
+	struct synaptics_rmi4_f12_ctrl_23 ctrl_23;
 
 	fhandler->fn_number = fd->fn_number;
 	fhandler->num_of_data_sources = fd->intr_src_count;
+	size_of_2d_data = sizeof(struct synaptics_rmi4_f12_finger_data);
+
 	fhandler->extra = kmalloc(sizeof(*extra_data), GFP_KERNEL);
-	if (!fhandler->extra) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to alloc mem for fhandler->extra\n",
-				__func__);
+	if (!fhandler->extra)
 		return -ENOMEM;
-	}
 	extra_data = (struct synaptics_rmi4_f12_extra_data *)fhandler->extra;
-	size_of_2d_data = sizeof(struct synaptics_rmi4_f12_finger_data);
-
-	query_5 = kmalloc(sizeof(*query_5), GFP_KERNEL);
-	if (!query_5) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to alloc mem for query_5\n",
-				__func__);
-		retval = -ENOMEM;
-		goto exit;
-	}
-
-	query_8 = kmalloc(sizeof(*query_8), GFP_KERNEL);
-	if (!query_8) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to alloc mem for query_8\n",
-				__func__);
-		retval = -ENOMEM;
-		goto exit;
-	}
-
-	ctrl_8 = kmalloc(sizeof(*ctrl_8), GFP_KERNEL);
-	if (!ctrl_8) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to alloc mem for ctrl_8\n",
-				__func__);
-		retval = -ENOMEM;
-		goto exit;
-	}
-
-	ctrl_23 = kmalloc(sizeof(*ctrl_23), GFP_KERNEL);
-	if (!ctrl_23) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to alloc mem for ctrl_23\n",
-				__func__);
-		retval = -ENOMEM;
-		goto exit;
-	}
-
-	ctrl_31 = kmalloc(sizeof(*ctrl_31), GFP_KERNEL);
-	if (!ctrl_31) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to alloc mem for ctrl_31\n",
-				__func__);
-		retval = -ENOMEM;
-		goto exit;
-	}
 
 	retval = synaptics_rmi4_reg_read(rmi4_data,
 			fhandler->full_addr.query_base + 5,
-			query_5->data,
-			sizeof(query_5->data));
+			query_5.data,
+			sizeof(query_5.data));
 	if (retval < 0)
-		goto exit;
-
-	ctrl_8_offset = query_5->ctrl0_is_present +
-			query_5->ctrl1_is_present +
-			query_5->ctrl2_is_present +
-			query_5->ctrl3_is_present +
-			query_5->ctrl4_is_present +
-			query_5->ctrl5_is_present +
-			query_5->ctrl6_is_present +
-			query_5->ctrl7_is_present;
-
-	ctrl_20_offset = ctrl_8_offset +
-			query_5->ctrl8_is_present +
-			query_5->ctrl9_is_present +
-			query_5->ctrl10_is_present +
-			query_5->ctrl11_is_present +
-			query_5->ctrl12_is_present +
-			query_5->ctrl13_is_present +
-			query_5->ctrl14_is_present +
-			query_5->ctrl15_is_present +
-			query_5->ctrl16_is_present +
-			query_5->ctrl17_is_present +
-			query_5->ctrl18_is_present +
-			query_5->ctrl19_is_present;
-
-	ctrl_23_offset = ctrl_20_offset +
-			query_5->ctrl20_is_present +
-			query_5->ctrl21_is_present +
-			query_5->ctrl22_is_present;
+		goto free_function_handler_mem;
+
+	ctrl_8_offset = query_5.ctrl0_is_present +
+			query_5.ctrl1_is_present +
+			query_5.ctrl2_is_present +
+			query_5.ctrl3_is_present +
+			query_5.ctrl4_is_present +
+			query_5.ctrl5_is_present +
+			query_5.ctrl6_is_present +
+			query_5.ctrl7_is_present;
+
+	ctrl_23_offset = ctrl_8_offset +
+			query_5.ctrl8_is_present +
+			query_5.ctrl9_is_present +
+			query_5.ctrl10_is_present +
+			query_5.ctrl11_is_present +
+			query_5.ctrl12_is_present +
+			query_5.ctrl13_is_present +
+			query_5.ctrl14_is_present +
+			query_5.ctrl15_is_present +
+			query_5.ctrl16_is_present +
+			query_5.ctrl17_is_present +
+			query_5.ctrl18_is_present +
+			query_5.ctrl19_is_present +
+			query_5.ctrl20_is_present +
+			query_5.ctrl21_is_present +
+			query_5.ctrl22_is_present;
 
 	ctrl_28_offset = ctrl_23_offset +
-			query_5->ctrl23_is_present +
-			query_5->ctrl24_is_present +
-			query_5->ctrl25_is_present +
-			query_5->ctrl26_is_present +
-			query_5->ctrl27_is_present;
-
-	ctrl_31_offset = ctrl_28_offset +
-			query_5->ctrl28_is_present +
-			query_5->ctrl29_is_present +
-			query_5->ctrl30_is_present;
-
-	ctrl_23_size = 2;
-	for (subpacket = 2; subpacket <= 4; subpacket++) {
-		retval = synaptics_rmi4_f12_ctrl_sub(rmi4_data,
-				fhandler, query_5, 23, subpacket);
-		if (retval == 1)
-			ctrl_23_size++;
-		else if (retval < 0)
-			goto exit;
-	}
+			query_5.ctrl23_is_present +
+			query_5.ctrl24_is_present +
+			query_5.ctrl25_is_present +
+			query_5.ctrl26_is_present +
+			query_5.ctrl27_is_present;
 
 	retval = synaptics_rmi4_reg_read(rmi4_data,
 			fhandler->full_addr.ctrl_base + ctrl_23_offset,
-			ctrl_23->data,
-			ctrl_23_size);
+			ctrl_23.data,
+			sizeof(ctrl_23.data));
 	if (retval < 0)
-		goto exit;
+		goto free_function_handler_mem;
 
 	/* Maximum number of fingers supported */
 	fhandler->num_of_data_points = min_t(unsigned char,
-			ctrl_23->max_reported_objects,
-			(unsigned char)F12_FINGERS_TO_SUPPORT);
+		 ctrl_23.max_reported_objects,	F12_FINGERS_TO_SUPPORT);
 
 	num_of_fingers = fhandler->num_of_data_points;
 	rmi4_data->num_of_fingers = num_of_fingers;
 
-	rmi4_data->stylus_enable = ctrl_23->stylus_enable;
-	rmi4_data->eraser_enable = ctrl_23->eraser_enable;
-
 	retval = synaptics_rmi4_reg_read(rmi4_data,
 			fhandler->full_addr.query_base + 7,
 			&size_of_query8,
 			sizeof(size_of_query8));
 	if (retval < 0)
-		goto exit;
+		goto free_function_handler_mem;
 
 	retval = synaptics_rmi4_reg_read(rmi4_data,
 			fhandler->full_addr.query_base + 8,
-			query_8->data,
+			query_8.data,
 			size_of_query8);
 	if (retval < 0)
-		goto exit;
+		goto free_function_handler_mem;
 
 	/* Determine the presence of the Data0 register */
-	extra_data->data1_offset = query_8->data0_is_present;
-
-	if ((size_of_query8 >= 3) && (query_8->data15_is_present)) {
-		extra_data->data15_offset = query_8->data0_is_present +
-				query_8->data1_is_present +
-				query_8->data2_is_present +
-				query_8->data3_is_present +
-				query_8->data4_is_present +
-				query_8->data5_is_present +
-				query_8->data6_is_present +
-				query_8->data7_is_present +
-				query_8->data8_is_present +
-				query_8->data9_is_present +
-				query_8->data10_is_present +
-				query_8->data11_is_present +
-				query_8->data12_is_present +
-				query_8->data13_is_present +
-				query_8->data14_is_present;
+	extra_data->data1_offset = query_8.data0_is_present;
+
+	if ((size_of_query8 >= 3) && (query_8.data15_is_present)) {
+		extra_data->data15_offset = query_8.data0_is_present +
+				query_8.data1_is_present +
+				query_8.data2_is_present +
+				query_8.data3_is_present +
+				query_8.data4_is_present +
+				query_8.data5_is_present +
+				query_8.data6_is_present +
+				query_8.data7_is_present +
+				query_8.data8_is_present +
+				query_8.data9_is_present +
+				query_8.data10_is_present +
+				query_8.data11_is_present +
+				query_8.data12_is_present +
+				query_8.data13_is_present +
+				query_8.data14_is_present;
 		extra_data->data15_size = (num_of_fingers + 7) / 8;
 	} else {
 		extra_data->data15_size = 0;
 	}
 
-#ifdef REPORT_2D_PRESSURE
-	if ((size_of_query8 >= 4) && (query_8->data23_is_present)) {
-		extra_data->data23_offset = query_8->data0_is_present +
-				query_8->data1_is_present +
-				query_8->data2_is_present +
-				query_8->data3_is_present +
-				query_8->data4_is_present +
-				query_8->data5_is_present +
-				query_8->data6_is_present +
-				query_8->data7_is_present +
-				query_8->data8_is_present +
-				query_8->data9_is_present +
-				query_8->data10_is_present +
-				query_8->data11_is_present +
-				query_8->data12_is_present +
-				query_8->data13_is_present +
-				query_8->data14_is_present +
-				query_8->data15_is_present +
-				query_8->data16_is_present +
-				query_8->data17_is_present +
-				query_8->data18_is_present +
-				query_8->data19_is_present +
-				query_8->data20_is_present +
-				query_8->data21_is_present +
-				query_8->data22_is_present;
-		extra_data->data23_size = num_of_fingers;
-		rmi4_data->report_pressure = true;
-	} else {
-		extra_data->data23_size = 0;
-		rmi4_data->report_pressure = false;
-	}
-#endif
-
 	rmi4_data->report_enable = RPT_DEFAULT;
 #ifdef REPORT_2D_Z
 	rmi4_data->report_enable |= RPT_Z;
@@ -2453,68 +2145,12 @@ static int synaptics_rmi4_f12_init(struct synaptics_rmi4_data *rmi4_data,
 	retval = synaptics_rmi4_f12_set_enables(rmi4_data,
 			fhandler->full_addr.ctrl_base + ctrl_28_offset);
 	if (retval < 0)
-		goto exit;
-
-	if (query_5->ctrl8_is_present) {
-		rmi4_data->wedge_sensor = false;
-
-		retval = synaptics_rmi4_reg_read(rmi4_data,
-				fhandler->full_addr.ctrl_base + ctrl_8_offset,
-				ctrl_8->data,
-				sizeof(ctrl_8->data));
-		if (retval < 0)
-			goto exit;
-
-		/* Maximum x and y */
-		rmi4_data->sensor_max_x =
-				((unsigned int)ctrl_8->max_x_coord_lsb << 0) |
-				((unsigned int)ctrl_8->max_x_coord_msb << 8);
-		rmi4_data->sensor_max_y =
-				((unsigned int)ctrl_8->max_y_coord_lsb << 0) |
-				((unsigned int)ctrl_8->max_y_coord_msb << 8);
-
-		rmi4_data->max_touch_width = MAX_F12_TOUCH_WIDTH;
-	} else {
-		rmi4_data->wedge_sensor = true;
-
-		retval = synaptics_rmi4_reg_read(rmi4_data,
-				fhandler->full_addr.ctrl_base + ctrl_31_offset,
-				ctrl_31->data,
-				sizeof(ctrl_31->data));
-		if (retval < 0)
-			goto exit;
-
-		/* Maximum x and y */
-		rmi4_data->sensor_max_x =
-				((unsigned int)ctrl_31->max_x_coord_lsb << 0) |
-				((unsigned int)ctrl_31->max_x_coord_msb << 8);
-		rmi4_data->sensor_max_y =
-				((unsigned int)ctrl_31->max_y_coord_lsb << 0) |
-				((unsigned int)ctrl_31->max_y_coord_msb << 8);
-
-		rmi4_data->max_touch_width = MAX_F12_TOUCH_WIDTH;
-	}
-
-	dev_dbg(rmi4_data->pdev->dev.parent,
-			"%s: Function %02x max x = %d max y = %d\n",
-			__func__, fhandler->fn_number,
-			rmi4_data->sensor_max_x,
-			rmi4_data->sensor_max_y);
+		goto free_function_handler_mem;
 
-	if (bdata->swap_axes) {
-		temp = rmi4_data->sensor_max_x;
-		rmi4_data->sensor_max_x = rmi4_data->sensor_max_y;
-		rmi4_data->sensor_max_y = temp;
-	}
 
-	rmi4_data->f12_wakeup_gesture = query_5->ctrl27_is_present;
-	if (rmi4_data->f12_wakeup_gesture) {
-		extra_data->ctrl20_offset = ctrl_20_offset;
-		extra_data->data4_offset = query_8->data0_is_present +
-				query_8->data1_is_present +
-				query_8->data2_is_present +
-				query_8->data3_is_present;
-	}
+	retval = synaptics_rmi4_f12_set_coords(rmi4_data, fhandler);
+	if (retval < 0)
+		goto free_function_handler_mem;
 
 	synaptics_rmi4_set_intr_mask(fhandler, fd, intr_count);
 
@@ -2523,19 +2159,16 @@ static int synaptics_rmi4_f12_init(struct synaptics_rmi4_data *rmi4_data,
 	fhandler->data = kmalloc(fhandler->data_size, GFP_KERNEL);
 	if (!fhandler->data) {
 		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to alloc mem for fhandler->data\n",
-				__func__);
+			"%s: Failed to alloc mem for function handler data\n",
+			__func__);
 		retval = -ENOMEM;
-		goto exit;
+		goto free_function_handler_mem;
 	}
 
-exit:
-	kfree(query_5);
-	kfree(query_8);
-	kfree(ctrl_8);
-	kfree(ctrl_23);
-	kfree(ctrl_31);
+	return retval;
 
+free_function_handler_mem:
+	kfree(fhandler->extra);
 	return retval;
 }
 
@@ -2546,12 +2179,8 @@ static int synaptics_rmi4_f1a_alloc_mem(struct synaptics_rmi4_data *rmi4_data,
 	struct synaptics_rmi4_f1a_handle *f1a;
 
 	f1a = kzalloc(sizeof(*f1a), GFP_KERNEL);
-	if (!f1a) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to alloc mem for function handle\n",
-				__func__);
+	if (!f1a)
 		return -ENOMEM;
-	}
 
 	fhandler->data = (void *)f1a;
 	fhandler->extra = NULL;
@@ -2570,32 +2199,20 @@ static int synaptics_rmi4_f1a_alloc_mem(struct synaptics_rmi4_data *rmi4_data,
 	f1a->max_count = f1a->button_query.max_button_count + 1;
 
 	f1a->button_control.txrx_map = kzalloc(f1a->max_count * 2, GFP_KERNEL);
-	if (!f1a->button_control.txrx_map) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to alloc mem for tx rx mapping\n",
-				__func__);
+	if (!f1a->button_control.txrx_map)
 		return -ENOMEM;
-	}
 
 	f1a->button_bitmask_size = (f1a->max_count + 7) / 8;
 
 	f1a->button_data_buffer = kcalloc(f1a->button_bitmask_size,
 			sizeof(*(f1a->button_data_buffer)), GFP_KERNEL);
-	if (!f1a->button_data_buffer) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to alloc mem for data buffer\n",
-				__func__);
+	if (!f1a->button_data_buffer)
 		return -ENOMEM;
-	}
 
 	f1a->button_map = kcalloc(f1a->max_count,
 			sizeof(*(f1a->button_map)), GFP_KERNEL);
-	if (!f1a->button_map) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to alloc mem for button map\n",
-				__func__);
+	if (!f1a->button_map)
 		return -ENOMEM;
-	}
 
 	return 0;
 }
@@ -2605,21 +2222,20 @@ static int synaptics_rmi4_f1a_button_map(struct synaptics_rmi4_data *rmi4_data,
 {
 	int retval;
 	unsigned char ii;
-	unsigned char offset = 0;
-	struct synaptics_rmi4_f1a_query_4 query_4;
+	unsigned char mapping_offset = 0;
 	struct synaptics_rmi4_f1a_handle *f1a = fhandler->data;
 	const struct synaptics_dsx_board_data *bdata =
 			rmi4_data->hw_if->board_data;
 
-	offset = f1a->button_query.has_general_control +
+	mapping_offset = f1a->button_query.has_general_control +
 			f1a->button_query.has_interrupt_enable +
 			f1a->button_query.has_multibutton_select;
 
 	if (f1a->button_query.has_tx_rx_map) {
 		retval = synaptics_rmi4_reg_read(rmi4_data,
-				fhandler->full_addr.ctrl_base + offset,
+				fhandler->full_addr.ctrl_base + mapping_offset,
 				f1a->button_control.txrx_map,
-				f1a->max_count * 2);
+				sizeof(f1a->button_control.txrx_map));
 		if (retval < 0) {
 			dev_err(rmi4_data->pdev->dev.parent,
 					"%s: Failed to read tx rx mapping\n",
@@ -2630,37 +2246,14 @@ static int synaptics_rmi4_f1a_button_map(struct synaptics_rmi4_data *rmi4_data,
 		rmi4_data->button_txrx_mapping = f1a->button_control.txrx_map;
 	}
 
-	if (f1a->button_query.has_query4) {
-		offset = 2 + f1a->button_query.has_query2 +
-				f1a->button_query.has_query3;
-
-		retval = synaptics_rmi4_reg_read(rmi4_data,
-				fhandler->full_addr.query_base + offset,
-				query_4.data,
-				sizeof(query_4.data));
-		if (retval < 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to read button features 4\n",
-					__func__);
-			return retval;
-		}
-
-		if (query_4.has_ctrl24)
-			rmi4_data->external_afe_buttons = true;
-		else
-			rmi4_data->external_afe_buttons = false;
-	}
-
 	if (!bdata->cap_button_map) {
-		dev_err(rmi4_data->pdev->dev.parent,
+		dev_dbg(rmi4_data->pdev->dev.parent,
 				"%s: cap_button_map is NULL in board file\n",
 				__func__);
-		return -ENODEV;
 	} else if (!bdata->cap_button_map->map) {
 		dev_err(rmi4_data->pdev->dev.parent,
 				"%s: Button map is missing in board file\n",
 				__func__);
-		return -ENODEV;
 	} else {
 		if (bdata->cap_button_map->nbuttons != f1a->max_count) {
 			f1a->valid_button_count = min(f1a->max_count,
@@ -2687,8 +2280,6 @@ static void synaptics_rmi4_f1a_kfree(struct synaptics_rmi4_fn *fhandler)
 		kfree(f1a);
 		fhandler->data = NULL;
 	}
-
-	return;
 }
 
 static int synaptics_rmi4_f1a_init(struct synaptics_rmi4_data *rmi4_data,
@@ -2745,8 +2336,6 @@ static void synaptics_rmi4_empty_fn_list(struct synaptics_rmi4_data *rmi4_data)
 		}
 	}
 	INIT_LIST_HEAD(&rmi->support_fn_list);
-
-	return;
 }
 
 static int synaptics_rmi4_check_status(struct synaptics_rmi4_data *rmi4_data,
@@ -2754,8 +2343,20 @@ static int synaptics_rmi4_check_status(struct synaptics_rmi4_data *rmi4_data,
 {
 	int retval;
 	int timeout = CHECK_STATUS_TIMEOUT_MS;
+	unsigned char command = 0x01;
+	unsigned char intr_status;
 	struct synaptics_rmi4_f01_device_status status;
 
+	/* Do a device reset first */
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			rmi4_data->f01_cmd_base_addr,
+			&command,
+			sizeof(command));
+	if (retval < 0)
+		return retval;
+
+	msleep(rmi4_data->hw_if->board_data->reset_delay_ms);
+
 	retval = synaptics_rmi4_reg_read(rmi4_data,
 			rmi4_data->f01_data_base_addr,
 			status.data,
@@ -2766,8 +2367,12 @@ static int synaptics_rmi4_check_status(struct synaptics_rmi4_data *rmi4_data,
 	while (status.status_code == STATUS_CRC_IN_PROGRESS) {
 		if (timeout > 0)
 			msleep(20);
-		else
+		else {
+			dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read interrupt status\n",
+				__func__);
 			return -EINVAL;
+		}
 
 		retval = synaptics_rmi4_reg_read(rmi4_data,
 				rmi4_data->f01_data_base_addr,
@@ -2791,6 +2396,17 @@ static int synaptics_rmi4_check_status(struct synaptics_rmi4_data *rmi4_data,
 		rmi4_data->flash_prog_mode = false;
 	}
 
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			rmi4_data->f01_data_base_addr + 1,
+			&intr_status,
+			sizeof(intr_status));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read interrupt status\n",
+				__func__);
+		return retval;
+	}
+
 	return 0;
 }
 
@@ -2822,8 +2438,6 @@ static void synaptics_rmi4_set_configured(struct synaptics_rmi4_data *rmi4_data)
 				"%s: Failed to set configured\n",
 				__func__);
 	}
-
-	return;
 }
 
 static int synaptics_rmi4_alloc_fh(struct synaptics_rmi4_fn **fhandler,
@@ -2849,25 +2463,65 @@ static int synaptics_rmi4_alloc_fh(struct synaptics_rmi4_fn **fhandler,
 	return 0;
 }
 
+static int synaptics_rmi4_read_configid(struct synaptics_rmi4_data *rmi4_data,
+		unsigned char ctrl_base_addr)
+{
+	unsigned int device_config_id;
+
+	/*
+	 * We may get an error while trying to read config id if it is
+	 *  not provisioned by vendor
+	 */
+	if (synaptics_rmi4_reg_read(rmi4_data, ctrl_base_addr,
+			(unsigned char *)(&device_config_id),
+			 sizeof(device_config_id)) < 0)
+		dev_err(rmi4_data->pdev->dev.parent, "Failed to read device config ID from CTP\n");
+
+	if (rmi4_data->hw_if->board_data->config_id)
+		dev_info(rmi4_data->pdev->dev.parent,
+			"CTP Config ID=%pI4\tDT Config ID=%pI4\n",
+			&device_config_id,
+			&rmi4_data->hw_if->board_data->config_id);
+	else
+		dev_info(rmi4_data->pdev->dev.parent,
+			"CTP Config ID=%pI4\n", &device_config_id);
+
+	return 0;
+}
+
+ /**
+ * synaptics_rmi4_query_device()
+ *
+ * Called by synaptics_rmi4_probe().
+ *
+ * This function scans the page description table, records the offsets
+ * to the register types of Function $01, sets up the function handlers
+ * for Function $11 and Function $12, determines the number of interrupt
+ * sources from the sensor, adds valid Functions with data inputs to the
+ * Function linked list, parses information from the query registers of
+ * Function $01, and enables the interrupt sources from the valid Functions
+ * with data inputs.
+ */
 static int synaptics_rmi4_query_device(struct synaptics_rmi4_data *rmi4_data)
 {
 	int retval;
+	unsigned char ii;
 	unsigned char page_number;
 	unsigned char intr_count;
-	unsigned char *f01_query;
+	unsigned char f01_query[F01_STD_QUERY_LEN];
 	unsigned short pdt_entry_addr;
+	unsigned short intr_addr;
 	bool f01found;
-	bool f35found;
 	bool was_in_bl_mode;
 	struct synaptics_rmi4_fn_desc rmi_fd;
 	struct synaptics_rmi4_fn *fhandler;
 	struct synaptics_rmi4_device_info *rmi;
+	unsigned char pkg_id[PACKAGE_ID_SIZE];
 
 	rmi = &(rmi4_data->rmi4_mod_info);
 
 rescan_pdt:
 	f01found = false;
-	f35found = false;
 	was_in_bl_mode = false;
 	intr_count = 0;
 	INIT_LIST_HEAD(&rmi->support_fn_list);
@@ -2902,6 +2556,15 @@ rescan_pdt:
 					page_number);
 
 			switch (rmi_fd.fn_number) {
+			case SYNAPTICS_RMI4_F34:
+				/*
+				 * Though function F34 is an interrupt source,
+				 * but it is not a data source, hence do not
+				 * add its handler to support_fn_list
+				 */
+				synaptics_rmi4_read_configid(rmi4_data,
+						 rmi_fd.ctrl_base_addr);
+				break;
 			case SYNAPTICS_RMI4_F01:
 				if (rmi_fd.intr_src_count == 0)
 					break;
@@ -3005,13 +2668,10 @@ rescan_pdt:
 #endif
 				}
 				break;
-			case SYNAPTICS_RMI4_F35:
-				f35found = true;
-				break;
 			}
 
 			/* Accumulate the interrupt count */
-			intr_count += rmi_fd.intr_src_count;
+			intr_count += (rmi_fd.intr_src_count & MASK_3BIT);
 
 			if (fhandler && rmi_fd.intr_src_count) {
 				list_add_tail(&fhandler->link,
@@ -3024,16 +2684,7 @@ rescan_pdt:
 		dev_err(rmi4_data->pdev->dev.parent,
 				"%s: Failed to find F01\n",
 				__func__);
-		if (!f35found) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to find F35\n",
-					__func__);
-			return -EINVAL;
-		} else {
-			pr_notice("%s: In microbootloader mode\n",
-					__func__);
-			return 0;
-		}
+		return -EINVAL;
 	}
 
 flash_prog_mode:
@@ -3042,22 +2693,12 @@ flash_prog_mode:
 			"%s: Number of interrupt registers = %d\n",
 			__func__, rmi4_data->num_of_intr_regs);
 
-	f01_query = kmalloc(F01_STD_QUERY_LEN, GFP_KERNEL);
-	if (!f01_query) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to alloc mem for f01_query\n",
-				__func__);
-		return -ENOMEM;
-	}
-
 	retval = synaptics_rmi4_reg_read(rmi4_data,
 			rmi4_data->f01_query_base_addr,
 			f01_query,
-			F01_STD_QUERY_LEN);
-	if (retval < 0) {
-		kfree(f01_query);
+			sizeof(f01_query));
+	if (retval < 0)
 		return retval;
-	}
 
 	/* RMI Version 4.0 currently supported */
 	rmi->version_major = 4;
@@ -3065,20 +2706,16 @@ flash_prog_mode:
 
 	rmi->manufacturer_id = f01_query[0];
 	rmi->product_props = f01_query[1];
-	rmi->product_info[0] = f01_query[2];
-	rmi->product_info[1] = f01_query[3];
-	retval = secure_memcpy(rmi->product_id_string,
-			sizeof(rmi->product_id_string),
-			&f01_query[11],
-			F01_STD_QUERY_LEN - 11,
-			PRODUCT_ID_SIZE);
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to copy product ID string\n",
-				__func__);
-	}
-
-	kfree(f01_query);
+	rmi->product_info[0] = f01_query[2] & MASK_7BIT;
+	rmi->product_info[1] = f01_query[3] & MASK_7BIT;
+	rmi->date_code[0] = f01_query[4] & MASK_5BIT;
+	rmi->date_code[1] = f01_query[5] & MASK_4BIT;
+	rmi->date_code[2] = f01_query[6] & MASK_5BIT;
+	rmi->tester_id = ((f01_query[7] & MASK_7BIT) << 8) |
+			(f01_query[8] & MASK_7BIT);
+	rmi->serial_number = ((f01_query[9] & MASK_7BIT) << 8) |
+			(f01_query[10] & MASK_7BIT);
+	memcpy(rmi->product_id_string, &f01_query[11], 10);
 
 	if (rmi->manufacturer_id != 1) {
 		dev_err(rmi4_data->pdev->dev.parent,
@@ -3087,6 +2724,19 @@ flash_prog_mode:
 	}
 
 	retval = synaptics_rmi4_reg_read(rmi4_data,
+			rmi4_data->f01_query_base_addr + F01_PACKAGE_ID_OFFSET,
+			pkg_id, sizeof(pkg_id));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+			"%s: Failed to read device package id (code %d)\n",
+			__func__, retval);
+		return retval;
+	}
+
+	rmi->package_id = (pkg_id[1] << 8) | pkg_id[0];
+	rmi->package_id_rev = (pkg_id[3] << 8) | pkg_id[2];
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
 			rmi4_data->f01_query_base_addr + F01_BUID_ID_OFFSET,
 			rmi->build_id,
 			sizeof(rmi->build_id));
@@ -3112,64 +2762,50 @@ flash_prog_mode:
 		}
 	}
 
-	if (rmi4_data->f11_wakeup_gesture || rmi4_data->f12_wakeup_gesture)
-		rmi4_data->enable_wakeup_gesture = WAKEUP_GESTURE;
-	else
-		rmi4_data->enable_wakeup_gesture = false;
+	/* Enable the interrupt sources */
+	for (ii = 0; ii < rmi4_data->num_of_intr_regs; ii++) {
+		if (rmi4_data->intr_mask[ii] != 0x00) {
+			dev_dbg(rmi4_data->pdev->dev.parent,
+					"%s: Interrupt enable mask %d = 0x%02x\n",
+					__func__, ii, rmi4_data->intr_mask[ii]);
+			intr_addr = rmi4_data->f01_ctrl_base_addr + 1 + ii;
+			retval = synaptics_rmi4_reg_write(rmi4_data,
+					intr_addr,
+					&(rmi4_data->intr_mask[ii]),
+					sizeof(rmi4_data->intr_mask[ii]));
+			if (retval < 0)
+				return retval;
+		}
+	}
 
 	synaptics_rmi4_set_configured(rmi4_data);
 
 	return 0;
 }
 
-static int synaptics_rmi4_gpio_setup(int gpio, bool config, int dir, int state)
-{
-	int retval = 0;
-	unsigned char buf[16];
-
-	if (config) {
-		retval = snprintf(buf, ARRAY_SIZE(buf), "dsx_gpio_%u\n", gpio);
-		if (retval >= 16)
-			return -EINVAL;
-
-		retval = gpio_request(gpio, buf);
-		if (retval) {
-			pr_err("%s: Failed to get gpio %d (code: %d)",
-					__func__, gpio, retval);
-			return retval;
-		}
-
-		if (dir == 0)
-			retval = gpio_direction_input(gpio);
-		else
-			retval = gpio_direction_output(gpio, state);
-		if (retval) {
-			pr_err("%s: Failed to set gpio %d direction",
-					__func__, gpio);
-			return retval;
-		}
-	} else {
-		gpio_free(gpio);
-	}
-
-	return retval;
-}
-
 static void synaptics_rmi4_set_params(struct synaptics_rmi4_data *rmi4_data)
 {
 	unsigned char ii;
 	struct synaptics_rmi4_f1a_handle *f1a;
 	struct synaptics_rmi4_fn *fhandler;
 	struct synaptics_rmi4_device_info *rmi;
+	const struct synaptics_dsx_board_data *bdata =
+			rmi4_data->hw_if->board_data;
 
 	rmi = &(rmi4_data->rmi4_mod_info);
 
-	input_set_abs_params(rmi4_data->input_dev,
-			ABS_MT_POSITION_X, 0,
-			rmi4_data->sensor_max_x, 0, 0);
-	input_set_abs_params(rmi4_data->input_dev,
-			ABS_MT_POSITION_Y, 0,
-			rmi4_data->sensor_max_y, 0, 0);
+	if (bdata->disp_maxx && bdata->disp_maxy) {
+		input_set_abs_params(rmi4_data->input_dev, ABS_MT_POSITION_X,
+				0, bdata->disp_maxx, 0, 0);
+		input_set_abs_params(rmi4_data->input_dev, ABS_MT_POSITION_Y,
+				0, bdata->disp_maxy, 0, 0);
+	} /* else {
+		input_set_abs_params(rmi4_data->input_dev, ABS_MT_POSITION_X,
+				0, rmi4_data->sensor_max_x, 0, 0);
+		input_set_abs_params(rmi4_data->input_dev, ABS_MT_POSITION_Y,
+				0, rmi4_data->sensor_max_y, 0, 0);
+	}*/
+
 #ifdef REPORT_2D_W
 	input_set_abs_params(rmi4_data->input_dev,
 			ABS_MT_TOUCH_MAJOR, 0,
@@ -3179,22 +2815,9 @@ static void synaptics_rmi4_set_params(struct synaptics_rmi4_data *rmi4_data)
 			rmi4_data->max_touch_width, 0, 0);
 #endif
 
-#ifdef REPORT_2D_PRESSURE
-	if (rmi4_data->report_pressure) {
-		input_set_abs_params(rmi4_data->input_dev,
-				ABS_MT_PRESSURE, 0,
-				MAX_F12_TOUCH_PRESSURE, 0, 0);
-	}
-#endif
-
 #ifdef TYPE_B_PROTOCOL
-#ifdef KERNEL_ABOVE_3_6
-	input_mt_init_slots(rmi4_data->input_dev,
-			rmi4_data->num_of_fingers, INPUT_MT_DIRECT);
-#else
 	input_mt_init_slots(rmi4_data->input_dev,
-			rmi4_data->num_of_fingers);
-#endif
+			rmi4_data->num_of_fingers, 0);
 #endif
 
 	f1a = NULL;
@@ -3213,40 +2836,292 @@ static void synaptics_rmi4_set_params(struct synaptics_rmi4_data *rmi4_data)
 					EV_KEY, f1a->button_map[ii]);
 		}
 	}
+}
 
-	if (vir_button_map->nbuttons) {
-		for (ii = 0; ii < vir_button_map->nbuttons; ii++) {
-			set_bit(vir_button_map->map[ii * 5],
-					rmi4_data->input_dev->keybit);
-			input_set_capability(rmi4_data->input_dev,
-					EV_KEY, vir_button_map->map[ii * 5]);
-		}
+static int synaptics_dsx_virtual_keys_init(struct device *dev,
+			struct synaptics_dsx_board_data	*rmi4_pdata)
+{
+	int width, height, center_x, center_y;
+	int x1 = 0, x2 = 0, i, c = 0, rc = 0, border;
+
+	vkey_buf = devm_kzalloc(dev, MAX_BUF_SIZE, GFP_KERNEL);
+	if (!vkey_buf)
+		return -ENOMEM;
+
+	border = (rmi4_pdata->panel_maxx - rmi4_pdata->disp_maxx) * 2;
+	width = ((rmi4_pdata->disp_maxx -
+			(border * (rmi4_pdata->virtual_key_map->nkeys - 1)))
+			/ rmi4_pdata->virtual_key_map->nkeys);
+	height = (rmi4_pdata->panel_maxy - rmi4_pdata->disp_maxy);
+	center_y = rmi4_pdata->disp_maxy + (height / 2);
+	height = height * HEIGHT_SCALE_NUM / HEIGHT_SCALE_DENOM;
+
+	x2 -= border * BORDER_ADJUST_NUM / BORDER_ADJUST_DENOM;
+
+	for (i = 0; i < rmi4_pdata->virtual_key_map->nkeys; i++) {
+		x1 = x2 + border;
+		x2 = x2 + border + width;
+		center_x = x1 + (x2 - x1) / 2;
+		c += snprintf(vkey_buf + c, MAX_BUF_SIZE - c,
+				"%s:%d:%d:%d:%d:%d\n", VKEY_VER_CODE,
+				rmi4_pdata->virtual_key_map->map[i],
+				center_x, center_y, width, height);
 	}
 
-	if (rmi4_data->f11_wakeup_gesture || rmi4_data->f12_wakeup_gesture) {
-		set_bit(KEY_WAKEUP, rmi4_data->input_dev->keybit);
-		input_set_capability(rmi4_data->input_dev, EV_KEY, KEY_WAKEUP);
+	vkey_buf[c] = '\0';
+
+	vkey_kobj = kobject_create_and_add("board_properties", NULL);
+	if (!vkey_kobj) {
+		dev_err(dev, "unable to create kobject\n");
+		return -ENOMEM;
 	}
 
-	return;
+	rc = sysfs_create_group(vkey_kobj, &vkey_grp);
+	if (rc) {
+		dev_err(dev, "failed to create attributes\n");
+		kobject_put(vkey_kobj);
+	}
+
+	return rc;
 }
 
-static int synaptics_rmi4_set_input_dev(struct synaptics_rmi4_data *rmi4_data)
+static int synaptics_dsx_get_virtual_keys(struct device *dev,
+				struct property *prop, char *name,
+				struct synaptics_dsx_board_data *rmi4_pdata,
+				struct device_node *np)
 {
-	int retval;
-	const struct synaptics_dsx_board_data *bdata =
-				rmi4_data->hw_if->board_data;
+	u32 num_keys;
+	int rc;
 
-	rmi4_data->input_dev = input_allocate_device();
-	if (rmi4_data->input_dev == NULL) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to allocate input device\n",
-				__func__);
-		retval = -ENOMEM;
-		goto err_input_device;
-	}
+	num_keys = prop->length / sizeof(u32);
 
-	retval = synaptics_rmi4_query_device(rmi4_data);
+	rmi4_pdata->virtual_key_map = devm_kzalloc(dev,
+			sizeof(*rmi4_pdata->virtual_key_map),
+			GFP_KERNEL);
+	if (!rmi4_pdata->virtual_key_map)
+		return -ENOMEM;
+
+	rmi4_pdata->virtual_key_map->map = devm_kzalloc(dev,
+		sizeof(*rmi4_pdata->virtual_key_map->map) *
+		num_keys, GFP_KERNEL);
+	if (!rmi4_pdata->virtual_key_map->map)
+		return -ENOMEM;
+
+	rc = of_property_read_u32_array(np, name,
+			rmi4_pdata->virtual_key_map->map,
+			num_keys);
+	if (rc) {
+		dev_err(dev, "Failed to read key codes\n");
+		return -EINVAL;
+	}
+	rmi4_pdata->virtual_key_map->nkeys = num_keys;
+
+	return 0;
+}
+
+static int synaptics_dsx_get_button_map(struct device *dev,
+				struct property *prop, char *name,
+				struct synaptics_dsx_board_data *rmi4_pdata,
+				struct device_node *np)
+{
+	int rc, i;
+	u32 num_buttons;
+	u32 button_map[MAX_NUMBER_OF_BUTTONS];
+
+	num_buttons = prop->length / sizeof(u32);
+
+	rmi4_pdata->cap_button_map = devm_kzalloc(dev,
+			sizeof(*rmi4_pdata->cap_button_map),
+			GFP_KERNEL);
+	if (!rmi4_pdata->cap_button_map)
+		return -ENOMEM;
+
+	rmi4_pdata->cap_button_map->map = devm_kzalloc(dev,
+		sizeof(*rmi4_pdata->cap_button_map->map) *
+		num_buttons, GFP_KERNEL);
+	if (!rmi4_pdata->cap_button_map->map)
+		return -ENOMEM;
+
+	if (num_buttons <= MAX_NUMBER_OF_BUTTONS) {
+		rc = of_property_read_u32_array(np,
+				name, button_map, num_buttons);
+		if (rc) {
+			dev_err(dev, "Unable to read key codes\n");
+			return rc;
+		}
+		for (i = 0; i < num_buttons; i++)
+			rmi4_pdata->cap_button_map->map[i] =
+				button_map[i];
+		rmi4_pdata->cap_button_map->nbuttons = num_buttons;
+	} else {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int synaptics_rmi4_parse_dt_children(struct device *dev,
+		struct synaptics_dsx_board_data *rmi4_pdata,
+		struct synaptics_rmi4_data *rmi4_data)
+{
+	struct synaptics_rmi4_device_info *rmi = &rmi4_data->rmi4_mod_info;
+	struct device_node *node = dev->of_node, *child = NULL;
+	int rc = 0;
+	struct synaptics_rmi4_fn *fhandler = NULL;
+	struct property *prop;
+
+	for_each_child_of_node(node, child) {
+		rc = of_property_read_u32(child, "synaptics,package-id",
+				&rmi4_pdata->package_id);
+		if (rc && (rc != -EINVAL)) {
+			dev_err(dev, "Unable to read package_id\n");
+			return rc;
+		} else if (rc == -EINVAL) {
+			rmi4_pdata->package_id = 0x00;
+		}
+
+		if (rmi4_pdata->package_id) {
+			if (rmi4_pdata->package_id != rmi->package_id) {
+				dev_err(dev,
+				"%s: Synaptics package id don't match %d %d\n",
+				__func__,
+				rmi4_pdata->package_id, rmi->package_id);
+				/*
+				 * Iterate over next child if package
+				 * id does not match
+				 */
+				continue;
+			} else if (of_property_read_bool(child,
+				"synaptics,bypass-sensor-coords-check") &&
+				of_find_property(child,
+					"synaptics,panel-coords", NULL)) {
+				/*
+				 * Some unprogrammed panels from touch vendor
+				 * and wrongly programmed panels from factory
+				 * may return incorrect sensor coordinate range
+				 * when their query registers are read, but
+				 * they normally work fine in field. In such
+				 * a scenario, driver can bypass the comparison
+				 * of coordinate range read from sensor and read
+				 * from DT and continue normal operation.
+				 */
+				synaptics_dsx_get_dt_coords(dev,
+						"synaptics,panel-coords",
+						rmi4_pdata, child);
+				dev_info(dev,
+					"%s Synaptics package id matches %d %d",
+					__func__, rmi4_pdata->package_id,
+					rmi->package_id);
+				dev_info(dev, "Pmax_x Pmax_y = %d:%d\n",
+					rmi4_pdata->panel_maxx,
+					rmi4_pdata->panel_maxy);
+				dev_info(dev, "Smax_x Smax_y = %d:%d\n",
+					rmi4_data->sensor_max_x,
+					rmi4_data->sensor_max_y);
+			} else {
+				/*
+				 * If package id read from DT matches the
+				 * package id value read from touch controller,
+				 * also check if sensor dimensions read from DT
+				 * match those read from controller, before
+				 * moving further. For this first check if touch
+				 * panel coordinates are defined in DT or not.
+				 */
+				if (of_find_property(child,
+					"synaptics,panel-coords", NULL)) {
+					synaptics_dsx_get_dt_coords(dev,
+						"synaptics,panel-coords",
+						rmi4_pdata, child);
+					dev_info(dev, "Pmax_x Pmax_y = %d:%d\n",
+						rmi4_pdata->panel_maxx,
+						rmi4_pdata->panel_maxy);
+					dev_info(dev, "Smax_x Smax_y = %d:%d\n",
+						rmi4_data->sensor_max_x,
+						rmi4_data->sensor_max_y);
+					if ((rmi4_pdata->panel_maxx !=
+						rmi4_data->sensor_max_x) ||
+						(rmi4_pdata->panel_maxy !=
+						rmi4_data->sensor_max_y))
+						continue;
+				} else {
+					dev_info(dev, "Smax_x Smax_y = %d:%d\n",
+						rmi4_data->sensor_max_x,
+						rmi4_data->sensor_max_y);
+				}
+			}
+		}
+
+		rc = synaptics_dsx_get_dt_coords(dev,
+				"synaptics,display-coords", rmi4_pdata, child);
+		if (rc && (rc != -EINVAL))
+			return rc;
+
+		prop = of_find_property(child, "synaptics,button-map", NULL);
+		if (prop) {
+			rc = synaptics_dsx_get_button_map(dev, prop,
+				"synaptics,button-map", rmi4_pdata, child);
+			if (rc < 0) {
+				dev_err(dev, "Unable to read button map\n");
+				return rc;
+			}
+
+			if (!list_empty(&rmi->support_fn_list)) {
+				list_for_each_entry(fhandler,
+						&rmi->support_fn_list, link) {
+					if (fhandler->fn_number ==
+						SYNAPTICS_RMI4_F1A)
+						break;
+				}
+			}
+
+			if (fhandler && fhandler->fn_number ==
+					SYNAPTICS_RMI4_F1A) {
+				rc = synaptics_rmi4_f1a_button_map(rmi4_data,
+								fhandler);
+				if (rc < 0) {
+					dev_err(dev,
+						"Fail to register F1A %d\n",
+						rc);
+					return rc;
+				}
+			}
+		}
+
+		prop = of_find_property(child, "synaptics,key-codes", NULL);
+		if (prop) {
+			rc = synaptics_dsx_get_virtual_keys(dev, prop,
+				"synaptics,key-codes", rmi4_pdata, child);
+			if (!rc) {
+				rc = synaptics_dsx_virtual_keys_init(dev,
+					rmi4_pdata);
+				if (!rc)
+					rmi4_data->support_vkeys = true;
+
+			} else {
+				dev_err(dev,
+					"Unable to read virtual key codes\n");
+				return rc;
+			}
+		}
+
+		break;
+	}
+
+	return 0;
+}
+
+static int synaptics_rmi4_set_input_dev(struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	int temp;
+
+	rmi4_data->input_dev = input_allocate_device();
+	if (rmi4_data->input_dev == NULL) {
+		retval = -ENOMEM;
+		goto err_input_device;
+	}
+
+	retval = synaptics_rmi4_query_device(rmi4_data);
 	if (retval < 0) {
 		dev_err(rmi4_data->pdev->dev.parent,
 				"%s: Failed to query device\n",
@@ -3254,6 +3129,17 @@ static int synaptics_rmi4_set_input_dev(struct synaptics_rmi4_data *rmi4_data)
 		goto err_query_device;
 	}
 
+	if (rmi4_data->hw_if->board_data->detect_device) {
+		retval = synaptics_rmi4_parse_dt_children(
+				rmi4_data->pdev->dev.parent,
+				rmi4_data->hw_if->board_data,
+				rmi4_data);
+		if (retval < 0)
+			dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to parse device tree property\n",
+				__func__);
+	}
+
 	rmi4_data->input_dev->name = PLATFORM_DRIVER_NAME;
 	rmi4_data->input_dev->phys = INPUT_PHYS_NAME;
 	rmi4_data->input_dev->id.product = SYNAPTICS_DSX_DRIVER_PRODUCT;
@@ -3270,8 +3156,11 @@ static int synaptics_rmi4_set_input_dev(struct synaptics_rmi4_data *rmi4_data)
 	set_bit(INPUT_PROP_DIRECT, rmi4_data->input_dev->propbit);
 #endif
 
-	if (bdata->max_y_for_2d >= 0)
-		rmi4_data->sensor_max_y = bdata->max_y_for_2d;
+	if (rmi4_data->hw_if->board_data->swap_axes) {
+		temp = rmi4_data->sensor_max_x;
+		rmi4_data->sensor_max_x = rmi4_data->sensor_max_y;
+		rmi4_data->sensor_max_y = temp;
+	}
 
 	synaptics_rmi4_set_params(rmi4_data);
 
@@ -3283,58 +3172,13 @@ static int synaptics_rmi4_set_input_dev(struct synaptics_rmi4_data *rmi4_data)
 		goto err_register_input;
 	}
 
-	if (!rmi4_data->stylus_enable)
-		return 0;
-
-	rmi4_data->stylus_dev = input_allocate_device();
-	if (rmi4_data->stylus_dev == NULL) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to allocate stylus device\n",
-				__func__);
-		retval = -ENOMEM;
-		goto err_stylus_device;
-	}
-
-	rmi4_data->stylus_dev->name = STYLUS_DRIVER_NAME;
-	rmi4_data->stylus_dev->phys = STYLUS_PHYS_NAME;
-	rmi4_data->stylus_dev->id.product = SYNAPTICS_DSX_DRIVER_PRODUCT;
-	rmi4_data->stylus_dev->id.version = SYNAPTICS_DSX_DRIVER_VERSION;
-	rmi4_data->stylus_dev->dev.parent = rmi4_data->pdev->dev.parent;
-	input_set_drvdata(rmi4_data->stylus_dev, rmi4_data);
-
-	set_bit(EV_KEY, rmi4_data->stylus_dev->evbit);
-	set_bit(EV_ABS, rmi4_data->stylus_dev->evbit);
-	set_bit(BTN_TOUCH, rmi4_data->stylus_dev->keybit);
-	set_bit(BTN_TOOL_PEN, rmi4_data->stylus_dev->keybit);
-	if (rmi4_data->eraser_enable)
-		set_bit(BTN_TOOL_RUBBER, rmi4_data->stylus_dev->keybit);
-#ifdef INPUT_PROP_DIRECT
-	set_bit(INPUT_PROP_DIRECT, rmi4_data->stylus_dev->propbit);
-#endif
-
-	input_set_abs_params(rmi4_data->stylus_dev, ABS_X, 0,
-			rmi4_data->sensor_max_x, 0, 0);
-	input_set_abs_params(rmi4_data->stylus_dev, ABS_Y, 0,
-			rmi4_data->sensor_max_y, 0, 0);
-
-	retval = input_register_device(rmi4_data->stylus_dev);
-	if (retval) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to register stylus device\n",
-				__func__);
-		goto err_register_stylus;
-	}
-
 	return 0;
 
-err_register_stylus:
-	rmi4_data->stylus_dev = NULL;
-
-err_stylus_device:
-	input_unregister_device(rmi4_data->input_dev);
-	rmi4_data->input_dev = NULL;
-
 err_register_input:
+	if (rmi4_data->support_vkeys) {
+		sysfs_remove_group(vkey_kobj, &vkey_grp);
+		kobject_put(vkey_kobj);
+	}
 err_query_device:
 	synaptics_rmi4_empty_fn_list(rmi4_data);
 	input_free_device(rmi4_data->input_dev);
@@ -3346,10 +3190,15 @@ err_input_device:
 static int synaptics_rmi4_set_gpio(struct synaptics_rmi4_data *rmi4_data)
 {
 	int retval;
+	int power_on;
+	int reset_on;
 	const struct synaptics_dsx_board_data *bdata =
 			rmi4_data->hw_if->board_data;
 
-	retval = synaptics_rmi4_gpio_setup(
+	power_on = bdata->power_on_state;
+	reset_on = bdata->reset_on_state;
+
+	retval = bdata->gpio_config(
 			bdata->irq_gpio,
 			true, 0, 0);
 	if (retval < 0) {
@@ -3360,9 +3209,9 @@ static int synaptics_rmi4_set_gpio(struct synaptics_rmi4_data *rmi4_data)
 	}
 
 	if (bdata->power_gpio >= 0) {
-		retval = synaptics_rmi4_gpio_setup(
+		retval = bdata->gpio_config(
 				bdata->power_gpio,
-				true, 1, !bdata->power_on_state);
+				true, 1, !power_on);
 		if (retval < 0) {
 			dev_err(rmi4_data->pdev->dev.parent,
 					"%s: Failed to configure power GPIO\n",
@@ -3372,9 +3221,9 @@ static int synaptics_rmi4_set_gpio(struct synaptics_rmi4_data *rmi4_data)
 	}
 
 	if (bdata->reset_gpio >= 0) {
-		retval = synaptics_rmi4_gpio_setup(
+		retval = bdata->gpio_config(
 				bdata->reset_gpio,
-				true, 1, !bdata->reset_on_state);
+				true, 1, !reset_on);
 		if (retval < 0) {
 			dev_err(rmi4_data->pdev->dev.parent,
 					"%s: Failed to configure reset GPIO\n",
@@ -3384,126 +3233,171 @@ static int synaptics_rmi4_set_gpio(struct synaptics_rmi4_data *rmi4_data)
 	}
 
 	if (bdata->power_gpio >= 0) {
-		gpio_set_value(bdata->power_gpio, bdata->power_on_state);
+		gpio_set_value(bdata->power_gpio, power_on);
 		msleep(bdata->power_delay_ms);
 	}
 
 	if (bdata->reset_gpio >= 0) {
-		gpio_set_value(bdata->reset_gpio, bdata->reset_on_state);
+		gpio_set_value(bdata->reset_gpio, reset_on);
 		msleep(bdata->reset_active_ms);
-		gpio_set_value(bdata->reset_gpio, !bdata->reset_on_state);
+		gpio_set_value(bdata->reset_gpio, !reset_on);
 		msleep(bdata->reset_delay_ms);
 	}
 
 	return 0;
 
 err_gpio_reset:
-	if (bdata->power_gpio >= 0)
-		synaptics_rmi4_gpio_setup(bdata->power_gpio, false, 0, 0);
+	if (bdata->power_gpio >= 0) {
+		bdata->gpio_config(
+				bdata->power_gpio,
+				false, 0, 0);
+	}
 
 err_gpio_power:
-	synaptics_rmi4_gpio_setup(bdata->irq_gpio, false, 0, 0);
+	bdata->gpio_config(
+			bdata->irq_gpio,
+			false, 0, 0);
 
 err_gpio_irq:
 	return retval;
 }
 
-static int synaptics_rmi4_get_reg(struct synaptics_rmi4_data *rmi4_data,
-		bool get)
+static int synaptics_dsx_pinctrl_init(struct synaptics_rmi4_data *rmi4_data)
 {
 	int retval;
-	const struct synaptics_dsx_board_data *bdata =
-			rmi4_data->hw_if->board_data;
 
-	if (!get) {
-		retval = 0;
-		goto regulator_put;
+	/* Get pinctrl if target uses pinctrl */
+	rmi4_data->ts_pinctrl = devm_pinctrl_get((rmi4_data->pdev->dev.parent));
+	if (IS_ERR_OR_NULL(rmi4_data->ts_pinctrl)) {
+		retval = PTR_ERR(rmi4_data->ts_pinctrl);
+		dev_dbg(rmi4_data->pdev->dev.parent,
+			"Target does not use pinctrl %d\n", retval);
+		goto err_pinctrl_get;
 	}
 
-	if ((bdata->pwr_reg_name != NULL) && (*bdata->pwr_reg_name != 0)) {
-		rmi4_data->pwr_reg = regulator_get(rmi4_data->pdev->dev.parent,
-				bdata->pwr_reg_name);
-		if (IS_ERR(rmi4_data->pwr_reg)) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to get power regulator\n",
-					__func__);
-			retval = PTR_ERR(rmi4_data->pwr_reg);
-			goto regulator_put;
-		}
+	rmi4_data->pinctrl_state_active
+		= pinctrl_lookup_state(rmi4_data->ts_pinctrl, "pmx_ts_active");
+	if (IS_ERR_OR_NULL(rmi4_data->pinctrl_state_active)) {
+		retval = PTR_ERR(rmi4_data->pinctrl_state_active);
+		dev_err(rmi4_data->pdev->dev.parent,
+			"Can not lookup %s pinstate %d\n",
+			PINCTRL_STATE_ACTIVE, retval);
+		goto err_pinctrl_lookup;
 	}
 
-	if ((bdata->bus_reg_name != NULL) && (*bdata->bus_reg_name != 0)) {
-		rmi4_data->bus_reg = regulator_get(rmi4_data->pdev->dev.parent,
-				bdata->bus_reg_name);
-		if (IS_ERR(rmi4_data->bus_reg)) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to get bus pullup regulator\n",
-					__func__);
-			retval = PTR_ERR(rmi4_data->bus_reg);
-			goto regulator_put;
-		}
+	rmi4_data->pinctrl_state_suspend
+		= pinctrl_lookup_state(rmi4_data->ts_pinctrl, "pmx_ts_suspend");
+	if (IS_ERR_OR_NULL(rmi4_data->pinctrl_state_suspend)) {
+		retval = PTR_ERR(rmi4_data->pinctrl_state_suspend);
+		dev_dbg(rmi4_data->pdev->dev.parent,
+			"Can not lookup %s pinstate %d\n",
+			PINCTRL_STATE_SUSPEND, retval);
+		goto err_pinctrl_lookup;
 	}
 
-	return 0;
-
-regulator_put:
-	if (rmi4_data->pwr_reg) {
-		regulator_put(rmi4_data->pwr_reg);
-		rmi4_data->pwr_reg = NULL;
+	rmi4_data->pinctrl_state_release
+		= pinctrl_lookup_state(rmi4_data->ts_pinctrl, "pmx_ts_release");
+	if (IS_ERR_OR_NULL(rmi4_data->pinctrl_state_release)) {
+		retval = PTR_ERR(rmi4_data->pinctrl_state_release);
+		dev_dbg(rmi4_data->pdev->dev.parent,
+			"Can not lookup %s pinstate %d\n",
+			PINCTRL_STATE_RELEASE, retval);
 	}
 
-	if (rmi4_data->bus_reg) {
-		regulator_put(rmi4_data->bus_reg);
-		rmi4_data->bus_reg = NULL;
-	}
+	return 0;
 
+err_pinctrl_lookup:
+	devm_pinctrl_put(rmi4_data->ts_pinctrl);
+err_pinctrl_get:
+	rmi4_data->ts_pinctrl = NULL;
 	return retval;
 }
 
-static int synaptics_rmi4_enable_reg(struct synaptics_rmi4_data *rmi4_data,
-		bool enable)
+static int synaptics_dsx_gpio_configure(struct synaptics_rmi4_data *rmi4_data,
+					bool on)
 {
-	int retval;
+	int retval = 0;
 	const struct synaptics_dsx_board_data *bdata =
 			rmi4_data->hw_if->board_data;
 
-	if (!enable) {
-		retval = 0;
-		goto disable_pwr_reg;
-	}
-
-	if (rmi4_data->bus_reg) {
-		retval = regulator_enable(rmi4_data->bus_reg);
-		if (retval < 0) {
+	if (on) {
+		if (gpio_is_valid(bdata->irq_gpio)) {
+			/* configure touchscreen irq gpio */
+			retval = gpio_request(bdata->irq_gpio,
+				"rmi4_irq_gpio");
+			if (retval) {
+				dev_err(rmi4_data->pdev->dev.parent,
+					"unable to request gpio [%d]\n",
+					bdata->irq_gpio);
+				goto err_irq_gpio_req;
+			}
+			retval = gpio_direction_input(bdata->irq_gpio);
+			if (retval) {
+				dev_err(rmi4_data->pdev->dev.parent,
+					"unable to set dir for gpio[%d]\n",
+					bdata->irq_gpio);
+				goto err_irq_gpio_dir;
+			}
+		} else {
 			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to enable bus pullup regulator\n",
-					__func__);
-			goto exit;
+				"irq gpio not provided\n");
+			goto err_irq_gpio_req;
 		}
-	}
 
-	if (rmi4_data->pwr_reg) {
-		retval = regulator_enable(rmi4_data->pwr_reg);
-		if (retval < 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to enable power regulator\n",
-					__func__);
-			goto disable_bus_reg;
+		if (gpio_is_valid(bdata->reset_gpio)) {
+			/* configure touchscreen reset out gpio */
+			retval = gpio_request(bdata->reset_gpio,
+					"rmi4_reset_gpio");
+			if (retval) {
+				dev_err(rmi4_data->pdev->dev.parent,
+					"unable to request gpio [%d]\n",
+					bdata->reset_gpio);
+				goto err_irq_gpio_dir;
+			}
+
+			retval = gpio_direction_output(bdata->reset_gpio, 1);
+			if (retval) {
+				dev_err(rmi4_data->pdev->dev.parent,
+					"unable to set dir for gpio [%d]\n",
+					bdata->reset_gpio);
+				goto err_reset_gpio_dir;
+			}
+
+			gpio_set_value(bdata->reset_gpio, 1);
+			msleep(bdata->reset_delay_ms);
+		}
+	} else {
+		if (bdata->disable_gpios) {
+			if (gpio_is_valid(bdata->irq_gpio))
+				gpio_free(bdata->irq_gpio);
+			if (gpio_is_valid(bdata->reset_gpio)) {
+				/*
+				 * This is intended to save leakage current
+				 * only. Even if the call(gpio_direction_input)
+				 * fails, only leakage current will be more but
+				 * functionality will not be affected.
+				 */
+				retval = gpio_direction_input(
+							bdata->reset_gpio);
+				if (retval) {
+					dev_err(rmi4_data->pdev->dev.parent,
+					"unable to set direction for gpio %d\n",
+					bdata->irq_gpio);
+				}
+				gpio_free(bdata->reset_gpio);
+			}
 		}
-		msleep(bdata->power_delay_ms);
 	}
 
 	return 0;
 
-disable_pwr_reg:
-	if (rmi4_data->pwr_reg)
-		regulator_disable(rmi4_data->pwr_reg);
-
-disable_bus_reg:
-	if (rmi4_data->bus_reg)
-		regulator_disable(rmi4_data->bus_reg);
-
-exit:
+err_reset_gpio_dir:
+	if (gpio_is_valid(bdata->reset_gpio))
+		gpio_free(bdata->reset_gpio);
+err_irq_gpio_dir:
+	if (gpio_is_valid(bdata->irq_gpio))
+		gpio_free(bdata->irq_gpio);
+err_irq_gpio_req:
 	return retval;
 }
 
@@ -3511,8 +3405,6 @@ static int synaptics_rmi4_free_fingers(struct synaptics_rmi4_data *rmi4_data)
 {
 	unsigned char ii;
 
-	mutex_lock(&(rmi4_data->rmi4_report_mutex));
-
 #ifdef TYPE_B_PROTOCOL
 	for (ii = 0; ii < rmi4_data->num_of_fingers; ii++) {
 		input_mt_slot(rmi4_data->input_dev, ii);
@@ -3529,166 +3421,119 @@ static int synaptics_rmi4_free_fingers(struct synaptics_rmi4_data *rmi4_data)
 #endif
 	input_sync(rmi4_data->input_dev);
 
-	if (rmi4_data->stylus_enable) {
-		input_report_key(rmi4_data->stylus_dev,
-				BTN_TOUCH, 0);
-		input_report_key(rmi4_data->stylus_dev,
-				BTN_TOOL_PEN, 0);
-		if (rmi4_data->eraser_enable) {
-			input_report_key(rmi4_data->stylus_dev,
-					BTN_TOOL_RUBBER, 0);
-		}
-		input_sync(rmi4_data->stylus_dev);
-	}
-
-	mutex_unlock(&(rmi4_data->rmi4_report_mutex));
-
 	rmi4_data->fingers_on_2d = false;
 
 	return 0;
 }
 
-static int synaptics_rmi4_sw_reset(struct synaptics_rmi4_data *rmi4_data)
+static int synaptics_rmi4_reinit_device(struct synaptics_rmi4_data *rmi4_data)
 {
 	int retval;
-	unsigned char command = 0x01;
+	unsigned char ii;
+	unsigned short intr_addr;
+	struct synaptics_rmi4_fn *fhandler;
+	struct synaptics_rmi4_exp_fhandler *exp_fhandler;
+	struct synaptics_rmi4_device_info *rmi;
 
-	retval = synaptics_rmi4_reg_write(rmi4_data,
-			rmi4_data->f01_cmd_base_addr,
-			&command,
-			sizeof(command));
-	if (retval < 0)
-		return retval;
+	rmi = &(rmi4_data->rmi4_mod_info);
 
-	msleep(rmi4_data->hw_if->board_data->reset_delay_ms);
+	mutex_lock(&(rmi4_data->rmi4_reset_mutex));
 
-	if (rmi4_data->hw_if->ui_hw_init) {
-		retval = rmi4_data->hw_if->ui_hw_init(rmi4_data);
-		if (retval < 0)
-			return retval;
+	synaptics_rmi4_free_fingers(rmi4_data);
+
+	if (!list_empty(&rmi->support_fn_list)) {
+		list_for_each_entry(fhandler, &rmi->support_fn_list, link) {
+			if (fhandler->fn_number == SYNAPTICS_RMI4_F12) {
+				synaptics_rmi4_f12_set_coords(rmi4_data,
+								fhandler);
+				synaptics_rmi4_f12_set_enables(rmi4_data, 0);
+				break;
+			} else if (fhandler->fn_number == SYNAPTICS_RMI4_F11) {
+				synaptics_rmi4_f11_set_coords(rmi4_data,
+								fhandler);
+				break;
+			}
+
+		}
 	}
 
-	return 0;
+	for (ii = 0; ii < rmi4_data->num_of_intr_regs; ii++) {
+		if (rmi4_data->intr_mask[ii] != 0x00) {
+			dev_dbg(rmi4_data->pdev->dev.parent,
+					"%s: Interrupt enable mask %d = 0x%02x\n",
+					__func__, ii, rmi4_data->intr_mask[ii]);
+			intr_addr = rmi4_data->f01_ctrl_base_addr + 1 + ii;
+			retval = synaptics_rmi4_reg_write(rmi4_data,
+					intr_addr,
+					&(rmi4_data->intr_mask[ii]),
+					sizeof(rmi4_data->intr_mask[ii]));
+			if (retval < 0)
+				goto exit;
+		}
+	}
+
+	mutex_lock(&exp_data.mutex);
+	if (!list_empty(&exp_data.list)) {
+		list_for_each_entry(exp_fhandler, &exp_data.list, link)
+			if (exp_fhandler->exp_fn->reinit != NULL)
+				exp_fhandler->exp_fn->reinit(rmi4_data);
+	}
+	mutex_unlock(&exp_data.mutex);
+
+	synaptics_rmi4_set_configured(rmi4_data);
+
+	retval = 0;
+
+exit:
+	mutex_unlock(&(rmi4_data->rmi4_reset_mutex));
+	return retval;
 }
 
-static void synaptics_rmi4_rebuild_work(struct work_struct *work)
+static int synaptics_rmi4_reset_device(struct synaptics_rmi4_data *rmi4_data)
 {
 	int retval;
-	unsigned char attr_count;
+	int temp;
+	unsigned char command = 0x01;
 	struct synaptics_rmi4_exp_fhandler *exp_fhandler;
-	struct delayed_work *delayed_work =
-			container_of(work, struct delayed_work, work);
-	struct synaptics_rmi4_data *rmi4_data =
-			container_of(delayed_work, struct synaptics_rmi4_data,
-			rb_work);
 
 	mutex_lock(&(rmi4_data->rmi4_reset_mutex));
 
-	mutex_lock(&exp_data.mutex);
-
-	synaptics_rmi4_irq_enable(rmi4_data, false, false);
+	rmi4_data->touch_stopped = true;
 
-	if (!list_empty(&exp_data.list)) {
-		list_for_each_entry(exp_fhandler, &exp_data.list, link)
-			if (exp_fhandler->exp_fn->remove != NULL)
-				exp_fhandler->exp_fn->remove(rmi4_data);
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			rmi4_data->f01_cmd_base_addr,
+			&command,
+			sizeof(command));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to issue reset command, error = %d\n",
+				__func__, retval);
+		mutex_unlock(&(rmi4_data->rmi4_reset_mutex));
+		return retval;
 	}
 
-	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++) {
-		sysfs_remove_file(&rmi4_data->input_dev->dev.kobj,
-				&attrs[attr_count].attr);
-	}
+	msleep(rmi4_data->hw_if->board_data->reset_delay_ms);
 
 	synaptics_rmi4_free_fingers(rmi4_data);
+
 	synaptics_rmi4_empty_fn_list(rmi4_data);
-	input_unregister_device(rmi4_data->input_dev);
-	rmi4_data->input_dev = NULL;
-	if (rmi4_data->stylus_enable) {
-		input_unregister_device(rmi4_data->stylus_dev);
-		rmi4_data->stylus_dev = NULL;
-	}
-
-	retval = synaptics_rmi4_sw_reset(rmi4_data);
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to issue reset command\n",
-				__func__);
-		goto exit;
-	}
 
-	retval = synaptics_rmi4_set_input_dev(rmi4_data);
+	retval = synaptics_rmi4_query_device(rmi4_data);
 	if (retval < 0) {
 		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to set up input device\n",
+				"%s: Failed to query device\n",
 				__func__);
-		goto exit;
-	}
-
-	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++) {
-		retval = sysfs_create_file(&rmi4_data->input_dev->dev.kobj,
-				&attrs[attr_count].attr);
-		if (retval < 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to create sysfs attributes\n",
-					__func__);
-			goto exit;
-		}
-	}
-
-	if (!list_empty(&exp_data.list)) {
-		list_for_each_entry(exp_fhandler, &exp_data.list, link)
-			if (exp_fhandler->exp_fn->init != NULL)
-				exp_fhandler->exp_fn->init(rmi4_data);
-	}
-
-	retval = 0;
-
-exit:
-	synaptics_rmi4_irq_enable(rmi4_data, true, false);
-
-	mutex_unlock(&exp_data.mutex);
-
-	mutex_unlock(&(rmi4_data->rmi4_reset_mutex));
-
-	return;
-}
-
-static int synaptics_rmi4_reset_device(struct synaptics_rmi4_data *rmi4_data,
-		bool rebuild)
-{
-	int retval;
-	struct synaptics_rmi4_exp_fhandler *exp_fhandler;
-
-	if (rebuild) {
-		queue_delayed_work(rmi4_data->rb_workqueue,
-				&rmi4_data->rb_work,
-				msecs_to_jiffies(REBUILD_WORK_DELAY_MS));
-		return 0;
+		mutex_unlock(&(rmi4_data->rmi4_reset_mutex));
+		return retval;
 	}
 
-	mutex_lock(&(rmi4_data->rmi4_reset_mutex));
-
-	synaptics_rmi4_irq_enable(rmi4_data, false, false);
-
-	retval = synaptics_rmi4_sw_reset(rmi4_data);
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to issue reset command\n",
-				__func__);
-		goto exit;
+	if (rmi4_data->hw_if->board_data->swap_axes) {
+		temp = rmi4_data->sensor_max_x;
+		rmi4_data->sensor_max_x = rmi4_data->sensor_max_y;
+		rmi4_data->sensor_max_y = temp;
 	}
 
-	synaptics_rmi4_free_fingers(rmi4_data);
-
-	synaptics_rmi4_empty_fn_list(rmi4_data);
-
-	retval = synaptics_rmi4_query_device(rmi4_data);
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to query device\n",
-				__func__);
-		goto exit;
-	}
+	synaptics_rmi4_set_params(rmi4_data);
 
 	mutex_lock(&exp_data.mutex);
 	if (!list_empty(&exp_data.list)) {
@@ -3698,101 +3543,29 @@ static int synaptics_rmi4_reset_device(struct synaptics_rmi4_data *rmi4_data,
 	}
 	mutex_unlock(&exp_data.mutex);
 
-	retval = 0;
-
-exit:
-	synaptics_rmi4_irq_enable(rmi4_data, true, false);
+	rmi4_data->touch_stopped = false;
 
 	mutex_unlock(&(rmi4_data->rmi4_reset_mutex));
 
-	return retval;
-}
-
-#ifdef FB_READY_RESET
-static void synaptics_rmi4_reset_work(struct work_struct *work)
-{
-	int retval;
-	unsigned int timeout;
-	struct synaptics_rmi4_data *rmi4_data =
-			container_of(work, struct synaptics_rmi4_data,
-			reset_work);
-
-	timeout = FB_READY_TIMEOUT_S * 1000 / FB_READY_WAIT_MS + 1;
-
-	while (!rmi4_data->fb_ready) {
-		msleep(FB_READY_WAIT_MS);
-		timeout--;
-		if (timeout == 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Timed out waiting for FB ready\n",
-					__func__);
-			return;
-		}
-	}
-
-	mutex_lock(&rmi4_data->rmi4_exp_init_mutex);
-
-	retval = synaptics_rmi4_reset_device(rmi4_data, false);
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to issue reset command\n",
-				__func__);
-	}
-
-	mutex_unlock(&rmi4_data->rmi4_exp_init_mutex);
-
-	return;
-}
-#endif
-
-static void synaptics_rmi4_sleep_enable(struct synaptics_rmi4_data *rmi4_data,
-		bool enable)
-{
-	int retval;
-	unsigned char device_ctrl;
-	unsigned char no_sleep_setting = rmi4_data->no_sleep_setting;
-
-	retval = synaptics_rmi4_reg_read(rmi4_data,
-			rmi4_data->f01_ctrl_base_addr,
-			&device_ctrl,
-			sizeof(device_ctrl));
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to read device control\n",
-				__func__);
-		return;
-	}
-
-	device_ctrl = device_ctrl & ~MASK_3BIT;
-	if (enable)
-		device_ctrl = device_ctrl | NO_SLEEP_OFF | SENSOR_SLEEP;
-	else
-		device_ctrl = device_ctrl | no_sleep_setting | NORMAL_OPERATION;
-
-	retval = synaptics_rmi4_reg_write(rmi4_data,
-			rmi4_data->f01_ctrl_base_addr,
-			&device_ctrl,
-			sizeof(device_ctrl));
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to write device control\n",
-				__func__);
-		return;
-	}
-
-	rmi4_data->sensor_sleep = enable;
-
-	return;
+	return 0;
 }
 
+/**
+* synaptics_rmi4_exp_fn_work()
+*
+* Called by the kernel at the scheduled time.
+*
+* This function is a work thread that checks for the insertion and
+* removal of other expansion Function modules such as rmi_dev and calls
+* their initialization and removal callback functions accordingly.
+*/
 static void synaptics_rmi4_exp_fn_work(struct work_struct *work)
 {
+	int retval;
 	struct synaptics_rmi4_exp_fhandler *exp_fhandler;
 	struct synaptics_rmi4_exp_fhandler *exp_fhandler_temp;
 	struct synaptics_rmi4_data *rmi4_data = exp_data.rmi4_data;
 
-	mutex_lock(&rmi4_data->rmi4_exp_init_mutex);
-	mutex_lock(&rmi4_data->rmi4_reset_mutex);
 	mutex_lock(&exp_data.mutex);
 	if (!list_empty(&exp_data.list)) {
 		list_for_each_entry_safe(exp_fhandler,
@@ -3801,8 +3574,13 @@ static void synaptics_rmi4_exp_fn_work(struct work_struct *work)
 				link) {
 			if ((exp_fhandler->exp_fn->init != NULL) &&
 					exp_fhandler->insert) {
-				exp_fhandler->exp_fn->init(rmi4_data);
-				exp_fhandler->insert = false;
+				retval = exp_fhandler->exp_fn->init(rmi4_data);
+				if (retval < 0) {
+					list_del(&exp_fhandler->link);
+					kfree(exp_fhandler);
+				} else {
+					exp_fhandler->insert = false;
+				}
 			} else if ((exp_fhandler->exp_fn->remove != NULL) &&
 					exp_fhandler->remove) {
 				exp_fhandler->exp_fn->remove(rmi4_data);
@@ -3812,13 +3590,21 @@ static void synaptics_rmi4_exp_fn_work(struct work_struct *work)
 		}
 	}
 	mutex_unlock(&exp_data.mutex);
-	mutex_unlock(&rmi4_data->rmi4_reset_mutex);
-	mutex_unlock(&rmi4_data->rmi4_exp_init_mutex);
-
-	return;
 }
 
-void synaptics_rmi4_new_function(struct synaptics_rmi4_exp_fn *exp_fn,
+/**
+* synaptics_rmi4_dsx_new_function()
+*
+* Called by other expansion Function modules in their module init and
+* module exit functions.
+*
+* This function is used by other expansion Function modules such as
+* rmi_dev to register themselves with the driver by providing their
+* initialization and removal callback function pointers so that they
+* can be inserted or removed dynamically at module init and exit times,
+* respectively.
+*/
+void synaptics_rmi4_dsx_new_function(struct synaptics_rmi4_exp_fn *exp_fn,
 		bool insert)
 {
 	struct synaptics_rmi4_exp_fhandler *exp_fhandler;
@@ -3859,69 +3645,89 @@ exit:
 				&exp_data.work,
 				msecs_to_jiffies(EXP_FN_WORK_DELAY_MS));
 	}
-
-	return;
 }
-EXPORT_SYMBOL(synaptics_rmi4_new_function);
+EXPORT_SYMBOL(synaptics_rmi4_dsx_new_function);
 
-static int synaptics_dsx_pinctrl_init(struct synaptics_rmi4_data *rmi4_data)
+static int synaptics_dsx_regulator_configure(struct synaptics_rmi4_data
+			*rmi4_data)
 {
 	int retval;
 
-	/* Get pinctrl if target uses pinctrl */
-	rmi4_data->ts_pinctrl = devm_pinctrl_get((rmi4_data->pdev->dev.parent));
-	if (IS_ERR_OR_NULL(rmi4_data->ts_pinctrl)) {
-		retval = PTR_ERR(rmi4_data->ts_pinctrl);
+	rmi4_data->regulator_vdd = regulator_get(rmi4_data->pdev->dev.parent,
+			"vdd");
+	if (IS_ERR(rmi4_data->regulator_vdd)) {
 		dev_err(rmi4_data->pdev->dev.parent,
-			"Target does not use pinctrl %d\n", retval);
-		goto err_pinctrl_get;
+				"%s: Failed to get regulator vdd\n",
+				__func__);
+		retval = PTR_ERR(rmi4_data->regulator_vdd);
+		return retval;
 	}
-
-	rmi4_data->pinctrl_state_active
-		= pinctrl_lookup_state(rmi4_data->ts_pinctrl, "pmx_ts_active");
-	if (IS_ERR_OR_NULL(rmi4_data->pinctrl_state_active)) {
-		retval = PTR_ERR(rmi4_data->pinctrl_state_active);
+	rmi4_data->regulator_avdd = regulator_get(rmi4_data->pdev->dev.parent,
+			"avdd");
+	if (IS_ERR(rmi4_data->regulator_avdd)) {
 		dev_err(rmi4_data->pdev->dev.parent,
-			"Can not lookup %s pinstate %d\n",
-			PINCTRL_STATE_ACTIVE, retval);
-		goto err_pinctrl_lookup;
+				"%s: Failed to get regulator avdd\n",
+				__func__);
+		retval = PTR_ERR(rmi4_data->regulator_avdd);
+		regulator_put(rmi4_data->regulator_vdd);
+		return retval;
 	}
 
-	rmi4_data->pinctrl_state_suspend
-		= pinctrl_lookup_state(rmi4_data->ts_pinctrl, "pmx_ts_suspend");
-	if (IS_ERR_OR_NULL(rmi4_data->pinctrl_state_suspend)) {
-		retval = PTR_ERR(rmi4_data->pinctrl_state_suspend);
-		dev_dbg(rmi4_data->pdev->dev.parent,
-			"Can not lookup %s pinstate %d\n",
-			PINCTRL_STATE_SUSPEND, retval);
-		goto err_pinctrl_lookup;
-	}
+	return 0;
+};
 
-	rmi4_data->pinctrl_state_release
-		= pinctrl_lookup_state(rmi4_data->ts_pinctrl, "pmx_ts_release");
-	if (IS_ERR_OR_NULL(rmi4_data->pinctrl_state_release)) {
-		retval = PTR_ERR(rmi4_data->pinctrl_state_release);
-		dev_dbg(rmi4_data->pdev->dev.parent,
-			"Can not lookup %s pinstate %d\n",
-			PINCTRL_STATE_RELEASE, retval);
+static int synaptics_dsx_regulator_enable(struct synaptics_rmi4_data
+			*rmi4_data, bool on)
+{
+	int retval;
+
+	if (on) {
+		retval = regulator_enable(rmi4_data->regulator_vdd);
+		if (retval) {
+			dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to enable regulator vdd\n",
+				__func__);
+			return retval;
+		}
+		retval = regulator_enable(rmi4_data->regulator_avdd);
+		if (retval) {
+			dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to enable regulator avdd\n",
+				__func__);
+			regulator_disable(rmi4_data->regulator_vdd);
+			return retval;
+		}
+		msleep(rmi4_data->hw_if->board_data->power_delay_ms);
+	} else {
+		regulator_disable(rmi4_data->regulator_vdd);
+		regulator_disable(rmi4_data->regulator_avdd);
 	}
 
 	return 0;
-
-err_pinctrl_lookup:
-	devm_pinctrl_put(rmi4_data->ts_pinctrl);
-err_pinctrl_get:
-	rmi4_data->ts_pinctrl = NULL;
-	return retval;
 }
 
+ /**
+ * synaptics_rmi4_probe()
+ *
+ * Called by the kernel when an association with an I2C device of the
+ * same name is made (after doing i2c_add_driver).
+ *
+ * This function allocates and initializes the resources for the driver
+ * as an input driver, turns on the power to the sensor, queries the
+ * sensor for its supported Functions and characteristics, registers
+ * the driver to the input subsystem, sets up the interrupt, handles
+ * the registration of the early_suspend and late_resume functions,
+ * and creates a work queue for detection of other expansion Function
+ * modules.
+ */
 static int synaptics_rmi4_probe(struct platform_device *pdev)
 {
-	int retval;
+	int retval, len;
 	unsigned char attr_count;
 	struct synaptics_rmi4_data *rmi4_data;
 	const struct synaptics_dsx_hw_interface *hw_if;
 	const struct synaptics_dsx_board_data *bdata;
+	struct dentry *temp;
 
 	hw_if = pdev->dev.platform_data;
 	if (!hw_if) {
@@ -3940,81 +3746,82 @@ static int synaptics_rmi4_probe(struct platform_device *pdev)
 	}
 
 	rmi4_data = kzalloc(sizeof(*rmi4_data), GFP_KERNEL);
-	if (!rmi4_data) {
-		dev_err(&pdev->dev,
-				"%s: Failed to alloc mem for rmi4_data\n",
-				__func__);
+	if (!rmi4_data)
 		return -ENOMEM;
-	}
 
 	rmi4_data->pdev = pdev;
 	rmi4_data->current_page = MASK_8BIT;
 	rmi4_data->hw_if = hw_if;
-	rmi4_data->suspend = false;
+	rmi4_data->touch_stopped = false;
+	rmi4_data->sensor_sleep = false;
 	rmi4_data->irq_enabled = false;
+	rmi4_data->fw_updating = false;
 	rmi4_data->fingers_on_2d = false;
+	rmi4_data->update_coords = true;
 
-	rmi4_data->reset_device = synaptics_rmi4_reset_device;
 	rmi4_data->irq_enable = synaptics_rmi4_irq_enable;
-	rmi4_data->sleep_enable = synaptics_rmi4_sleep_enable;
-	rmi4_data->report_touch = synaptics_rmi4_report_touch;
+	rmi4_data->reset_device = synaptics_rmi4_reset_device;
 
-	mutex_init(&(rmi4_data->rmi4_reset_mutex));
-	mutex_init(&(rmi4_data->rmi4_report_mutex));
 	mutex_init(&(rmi4_data->rmi4_io_ctrl_mutex));
-	mutex_init(&(rmi4_data->rmi4_exp_init_mutex));
-
-	platform_set_drvdata(pdev, rmi4_data);
-
-	vir_button_map = bdata->vir_button_map;
+	mutex_init(&(rmi4_data->rmi4_reset_mutex));
 
-	retval = synaptics_rmi4_get_reg(rmi4_data, true);
-	if (retval < 0) {
+	retval = synaptics_dsx_regulator_configure(rmi4_data);
+	if (retval) {
 		dev_err(&pdev->dev,
-				"%s: Failed to get regulators\n",
-				__func__);
-		goto err_get_reg;
+			"%s: regulator configuration failed\n", __func__);
+		goto err_regulator_configure;
 	}
-
-	retval = synaptics_rmi4_enable_reg(rmi4_data, true);
-	if (retval < 0) {
+	retval = synaptics_dsx_regulator_enable(rmi4_data, true);
+	if (retval) {
 		dev_err(&pdev->dev,
-				"%s: Failed to enable regulators\n",
-				__func__);
-		goto err_enable_reg;
+			"%s: regulator enable failed\n", __func__);
+		goto err_regulator_enable;
 	}
 
-	retval = synaptics_dsx_pinctrl_init(rmi4_data);
-	if (!retval && rmi4_data->ts_pinctrl) {
-		/*
-		* Pinctrl handle is optional. If pinctrl handle is found
-		* let pins to be configured in active state. If not
-		* found continue further without error.
-		*/
-		retval = pinctrl_select_state(rmi4_data->ts_pinctrl,
-		rmi4_data->pinctrl_state_active);
+	platform_set_drvdata(pdev, rmi4_data);
+
+	if (bdata->gpio_config) {
+		retval = synaptics_rmi4_set_gpio(rmi4_data);
 		if (retval < 0) {
 			dev_err(&pdev->dev,
-				"%s: Failed to select %s pinstate %d\n",
-				__func__, PINCTRL_STATE_ACTIVE, retval);
-		}
-	}
-	retval = synaptics_rmi4_set_gpio(rmi4_data);
-	if (retval < 0) {
-		dev_err(&pdev->dev,
 				"%s: Failed to set up GPIO's\n",
 				__func__);
-		goto err_set_gpio;
-	}
+			goto err_set_gpio;
+		}
+	} else {
+		retval = synaptics_dsx_pinctrl_init(rmi4_data);
+		if (!retval && rmi4_data->ts_pinctrl) {
+			/*
+			* Pinctrl handle is optional. If pinctrl handle is found
+			* let pins to be configured in active state. If not
+			* found continue further without error.
+			*/
+			retval = pinctrl_select_state(rmi4_data->ts_pinctrl,
+					rmi4_data->pinctrl_state_active);
+			if (retval < 0) {
+				dev_err(&pdev->dev,
+					"%s: Failed to select %s pinstate %d\n",
+					__func__, PINCTRL_STATE_ACTIVE, retval);
+			}
+		}
 
-	if (hw_if->ui_hw_init) {
-		retval = hw_if->ui_hw_init(rmi4_data);
+		retval = synaptics_dsx_gpio_configure(rmi4_data, true);
 		if (retval < 0) {
 			dev_err(&pdev->dev,
-					"%s: Failed to initialize hardware interface\n",
+					"%s: Failed to set up GPIO's\n",
 					__func__);
-			goto err_ui_hw_init;
+			goto err_config_gpio;
+		}
+	}
+
+	if (bdata->fw_name) {
+		len = strlen(bdata->fw_name);
+		if (len > SYNA_FW_NAME_MAX_LEN - 1) {
+			dev_err(&pdev->dev, "Invalid firmware name\n");
+			goto err_set_input_dev;
 		}
+
+		strlcpy(rmi4_data->fw_name, bdata->fw_name, len + 1);
 	}
 
 	retval = synaptics_rmi4_set_input_dev(rmi4_data);
@@ -4026,62 +3833,95 @@ static int synaptics_rmi4_probe(struct platform_device *pdev)
 	}
 
 #ifdef CONFIG_FB
-	INIT_WORK(&rmi4_data->fb_notify_work,
-		  synaptics_rmi4_fb_notify_resume_work);
-	rmi4_data->fb_notifier.notifier_call = synaptics_rmi4_fb_notifier_cb;
-	retval = fb_register_client(&rmi4_data->fb_notifier);
-	if (retval < 0) {
-		dev_err(&pdev->dev,
-				"%s: Failed to register fb notifier client\n",
-				__func__);
-	}
+#ifdef FIRST_FLAG
+	rmi4_data->flag = 0;
 #endif
+	rmi4_data->fb_notif.notifier_call = fb_notifier_callback;
 
-#ifdef USE_EARLYSUSPEND
+	retval = fb_register_client(&rmi4_data->fb_notif);
+	if (retval)
+		dev_err(rmi4_data->pdev->dev.parent,
+			"Unable to register fb_notifier: %d\n", retval);
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
 	rmi4_data->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
 	rmi4_data->early_suspend.suspend = synaptics_rmi4_early_suspend;
 	rmi4_data->early_suspend.resume = synaptics_rmi4_late_resume;
 	register_early_suspend(&rmi4_data->early_suspend);
 #endif
 
+	rmi4_data->irq = gpio_to_irq(bdata->irq_gpio);
+
 	if (!exp_data.initialized) {
 		mutex_init(&exp_data.mutex);
 		INIT_LIST_HEAD(&exp_data.list);
 		exp_data.initialized = true;
 	}
 
-	rmi4_data->irq = gpio_to_irq(bdata->irq_gpio);
+	exp_data.workqueue = create_singlethread_workqueue("dsx_exp_workqueue");
+	INIT_DELAYED_WORK(&exp_data.work, synaptics_rmi4_exp_fn_work);
+	exp_data.rmi4_data = rmi4_data;
+	exp_data.queue_work = true;
+	queue_delayed_work(exp_data.workqueue,
+			&exp_data.work,
+			msecs_to_jiffies(EXP_FN_WORK_DELAY_MS));
 
-	retval = synaptics_rmi4_irq_enable(rmi4_data, true, false);
-	if (retval < 0) {
+	rmi4_data->dir = debugfs_create_dir(DEBUGFS_DIR_NAME, NULL);
+	if (rmi4_data->dir == NULL || IS_ERR(rmi4_data->dir)) {
+		retval = rmi4_data->dir ? PTR_ERR(rmi4_data->dir) : -EIO;
 		dev_err(&pdev->dev,
-				"%s: Failed to enable attention interrupt\n",
-				__func__);
-		goto err_enable_irq;
+			"%s: Failed to create debugfs directory, rc = %d\n",
+			__func__, retval);
+		goto err_create_debugfs_dir;
 	}
 
-	if (vir_button_map->nbuttons) {
-		rmi4_data->board_prop_dir = kobject_create_and_add(
-				"board_properties", NULL);
-		if (!rmi4_data->board_prop_dir) {
-			dev_err(&pdev->dev,
-					"%s: Failed to create board_properties directory\n",
-					__func__);
-			goto err_virtual_buttons;
-		} else {
-			retval = sysfs_create_file(rmi4_data->board_prop_dir,
-					&virtual_key_map_attr.attr);
-			if (retval < 0) {
-				dev_err(&pdev->dev,
-						"%s: Failed to create virtual key map file\n",
-						__func__);
-				goto err_virtual_buttons;
-			}
-		}
+	temp = debugfs_create_file("suspend", S_IRUSR | S_IWUSR, rmi4_data->dir,
+					rmi4_data, &debug_suspend_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		retval = temp ? PTR_ERR(temp) : -EIO;
+		dev_err(&pdev->dev,
+			"%s: Failed to create suspend debugfs file, rc = %d\n",
+			__func__, retval);
+		goto err_create_debugfs_file;
+	}
+	temp = debugfs_create_file("addr", S_IRUSR | S_IWUSR, rmi4_data->dir,
+					rmi4_data, &debug_addr_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		dev_err(&pdev->dev,
+			"%s: Failed to create addr debugfs file, rc = %ld\n",
+			__func__, PTR_ERR(temp));
+		retval = PTR_ERR(temp);
+		goto err_create_debugfs_file;
+	}
+
+	temp = debugfs_create_file("data", S_IRUSR | S_IWUSR, rmi4_data->dir,
+					rmi4_data, &debug_data_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		dev_err(&pdev->dev,
+			"%s: Failed to create data debugfs file, rc = %ld\n",
+			__func__, PTR_ERR(temp));
+		retval = PTR_ERR(temp);
+		goto err_create_debugfs_file;
+	}
+	temp = debugfs_create_file("dump_info", S_IRUSR | S_IWUSR,
+					rmi4_data->dir,
+					rmi4_data, &debug_dump_info_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		dev_err(&pdev->dev,
+			"%s: Failed to create data debugfs file, rc = %ld\n",
+			__func__, PTR_ERR(temp));
+		retval = PTR_ERR(temp);
+		goto err_create_debugfs_file;
 	}
 
+	rmi4_data->ts_info = kzalloc(RMI4_INFO_MAX_LEN, GFP_KERNEL);
+	if (!rmi4_data->ts_info) {
+		/*dev_err(&pdev->dev, "Not enough memory\n");*/
+		goto err_alloc_ts_info_mem;
+	}
+	synaptics_rmi4_update_ts_info(rmi4_data);
+
 	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++) {
-		retval = sysfs_create_file(&rmi4_data->input_dev->dev.kobj,
+		retval = sysfs_create_file(&rmi4_data->pdev->dev.kobj,
 				&attrs[attr_count].attr);
 		if (retval < 0) {
 			dev_err(&pdev->dev,
@@ -4091,107 +3931,78 @@ static int synaptics_rmi4_probe(struct platform_device *pdev)
 		}
 	}
 
-	rmi4_data->rb_workqueue =
-			create_singlethread_workqueue("dsx_rebuild_workqueue");
-	if (!rmi4_data->rb_workqueue) {
-		retval = -ENOMEM;
-		goto err_rb_workqueue;
-	}
-	INIT_DELAYED_WORK(&rmi4_data->rb_work, synaptics_rmi4_rebuild_work);
-
-	exp_data.workqueue = create_singlethread_workqueue("dsx_exp_workqueue");
-	if (!exp_data.workqueue) {
-		retval = -ENOMEM;
-		goto err_exp_data_workqueue;
-	}
-	INIT_DELAYED_WORK(&exp_data.work, synaptics_rmi4_exp_fn_work);
-	exp_data.rmi4_data = rmi4_data;
-	exp_data.queue_work = true;
-	queue_delayed_work(exp_data.workqueue, &exp_data.work, 0);
-
-#ifdef FB_READY_RESET
-	rmi4_data->reset_workqueue =
-			create_singlethread_workqueue("dsx_reset_workqueue");
-	if (!rmi4_data->reset_workqueue) {
-		retval = -ENOMEM;
-		goto err_reset_workqueue;
+	retval = synaptics_rmi4_irq_enable(rmi4_data, true);
+	if (retval < 0) {
+		dev_err(&pdev->dev,
+				"%s: Failed to enable attention interrupt\n",
+				__func__);
+		goto err_enable_irq;
 	}
-	INIT_WORK(&rmi4_data->reset_work, synaptics_rmi4_reset_work);
-	queue_work(rmi4_data->reset_workqueue, &rmi4_data->reset_work);
-#endif
 
-	/* Initialize secure touch */
 	synaptics_secure_touch_init(rmi4_data);
-	synaptics_secure_touch_stop(rmi4_data, true);
+	synaptics_secure_touch_stop(rmi4_data, 1);
 
 	return retval;
 
-#ifdef FB_READY_RESET
-err_reset_workqueue:
-#endif
-	cancel_delayed_work_sync(&exp_data.work);
-	flush_workqueue(exp_data.workqueue);
-	destroy_workqueue(exp_data.workqueue);
-
-err_exp_data_workqueue:
-	cancel_delayed_work_sync(&rmi4_data->rb_work);
-	flush_workqueue(rmi4_data->rb_workqueue);
-	destroy_workqueue(rmi4_data->rb_workqueue);
-
-err_rb_workqueue:
 err_sysfs:
 	for (attr_count--; attr_count >= 0; attr_count--) {
 		sysfs_remove_file(&rmi4_data->input_dev->dev.kobj,
 				&attrs[attr_count].attr);
 	}
-
-err_virtual_buttons:
-	if (rmi4_data->board_prop_dir) {
-		sysfs_remove_file(rmi4_data->board_prop_dir,
-				&virtual_key_map_attr.attr);
-		kobject_put(rmi4_data->board_prop_dir);
+	kfree(rmi4_data->ts_info);
+	rmi4_data->ts_info = NULL;
+err_alloc_ts_info_mem:
+err_create_debugfs_file:
+	debugfs_remove_recursive(rmi4_data->dir);
+err_create_debugfs_dir:
+	cancel_delayed_work_sync(&exp_data.work);
+	if (exp_data.workqueue != NULL) {
+		flush_workqueue(exp_data.workqueue);
+		destroy_workqueue(exp_data.workqueue);
 	}
-
-	synaptics_rmi4_irq_enable(rmi4_data, false, false);
+	synaptics_rmi4_irq_enable(rmi4_data, false);
+	free_irq(rmi4_data->irq, rmi4_data);
 
 err_enable_irq:
-#ifdef CONFIG_FB
-	fb_unregister_client(&rmi4_data->fb_notifier);
-#endif
-
-#ifdef USE_EARLYSUSPEND
+#if defined(CONFIG_FB)
+	fb_unregister_client(&rmi4_data->fb_notif);
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
 	unregister_early_suspend(&rmi4_data->early_suspend);
 #endif
 
 	synaptics_rmi4_empty_fn_list(rmi4_data);
 	input_unregister_device(rmi4_data->input_dev);
 	rmi4_data->input_dev = NULL;
-	if (rmi4_data->stylus_enable) {
-		input_unregister_device(rmi4_data->stylus_dev);
-		rmi4_data->stylus_dev = NULL;
-	}
 
 err_set_input_dev:
-	synaptics_rmi4_gpio_setup(bdata->irq_gpio, false, 0, 0);
-
-	if (bdata->reset_gpio >= 0)
-		synaptics_rmi4_gpio_setup(bdata->reset_gpio, false, 0, 0);
-
-	if (bdata->power_gpio >= 0)
-		synaptics_rmi4_gpio_setup(bdata->power_gpio, false, 0, 0);
-
-err_ui_hw_init:
-err_set_gpio:
-	synaptics_rmi4_enable_reg(rmi4_data, false);
+	if (bdata->gpio_config) {
+		bdata->gpio_config(
+				bdata->irq_gpio,
+				false, 0, 0);
+
+		if (bdata->reset_gpio >= 0) {
+			bdata->gpio_config(
+					bdata->reset_gpio,
+					false, 0, 0);
+		}
 
+		if (bdata->power_gpio >= 0) {
+			bdata->gpio_config(
+					bdata->power_gpio,
+					false, 0, 0);
+		}
+	} else {
+		synaptics_dsx_gpio_configure(rmi4_data, false);
+	}
+err_config_gpio:
 	if (rmi4_data->ts_pinctrl) {
 		if (IS_ERR_OR_NULL(rmi4_data->pinctrl_state_release)) {
 			devm_pinctrl_put(rmi4_data->ts_pinctrl);
 			rmi4_data->ts_pinctrl = NULL;
 		} else {
 			retval = pinctrl_select_state(
-			rmi4_data->ts_pinctrl,
-			rmi4_data->pinctrl_state_release);
+				rmi4_data->ts_pinctrl,
+				rmi4_data->pinctrl_state_release);
 			if (retval)
 				dev_err(&pdev->dev,
 					"%s: Failed to create sysfs attributes\n",
@@ -4199,263 +4010,147 @@ err_set_gpio:
 		}
 	}
 
-err_enable_reg:
-	synaptics_rmi4_get_reg(rmi4_data, false);
-
-err_get_reg:
+err_set_gpio:
+	regulator_disable(rmi4_data->regulator_vdd);
+	regulator_disable(rmi4_data->regulator_avdd);
+err_regulator_enable:
+	regulator_put(rmi4_data->regulator_vdd);
+	regulator_put(rmi4_data->regulator_avdd);
+err_regulator_configure:
 	kfree(rmi4_data);
 
 	return retval;
 }
 
+ /**
+ * synaptics_rmi4_remove()
+ *
+ * Called by the kernel when the association with an I2C device of the
+ * same name is broken (when the driver is unloaded).
+ *
+ * This function terminates the work queue, stops sensor data acquisition,
+ * frees the interrupt, unregisters the driver from the input subsystem,
+ * turns off the power to the sensor, and frees other allocated resources.
+ */
 static int synaptics_rmi4_remove(struct platform_device *pdev)
 {
 	unsigned char attr_count;
-	int err;
 	struct synaptics_rmi4_data *rmi4_data = platform_get_drvdata(pdev);
 	const struct synaptics_dsx_board_data *bdata =
 			rmi4_data->hw_if->board_data;
+	int err;
 
-#ifdef FB_READY_RESET
-	cancel_work_sync(&rmi4_data->reset_work);
-	flush_workqueue(rmi4_data->reset_workqueue);
-	destroy_workqueue(rmi4_data->reset_workqueue);
-#endif
-
-	cancel_delayed_work_sync(&exp_data.work);
-	flush_workqueue(exp_data.workqueue);
-	destroy_workqueue(exp_data.workqueue);
-
-	cancel_delayed_work_sync(&rmi4_data->rb_work);
-	flush_workqueue(rmi4_data->rb_workqueue);
-	destroy_workqueue(rmi4_data->rb_workqueue);
+	if (rmi4_data->support_vkeys) {
+		sysfs_remove_group(vkey_kobj, &vkey_grp);
+		kobject_put(vkey_kobj);
+	}
 
 	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++) {
 		sysfs_remove_file(&rmi4_data->input_dev->dev.kobj,
 				&attrs[attr_count].attr);
 	}
 
-	if (rmi4_data->board_prop_dir) {
-		sysfs_remove_file(rmi4_data->board_prop_dir,
-				&virtual_key_map_attr.attr);
-		kobject_put(rmi4_data->board_prop_dir);
-	}
-
-	synaptics_rmi4_irq_enable(rmi4_data, false, false);
+	debugfs_remove_recursive(rmi4_data->dir);
+	cancel_delayed_work_sync(&exp_data.work);
+	flush_workqueue(exp_data.workqueue);
+	destroy_workqueue(exp_data.workqueue);
 
-#ifdef CONFIG_FB
-	fb_unregister_client(&rmi4_data->fb_notifier);
-#endif
+	synaptics_rmi4_irq_enable(rmi4_data, false);
 
-#ifdef USE_EARLYSUSPEND
+#if defined(CONFIG_FB)
+	fb_unregister_client(&rmi4_data->fb_notif);
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
 	unregister_early_suspend(&rmi4_data->early_suspend);
 #endif
 
 	synaptics_rmi4_empty_fn_list(rmi4_data);
 	input_unregister_device(rmi4_data->input_dev);
 	rmi4_data->input_dev = NULL;
-	if (rmi4_data->stylus_enable) {
-		input_unregister_device(rmi4_data->stylus_dev);
-		rmi4_data->stylus_dev = NULL;
-	}
-
-	synaptics_rmi4_gpio_setup(bdata->irq_gpio, false, 0, 0);
 
-	if (bdata->reset_gpio >= 0)
-		synaptics_rmi4_gpio_setup(bdata->reset_gpio, false, 0, 0);
+	if (bdata->gpio_config) {
+		bdata->gpio_config(
+				bdata->irq_gpio,
+				false, 0, 0);
 
-	if (bdata->power_gpio >= 0)
-		synaptics_rmi4_gpio_setup(bdata->power_gpio, false, 0, 0);
-
-
-	if (rmi4_data->ts_pinctrl) {
-		if (IS_ERR_OR_NULL(rmi4_data->pinctrl_state_release)) {
-			devm_pinctrl_put(rmi4_data->ts_pinctrl);
-			rmi4_data->ts_pinctrl = NULL;
-		} else {
-			err = pinctrl_select_state(
-			rmi4_data->ts_pinctrl,
-			rmi4_data->pinctrl_state_release);
-			if (err)
-				dev_err(&pdev->dev,
-					"Failed to select release pinctrl state %d\n",
-					err);
+		if (bdata->reset_gpio >= 0) {
+			bdata->gpio_config(
+					bdata->reset_gpio,
+					false, 0, 0);
 		}
-	}
-
-	synaptics_rmi4_enable_reg(rmi4_data, false);
-	synaptics_rmi4_get_reg(rmi4_data, false);
-
-	kfree(rmi4_data);
-
-	return 0;
-}
 
-static void synaptics_rmi4_f11_wg(struct synaptics_rmi4_data *rmi4_data,
-		bool enable)
-{
-	int retval;
-	unsigned char reporting_control;
-	struct synaptics_rmi4_fn *fhandler;
-	struct synaptics_rmi4_device_info *rmi;
-
-	rmi = &(rmi4_data->rmi4_mod_info);
-
-	list_for_each_entry(fhandler, &rmi->support_fn_list, link) {
-		if (fhandler->fn_number == SYNAPTICS_RMI4_F11)
-			break;
-	}
-
-	retval = synaptics_rmi4_reg_read(rmi4_data,
-			fhandler->full_addr.ctrl_base,
-			&reporting_control,
-			sizeof(reporting_control));
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to change reporting mode\n",
-				__func__);
-		return;
-	}
-
-	reporting_control = (reporting_control & ~MASK_3BIT);
-	if (enable)
-		reporting_control |= F11_WAKEUP_GESTURE_MODE;
-	else
-		reporting_control |= F11_CONTINUOUS_MODE;
-
-	retval = synaptics_rmi4_reg_write(rmi4_data,
-			fhandler->full_addr.ctrl_base,
-			&reporting_control,
-			sizeof(reporting_control));
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to change reporting mode\n",
-				__func__);
-		return;
-	}
-
-	return;
-}
-
-static void synaptics_rmi4_f12_wg(struct synaptics_rmi4_data *rmi4_data,
-		bool enable)
-{
-	int retval;
-	unsigned char offset;
-	unsigned char reporting_control[3];
-	struct synaptics_rmi4_f12_extra_data *extra_data;
-	struct synaptics_rmi4_fn *fhandler;
-	struct synaptics_rmi4_device_info *rmi;
-
-	rmi = &(rmi4_data->rmi4_mod_info);
-
-	list_for_each_entry(fhandler, &rmi->support_fn_list, link) {
-		if (fhandler->fn_number == SYNAPTICS_RMI4_F12)
-			break;
+		if (bdata->power_gpio >= 0) {
+			bdata->gpio_config(
+					bdata->power_gpio,
+					false, 0, 0);
+		}
+	} else {
+		synaptics_dsx_gpio_configure(rmi4_data, false);
+		if (rmi4_data->ts_pinctrl) {
+			if (IS_ERR_OR_NULL(rmi4_data->pinctrl_state_release)) {
+				devm_pinctrl_put(rmi4_data->ts_pinctrl);
+				rmi4_data->ts_pinctrl = NULL;
+			} else {
+				err = pinctrl_select_state(
+					rmi4_data->ts_pinctrl,
+					rmi4_data->pinctrl_state_release);
+				if (err)
+					dev_err(&pdev->dev,
+						"Failed to select release pinctrl state %d\n",
+						err);
+			}
+		}
 	}
 
-	extra_data = (struct synaptics_rmi4_f12_extra_data *)fhandler->extra;
-	offset = extra_data->ctrl20_offset;
-
-	retval = synaptics_rmi4_reg_read(rmi4_data,
-			fhandler->full_addr.ctrl_base + offset,
-			reporting_control,
-			sizeof(reporting_control));
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to change reporting mode\n",
-				__func__);
-		return;
+	if (rmi4_data->regulator_vdd) {
+		regulator_disable(rmi4_data->regulator_vdd);
+		regulator_put(rmi4_data->regulator_vdd);
 	}
 
-	if (enable)
-		reporting_control[2] = F12_WAKEUP_GESTURE_MODE;
-	else
-		reporting_control[2] = F12_CONTINUOUS_MODE;
-
-	retval = synaptics_rmi4_reg_write(rmi4_data,
-			fhandler->full_addr.ctrl_base + offset,
-			reporting_control,
-			sizeof(reporting_control));
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to change reporting mode\n",
-				__func__);
-		return;
+	if (rmi4_data->regulator_avdd) {
+		regulator_disable(rmi4_data->regulator_avdd);
+		regulator_put(rmi4_data->regulator_avdd);
 	}
 
-	return;
-}
-
-static void synaptics_rmi4_wakeup_gesture(struct synaptics_rmi4_data *rmi4_data,
-		bool enable)
-{
-	if (rmi4_data->f11_wakeup_gesture)
-		synaptics_rmi4_f11_wg(rmi4_data, enable);
-	else if (rmi4_data->f12_wakeup_gesture)
-		synaptics_rmi4_f12_wg(rmi4_data, enable);
-
-	return;
-}
+	kfree(rmi4_data);
 
-#ifdef CONFIG_FB
-static void synaptics_rmi4_fb_notify_resume_work(struct work_struct *work)
-{
-	struct synaptics_rmi4_data *rmi4_data =
-		container_of(work, struct synaptics_rmi4_data, fb_notify_work);
-	synaptics_rmi4_resume(&(rmi4_data->input_dev->dev));
-	rmi4_data->fb_ready = true;
+	return 0;
 }
 
-static int synaptics_rmi4_fb_notifier_cb(struct notifier_block *self,
-		unsigned long event, void *data)
+#if defined(CONFIG_FB)
+static int fb_notifier_callback(struct notifier_block *self,
+				unsigned long event, void *data)
 {
-	int *transition;
 	struct fb_event *evdata = data;
+	int *blank;
 	struct synaptics_rmi4_data *rmi4_data =
-			container_of(self, struct synaptics_rmi4_data,
-			fb_notifier);
+		container_of(self, struct synaptics_rmi4_data, fb_notif);
 
 	if (evdata && evdata->data && rmi4_data) {
-		if (rmi4_data->hw_if->board_data->resume_in_workqueue) {
-			if (event == FB_EARLY_EVENT_BLANK) {
-				synaptics_secure_touch_stop(rmi4_data, false);
-			} else if (event == FB_EVENT_BLANK) {
-				transition = evdata->data;
-				if (*transition == FB_BLANK_POWERDOWN) {
-					flush_work(
-						&(rmi4_data->fb_notify_work));
-					synaptics_rmi4_suspend(
-						&rmi4_data->pdev->dev);
-					rmi4_data->fb_ready = false;
-				} else if (*transition == FB_BLANK_UNBLANK) {
-					schedule_work(
-						&(rmi4_data->fb_notify_work));
-				}
-			}
-		} else {
-			if (event == FB_EARLY_EVENT_BLANK) {
-				synaptics_secure_touch_stop(rmi4_data, false);
-			} else if (event == FB_EVENT_BLANK) {
-				transition = evdata->data;
-				if (*transition == FB_BLANK_POWERDOWN) {
-					synaptics_rmi4_suspend(
-						&rmi4_data->pdev->dev);
-					rmi4_data->fb_ready = false;
-				} else if (*transition == FB_BLANK_UNBLANK) {
-					synaptics_rmi4_resume(
-						&rmi4_data->pdev->dev);
-					rmi4_data->fb_ready = true;
-				}
-			}
+		if (event == FB_EARLY_EVENT_BLANK)
+			synaptics_secure_touch_stop(rmi4_data, 0);
+		else if (event == FB_EVENT_BLANK) {
+			blank = evdata->data;
+			if (*blank == FB_BLANK_UNBLANK)
+				synaptics_rmi4_resume(
+					&(rmi4_data->input_dev->dev));
+			else if (*blank == FB_BLANK_POWERDOWN)
+				synaptics_rmi4_suspend(
+					&(rmi4_data->input_dev->dev));
 		}
 	}
 
 	return 0;
 }
-#endif
-
-#ifdef USE_EARLYSUSPEND
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+ /**
+ * synaptics_rmi4_early_suspend()
+ *
+ * Called by the kernel during the early suspend phase when the system
+ * enters suspend.
+ *
+ * This function calls synaptics_rmi4_sensor_sleep() to stop finger
+ * data acquisition and put the sensor to sleep.
+ */
 static void synaptics_rmi4_early_suspend(struct early_suspend *h)
 {
 	struct synaptics_rmi4_exp_fhandler *exp_fhandler;
@@ -4463,28 +4158,20 @@ static void synaptics_rmi4_early_suspend(struct early_suspend *h)
 			container_of(h, struct synaptics_rmi4_data,
 			early_suspend);
 
-	if (rmi4_data->stay_awake)
+	if (!rmi4_data->stay_awake) {
+		rmi4_data->staying_awake = false;
+	} else {
+		rmi4_data->staying_awake = true;
 		return;
-
-	/*
-	 * During early suspend/late resume, the driver doesn't access xPU/SMMU
-	 * protected HW resources. So, there is no compelling need to block,
-	 * but notifying the userspace that a power event has occurred is
-	 * enough. Hence 'blocking' variable can be set to false.
-	 */
-	synaptics_secure_touch_stop(rmi4_data, false);
-
-	if (rmi4_data->enable_wakeup_gesture) {
-		synaptics_rmi4_wakeup_gesture(rmi4_data, true);
-		enable_irq_wake(rmi4_data->irq);
-		goto exit;
 	}
 
-	synaptics_rmi4_irq_enable(rmi4_data, false, false);
-	synaptics_rmi4_sleep_enable(rmi4_data, true);
+	synaptics_secure_touch_stop(rmi4_data, 0);
+
+	rmi4_data->touch_stopped = true;
+	synaptics_rmi4_irq_enable(rmi4_data, false);
+	synaptics_rmi4_sensor_sleep(rmi4_data);
 	synaptics_rmi4_free_fingers(rmi4_data);
 
-exit:
 	mutex_lock(&exp_data.mutex);
 	if (!list_empty(&exp_data.list)) {
 		list_for_each_entry(exp_fhandler, &exp_data.list, link)
@@ -4493,50 +4180,46 @@ exit:
 	}
 	mutex_unlock(&exp_data.mutex);
 
-	rmi4_data->suspend = true;
-
-	return;
+	if (rmi4_data->full_pm_cycle)
+		synaptics_rmi4_suspend(&(rmi4_data->input_dev->dev));
 }
 
+ /**
+ * synaptics_rmi4_late_resume()
+ *
+ * Called by the kernel during the late resume phase when the system
+ * wakes up from suspend.
+ *
+ * This function goes through the sensor wake process if the system wakes
+ * up from early suspend (without going into suspend).
+ */
 static void synaptics_rmi4_late_resume(struct early_suspend *h)
 {
-#ifdef FB_READY_RESET
 	int retval;
-#endif
 	struct synaptics_rmi4_exp_fhandler *exp_fhandler;
 	struct synaptics_rmi4_data *rmi4_data =
 			container_of(h, struct synaptics_rmi4_data,
 			early_suspend);
 
-	if (rmi4_data->stay_awake)
+	if (rmi4_data->staying_awake)
 		return;
 
-	synaptics_secure_touch_stop(rmi4_data, false);
-
-	if (rmi4_data->enable_wakeup_gesture) {
-		synaptics_rmi4_wakeup_gesture(rmi4_data, false);
-		disable_irq_wake(rmi4_data->irq);
-		goto exit;
-	}
+	synaptics_secure_touch_stop(rmi4_data, 0);
 
-	rmi4_data->current_page = MASK_8BIT;
+	if (rmi4_data->full_pm_cycle)
+		synaptics_rmi4_resume(&(rmi4_data->input_dev->dev));
 
-	if (rmi4_data->suspend) {
-		synaptics_rmi4_sleep_enable(rmi4_data, false);
-		synaptics_rmi4_irq_enable(rmi4_data, true, false);
-	}
-
-exit:
-#ifdef FB_READY_RESET
-	if (rmi4_data->suspend) {
-		retval = synaptics_rmi4_reset_device(rmi4_data, false);
+	if (rmi4_data->sensor_sleep == true) {
+		synaptics_rmi4_sensor_wake(rmi4_data);
+		synaptics_rmi4_irq_enable(rmi4_data, true);
+		retval = synaptics_rmi4_reinit_device(rmi4_data);
 		if (retval < 0) {
 			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to issue reset command\n",
+					"%s: Failed to reinit device\n",
 					__func__);
 		}
 	}
-#endif
+
 	mutex_lock(&exp_data.mutex);
 	if (!list_empty(&exp_data.list)) {
 		list_for_each_entry(exp_fhandler, &exp_data.list, link)
@@ -4545,109 +4228,259 @@ exit:
 	}
 	mutex_unlock(&exp_data.mutex);
 
-	rmi4_data->suspend = false;
-
-	return;
+	rmi4_data->touch_stopped = false;
 }
 #endif
 
+#ifdef CONFIG_PM
+ /**
+ * synaptics_rmi4_sensor_sleep()
+ *
+ * Called by synaptics_rmi4_early_suspend() and synaptics_rmi4_suspend().
+ *
+ * This function stops finger data acquisition and puts the sensor to sleep.
+ */
+static void synaptics_rmi4_sensor_sleep(struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	unsigned char device_ctrl;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			rmi4_data->f01_ctrl_base_addr,
+			&device_ctrl,
+			sizeof(device_ctrl));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to enter sleep mode\n",
+				__func__);
+		rmi4_data->sensor_sleep = false;
+		return;
+	}
+
+	device_ctrl = (device_ctrl & ~MASK_3BIT);
+	device_ctrl = (device_ctrl | NO_SLEEP_OFF | SENSOR_SLEEP);
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			rmi4_data->f01_ctrl_base_addr,
+			&device_ctrl,
+			sizeof(device_ctrl));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to enter sleep mode\n",
+				__func__);
+		rmi4_data->sensor_sleep = false;
+	} else {
+		rmi4_data->sensor_sleep = true;
+	}
+}
+
+ /**
+ * synaptics_rmi4_sensor_wake()
+ *
+ * Called by synaptics_rmi4_resume() and synaptics_rmi4_late_resume().
+ *
+ * This function wakes the sensor from sleep.
+ */
+static void synaptics_rmi4_sensor_wake(struct synaptics_rmi4_data *rmi4_data)
+{
+	int retval;
+	unsigned char device_ctrl;
+	unsigned char no_sleep_setting = rmi4_data->no_sleep_setting;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			rmi4_data->f01_ctrl_base_addr,
+			&device_ctrl,
+			sizeof(device_ctrl));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to wake from sleep mode\n",
+				__func__);
+		rmi4_data->sensor_sleep = true;
+		return;
+	}
+
+	device_ctrl = (device_ctrl & ~MASK_3BIT);
+	device_ctrl = (device_ctrl | no_sleep_setting | NORMAL_OPERATION);
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			rmi4_data->f01_ctrl_base_addr,
+			&device_ctrl,
+			sizeof(device_ctrl));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to wake from sleep mode\n",
+				__func__);
+		rmi4_data->sensor_sleep = true;
+	} else {
+		rmi4_data->sensor_sleep = false;
+	}
+}
+
+ /**
+ * synaptics_rmi4_suspend()
+ *
+ * Called by the kernel during the suspend phase when the system
+ * enters suspend.
+ *
+ * This function stops finger data acquisition and puts the sensor to
+ * sleep (if not already done so during the early suspend phase),
+ * disables the interrupt, and turns off the power to the sensor.
+ */
 static int synaptics_rmi4_suspend(struct device *dev)
 {
 	struct synaptics_rmi4_exp_fhandler *exp_fhandler;
 	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+	const struct synaptics_dsx_board_data *bdata =
+			rmi4_data->hw_if->board_data;
 	int retval;
 
-	if (rmi4_data->stay_awake)
+	if (!rmi4_data->stay_awake) {
+		rmi4_data->staying_awake = false;
+	} else {
+		rmi4_data->staying_awake = true;
 		return 0;
+	}
+
+	if (rmi4_data->suspended) {
+		dev_info(dev, "Already in suspend state\n");
+		return 0;
+	}
 
-	synaptics_secure_touch_stop(rmi4_data, true);
+	synaptics_secure_touch_stop(rmi4_data, 1);
 
-	if (rmi4_data->enable_wakeup_gesture) {
-		synaptics_rmi4_wakeup_gesture(rmi4_data, true);
-		enable_irq_wake(rmi4_data->irq);
-		goto exit;
+	if (!rmi4_data->fw_updating) {
+		if (!rmi4_data->sensor_sleep) {
+			rmi4_data->touch_stopped = true;
+			synaptics_rmi4_irq_enable(rmi4_data, false);
+			synaptics_rmi4_sensor_sleep(rmi4_data);
+			synaptics_rmi4_free_fingers(rmi4_data);
+		}
+
+#ifdef FIRST_FLAG
+	if (rmi4_data->flag) {
+#endif
+		mutex_lock(&exp_data.mutex);
+		if (!list_empty(&exp_data.list)) {
+			list_for_each_entry(exp_fhandler, &exp_data.list,
+				link)
+				if (exp_fhandler->exp_fn->suspend != NULL)
+					exp_fhandler->exp_fn->suspend(
+						rmi4_data);
+		}
+		mutex_unlock(&exp_data.mutex);
+#ifdef FIRST_FLAG
+	}
+#endif
+		retval = synaptics_dsx_regulator_enable(rmi4_data, false);
+		if (retval < 0) {
+			dev_err(dev, "failed to enter low power mode\n");
+			goto err_lpm_regulator;
+		}
+	} else {
+		dev_err(dev,
+			"Firmware updating, cannot go into suspend mode\n");
+		return 0;
 	}
 
-	if (!rmi4_data->suspend) {
-		synaptics_rmi4_irq_enable(rmi4_data, false, false);
-		synaptics_rmi4_sleep_enable(rmi4_data, true);
-		synaptics_rmi4_free_fingers(rmi4_data);
+	if (bdata->disable_gpios) {
+		if (rmi4_data->ts_pinctrl) {
+			retval = pinctrl_select_state(rmi4_data->ts_pinctrl,
+					rmi4_data->pinctrl_state_suspend);
+			if (retval < 0) {
+				dev_err(dev, "Cannot get idle pinctrl state\n");
+				goto err_pinctrl_select_suspend;
+			}
+		}
+
+		retval = synaptics_dsx_gpio_configure(rmi4_data, false);
+		if (retval < 0) {
+			dev_err(dev, "failed to put gpios in suspend state\n");
+			goto err_gpio_configure;
+		}
 	}
 
+	rmi4_data->suspended = true;
+
+	return 0;
+
+err_gpio_configure:
 	if (rmi4_data->ts_pinctrl) {
 		retval = pinctrl_select_state(rmi4_data->ts_pinctrl,
-		rmi4_data->pinctrl_state_suspend);
+					rmi4_data->pinctrl_state_active);
 		if (retval < 0)
-			dev_err(dev, "Cannot get idle pinctrl state\n");
-			goto err_pinctrl;
-	}
-exit:
-	mutex_lock(&exp_data.mutex);
-	if (!list_empty(&exp_data.list)) {
-		list_for_each_entry(exp_fhandler, &exp_data.list, link)
-			if (exp_fhandler->exp_fn->suspend != NULL)
-				exp_fhandler->exp_fn->suspend(rmi4_data);
+			dev_err(dev, "Cannot get default pinctrl state\n");
 	}
-	mutex_unlock(&exp_data.mutex);
-
-	if (!rmi4_data->suspend) {
-		synaptics_rmi4_enable_reg(rmi4_data, false);
-		synaptics_rmi4_get_reg(rmi4_data, false);
+err_pinctrl_select_suspend:
+	synaptics_dsx_regulator_enable(rmi4_data, true);
+err_lpm_regulator:
+	if (rmi4_data->sensor_sleep) {
+		synaptics_rmi4_sensor_wake(rmi4_data);
+		synaptics_rmi4_irq_enable(rmi4_data, true);
+		rmi4_data->touch_stopped = false;
 	}
-	rmi4_data->suspend = true;
 
-	return 0;
-
-err_pinctrl:
-	synaptics_rmi4_sleep_enable(rmi4_data, false);
-	synaptics_rmi4_irq_enable(rmi4_data, true, false);
 	return retval;
-
 }
 
+ /**
+ * synaptics_rmi4_resume()
+ *
+ * Called by the kernel during the resume phase when the system
+ * wakes up from suspend.
+ *
+ * This function turns on the power to the sensor, wakes the sensor
+ * from sleep, enables the interrupt, and starts finger data
+ * acquisition.
+ */
 static int synaptics_rmi4_resume(struct device *dev)
 {
-#ifdef FB_READY_RESET
 	int retval;
-#endif
 	struct synaptics_rmi4_exp_fhandler *exp_fhandler;
 	struct synaptics_rmi4_data *rmi4_data = dev_get_drvdata(dev);
+	struct synaptics_rmi4_device_info *rmi;
+	const struct synaptics_dsx_board_data *bdata =
+			rmi4_data->hw_if->board_data;
 
-	if (rmi4_data->stay_awake)
+	rmi = &(rmi4_data->rmi4_mod_info);
+	if (rmi->package_id == SYNA_S332U_PACKAGE_ID &&
+			rmi->package_id_rev == SYNA_S332U_PACKAGE_ID_REV) {
+		synaptics_rmi4_reset_device(rmi4_data);
+	}
+
+	if (rmi4_data->staying_awake)
 		return 0;
 
-	synaptics_secure_touch_stop(rmi4_data, true);
+	if (!rmi4_data->suspended)
+		return 0;
 
-	if (rmi4_data->enable_wakeup_gesture) {
-		synaptics_rmi4_wakeup_gesture(rmi4_data, false);
-		disable_irq_wake(rmi4_data->irq);
-		goto exit;
-	}
+	synaptics_secure_touch_stop(rmi4_data, 1);
 
-	rmi4_data->current_page = MASK_8BIT;
+	synaptics_dsx_regulator_enable(rmi4_data, true);
 
-	if(rmi4_data->suspend) {
-		synaptics_rmi4_get_reg(rmi4_data, true);
-		synaptics_rmi4_enable_reg(rmi4_data, true);
-	}
+	if (bdata->disable_gpios) {
+		if (rmi4_data->ts_pinctrl) {
+			retval = pinctrl_select_state(rmi4_data->ts_pinctrl,
+					rmi4_data->pinctrl_state_active);
+			if (retval < 0)
+				dev_err(dev, "Cannot get default pinctrl state\n");
+		}
 
-	synaptics_rmi4_sleep_enable(rmi4_data, false);
-	synaptics_rmi4_irq_enable(rmi4_data, true, false);
-	if (rmi4_data->ts_pinctrl) {
-		retval = pinctrl_select_state(rmi4_data->ts_pinctrl,
-		rmi4_data->pinctrl_state_active);
+		retval = synaptics_dsx_gpio_configure(rmi4_data, true);
 		if (retval < 0)
-			dev_err(dev, "Cannot get default pinctrl state\n");
+			dev_err(dev, "Failed to put gpios in active state\n");
 	}
 
-exit:
-#ifdef FB_READY_RESET
-	retval = synaptics_rmi4_reset_device(rmi4_data, false);
+	synaptics_rmi4_sensor_wake(rmi4_data);
+	retval = synaptics_rmi4_reinit_device(rmi4_data);
 	if (retval < 0) {
 		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to issue reset command\n",
+				"%s: Failed to reinit device\n",
 				__func__);
+		return retval;
 	}
+
+#ifdef FIRST_FLAG
+	rmi4_data->flag = 1;
 #endif
 	mutex_lock(&exp_data.mutex);
 	if (!list_empty(&exp_data.list)) {
@@ -4657,18 +4490,32 @@ exit:
 	}
 	mutex_unlock(&exp_data.mutex);
 
-	rmi4_data->suspend = false;
+	rmi4_data->touch_stopped = false;
+	rmi4_data->suspended = false;
+
+	synaptics_rmi4_irq_enable(rmi4_data, true);
 
 	return 0;
 }
 
-#ifdef CONFIG_PM
 static const struct dev_pm_ops synaptics_rmi4_dev_pm_ops = {
-#ifndef CONFIG_FB
+#if (!defined(CONFIG_FB) && !defined(CONFIG_HAS_EARLYSUSPEND))
 	.suspend = synaptics_rmi4_suspend,
-	.resume = synaptics_rmi4_resume,
+	.resume  = synaptics_rmi4_resume,
 #endif
 };
+#else
+static int synaptics_rmi4_suspend(struct device *dev)
+{
+	dev_err(dev, "PM not supported\n");
+	return -EINVAL;
+}
+
+static int synaptics_rmi4_resume(struct device *dev)
+{
+	dev_err(dev, "PM not supported\n");
+	return -EINVAL;
+}
 #endif
 
 static struct platform_driver synaptics_rmi4_driver = {
@@ -4683,29 +4530,44 @@ static struct platform_driver synaptics_rmi4_driver = {
 	.remove = synaptics_rmi4_remove,
 };
 
+ /**
+ * synaptics_rmi4_init()
+ *
+ * Called by the kernel during do_initcalls (if built-in)
+ * or when the driver is loaded (if a module).
+ *
+ * This function registers the driver to the I2C subsystem.
+ *
+ */
 static int __init synaptics_rmi4_init(void)
 {
 	int retval;
 
-	retval = synaptics_rmi4_bus_init_v26();
+	retval = synaptics_rmi4_bus_init();
 	if (retval)
 		return retval;
 
 	return platform_driver_register(&synaptics_rmi4_driver);
 }
 
+ /**
+ * synaptics_rmi4_exit()
+ *
+ * Called by the kernel when the driver is unloaded.
+ *
+ * This function unregisters the driver from the I2C subsystem.
+ *
+ */
 static void __exit synaptics_rmi4_exit(void)
 {
 	platform_driver_unregister(&synaptics_rmi4_driver);
 
-	synaptics_rmi4_bus_exit_v26();
-
-	return;
+	synaptics_rmi4_bus_exit();
 }
 
 module_init(synaptics_rmi4_init);
 module_exit(synaptics_rmi4_exit);
 
 MODULE_AUTHOR("Synaptics, Inc.");
-MODULE_DESCRIPTION("Synaptics DSX Touch Driver");
+MODULE_DESCRIPTION("Synaptics DSX I2C Touch Driver");
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_core.h b/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_core.h
index 7d92791..43cbc13 100644
--- a/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_core.h
+++ b/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_core.h
@@ -1,11 +1,12 @@
 /*
  * Synaptics DSX touchscreen driver
  *
- * Copyright (C) 2012-2015 Synaptics Incorporated. All rights reserved.
+ * Copyright (C) 2012-2016 Synaptics Incorporated
+ *
+ * Copyright (C) 2012-2016 Alexandra Chin <alexandra.chin@tw.synaptics.com>
+ * Copyright (C) 2012-2016 Scott Lin <scott.lin@tw.synaptics.com>
+ * Copyright (c) 2014-2016, The Linux Foundation. All rights reserved.
  *
- * Copyright (C) 2012 Alexandra Chin <alexandra.chin@tw.synaptics.com>
- * Copyright (C) 2012 Scott Lin <scott.lin@tw.synaptics.com>
- * Copyright (C) 2016 The Linux Foundation. All rights reserved.
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
@@ -13,60 +14,40 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
- * INFORMATION CONTAINED IN THIS DOCUMENT IS PROVIDED "AS-IS," AND SYNAPTICS
- * EXPRESSLY DISCLAIMS ALL EXPRESS AND IMPLIED WARRANTIES, INCLUDING ANY
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE,
- * AND ANY WARRANTIES OF NON-INFRINGEMENT OF ANY INTELLECTUAL PROPERTY RIGHTS.
- * IN NO EVENT SHALL SYNAPTICS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES ARISING OUT OF OR IN CONNECTION
- * WITH THE USE OF THE INFORMATION CONTAINED IN THIS DOCUMENT, HOWEVER CAUSED
- * AND BASED ON ANY THEORY OF LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * NEGLIGENCE OR OTHER TORTIOUS ACTION, AND EVEN IF SYNAPTICS WAS ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE. IF A TRIBUNAL OF COMPETENT JURISDICTION DOES
- * NOT PERMIT THE DISCLAIMER OF DIRECT DAMAGES OR ANY OTHER DAMAGES, SYNAPTICS'
- * TOTAL CUMULATIVE LIABILITY TO ANY PARTY SHALL NOT EXCEED ONE HUNDRED U.S.
- * DOLLARS.
  */
-
 #ifndef _SYNAPTICS_DSX_RMI4_H_
 #define _SYNAPTICS_DSX_RMI4_H_
 
 #define SYNAPTICS_DS4 (1 << 0)
 #define SYNAPTICS_DS5 (1 << 1)
 #define SYNAPTICS_DSX_DRIVER_PRODUCT (SYNAPTICS_DS4 | SYNAPTICS_DS5)
-#define SYNAPTICS_DSX_DRIVER_VERSION 0x2061
+#define SYNAPTICS_DSX_DRIVER_VERSION 0x2001
 
 #include <linux/version.h>
-#ifdef CONFIG_FB
+#include <linux/debugfs.h>
+
+#if defined(CONFIG_FB)
 #include <linux/notifier.h>
 #include <linux/fb.h>
-#endif
-#ifdef CONFIG_HAS_EARLYSUSPEND
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
 #include <linux/earlysuspend.h>
 #endif
-
 #if defined(CONFIG_SECURE_TOUCH_SYNAPTICS_DSX_V26)
 #include <linux/completion.h>
 #include <linux/atomic.h>
-#include <linux/pm_runtime.h>
 #include <linux/clk.h>
 #endif
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 38))
+/*#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 38))*/
 #define KERNEL_ABOVE_2_6_38
-#endif
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0))
-#define KERNEL_ABOVE_3_6
-#endif
+/*#endif*/
 
 #ifdef KERNEL_ABOVE_2_6_38
 #define sstrtoul(...) kstrtoul(__VA_ARGS__)
 #else
-#define sstrtoul(...) strict_strtoul(__VA_ARGS__)
+/*#define sstrtoul(...) strict_strtoul(__VA_ARGS__)*/
 #endif
 
 #define PDT_PROPS (0X00EF)
@@ -80,34 +61,27 @@
 #define SYNAPTICS_RMI4_F01 (0x01)
 #define SYNAPTICS_RMI4_F11 (0x11)
 #define SYNAPTICS_RMI4_F12 (0x12)
-#define SYNAPTICS_RMI4_F1A (0x1A)
+#define SYNAPTICS_RMI4_F1A (0x1a)
 #define SYNAPTICS_RMI4_F34 (0x34)
-#define SYNAPTICS_RMI4_F35 (0x35)
-#define SYNAPTICS_RMI4_F38 (0x38)
 #define SYNAPTICS_RMI4_F51 (0x51)
 #define SYNAPTICS_RMI4_F54 (0x54)
 #define SYNAPTICS_RMI4_F55 (0x55)
-#define SYNAPTICS_RMI4_FDB (0xDB)
 
-#define PRODUCT_INFO_SIZE 2
-#define PRODUCT_ID_SIZE 10
-#define BUILD_ID_SIZE 3
+#define SYNAPTICS_RMI4_PRODUCT_INFO_SIZE 2
+#define SYNAPTICS_RMI4_DATE_CODE_SIZE 3
+#define SYNAPTICS_RMI4_PRODUCT_ID_SIZE 10
+#define SYNAPTICS_RMI4_BUILD_ID_SIZE 3
+
+#define F01_PACKAGE_ID_OFFSET 17
+#define PACKAGE_ID_SIZE 4
 
 #define F12_FINGERS_TO_SUPPORT 10
 #define F12_NO_OBJECT_STATUS 0x00
 #define F12_FINGER_STATUS 0x01
-#define F12_ACTIVE_STYLUS_STATUS 0x02
+#define F12_STYLUS_STATUS 0x02
 #define F12_PALM_STATUS 0x03
 #define F12_HOVERING_FINGER_STATUS 0x05
 #define F12_GLOVED_FINGER_STATUS 0x06
-#define F12_NARROW_OBJECT_STATUS 0x07
-#define F12_HAND_EDGE_STATUS 0x08
-#define F12_COVER_STATUS 0x0A
-#define F12_STYLUS_STATUS 0x0B
-#define F12_ERASER_STATUS 0x0C
-#define F12_SMALL_OBJECT_STATUS 0x0D
-
-#define F12_GESTURE_DETECTION_LEN 5
 
 #define MAX_NUMBER_OF_BUTTONS 4
 #define MAX_INTR_REGISTERS 4
@@ -125,51 +99,49 @@
 #define PINCTRL_STATE_ACTIVE    "pmx_ts_active"
 #define PINCTRL_STATE_SUSPEND   "pmx_ts_suspend"
 #define PINCTRL_STATE_RELEASE   "pmx_ts_release"
+
+#define SYNA_FW_NAME_MAX_LEN	50
+
+/*#define FIRST_FLAG
+*/
 enum exp_fn {
 	RMI_DEV = 0,
+	RMI_F54,
 	RMI_FW_UPDATER,
-	RMI_TEST_REPORTING,
 	RMI_PROXIMITY,
 	RMI_ACTIVE_PEN,
-	RMI_GESTURE,
-	RMI_VIDEO,
-	RMI_DEBUG,
 	RMI_LAST,
 };
 
+struct synaptics_dsx_hw_interface {
+	struct synaptics_dsx_board_data *board_data;
+	const struct synaptics_dsx_bus_access *bus_access;
+};
+
 /*
- * struct synaptics_rmi4_fn_desc - function descriptor fields in PDT entry
+ * struct synaptics_rmi4_fn_desc - function descriptor fields in PDT
  * @query_base_addr: base address for query registers
  * @cmd_base_addr: base address for command registers
  * @ctrl_base_addr: base address for control registers
  * @data_base_addr: base address for data registers
  * @intr_src_count: number of interrupt sources
- * @fn_version: version of function
  * @fn_number: function number
  */
 struct synaptics_rmi4_fn_desc {
-	union {
-		struct {
-			unsigned char query_base_addr;
-			unsigned char cmd_base_addr;
-			unsigned char ctrl_base_addr;
-			unsigned char data_base_addr;
-			unsigned char intr_src_count:3;
-			unsigned char reserved_1:2;
-			unsigned char fn_version:2;
-			unsigned char reserved_2:1;
-			unsigned char fn_number;
-		} __packed;
-		unsigned char data[6];
-	};
+	unsigned char query_base_addr;
+	unsigned char cmd_base_addr;
+	unsigned char ctrl_base_addr;
+	unsigned char data_base_addr;
+	unsigned char intr_src_count;
+	unsigned char fn_number;
 };
 
 /*
  * synaptics_rmi4_fn_full_addr - full 16-bit base addresses
  * @query_base: 16-bit base address for query registers
- * @cmd_base: 16-bit base address for command registers
- * @ctrl_base: 16-bit base address for control registers
- * @data_base: 16-bit base address for data registers
+ * @cmd_base: 16-bit base address for data registers
+ * @ctrl_base: 16-bit base address for command registers
+ * @data_base: 16-bit base address for control registers
  */
 struct synaptics_rmi4_fn_full_addr {
 	unsigned short query_base;
@@ -178,55 +150,31 @@ struct synaptics_rmi4_fn_full_addr {
 	unsigned short data_base;
 };
 
-/*
- * struct synaptics_rmi4_f11_extra_data - extra data of F$11
- * @data38_offset: offset to F11_2D_DATA38 register
- */
-struct synaptics_rmi4_f11_extra_data {
-	unsigned char data38_offset;
-};
-
-/*
- * struct synaptics_rmi4_f12_extra_data - extra data of F$12
- * @data1_offset: offset to F12_2D_DATA01 register
- * @data4_offset: offset to F12_2D_DATA04 register
- * @data15_offset: offset to F12_2D_DATA15 register
- * @data15_size: size of F12_2D_DATA15 register
- * @data15_data: buffer for reading F12_2D_DATA15 register
- * @data23_offset: offset to F12_2D_DATA23 register
- * @data23_size: size of F12_2D_DATA23 register
- * @data23_data: buffer for reading F12_2D_DATA23 register
- * @ctrl20_offset: offset to F12_2D_CTRL20 register
- */
 struct synaptics_rmi4_f12_extra_data {
 	unsigned char data1_offset;
-	unsigned char data4_offset;
 	unsigned char data15_offset;
 	unsigned char data15_size;
 	unsigned char data15_data[(F12_FINGERS_TO_SUPPORT + 7) / 8];
-	unsigned char data23_offset;
-	unsigned char data23_size;
-	unsigned char data23_data[F12_FINGERS_TO_SUPPORT];
-	unsigned char ctrl20_offset;
 };
 
 /*
- * struct synaptics_rmi4_fn - RMI function handler
+ * struct synaptics_rmi4_fn - function handler data structure
  * @fn_number: function number
  * @num_of_data_sources: number of data sources
  * @num_of_data_points: maximum number of fingers supported
+ * @size_of_data_register_block: data register block size
  * @intr_reg_num: index to associated interrupt register
  * @intr_mask: interrupt mask
  * @full_addr: full 16-bit base addresses of function registers
  * @link: linked list for function handlers
  * @data_size: size of private data
  * @data: pointer to private data
- * @extra: pointer to extra data
  */
 struct synaptics_rmi4_fn {
 	unsigned char fn_number;
 	unsigned char num_of_data_sources;
 	unsigned char num_of_data_points;
+	unsigned char size_of_data_register_block;
 	unsigned char intr_reg_num;
 	unsigned char intr_mask;
 	struct synaptics_rmi4_fn_full_addr full_addr;
@@ -238,13 +186,15 @@ struct synaptics_rmi4_fn {
 
 /*
  * struct synaptics_rmi4_device_info - device information
- * @version_major: RMI protocol major version number
- * @version_minor: RMI protocol minor version number
- * @manufacturer_id: manufacturer ID
- * @product_props: product properties
- * @product_info: product information
- * @product_id_string: product ID
- * @build_id: firmware build ID
+ * @version_major: rmi protocol major version number
+ * @version_minor: rmi protocol minor version number
+ * @manufacturer_id: manufacturer id
+ * @product_props: product properties information
+ * @product_info: product info array
+ * @date_code: device manufacture date
+ * @tester_id: tester id array
+ * @serial_number: device serial number
+ * @product_id_string: device product id
  * @support_fn_list: linked list for function handlers
  */
 struct synaptics_rmi4_device_info {
@@ -252,107 +202,71 @@ struct synaptics_rmi4_device_info {
 	unsigned int version_minor;
 	unsigned char manufacturer_id;
 	unsigned char product_props;
-	unsigned char product_info[PRODUCT_INFO_SIZE];
-	unsigned char product_id_string[PRODUCT_ID_SIZE + 1];
-	unsigned char build_id[BUILD_ID_SIZE];
+	unsigned char product_info[SYNAPTICS_RMI4_PRODUCT_INFO_SIZE];
+	unsigned char date_code[SYNAPTICS_RMI4_DATE_CODE_SIZE];
+	unsigned short tester_id;
+	unsigned short serial_number;
+	unsigned char product_id_string[SYNAPTICS_RMI4_PRODUCT_ID_SIZE + 1];
+	unsigned char build_id[SYNAPTICS_RMI4_BUILD_ID_SIZE];
 	struct list_head support_fn_list;
+	unsigned int package_id;
+	unsigned int package_id_rev;
 };
 
 /*
- * struct synaptics_rmi4_data - RMI4 device instance data
+ * struct synaptics_rmi4_data - rmi4 device instance data
  * @pdev: pointer to platform device
  * @input_dev: pointer to associated input device
- * @stylus_dev: pointer to associated stylus device
  * @hw_if: pointer to hardware interface data
  * @rmi4_mod_info: device information
- * @board_prop_dir: /sys/board_properties directory for virtual key map file
- * @pwr_reg: pointer to regulator for power control
- * @bus_reg: pointer to regulator for bus pullup control
- * @rmi4_reset_mutex: mutex for software reset
- * @rmi4_report_mutex: mutex for input event reporting
- * @rmi4_io_ctrl_mutex: mutex for communication interface I/O
- * @rmi4_exp_init_mutex: mutex for expansion function module initialization
- * @rb_work: work for rebuilding input device
- * @rb_workqueue: workqueue for rebuilding input device
- * @fb_notifier: framebuffer notifier client
- * @reset_work: work for issuing reset after display framebuffer ready
- * @reset_workqueue: workqueue for issuing reset after display framebuffer ready
- * @early_suspend: early suspend power management
- * @current_page: current RMI page for register access
- * @button_0d_enabled: switch for enabling 0d button support
- * @num_of_tx: number of Tx channels for 2D touch
- * @num_of_rx: number of Rx channels for 2D touch
- * @num_of_fingers: maximum number of fingers for 2D touch
- * @max_touch_width: maximum touch width
- * @report_enable: input data to report for F$12
- * @no_sleep_setting: default setting of NoSleep in F01_RMI_CTRL00 register
- * @gesture_detection: detected gesture type and properties
- * @intr_mask: interrupt enable mask
- * @button_txrx_mapping: Tx Rx mapping of 0D buttons
+ * @regulator_vdd: pointer to associated vdd regulator
+ * @regulator_add: pointer to associated avdd regulator
+ * @rmi4_io_ctrl_mutex: mutex for i2c i/o control
+ * @early_suspend: instance to support early suspend power management
+ * @current_page: current page in sensor to access
+ * @button_0d_enabled: flag for 0d button support
+ * @full_pm_cycle: flag for full power management cycle in early suspend stage
  * @num_of_intr_regs: number of interrupt registers
- * @f01_query_base_addr: query base address for f$01
- * @f01_cmd_base_addr: command base address for f$01
- * @f01_ctrl_base_addr: control base address for f$01
- * @f01_data_base_addr: data base address for f$01
- * @firmware_id: firmware build ID
+ * @f01_query_base_addr: query base address for f01
+ * @f01_cmd_base_addr: command base address for f01
+ * @f01_ctrl_base_addr: control base address for f01
+ * @f01_data_base_addr: data base address for f01
  * @irq: attention interrupt
- * @sensor_max_x: maximum x coordinate for 2D touch
- * @sensor_max_y: maximum y coordinate for 2D touch
- * @flash_prog_mode: flag to indicate flash programming mode status
- * @irq_enabled: flag to indicate attention interrupt enable status
- * @fingers_on_2d: flag to indicate presence of fingers in 2D area
- * @suspend: flag to indicate whether in suspend state
+ * @sensor_max_x: sensor maximum x value
+ * @sensor_max_y: sensor maximum y value
+ * @irq_enabled: flag for indicating interrupt enable status
+ * @fingers_on_2d: flag to indicate presence of fingers in 2d area
  * @sensor_sleep: flag to indicate sleep state of sensor
- * @stay_awake: flag to indicate whether to stay awake during suspend
- * @fb_ready: flag to indicate whether display framebuffer in ready state
- * @f11_wakeup_gesture: flag to indicate support for wakeup gestures in F$11
- * @f12_wakeup_gesture: flag to indicate support for wakeup gestures in F$12
- * @enable_wakeup_gesture: flag to indicate usage of wakeup gestures
- * @wedge_sensor: flag to indicate use of wedge sensor
- * @report_pressure: flag to indicate reporting of pressure data
- * @stylus_enable: flag to indicate reporting of stylus data
- * @eraser_enable: flag to indicate reporting of eraser data
- * @external_afe_buttons: flag to indicate presence of external AFE buttons
- * @reset_device: pointer to device reset function
- * @irq_enable: pointer to interrupt enable function
- * @sleep_enable: pointer to sleep enable function
- * @report_touch: pointer to touch reporting function
+ * @wait: wait queue for touch data polling in interrupt thread
+ * @irq_enable: pointer to irq enable function
  */
 struct synaptics_rmi4_data {
 	struct platform_device *pdev;
 	struct input_dev *input_dev;
-	struct input_dev *stylus_dev;
 	const struct synaptics_dsx_hw_interface *hw_if;
 	struct synaptics_rmi4_device_info rmi4_mod_info;
-	struct kobject *board_prop_dir;
-	struct regulator *pwr_reg;
-	struct regulator *bus_reg;
+	struct regulator *regulator_vdd;
+	struct regulator *regulator_avdd;
 	struct mutex rmi4_reset_mutex;
-	struct mutex rmi4_report_mutex;
 	struct mutex rmi4_io_ctrl_mutex;
-	struct mutex rmi4_exp_init_mutex;
-	struct delayed_work rb_work;
-	struct workqueue_struct *rb_workqueue;
-#ifdef CONFIG_FB
-	struct work_struct fb_notify_work;
-	struct notifier_block fb_notifier;
-	struct work_struct reset_work;
-	struct workqueue_struct *reset_workqueue;
-#endif
-#ifdef CONFIG_HAS_EARLYSUSPEND
+#if defined(CONFIG_FB)
+	struct notifier_block fb_notif;
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
 	struct early_suspend early_suspend;
 #endif
+	struct dentry *dir;
 	unsigned char current_page;
 	unsigned char button_0d_enabled;
-	unsigned char num_of_tx;
+	unsigned char full_pm_cycle;
 	unsigned char num_of_rx;
+	unsigned char num_of_tx;
 	unsigned char num_of_fingers;
 	unsigned char max_touch_width;
 	unsigned char report_enable;
 	unsigned char no_sleep_setting;
-	unsigned char gesture_detection[F12_GESTURE_DETECTION_LEN];
 	unsigned char intr_mask[MAX_INTR_REGISTERS];
 	unsigned char *button_txrx_mapping;
+	unsigned char *ts_info;
 	unsigned short num_of_intr_regs;
 	unsigned short f01_query_base_addr;
 	unsigned short f01_cmd_base_addr;
@@ -364,40 +278,38 @@ struct synaptics_rmi4_data {
 	int sensor_max_y;
 	bool flash_prog_mode;
 	bool irq_enabled;
+	bool touch_stopped;
 	bool fingers_on_2d;
-	bool suspend;
 	bool sensor_sleep;
 	bool stay_awake;
-	bool fb_ready;
-	bool f11_wakeup_gesture;
-	bool f12_wakeup_gesture;
-	bool enable_wakeup_gesture;
-	bool wedge_sensor;
-	bool report_pressure;
-	bool stylus_enable;
-	bool eraser_enable;
-	bool external_afe_buttons;
-	int (*reset_device)(struct synaptics_rmi4_data *rmi4_data,
-			bool rebuild);
-	int (*irq_enable)(struct synaptics_rmi4_data *rmi4_data, bool enable,
-			bool attn_only);
-	void (*sleep_enable)(struct synaptics_rmi4_data *rmi4_data,
-			bool enable);
-	void (*report_touch)(struct synaptics_rmi4_data *rmi4_data,
-			struct synaptics_rmi4_fn *fhandler);
+	bool staying_awake;
+	bool fw_updating;
+	bool support_vkeys;
+	bool update_coords;
+	int (*irq_enable)(struct synaptics_rmi4_data *rmi4_data, bool enable);
+	int (*reset_device)(struct synaptics_rmi4_data *rmi4_data);
+
 	struct pinctrl *ts_pinctrl;
 	struct pinctrl_state *pinctrl_state_active;
 	struct pinctrl_state *pinctrl_state_suspend;
 	struct pinctrl_state *pinctrl_state_release;
+	char fw_name[SYNA_FW_NAME_MAX_LEN];
+	bool suspended;
+	bool enable;
+	unsigned short addr;
 #if defined(CONFIG_SECURE_TOUCH_SYNAPTICS_DSX_V26)
 	atomic_t st_enabled;
 	atomic_t st_pending_irqs;
+	bool st_initialized;
 	struct completion st_powerdown;
 	struct completion st_irq_processed;
-	bool st_initialized;
 	struct clk *core_clk;
 	struct clk *iface_clk;
 #endif
+
+#ifdef FIRST_FLAG
+	int flag;
+#endif
 };
 
 struct synaptics_dsx_bus_access {
@@ -412,13 +324,6 @@ struct synaptics_dsx_bus_access {
 #endif
 };
 
-struct synaptics_dsx_hw_interface {
-	struct synaptics_dsx_board_data *board_data;
-	const struct synaptics_dsx_bus_access *bus_access;
-	int (*bl_hw_init)(struct synaptics_rmi4_data *rmi4_data);
-	int (*ui_hw_init)(struct synaptics_rmi4_data *rmi4_data);
-};
-
 struct synaptics_rmi4_exp_fn {
 	enum exp_fn fn_type;
 	int (*init)(struct synaptics_rmi4_data *rmi4_data);
@@ -433,14 +338,18 @@ struct synaptics_rmi4_exp_fn {
 			unsigned char intr_mask);
 };
 
-int synaptics_rmi4_bus_init_v26(void);
+int synaptics_rmi4_bus_init(void);
 
-void synaptics_rmi4_bus_exit_v26(void);
+void synaptics_rmi4_bus_exit(void);
 
-void synaptics_rmi4_new_function(struct synaptics_rmi4_exp_fn *exp_fn_module,
+void synaptics_rmi4_dsx_new_function(struct synaptics_rmi4_exp_fn *exp_fn_mod,
 		bool insert);
 
-int synaptics_fw_updater(const unsigned char *fw_data);
+int synaptics_dsx_fw_updater(unsigned char *fw_data);
+
+int synaptics_dsx_get_dt_coords(struct device *dev, char *name,
+				struct synaptics_dsx_board_data *pdata,
+				struct device_node *node);
 
 static inline int synaptics_rmi4_reg_read(
 		struct synaptics_rmi4_data *rmi4_data,
@@ -471,19 +380,12 @@ static inline void synaptics_rmi4_bus_put(struct synaptics_rmi4_data *rmi4_data)
 }
 #endif
 
-static inline int secure_memcpy(unsigned char *dest, unsigned int dest_size,
-		const unsigned char *src, unsigned int src_size,
-		unsigned int count)
+static inline ssize_t synaptics_rmi4_store_error(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
 {
-	if (dest == NULL || src == NULL)
-		return -EINVAL;
-
-	if (count > dest_size || count > src_size)
-		return -EINVAL;
-
-	memcpy((void *)dest, (const void *)src, count);
-
-	return 0;
+	dev_warn(dev, "%s Attempted to write to read-only attribute %s\n",
+			__func__, attr->attr.name);
+	return -EPERM;
 }
 
 static inline void batohs(unsigned short *dest, unsigned char *src)
@@ -496,5 +398,4 @@ static inline void hstoba(unsigned char *dest, unsigned short src)
 	dest[0] = src % 0x100;
 	dest[1] = src / 0x100;
 }
-
 #endif
diff --git a/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_fw_update.c b/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_fw_update.c
index 52bd5cf..226bc25 100644
--- a/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_fw_update.c
+++ b/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_fw_update.c
@@ -1,10 +1,10 @@
 /*
  * Synaptics DSX touchscreen driver
  *
- * Copyright (C) 2012-2015 Synaptics Incorporated. All rights reserved.
+ * Copyright (C) 2012-2016 Synaptics Incorporated
  *
- * Copyright (C) 2012 Alexandra Chin <alexandra.chin@tw.synaptics.com>
- * Copyright (C) 2012 Scott Lin <scott.lin@tw.synaptics.com>
+ * Copyright (C) 2012-2016 Alexandra Chin <alexandra.chin@tw.synaptics.com>
+ * Copyright (C) 2014-2016 Scott Lin <scott.lin@tw.synaptics.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -15,22 +15,7 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  * GNU General Public License for more details.
- *
- * INFORMATION CONTAINED IN THIS DOCUMENT IS PROVIDED "AS-IS," AND SYNAPTICS
- * EXPRESSLY DISCLAIMS ALL EXPRESS AND IMPLIED WARRANTIES, INCLUDING ANY
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE,
- * AND ANY WARRANTIES OF NON-INFRINGEMENT OF ANY INTELLECTUAL PROPERTY RIGHTS.
- * IN NO EVENT SHALL SYNAPTICS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES ARISING OUT OF OR IN CONNECTION
- * WITH THE USE OF THE INFORMATION CONTAINED IN THIS DOCUMENT, HOWEVER CAUSED
- * AND BASED ON ANY THEORY OF LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * NEGLIGENCE OR OTHER TORTIOUS ACTION, AND EVEN IF SYNAPTICS WAS ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE. IF A TRIBUNAL OF COMPETENT JURISDICTION DOES
- * NOT PERMIT THE DISCLAIMER OF DIRECT DAMAGES OR ANY OTHER DAMAGES, SYNAPTICS'
- * TOTAL CUMULATIVE LIABILITY TO ANY PARTY SHALL NOT EXCEED ONE HUNDRED U.S.
- * DOLLARS.
  */
-
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
@@ -39,74 +24,58 @@
 #include <linux/input.h>
 #include <linux/firmware.h>
 #include <linux/platform_device.h>
-#include <linux/input/synaptics_dsx_v2_6.h>
+#include <linux/input/synaptics_dsx_v2.h>
 #include "synaptics_dsx_core.h"
 
-#define FW_IMAGE_NAME "synaptics/startup_fw_update.img"
-/*
-#define DO_STARTUP_FW_UPDATE
-*/
-/*
-#ifdef DO_STARTUP_FW_UPDATE
-#ifdef CONFIG_FB
-#define WAIT_FOR_FB_READY
-#define FB_READY_WAIT_MS 100
-#define FB_READY_TIMEOUT_S 30
-#endif
-#endif
-*/
+#define STARTUP_FW_UPDATE_DELAY_MS 1000 /* ms */
 #define FORCE_UPDATE false
 #define DO_LOCKDOWN false
 
 #define MAX_IMAGE_NAME_LEN 256
 #define MAX_FIRMWARE_ID_LEN 10
 
-#define IMAGE_HEADER_VERSION_05 0x05
-#define IMAGE_HEADER_VERSION_06 0x06
-#define IMAGE_HEADER_VERSION_10 0x10
+#define LOCKDOWN_OFFSET 0xb0
+#define FW_IMAGE_OFFSET 0x100
 
-#define IMAGE_AREA_OFFSET 0x100
-#define LOCKDOWN_SIZE 0x50
-
-#define V5V6_BOOTLOADER_ID_OFFSET 0
-#define V5V6_CONFIG_ID_SIZE 4
+#define BOOTLOADER_ID_OFFSET 0
+#define BLOCK_NUMBER_OFFSET 0
 
 #define V5_PROPERTIES_OFFSET 2
 #define V5_BLOCK_SIZE_OFFSET 3
 #define V5_BLOCK_COUNT_OFFSET 5
-#define V5_BLOCK_NUMBER_OFFSET 0
 #define V5_BLOCK_DATA_OFFSET 2
 
 #define V6_PROPERTIES_OFFSET 1
 #define V6_BLOCK_SIZE_OFFSET 2
 #define V6_BLOCK_COUNT_OFFSET 3
-#define V6_PROPERTIES_2_OFFSET 4
-#define V6_GUEST_CODE_BLOCK_COUNT_OFFSET 5
-#define V6_BLOCK_NUMBER_OFFSET 0
 #define V6_BLOCK_DATA_OFFSET 1
 #define V6_FLASH_COMMAND_OFFSET 2
 #define V6_FLASH_STATUS_OFFSET 3
 
-#define V7_CONFIG_ID_SIZE 32
-
-#define V7_FLASH_STATUS_OFFSET 0
-#define V7_PARTITION_ID_OFFSET 1
-#define V7_BLOCK_NUMBER_OFFSET 2
-#define V7_TRANSFER_LENGTH_OFFSET 3
-#define V7_COMMAND_OFFSET 4
-#define V7_PAYLOAD_OFFSET 5
-
-#define V7_PARTITION_SUPPORT_BYTES 4
-
-#define F35_ERROR_CODE_OFFSET 0
-#define F35_CHUNK_NUM_LSB_OFFSET 0
-#define F35_CHUNK_NUM_MSB_OFFSET 1
-#define F35_CHUNK_DATA_OFFSET 2
-#define F35_CHUNK_COMMAND_OFFSET 18
-
-#define F35_CHUNK_SIZE 16
-#define F35_ERASE_ALL_WAIT_MS 3000
-#define F35_RESET_WAIT_MS 250
+#define LOCKDOWN_BLOCK_COUNT 5
+
+#define REG_MAP (1 << 0)
+#define UNLOCKED (1 << 1)
+#define HAS_CONFIG_ID (1 << 2)
+#define HAS_PERM_CONFIG (1 << 3)
+#define HAS_BL_CONFIG (1 << 4)
+#define HAS_DISP_CONFIG (1 << 5)
+#define HAS_CTRL1 (1 << 6)
+
+#define UI_CONFIG_AREA 0x00
+#define PERM_CONFIG_AREA 0x01
+#define BL_CONFIG_AREA 0x02
+#define DISP_CONFIG_AREA 0x03
+
+#define CMD_WRITE_FW_BLOCK 0x2
+#define CMD_ERASE_ALL 0x3
+#define CMD_WRITE_LOCKDOWN_BLOCK 0x4
+#define CMD_READ_CONFIG_BLOCK 0x5
+#define CMD_WRITE_CONFIG_BLOCK 0x6
+#define CMD_ERASE_CONFIG 0x7
+#define CMD_ERASE_BL_CONFIG 0x9
+#define CMD_ERASE_DISP_CONFIG 0xa
+#define CMD_ENABLE_FLASH_PROG 0xf
 
 #define SLEEP_MODE_NORMAL (0x00)
 #define SLEEP_MODE_SENSOR_SLEEP (0x01)
@@ -120,12 +89,18 @@
 #define MIN_SLEEP_TIME_US 50
 #define MAX_SLEEP_TIME_US 100
 
-#define INT_DISABLE_WAIT_MS 20
-#define ENTER_FLASH_PROG_WAIT_MS 20
-
-static int fwu_do_reflash(void);
+#define SYN_FW_CFG_GREATER(fwu, config_id) \
+		((fwu->config_data[0] == 0) && (config_id[0] == 0) && \
+		 (fwu->config_data[1] == config_id[1]) && \
+		  (((fwu->config_data[2] == config_id[2]) && \
+		    (fwu->config_data[3] > config_id[3])) || \
+			(fwu->config_data[2] > config_id[2])))
 
-static int fwu_recovery_check_status(void);
+#define SYN_FW_CFG_EQUAL(fwu, config_id) \
+		((fwu->config_data[0] == 0) && (config_id[0] == 0) && \
+		 (fwu->config_data[1] == config_id[1]) && \
+		 (fwu->config_data[2] == config_id[2]) && \
+		 (fwu->config_data[3] == config_id[3]))
 
 static ssize_t fwu_sysfs_show_image(struct file *data_file,
 		struct kobject *kobj, struct bin_attribute *attributes,
@@ -135,7 +110,7 @@ static ssize_t fwu_sysfs_store_image(struct file *data_file,
 		struct kobject *kobj, struct bin_attribute *attributes,
 		char *buf, loff_t pos, size_t count);
 
-static ssize_t fwu_sysfs_do_recovery_store(struct device *dev,
+static ssize_t fwu_sysfs_force_reflash_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t count);
 
 static ssize_t fwu_sysfs_do_reflash_store(struct device *dev,
@@ -150,6 +125,9 @@ static ssize_t fwu_sysfs_read_config_store(struct device *dev,
 static ssize_t fwu_sysfs_config_area_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t count);
 
+static ssize_t fwu_sysfs_image_name_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
 static ssize_t fwu_sysfs_image_name_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t count);
 
@@ -165,38 +143,30 @@ static ssize_t fwu_sysfs_firmware_block_count_show(struct device *dev,
 static ssize_t fwu_sysfs_configuration_block_count_show(struct device *dev,
 		struct device_attribute *attr, char *buf);
 
-static ssize_t fwu_sysfs_disp_config_block_count_show(struct device *dev,
-		struct device_attribute *attr, char *buf);
-
 static ssize_t fwu_sysfs_perm_config_block_count_show(struct device *dev,
 		struct device_attribute *attr, char *buf);
 
 static ssize_t fwu_sysfs_bl_config_block_count_show(struct device *dev,
 		struct device_attribute *attr, char *buf);
 
-static ssize_t fwu_sysfs_guest_code_block_count_show(struct device *dev,
+static ssize_t fwu_sysfs_disp_config_block_count_show(struct device *dev,
 		struct device_attribute *attr, char *buf);
 
-static ssize_t fwu_sysfs_write_guest_code_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t fwu_sysfs_config_id_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
 
-enum f34_version {
-	F34_V0 = 0,
-	F34_V1,
-	F34_V2,
-};
+static ssize_t fwu_sysfs_package_id_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
 
 enum bl_version {
-	BL_V5 = 5,
-	BL_V6 = 6,
-	BL_V7 = 7,
-	BL_V8 = 8,
+	V5 = 5,
+	V6 = 6,
 };
 
 enum flash_area {
-	NONE = 0,
+	NONE,
 	UI_FIRMWARE,
-	UI_CONFIG,
+	CONFIG_AREA,
 };
 
 enum update_mode {
@@ -205,113 +175,42 @@ enum update_mode {
 	LOCKDOWN = 8,
 };
 
-enum config_area {
-	UI_CONFIG_AREA = 0,
-	PM_CONFIG_AREA,
-	BL_CONFIG_AREA,
-	DP_CONFIG_AREA,
-	FLASH_CONFIG_AREA,
-};
-
-enum v7_status {
-	SUCCESS = 0x00,
-	DEVICE_NOT_IN_BOOTLOADER_MODE,
-	INVALID_PARTITION,
-	INVALID_COMMAND,
-	INVALID_BLOCK_OFFSET,
-	INVALID_TRANSFER,
-	NOT_ERASED,
-	FLASH_PROGRAMMING_KEY_INCORRECT,
-	BAD_PARTITION_TABLE,
-	CHECKSUM_FAILED,
-	FLASH_HARDWARE_FAILURE = 0x1f,
-};
-
-enum v7_partition_id {
-	BOOTLOADER_PARTITION = 0x01,
-	DEVICE_CONFIG_PARTITION,
-	FLASH_CONFIG_PARTITION,
-	MANUFACTURING_BLOCK_PARTITION,
-	GUEST_SERIALIZATION_PARTITION,
-	GLOBAL_PARAMETERS_PARTITION,
-	CORE_CODE_PARTITION,
-	CORE_CONFIG_PARTITION,
-	GUEST_CODE_PARTITION,
-	DISPLAY_CONFIG_PARTITION,
-};
-
-enum v7_flash_command {
-	CMD_V7_IDLE = 0x00,
-	CMD_V7_ENTER_BL,
-	CMD_V7_READ,
-	CMD_V7_WRITE,
-	CMD_V7_ERASE,
-	CMD_V7_ERASE_AP,
-	CMD_V7_SENSOR_ID,
-};
-
-enum v5v6_flash_command {
-	CMD_V5V6_IDLE = 0x0,
-	CMD_V5V6_WRITE_FW = 0x2,
-	CMD_V5V6_ERASE_ALL = 0x3,
-	CMD_V5V6_WRITE_LOCKDOWN = 0x4,
-	CMD_V5V6_READ_CONFIG = 0x5,
-	CMD_V5V6_WRITE_CONFIG = 0x6,
-	CMD_V5V6_ERASE_UI_CONFIG = 0x7,
-	CMD_V5V6_ERASE_BL_CONFIG = 0x9,
-	CMD_V5V6_ERASE_DISP_CONFIG = 0xa,
-	CMD_V5V6_ERASE_GUEST_CODE = 0xb,
-	CMD_V5V6_WRITE_GUEST_CODE = 0xc,
-	CMD_V5V6_ENABLE_FLASH_PROG = 0xf,
-};
-
-enum flash_command {
-	CMD_IDLE = 0,
-	CMD_WRITE_FW,
-	CMD_WRITE_CONFIG,
-	CMD_WRITE_LOCKDOWN,
-	CMD_WRITE_GUEST_CODE,
-	CMD_READ_CONFIG,
-	CMD_ERASE_ALL,
-	CMD_ERASE_UI_FIRMWARE,
-	CMD_ERASE_UI_CONFIG,
-	CMD_ERASE_BL_CONFIG,
-	CMD_ERASE_DISP_CONFIG,
-	CMD_ERASE_FLASH_CONFIG,
-	CMD_ERASE_GUEST_CODE,
-	CMD_ENABLE_FLASH_PROG,
-};
-
-enum f35_flash_command {
-	CMD_F35_IDLE = 0x0,
-	CMD_F35_RESERVED = 0x1,
-	CMD_F35_WRITE_CHUNK = 0x2,
-	CMD_F35_ERASE_ALL = 0x3,
-	CMD_F35_RESET = 0x10,
+struct image_header {
+	/* 0x00 - 0x0f */
+	unsigned char checksum[4];
+	unsigned char reserved_04;
+	unsigned char reserved_05;
+	unsigned char options_firmware_id:1;
+	unsigned char options_contain_bootloader:1;
+	unsigned char options_reserved:6;
+	unsigned char bootloader_version;
+	unsigned char firmware_size[4];
+	unsigned char config_size[4];
+	/* 0x10 - 0x1f */
+	unsigned char product_id[SYNAPTICS_RMI4_PRODUCT_ID_SIZE];
+	unsigned char package_id[2];
+	unsigned char package_id_revision[2];
+	unsigned char product_info[SYNAPTICS_RMI4_PRODUCT_INFO_SIZE];
+	/* 0x20 - 0x2f */
+	unsigned char reserved_20_2f[16];
+	/* 0x30 - 0x3f */
+	unsigned char ds_id[16];
+	/* 0x40 - 0x4f */
+	unsigned char ds_info[10];
+	unsigned char reserved_4a_4f[6];
+	/* 0x50 - 0x53 */
+	unsigned char firmware_id[4];
 };
 
-enum container_id {
-	TOP_LEVEL_CONTAINER = 0,
-	UI_CONTAINER,
-	UI_CONFIG_CONTAINER,
-	BL_CONTAINER,
-	BL_IMAGE_CONTAINER,
-	BL_CONFIG_CONTAINER,
-	BL_LOCKDOWN_INFO_CONTAINER,
-	PERMANENT_CONFIG_CONTAINER,
-	GUEST_CODE_CONTAINER,
-	BL_PROTOCOL_DESCRIPTOR_CONTAINER,
-	UI_PROTOCOL_DESCRIPTOR_CONTAINER,
-	RMI_SELF_DISCOVERY_CONTAINER,
-	RMI_PAGE_CONTENT_CONTAINER,
-	GENERAL_INFORMATION_CONTAINER,
-	DEVICE_CONFIG_CONTAINER,
-	FLASH_CONFIG_CONTAINER,
-	GUEST_SERIALIZATION_CONTAINER,
-	GLOBAL_PARAMETERS_CONTAINER,
-	CORE_CODE_CONTAINER,
-	CORE_CONFIG_CONTAINER,
-	DISPLAY_CONFIG_CONTAINER,
+struct image_header_data {
+	bool contains_firmware_id;
+	unsigned int firmware_id;
+	unsigned int checksum;
+	unsigned int firmware_size;
+	unsigned int config_size;
+	unsigned char bootloader_version;
+	unsigned char product_id[SYNAPTICS_RMI4_PRODUCT_ID_SIZE + 1];
+	unsigned char product_info[SYNAPTICS_RMI4_PRODUCT_INFO_SIZE];
 };
 
 struct pdt_properties {
@@ -325,346 +224,94 @@ struct pdt_properties {
 	};
 };
 
-struct partition_table {
-	unsigned char partition_id:5;
-	unsigned char byte_0_reserved:3;
-	unsigned char byte_1_reserved;
-	unsigned char partition_length_7_0;
-	unsigned char partition_length_15_8;
-	unsigned char start_physical_address_7_0;
-	unsigned char start_physical_address_15_8;
-	unsigned char partition_properties_7_0;
-	unsigned char partition_properties_15_8;
-} __packed;
-
-struct f01_device_control {
+struct f01_device_status {
 	union {
 		struct {
-			unsigned char sleep_mode:2;
-			unsigned char nosleep:1;
+			unsigned char status_code:4;
 			unsigned char reserved:2;
-			unsigned char charger_connected:1;
-			unsigned char report_rate:1;
-			unsigned char configured:1;
-		} __packed;
-		unsigned char data[1];
-	};
-};
-
-struct f34_v7_query_0 {
-	union {
-		struct {
-			unsigned char subpacket_1_size:3;
-			unsigned char has_config_id:1;
-			unsigned char f34_query0_b4:1;
-			unsigned char has_thqa:1;
-			unsigned char f34_query0_b6__7:2;
-		} __packed;
-		unsigned char data[1];
-	};
-};
-
-struct f34_v7_query_1_7 {
-	union {
-		struct {
-			/* query 1 */
-			unsigned char bl_minor_revision;
-			unsigned char bl_major_revision;
-
-			/* query 2 */
-			unsigned char bl_fw_id_7_0;
-			unsigned char bl_fw_id_15_8;
-			unsigned char bl_fw_id_23_16;
-			unsigned char bl_fw_id_31_24;
-
-			/* query 3 */
-			unsigned char minimum_write_size;
-			unsigned char block_size_7_0;
-			unsigned char block_size_15_8;
-			unsigned char flash_page_size_7_0;
-			unsigned char flash_page_size_15_8;
-
-			/* query 4 */
-			unsigned char adjustable_partition_area_size_7_0;
-			unsigned char adjustable_partition_area_size_15_8;
-
-			/* query 5 */
-			unsigned char flash_config_length_7_0;
-			unsigned char flash_config_length_15_8;
-
-			/* query 6 */
-			unsigned char payload_length_7_0;
-			unsigned char payload_length_15_8;
-
-			/* query 7 */
-			unsigned char f34_query7_b0:1;
-			unsigned char has_bootloader:1;
-			unsigned char has_device_config:1;
-			unsigned char has_flash_config:1;
-			unsigned char has_manufacturing_block:1;
-			unsigned char has_guest_serialization:1;
-			unsigned char has_global_parameters:1;
-			unsigned char has_core_code:1;
-			unsigned char has_core_config:1;
-			unsigned char has_guest_code:1;
-			unsigned char has_display_config:1;
-			unsigned char f34_query7_b11__15:5;
-			unsigned char f34_query7_b16__23;
-			unsigned char f34_query7_b24__31;
-		} __packed;
-		unsigned char data[21];
-	};
-};
-
-struct f34_v7_data0 {
-	union {
-		struct {
-			unsigned char operation_status:5;
-			unsigned char device_cfg_status:2;
-			unsigned char bl_mode:1;
-		} __packed;
-		unsigned char data[1];
-	};
-};
-
-struct f34_v7_data_1_5 {
-	union {
-		struct {
-			unsigned char partition_id:5;
-			unsigned char f34_data1_b5__7:3;
-			unsigned char block_offset_7_0;
-			unsigned char block_offset_15_8;
-			unsigned char transfer_length_7_0;
-			unsigned char transfer_length_15_8;
-			unsigned char command;
-			unsigned char payload_0;
-			unsigned char payload_1;
-		} __packed;
-		unsigned char data[8];
-	};
-};
-
-struct f34_v5v6_flash_properties {
-	union {
-		struct {
-			unsigned char reg_map:1;
-			unsigned char unlocked:1;
-			unsigned char has_config_id:1;
-			unsigned char has_pm_config:1;
-			unsigned char has_bl_config:1;
-			unsigned char has_disp_config:1;
-			unsigned char has_ctrl1:1;
-			unsigned char has_query4:1;
+			unsigned char flash_prog:1;
+			unsigned char unconfigured:1;
 		} __packed;
 		unsigned char data[1];
 	};
 };
 
-struct f34_v5v6_flash_properties_2 {
+struct f01_device_control {
 	union {
 		struct {
-			unsigned char has_guest_code:1;
-			unsigned char reserved:7;
+			unsigned char sleep_mode:2;
+			unsigned char nosleep:1;
+			unsigned char reserved:2;
+			unsigned char charger_connected:1;
+			unsigned char report_rate:1;
+			unsigned char configured:1;
 		} __packed;
 		unsigned char data[1];
 	};
 };
 
-struct register_offset {
-	unsigned char properties;
-	unsigned char properties_2;
-	unsigned char block_size;
-	unsigned char block_count;
-	unsigned char gc_block_count;
-	unsigned char flash_status;
-	unsigned char partition_id;
-	unsigned char block_number;
-	unsigned char transfer_length;
-	unsigned char flash_cmd;
-	unsigned char payload;
-};
-
-struct block_count {
-	unsigned short ui_firmware;
-	unsigned short ui_config;
-	unsigned short dp_config;
-	unsigned short pm_config;
-	unsigned short fl_config;
-	unsigned short bl_image;
-	unsigned short bl_config;
-	unsigned short lockdown;
-	unsigned short guest_code;
-	unsigned short total_count;
-};
-
-struct physical_address {
-	unsigned short ui_firmware;
-	unsigned short ui_config;
-	unsigned short dp_config;
-	unsigned short fl_config;
-	unsigned short guest_code;
-};
-
-struct container_descriptor {
-	unsigned char content_checksum[4];
-	unsigned char container_id[2];
-	unsigned char minor_version;
-	unsigned char major_version;
-	unsigned char reserved_08;
-	unsigned char reserved_09;
-	unsigned char reserved_0a;
-	unsigned char reserved_0b;
-	unsigned char container_option_flags[4];
-	unsigned char content_options_length[4];
-	unsigned char content_options_address[4];
-	unsigned char content_length[4];
-	unsigned char content_address[4];
-};
-
-struct image_header_10 {
-	unsigned char checksum[4];
-	unsigned char reserved_04;
-	unsigned char reserved_05;
-	unsigned char minor_header_version;
-	unsigned char major_header_version;
-	unsigned char reserved_08;
-	unsigned char reserved_09;
-	unsigned char reserved_0a;
-	unsigned char reserved_0b;
-	unsigned char top_level_container_start_addr[4];
-};
-
-struct image_header_05_06 {
-	/* 0x00 - 0x0f */
-	unsigned char checksum[4];
-	unsigned char reserved_04;
-	unsigned char reserved_05;
-	unsigned char options_firmware_id:1;
-	unsigned char options_bootloader:1;
-	unsigned char options_guest_code:1;
-	unsigned char options_tddi:1;
-	unsigned char options_reserved:4;
-	unsigned char header_version;
-	unsigned char firmware_size[4];
-	unsigned char config_size[4];
-	/* 0x10 - 0x1f */
-	unsigned char product_id[PRODUCT_ID_SIZE];
-	unsigned char package_id[2];
-	unsigned char package_id_revision[2];
-	unsigned char product_info[PRODUCT_INFO_SIZE];
-	/* 0x20 - 0x2f */
-	unsigned char bootloader_addr[4];
-	unsigned char bootloader_size[4];
-	unsigned char ui_addr[4];
-	unsigned char ui_size[4];
-	/* 0x30 - 0x3f */
-	unsigned char ds_id[16];
-	/* 0x40 - 0x4f */
-	union {
-		struct {
-			unsigned char cstmr_product_id[PRODUCT_ID_SIZE];
-			unsigned char reserved_4a_4f[6];
-		};
-		struct {
-			unsigned char dsp_cfg_addr[4];
-			unsigned char dsp_cfg_size[4];
-			unsigned char reserved_48_4f[8];
-		};
-	};
-	/* 0x50 - 0x53 */
-	unsigned char firmware_id[4];
-};
-
-struct block_data {
-	unsigned int size;
-	const unsigned char *data;
-};
-
-struct image_metadata {
-	bool contains_firmware_id;
-	bool contains_bootloader;
-	bool contains_guest_code;
-	bool contains_disp_config;
-	bool contains_perm_config;
-	bool contains_flash_config;
-	unsigned int firmware_id;
-	unsigned int checksum;
-	unsigned int bootloader_size;
-	unsigned int disp_config_offset;
-	unsigned char bl_version;
-	unsigned char product_id[PRODUCT_ID_SIZE + 1];
-	unsigned char cstmr_product_id[PRODUCT_ID_SIZE + 1];
-	struct block_data bootloader;
-	struct block_data ui_firmware;
-	struct block_data ui_config;
-	struct block_data dp_config;
-	struct block_data pm_config;
-	struct block_data fl_config;
-	struct block_data bl_image;
-	struct block_data bl_config;
-	struct block_data lockdown;
-	struct block_data guest_code;
-	struct block_count blkcount;
-	struct physical_address phyaddr;
-};
-
 struct synaptics_rmi4_fwu_handle {
 	enum bl_version bl_version;
 	bool initialized;
-	bool in_bl_mode;
-	bool in_ub_mode;
+	bool program_enabled;
+	bool has_perm_config;
+	bool has_bl_config;
+	bool has_disp_config;
 	bool force_update;
+	bool in_flash_prog_mode;
 	bool do_lockdown;
-	bool has_guest_code;
-	bool new_partition_table;
 	unsigned int data_pos;
+	unsigned int image_size;
+	unsigned char *image_name;
 	unsigned char *ext_data_source;
 	unsigned char *read_config_buf;
 	unsigned char intr_mask;
 	unsigned char command;
 	unsigned char bootloader_id[2];
-	unsigned char config_id[32];
+	unsigned char flash_properties;
 	unsigned char flash_status;
-	unsigned char partitions;
+	unsigned char productinfo1;
+	unsigned char productinfo2;
+	unsigned char properties_off;
+	unsigned char blk_size_off;
+	unsigned char blk_count_off;
+	unsigned char blk_data_off;
+	unsigned char flash_cmd_off;
+	unsigned char flash_status_off;
 	unsigned short block_size;
+	unsigned short fw_block_count;
+	unsigned short config_block_count;
+	unsigned short lockdown_block_count;
+	unsigned short perm_config_block_count;
+	unsigned short bl_config_block_count;
+	unsigned short disp_config_block_count;
 	unsigned short config_size;
 	unsigned short config_area;
-	unsigned short config_block_count;
-	unsigned short flash_config_length;
-	unsigned short payload_length;
-	unsigned short partition_table_bytes;
-	unsigned short read_config_buf_size;
+	char product_id[SYNAPTICS_RMI4_PRODUCT_ID_SIZE + 1];
+	const unsigned char *firmware_data;
 	const unsigned char *config_data;
-	const unsigned char *image;
-	unsigned char *image_name;
-	unsigned int image_size;
-	struct image_metadata img;
-	struct register_offset off;
-	struct block_count blkcount;
-	struct physical_address phyaddr;
-	struct f34_v5v6_flash_properties flash_properties;
+	const unsigned char *lockdown_data;
+	struct delayed_work fwu_work;
 	struct synaptics_rmi4_fn_desc f34_fd;
-	struct synaptics_rmi4_fn_desc f35_fd;
 	struct synaptics_rmi4_data *rmi4_data;
-	struct workqueue_struct *fwu_workqueue;
-	struct work_struct fwu_work;
 };
 
 static struct bin_attribute dev_attr_data = {
 	.attr = {
 		.name = "data",
-		.mode = (S_IRUGO | S_IWUGO),
+		.mode = (S_IRUGO | S_IWUSR),
 	},
 	.size = 0,
 	.read = fwu_sysfs_show_image,
 	.write = fwu_sysfs_store_image,
 };
 
+
 static struct device_attribute attrs[] = {
-	__ATTR(dorecovery, S_IWUSR | S_IWGRP,
+	__ATTR(force_update_fw, S_IWUSR | S_IWGRP,
 			NULL,
-			fwu_sysfs_do_recovery_store),
-	__ATTR(doreflash, S_IWUSR | S_IWGRP,
+			fwu_sysfs_force_reflash_store),
+	__ATTR(update_fw, S_IWUSR | S_IWGRP,
 			NULL,
 			fwu_sysfs_do_reflash_store),
 	__ATTR(writeconfig, S_IWUSR | S_IWGRP,
@@ -676,43 +323,43 @@ static struct device_attribute attrs[] = {
 	__ATTR(configarea, S_IWUSR | S_IWGRP,
 			NULL,
 			fwu_sysfs_config_area_store),
-	__ATTR(imagename, S_IWUSR | S_IWGRP,
-			NULL,
+	__ATTR(fw_name, S_IRUGO | S_IWUSR | S_IWGRP,
+			fwu_sysfs_image_name_show,
 			fwu_sysfs_image_name_store),
 	__ATTR(imagesize, S_IWUSR | S_IWGRP,
 			NULL,
 			fwu_sysfs_image_size_store),
 	__ATTR(blocksize, S_IRUGO,
 			fwu_sysfs_block_size_show,
-			NULL),
+			synaptics_rmi4_store_error),
 	__ATTR(fwblockcount, S_IRUGO,
 			fwu_sysfs_firmware_block_count_show,
-			NULL),
+			synaptics_rmi4_store_error),
 	__ATTR(configblockcount, S_IRUGO,
 			fwu_sysfs_configuration_block_count_show,
-			NULL),
-	__ATTR(dispconfigblockcount, S_IRUGO,
-			fwu_sysfs_disp_config_block_count_show,
-			NULL),
+			synaptics_rmi4_store_error),
 	__ATTR(permconfigblockcount, S_IRUGO,
 			fwu_sysfs_perm_config_block_count_show,
-			NULL),
+			synaptics_rmi4_store_error),
 	__ATTR(blconfigblockcount, S_IRUGO,
 			fwu_sysfs_bl_config_block_count_show,
-			NULL),
-	__ATTR(guestcodeblockcount, S_IRUGO,
-			fwu_sysfs_guest_code_block_count_show,
-			NULL),
-	__ATTR(writeguestcode, S_IWUSR | S_IWGRP,
-			NULL,
-			fwu_sysfs_write_guest_code_store),
+			synaptics_rmi4_store_error),
+	__ATTR(dispconfigblockcount, S_IRUGO,
+			fwu_sysfs_disp_config_block_count_show,
+			synaptics_rmi4_store_error),
+	__ATTR(config_id, S_IRUGO,
+			fwu_sysfs_config_id_show,
+			synaptics_rmi4_store_error),
+	__ATTR(package_id, S_IRUGO,
+			fwu_sysfs_package_id_show,
+			synaptics_rmi4_store_error),
 };
 
 static struct synaptics_rmi4_fwu_handle *fwu;
 
-DECLARE_COMPLETION(fwu_remove_complete);
+DECLARE_COMPLETION(fwu_dsx_remove_complete);
 
-static unsigned int le_to_uint(const unsigned char *ptr)
+static unsigned int extract_uint_le(const unsigned char *ptr)
 {
 	return (unsigned int)ptr[0] +
 			(unsigned int)ptr[1] * 0x100 +
@@ -720,409 +367,172 @@ static unsigned int le_to_uint(const unsigned char *ptr)
 			(unsigned int)ptr[3] * 0x1000000;
 }
 
-static int fwu_allocate_read_config_buf(unsigned int count)
+static void parse_header(struct image_header_data *header,
+		const unsigned char *fw_image)
 {
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	if (count > fwu->read_config_buf_size) {
-		kfree(fwu->read_config_buf);
-		fwu->read_config_buf = kzalloc(count, GFP_KERNEL);
-		if (!fwu->read_config_buf) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to alloc mem for fwu->read_config_buf\n",
-					__func__);
-			fwu->read_config_buf_size = 0;
-			return -ENOMEM;
-		}
-		fwu->read_config_buf_size = count;
-	}
+	struct image_header *data = (struct image_header *)fw_image;
 
-	return 0;
-}
+	header->checksum = extract_uint_le(data->checksum);
 
-static void fwu_compare_partition_tables(void)
-{
-	if (fwu->phyaddr.ui_firmware != fwu->img.phyaddr.ui_firmware) {
-		fwu->new_partition_table = true;
-		return;
-	}
+	header->bootloader_version = data->bootloader_version;
 
-	if (fwu->phyaddr.ui_config != fwu->img.phyaddr.ui_config) {
-		fwu->new_partition_table = true;
-		return;
-	}
+	header->firmware_size = extract_uint_le(data->firmware_size);
 
-	if (fwu->flash_properties.has_disp_config) {
-		if (fwu->phyaddr.dp_config != fwu->img.phyaddr.dp_config) {
-			fwu->new_partition_table = true;
-			return;
-		}
-	}
+	header->config_size = extract_uint_le(data->config_size);
 
-	if (fwu->has_guest_code) {
-		if (fwu->phyaddr.guest_code != fwu->img.phyaddr.guest_code) {
-			fwu->new_partition_table = true;
-			return;
-		}
-	}
+	memcpy(header->product_id, data->product_id, sizeof(data->product_id));
+	header->product_id[sizeof(data->product_id)] = 0;
 
-	fwu->new_partition_table = false;
+	memcpy(header->product_info, data->product_info,
+			sizeof(data->product_info));
 
-	return;
+	header->contains_firmware_id = data->options_firmware_id;
+	if (header->contains_firmware_id)
+		header->firmware_id = extract_uint_le(data->firmware_id);
 }
 
-static void fwu_parse_partition_table(const unsigned char *partition_table,
-		struct block_count *blkcount, struct physical_address *phyaddr)
+static int fwu_read_f01_device_status(struct f01_device_status *status)
 {
-	unsigned char ii;
-	unsigned char index;
-	unsigned char offset;
-	unsigned short partition_length;
-	unsigned short physical_address;
-	struct partition_table *ptable;
+	int retval;
 	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
 
-	for (ii = 0; ii < fwu->partitions; ii++) {
-		index = ii * 8 + 2;
-		ptable = (struct partition_table *)&partition_table[index];
-		partition_length = ptable->partition_length_15_8 << 8 |
-				ptable->partition_length_7_0;
-		physical_address = ptable->start_physical_address_15_8 << 8 |
-				ptable->start_physical_address_7_0;
-		dev_dbg(rmi4_data->pdev->dev.parent,
-				"%s: Partition entry %d:\n",
-				__func__, ii);
-		for (offset = 0; offset < 8; offset++) {
-			dev_dbg(rmi4_data->pdev->dev.parent,
-					"%s: 0x%02x\n",
-					__func__,
-					partition_table[index + offset]);
-		}
-		switch (ptable->partition_id) {
-		case CORE_CODE_PARTITION:
-			blkcount->ui_firmware = partition_length;
-			phyaddr->ui_firmware = physical_address;
-			dev_dbg(rmi4_data->pdev->dev.parent,
-					"%s: Core code block count: %d\n",
-					__func__, blkcount->ui_firmware);
-			blkcount->total_count += partition_length;
-			break;
-		case CORE_CONFIG_PARTITION:
-			blkcount->ui_config = partition_length;
-			phyaddr->ui_config = physical_address;
-			dev_dbg(rmi4_data->pdev->dev.parent,
-					"%s: Core config block count: %d\n",
-					__func__, blkcount->ui_config);
-			blkcount->total_count += partition_length;
-			break;
-		case BOOTLOADER_PARTITION:
-			blkcount->bl_image = partition_length;
-			dev_dbg(rmi4_data->pdev->dev.parent,
-					"%s: Core config block count: %d\n",
-					__func__, blkcount->ui_config);
-			blkcount->total_count += partition_length;
-			break;
-		case DISPLAY_CONFIG_PARTITION:
-			blkcount->dp_config = partition_length;
-			phyaddr->dp_config = physical_address;
-			dev_dbg(rmi4_data->pdev->dev.parent,
-					"%s: Display config block count: %d\n",
-					__func__, blkcount->dp_config);
-			blkcount->total_count += partition_length;
-			break;
-		case FLASH_CONFIG_PARTITION:
-			blkcount->fl_config = partition_length;
-			phyaddr->fl_config = physical_address;
-			dev_dbg(rmi4_data->pdev->dev.parent,
-					"%s: Flash config block count: %d\n",
-					__func__, blkcount->fl_config);
-			blkcount->total_count += partition_length;
-			break;
-		case GUEST_CODE_PARTITION:
-			blkcount->guest_code = partition_length;
-			phyaddr->guest_code = physical_address;
-			dev_dbg(rmi4_data->pdev->dev.parent,
-					"%s: Guest code block count: %d\n",
-					__func__, blkcount->guest_code);
-			blkcount->total_count += partition_length;
-			break;
-		case GUEST_SERIALIZATION_PARTITION:
-			blkcount->pm_config = partition_length;
-			dev_dbg(rmi4_data->pdev->dev.parent,
-					"%s: Guest serialization block count: %d\n",
-					__func__, blkcount->pm_config);
-			blkcount->total_count += partition_length;
-			break;
-		case GLOBAL_PARAMETERS_PARTITION:
-			blkcount->bl_config = partition_length;
-			dev_dbg(rmi4_data->pdev->dev.parent,
-					"%s: Global parameters block count: %d\n",
-					__func__, blkcount->bl_config);
-			blkcount->total_count += partition_length;
-			break;
-		case DEVICE_CONFIG_PARTITION:
-			blkcount->lockdown = partition_length;
-			dev_dbg(rmi4_data->pdev->dev.parent,
-					"%s: Device config block count: %d\n",
-					__func__, blkcount->lockdown);
-			blkcount->total_count += partition_length;
-			break;
-		};
-	}
-
-	return;
-}
-
-static void fwu_parse_image_header_10_bl_container(const unsigned char *image)
-{
-	unsigned char ii;
-	unsigned char num_of_containers;
-	unsigned int addr;
-	unsigned int container_id;
-	unsigned int length;
-	const unsigned char *content;
-	struct container_descriptor *descriptor;
-
-	num_of_containers = (fwu->img.bootloader.size - 4) / 4;
-
-	for (ii = 1; ii <= num_of_containers; ii++) {
-		addr = le_to_uint(fwu->img.bootloader.data + (ii * 4));
-		descriptor = (struct container_descriptor *)(image + addr);
-		container_id = descriptor->container_id[0] |
-				descriptor->container_id[1] << 8;
-		content = image + le_to_uint(descriptor->content_address);
-		length = le_to_uint(descriptor->content_length);
-		switch (container_id) {
-		case BL_IMAGE_CONTAINER:
-			fwu->img.bl_image.data = content;
-			fwu->img.bl_image.size = length;
-			break;
-		case BL_CONFIG_CONTAINER:
-		case GLOBAL_PARAMETERS_CONTAINER:
-			fwu->img.bl_config.data = content;
-			fwu->img.bl_config.size = length;
-			break;
-		case BL_LOCKDOWN_INFO_CONTAINER:
-		case DEVICE_CONFIG_CONTAINER:
-			fwu->img.lockdown.data = content;
-			fwu->img.lockdown.size = length;
-			break;
-		default:
-			break;
-		};
-	}
-
-	return;
-}
-
-static void fwu_parse_image_header_10(void)
-{
-	unsigned char ii;
-	unsigned char num_of_containers;
-	unsigned int addr;
-	unsigned int offset;
-	unsigned int container_id;
-	unsigned int length;
-	const unsigned char *image;
-	const unsigned char *content;
-	struct container_descriptor *descriptor;
-	struct image_header_10 *header;
-
-	image = fwu->image;
-	header = (struct image_header_10 *)image;
-
-	fwu->img.checksum = le_to_uint(header->checksum);
-
-	/* address of top level container */
-	offset = le_to_uint(header->top_level_container_start_addr);
-	descriptor = (struct container_descriptor *)(image + offset);
-
-	/* address of top level container content */
-	offset = le_to_uint(descriptor->content_address);
-	num_of_containers = le_to_uint(descriptor->content_length) / 4;
-
-	for (ii = 0; ii < num_of_containers; ii++) {
-		addr = le_to_uint(image + offset);
-		offset += 4;
-		descriptor = (struct container_descriptor *)(image + addr);
-		container_id = descriptor->container_id[0] |
-				descriptor->container_id[1] << 8;
-		content = image + le_to_uint(descriptor->content_address);
-		length = le_to_uint(descriptor->content_length);
-		switch (container_id) {
-		case UI_CONTAINER:
-		case CORE_CODE_CONTAINER:
-			fwu->img.ui_firmware.data = content;
-			fwu->img.ui_firmware.size = length;
-			break;
-		case UI_CONFIG_CONTAINER:
-		case CORE_CONFIG_CONTAINER:
-			fwu->img.ui_config.data = content;
-			fwu->img.ui_config.size = length;
-			break;
-		case BL_CONTAINER:
-			fwu->img.bl_version = *content;
-			fwu->img.bootloader.data = content;
-			fwu->img.bootloader.size = length;
-			fwu_parse_image_header_10_bl_container(image);
-			break;
-		case GUEST_CODE_CONTAINER:
-			fwu->img.contains_guest_code = true;
-			fwu->img.guest_code.data = content;
-			fwu->img.guest_code.size = length;
-			break;
-		case DISPLAY_CONFIG_CONTAINER:
-			fwu->img.contains_disp_config = true;
-			fwu->img.dp_config.data = content;
-			fwu->img.dp_config.size = length;
-			break;
-		case PERMANENT_CONFIG_CONTAINER:
-		case GUEST_SERIALIZATION_CONTAINER:
-			fwu->img.contains_perm_config = true;
-			fwu->img.pm_config.data = content;
-			fwu->img.pm_config.size = length;
-			break;
-		case FLASH_CONFIG_CONTAINER:
-			fwu->img.contains_flash_config = true;
-			fwu->img.fl_config.data = content;
-			fwu->img.fl_config.size = length;
-			break;
-		case GENERAL_INFORMATION_CONTAINER:
-			fwu->img.contains_firmware_id = true;
-			fwu->img.firmware_id = le_to_uint(content + 4);
-			break;
-		default:
-			break;
-		}
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			rmi4_data->f01_data_base_addr,
+			status->data,
+			sizeof(status->data));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read F01 device status\n",
+				__func__);
+		return retval;
 	}
 
-	return;
+	return 0;
 }
 
-static void fwu_parse_image_header_05_06(void)
+static int fwu_read_f34_queries(void)
 {
 	int retval;
-	const unsigned char *image;
-	struct image_header_05_06 *header;
+	unsigned char count;
+	unsigned char buf[10];
 	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
 
-	image = fwu->image;
-	header = (struct image_header_05_06 *)image;
-
-	fwu->img.checksum = le_to_uint(header->checksum);
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			fwu->f34_fd.query_base_addr + BOOTLOADER_ID_OFFSET,
+			fwu->bootloader_id,
+			sizeof(fwu->bootloader_id));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read bootloader ID\n",
+				__func__);
+		return retval;
+	}
 
-	fwu->img.bl_version = header->header_version;
+	if (fwu->bootloader_id[1] == '5') {
+		fwu->bl_version = V5;
+	} else if (fwu->bootloader_id[1] == '6') {
+		fwu->bl_version = V6;
+	} else {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Unrecognized bootloader version\n",
+				__func__);
+		return -EINVAL;
+	}
 
-	fwu->img.contains_bootloader = header->options_bootloader;
-	if (fwu->img.contains_bootloader)
-		fwu->img.bootloader_size = le_to_uint(header->bootloader_size);
+	if (fwu->bl_version == V5) {
+		fwu->properties_off = V5_PROPERTIES_OFFSET;
+		fwu->blk_size_off = V5_BLOCK_SIZE_OFFSET;
+		fwu->blk_count_off = V5_BLOCK_COUNT_OFFSET;
+		fwu->blk_data_off = V5_BLOCK_DATA_OFFSET;
+	} else if (fwu->bl_version == V6) {
+		fwu->properties_off = V6_PROPERTIES_OFFSET;
+		fwu->blk_size_off = V6_BLOCK_SIZE_OFFSET;
+		fwu->blk_count_off = V6_BLOCK_COUNT_OFFSET;
+		fwu->blk_data_off = V6_BLOCK_DATA_OFFSET;
+	}
 
-	fwu->img.ui_firmware.size = le_to_uint(header->firmware_size);
-	if (fwu->img.ui_firmware.size) {
-		fwu->img.ui_firmware.data = image + IMAGE_AREA_OFFSET;
-		if (fwu->img.contains_bootloader)
-			fwu->img.ui_firmware.data += fwu->img.bootloader_size;
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			fwu->f34_fd.query_base_addr + fwu->properties_off,
+			&fwu->flash_properties,
+			sizeof(fwu->flash_properties));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to read flash properties\n",
+				__func__);
+		return retval;
 	}
 
-	if ((fwu->img.bl_version == BL_V6) && header->options_tddi)
-		fwu->img.ui_firmware.data = image + IMAGE_AREA_OFFSET;
+	count = 4;
 
-	fwu->img.ui_config.size = le_to_uint(header->config_size);
-	if (fwu->img.ui_config.size) {
-		fwu->img.ui_config.data = fwu->img.ui_firmware.data +
-				fwu->img.ui_firmware.size;
+	if (fwu->flash_properties & HAS_PERM_CONFIG) {
+		fwu->has_perm_config = 1;
+		count += 2;
 	}
 
-	if ((fwu->img.bl_version == BL_V5 && fwu->img.contains_bootloader) ||
-			(fwu->img.bl_version == BL_V6 && header->options_tddi))
-		fwu->img.contains_disp_config = true;
-	else
-		fwu->img.contains_disp_config = false;
-
-	if (fwu->img.contains_disp_config) {
-		fwu->img.disp_config_offset = le_to_uint(header->dsp_cfg_addr);
-		fwu->img.dp_config.size = le_to_uint(header->dsp_cfg_size);
-		fwu->img.dp_config.data = image + fwu->img.disp_config_offset;
-	} else {
-		retval = secure_memcpy(fwu->img.cstmr_product_id,
-				sizeof(fwu->img.cstmr_product_id),
-				header->cstmr_product_id,
-				sizeof(header->cstmr_product_id),
-				PRODUCT_ID_SIZE);
-		if (retval < 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to copy custom product ID string\n",
-					__func__);
-		}
-		fwu->img.cstmr_product_id[PRODUCT_ID_SIZE] = 0;
+	if (fwu->flash_properties & HAS_BL_CONFIG) {
+		fwu->has_bl_config = 1;
+		count += 2;
 	}
 
-	fwu->img.contains_firmware_id = header->options_firmware_id;
-	if (fwu->img.contains_firmware_id)
-		fwu->img.firmware_id = le_to_uint(header->firmware_id);
+	if (fwu->flash_properties & HAS_DISP_CONFIG) {
+		fwu->has_disp_config = 1;
+		count += 2;
+	}
 
-	retval = secure_memcpy(fwu->img.product_id,
-			sizeof(fwu->img.product_id),
-			header->product_id,
-			sizeof(header->product_id),
-			PRODUCT_ID_SIZE);
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			fwu->f34_fd.query_base_addr + fwu->blk_size_off,
+			buf,
+			2);
 	if (retval < 0) {
 		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to copy product ID string\n",
+				"%s: Failed to read block size info\n",
 				__func__);
+		return retval;
 	}
-	fwu->img.product_id[PRODUCT_ID_SIZE] = 0;
-
-	fwu->img.lockdown.size = LOCKDOWN_SIZE;
-	fwu->img.lockdown.data = image + IMAGE_AREA_OFFSET - LOCKDOWN_SIZE;
 
-	return;
-}
-
-static int fwu_parse_image_info(void)
-{
-	struct image_header_10 *header;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	header = (struct image_header_10 *)fwu->image;
+	batohs(&fwu->block_size, &(buf[0]));
 
-	memset(&fwu->img, 0x00, sizeof(fwu->img));
+	if (fwu->bl_version == V5) {
+		fwu->flash_cmd_off = fwu->blk_data_off + fwu->block_size;
+		fwu->flash_status_off = fwu->flash_cmd_off;
+	} else if (fwu->bl_version == V6) {
+		fwu->flash_cmd_off = V6_FLASH_COMMAND_OFFSET;
+		fwu->flash_status_off = V6_FLASH_STATUS_OFFSET;
+	}
 
-	switch (header->major_header_version) {
-	case IMAGE_HEADER_VERSION_10:
-		fwu_parse_image_header_10();
-		break;
-	case IMAGE_HEADER_VERSION_05:
-	case IMAGE_HEADER_VERSION_06:
-		fwu_parse_image_header_05_06();
-		break;
-	default:
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			fwu->f34_fd.query_base_addr + fwu->blk_count_off,
+			buf,
+			count);
+	if (retval < 0) {
 		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Unsupported image file format (0x%02x)\n",
-				__func__, header->major_header_version);
-		return -EINVAL;
+				"%s: Failed to read block count info\n",
+				__func__);
+		return retval;
 	}
 
-	if (fwu->bl_version == BL_V7 || fwu->bl_version == BL_V8) {
-		if (!fwu->img.contains_flash_config) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: No flash config found in firmware image\n",
-					__func__);
-			return -EINVAL;
-		}
+	batohs(&fwu->fw_block_count, &(buf[0]));
+	batohs(&fwu->config_block_count, &(buf[2]));
 
-		fwu_parse_partition_table(fwu->img.fl_config.data,
-				&fwu->img.blkcount, &fwu->img.phyaddr);
+	count = 4;
 
-		fwu_compare_partition_tables();
-	} else {
-		fwu->new_partition_table = false;
+	if (fwu->has_perm_config) {
+		batohs(&fwu->perm_config_block_count, &(buf[count]));
+		count += 2;
+	}
+
+	if (fwu->has_bl_config) {
+		batohs(&fwu->bl_config_block_count, &(buf[count]));
+		count += 2;
 	}
 
+	if (fwu->has_disp_config)
+		batohs(&fwu->disp_config_block_count, &(buf[count]));
+
 	return 0;
 }
 
-static int fwu_read_flash_status(void)
+static int fwu_read_f34_flash_status(void)
 {
 	int retval;
 	unsigned char status;
@@ -1130,7 +540,7 @@ static int fwu_read_flash_status(void)
 	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
 
 	retval = synaptics_rmi4_reg_read(rmi4_data,
-			fwu->f34_fd.data_base_addr + fwu->off.flash_status,
+			fwu->f34_fd.data_base_addr + fwu->flash_status_off,
 			&status,
 			sizeof(status));
 	if (retval < 0) {
@@ -1140,23 +550,15 @@ static int fwu_read_flash_status(void)
 		return retval;
 	}
 
-	fwu->in_bl_mode = status >> 7;
+	fwu->program_enabled = status >> 7;
 
-	if (fwu->bl_version == BL_V5)
+	if (fwu->bl_version == V5)
 		fwu->flash_status = (status >> 4) & MASK_3BIT;
-	else if (fwu->bl_version == BL_V6)
+	else if (fwu->bl_version == V6)
 		fwu->flash_status = status & MASK_3BIT;
-	else if (fwu->bl_version == BL_V7 || fwu->bl_version == BL_V8)
-		fwu->flash_status = status & MASK_5BIT;
-
-	if (fwu->flash_status != 0x00) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Flash status = %d, command = 0x%02x\n",
-				__func__, fwu->flash_status, fwu->command);
-	}
 
 	retval = synaptics_rmi4_reg_read(rmi4_data,
-			fwu->f34_fd.data_base_addr + fwu->off.flash_cmd,
+			fwu->f34_fd.data_base_addr + fwu->flash_cmd_off,
 			&command,
 			sizeof(command));
 	if (retval < 0) {
@@ -1166,17 +568,34 @@ static int fwu_read_flash_status(void)
 		return retval;
 	}
 
-	if (fwu->bl_version == BL_V5)
-		fwu->command = command & MASK_4BIT;
-	else if (fwu->bl_version == BL_V6)
-		fwu->command = command & MASK_6BIT;
-	else if (fwu->bl_version == BL_V7 || fwu->bl_version == BL_V8)
-		fwu->command = command;
+	fwu->command = command & MASK_4BIT;
+
+	return 0;
+}
+
+static int fwu_write_f34_command(unsigned char cmd)
+{
+	int retval;
+	unsigned char command = cmd & MASK_4BIT;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	fwu->command = cmd;
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			fwu->f34_fd.data_base_addr + fwu->flash_cmd_off,
+			&command,
+			sizeof(command));
+	if (retval < 0) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: Failed to write command 0x%02x\n",
+				__func__, command);
+		return retval;
+	}
 
 	return 0;
 }
 
-static int fwu_wait_for_idle(int timeout_ms, bool poll)
+static int fwu_wait_for_idle(int timeout_ms)
 {
 	int count = 0;
 	int timeout_count = ((timeout_ms * 1000) / MAX_SLEEP_TIME_US) + 1;
@@ -1186,10 +605,10 @@ static int fwu_wait_for_idle(int timeout_ms, bool poll)
 		usleep_range(MIN_SLEEP_TIME_US, MAX_SLEEP_TIME_US);
 
 		count++;
-		if (poll || (count == timeout_count))
-			fwu_read_flash_status();
+		if (count == timeout_count)
+			fwu_read_f34_flash_status();
 
-		if ((fwu->command == CMD_IDLE) && (fwu->flash_status == 0x00))
+		if ((fwu->command == 0x00) && (fwu->flash_status == 0x00))
 			return 0;
 	} while (count < timeout_count);
 
@@ -1200,309 +619,406 @@ static int fwu_wait_for_idle(int timeout_ms, bool poll)
 	return -ETIMEDOUT;
 }
 
-static int fwu_write_f34_v7_command_single_transaction(unsigned char cmd)
+static enum flash_area fwu_go_nogo(struct image_header_data *header)
 {
 	int retval;
-	unsigned char base;
-	struct f34_v7_data_1_5 data_1_5;
+	enum flash_area flash_area = NONE;
+	unsigned char index = 0;
+	unsigned char config_id[4];
+	unsigned int device_fw_id;
+	unsigned long image_fw_id;
+	char *strptr;
+	char *firmware_id;
 	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
 
-	base = fwu->f34_fd.data_base_addr;
+	if (fwu->force_update) {
+		flash_area = UI_FIRMWARE;
+		goto exit;
+	}
+
+	/* Update both UI and config if device is in bootloader mode */
+	if (fwu->in_flash_prog_mode) {
+		flash_area = UI_FIRMWARE;
+		goto exit;
+	}
 
-	memset(data_1_5.data, 0x00, sizeof(data_1_5.data));
+	/* Get device firmware ID */
+	device_fw_id = rmi4_data->firmware_id;
+	dev_info(rmi4_data->pdev->dev.parent,
+			"%s: Device firmware ID = %d\n",
+			__func__, device_fw_id);
 
-	switch (cmd) {
-	case CMD_ERASE_ALL:
-		data_1_5.partition_id = CORE_CODE_PARTITION;
-		data_1_5.command = CMD_V7_ERASE_AP;
-		break;
-	case CMD_ERASE_UI_FIRMWARE:
-		data_1_5.partition_id = CORE_CODE_PARTITION;
-		data_1_5.command = CMD_V7_ERASE;
-		break;
-	case CMD_ERASE_BL_CONFIG:
-		data_1_5.partition_id = GLOBAL_PARAMETERS_PARTITION;
-		data_1_5.command = CMD_V7_ERASE;
-		break;
-	case CMD_ERASE_UI_CONFIG:
-		data_1_5.partition_id = CORE_CONFIG_PARTITION;
-		data_1_5.command = CMD_V7_ERASE;
-		break;
-	case CMD_ERASE_DISP_CONFIG:
-		data_1_5.partition_id = DISPLAY_CONFIG_PARTITION;
-		data_1_5.command = CMD_V7_ERASE;
-		break;
-	case CMD_ERASE_FLASH_CONFIG:
-		data_1_5.partition_id = FLASH_CONFIG_PARTITION;
-		data_1_5.command = CMD_V7_ERASE;
-		break;
-	case CMD_ERASE_GUEST_CODE:
-		data_1_5.partition_id = GUEST_CODE_PARTITION;
-		data_1_5.command = CMD_V7_ERASE;
-		break;
-	case CMD_ENABLE_FLASH_PROG:
-		data_1_5.partition_id = BOOTLOADER_PARTITION;
-		data_1_5.command = CMD_V7_ENTER_BL;
-		break;
-	};
+	/* Get image firmware ID */
+	if (header->contains_firmware_id) {
+		image_fw_id = header->firmware_id;
+	} else {
+		strptr = strnstr(fwu->image_name, "PR",
+				sizeof(fwu->image_name));
+		if (!strptr) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: No valid PR number (PRxxxxxxx) found in image file name (%s)\n",
+					__func__, fwu->image_name);
+			flash_area = NONE;
+			goto exit;
+		}
+
+		strptr += 2;
+		firmware_id = kzalloc(MAX_FIRMWARE_ID_LEN, GFP_KERNEL);
+		if (!firmware_id) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to alloc mem for firmware id\n",
+					__func__);
+			flash_area = NONE;
+			goto exit;
+		}
 
-	data_1_5.payload_0 = fwu->bootloader_id[0];
-	data_1_5.payload_1 = fwu->bootloader_id[1];
+		while (strptr[index] >= '0' && strptr[index] <= '9') {
+			firmware_id[index] = strptr[index];
+			index++;
+		}
 
-	retval = synaptics_rmi4_reg_write(rmi4_data,
-			base + fwu->off.partition_id,
-			data_1_5.data,
-			sizeof(data_1_5.data));
+		retval = sstrtoul(firmware_id, 10, &image_fw_id);
+		kfree(firmware_id);
+		if (retval) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to obtain image firmware ID\n",
+					__func__);
+			flash_area = NONE;
+			goto exit;
+		}
+	}
+	dev_info(rmi4_data->pdev->dev.parent,
+			"%s: Image firmware ID = %d\n",
+			__func__, (unsigned int)image_fw_id);
+
+	if (!rmi4_data->hw_if->board_data->bypass_packrat_id_check) {
+		if (image_fw_id > device_fw_id) {
+			flash_area = UI_FIRMWARE;
+			goto exit;
+		} else if (image_fw_id < device_fw_id) {
+			dev_info(rmi4_data->pdev->dev.parent,
+					"%s: Image firmware ID older than device firmware ID\n",
+					__func__);
+			flash_area = NONE;
+			goto exit;
+		}
+	}
+
+	/* Get device config ID */
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+				fwu->f34_fd.ctrl_base_addr,
+				config_id,
+				sizeof(config_id));
 	if (retval < 0) {
 		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to write single transaction command\n",
+				"%s: Failed to read device config ID\n",
 				__func__);
-		return retval;
+		flash_area = NONE;
+		goto exit;
+	}
+	dev_info(rmi4_data->pdev->dev.parent,
+			"%s: Device config ID = 0x%02x 0x%02x 0x%02x 0x%02x\n",
+			__func__,
+			config_id[0],
+			config_id[1],
+			config_id[2],
+			config_id[3]);
+
+	/* Get image config ID */
+	dev_info(rmi4_data->pdev->dev.parent,
+			"%s: Image config ID = 0x%02x 0x%02x 0x%02x 0x%02x\n",
+			__func__,
+			fwu->config_data[0],
+			fwu->config_data[1],
+			fwu->config_data[2],
+			fwu->config_data[3]);
+
+	if (SYN_FW_CFG_GREATER(fwu, config_id)) {
+		if (image_fw_id > device_fw_id) {
+			dev_info(rmi4_data->pdev->dev.parent,
+				"%s: Image file has higher packrat id than device\n",
+				__func__);
+			/*
+			 * If packrat id of the firmware file is greater than
+			 * the firmware build id in the device(same as packrat
+			 * id), then both firmware and config area need to be
+			 * upgraded.
+			 */
+			flash_area = UI_FIRMWARE;
+			goto exit;
+		} else if (image_fw_id == device_fw_id) {
+			dev_info(rmi4_data->pdev->dev.parent,
+				"%s: Image file has equal packrat id as is in device\n",
+				__func__);
+			/*
+			 * If packrat id of the firmware file equals the
+			 * firmware build id in the device(same as packrat id),
+			 * then only config area needs to be upgraded.
+			 */
+			flash_area = CONFIG_AREA;
+			goto exit;
+		} else if (image_fw_id < device_fw_id) {
+			dev_info(rmi4_data->pdev->dev.parent,
+				"%s: Image file has lesser packrat id than device, even though config id is greater\n",
+				__func__);
+			/*
+			 * If packrat id of the firmware file is lesser than
+			 * the firmware build id in the device(same as packrat
+			 * id), then it is treated as an error
+			 */
+			flash_area = NONE;
+			goto exit;
+		}
+	} else if (SYN_FW_CFG_EQUAL(fwu, config_id)) {
+		if (image_fw_id > device_fw_id) {
+			dev_info(rmi4_data->pdev->dev.parent,
+				"%s: Image file has higher packrat id than device, though config id is equal\n",
+				__func__);
+			/*
+			 * If config id of the firmware file equals the config
+			 * id in the device, but packrat id of the firmware is
+			 * greater than the firmware build id in the device
+			 * (same as packrat id), then both firmware and config
+			 * area need to be upgraded.
+			 */
+			flash_area = UI_FIRMWARE;
+			goto exit;
+		} else if (image_fw_id == device_fw_id) {
+			dev_info(rmi4_data->pdev->dev.parent,
+				"%s: Image file has equal packrat id and config id as are in device\n",
+				__func__);
+			/*
+			 * If config id of the firmware file equals the config
+			 * id in the device and if packrat id of the firmware
+			 * is also equal to the firmware build id in the device
+			 * (same as packrat id), then no update is needed.
+			 */
+			flash_area = NONE;
+			goto exit;
+		} else if (image_fw_id < device_fw_id) {
+			dev_info(rmi4_data->pdev->dev.parent,
+				"%s: Image file has lesser packrat id than device, though config id is equal\n",
+				__func__);
+			/*
+			 * If config id of the firmware file equals the config
+			 * id in the device, but the packrat id of the firmware
+			 * file is lesser than the firmware build id in the
+			 * device(same as packrat id), then it is treated as an
+			 * error and no update is needed.
+			 */
+			flash_area = NONE;
+			goto exit;
+		}
 	}
 
-	return 0;
+	flash_area = NONE;
+
+exit:
+	if (flash_area == NONE) {
+		dev_info(rmi4_data->pdev->dev.parent,
+				"%s: No need to do reflash\n",
+				__func__);
+	} else {
+		dev_info(rmi4_data->pdev->dev.parent,
+				"%s: Updating %s\n",
+				__func__,
+				flash_area == UI_FIRMWARE ?
+				"UI firmware" :
+				"config only");
+	}
+
+	return flash_area;
 }
 
-static int fwu_write_f34_v7_command(unsigned char cmd)
+static int fwu_scan_pdt(void)
 {
 	int retval;
-	unsigned char base;
-	unsigned char command;
+	unsigned char ii;
+	unsigned char intr_count = 0;
+	unsigned char intr_off;
+	unsigned char intr_src;
+	unsigned short addr;
+	bool f01found = false;
+	bool f34found = false;
+	struct synaptics_rmi4_fn_desc rmi_fd;
 	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
 
-	base = fwu->f34_fd.data_base_addr;
-
-	switch (cmd) {
-	case CMD_WRITE_FW:
-	case CMD_WRITE_CONFIG:
-	case CMD_WRITE_LOCKDOWN:
-	case CMD_WRITE_GUEST_CODE:
-		command = CMD_V7_WRITE;
-		break;
-	case CMD_READ_CONFIG:
-		command = CMD_V7_READ;
-		break;
-	case CMD_ERASE_ALL:
-		command = CMD_V7_ERASE_AP;
-		break;
-	case CMD_ERASE_UI_FIRMWARE:
-	case CMD_ERASE_BL_CONFIG:
-	case CMD_ERASE_UI_CONFIG:
-	case CMD_ERASE_DISP_CONFIG:
-	case CMD_ERASE_FLASH_CONFIG:
-	case CMD_ERASE_GUEST_CODE:
-		command = CMD_V7_ERASE;
-		break;
-	case CMD_ENABLE_FLASH_PROG:
-		command = CMD_V7_ENTER_BL;
-		break;
-	default:
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Invalid command 0x%02x\n",
-				__func__, cmd);
-		return -EINVAL;
-	};
-
-	fwu->command = command;
-
-	switch (cmd) {
-	case CMD_ERASE_ALL:
-	case CMD_ERASE_UI_FIRMWARE:
-	case CMD_ERASE_BL_CONFIG:
-	case CMD_ERASE_UI_CONFIG:
-	case CMD_ERASE_DISP_CONFIG:
-	case CMD_ERASE_FLASH_CONFIG:
-	case CMD_ERASE_GUEST_CODE:
-	case CMD_ENABLE_FLASH_PROG:
-		retval = fwu_write_f34_v7_command_single_transaction(cmd);
+	for (addr = PDT_START; addr > PDT_END; addr -= PDT_ENTRY_SIZE) {
+		retval = synaptics_rmi4_reg_read(rmi4_data,
+				addr,
+				(unsigned char *)&rmi_fd,
+				sizeof(rmi_fd));
 		if (retval < 0)
 			return retval;
-		else
-			return 0;
-	default:
-		break;
-	};
 
-	retval = synaptics_rmi4_reg_write(rmi4_data,
-			base + fwu->off.flash_cmd,
-			&command,
-			sizeof(command));
-	if (retval < 0) {
+		if (rmi_fd.fn_number) {
+			dev_dbg(rmi4_data->pdev->dev.parent,
+					"%s: Found F%02x\n",
+					__func__, rmi_fd.fn_number);
+			switch (rmi_fd.fn_number) {
+			case SYNAPTICS_RMI4_F01:
+				f01found = true;
+
+				rmi4_data->f01_query_base_addr =
+						rmi_fd.query_base_addr;
+				rmi4_data->f01_ctrl_base_addr =
+						rmi_fd.ctrl_base_addr;
+				rmi4_data->f01_data_base_addr =
+						rmi_fd.data_base_addr;
+				rmi4_data->f01_cmd_base_addr =
+						rmi_fd.cmd_base_addr;
+				break;
+			case SYNAPTICS_RMI4_F34:
+				f34found = true;
+				fwu->f34_fd.query_base_addr =
+						rmi_fd.query_base_addr;
+				fwu->f34_fd.ctrl_base_addr =
+						rmi_fd.ctrl_base_addr;
+				fwu->f34_fd.data_base_addr =
+						rmi_fd.data_base_addr;
+
+				fwu->intr_mask = 0;
+				intr_src = rmi_fd.intr_src_count;
+				intr_off = intr_count % 8;
+				for (ii = intr_off;
+						ii < ((intr_src & MASK_3BIT) +
+						intr_off);
+						ii++) {
+					fwu->intr_mask |= 1 << ii;
+				}
+				break;
+			}
+		} else {
+			break;
+		}
+
+		intr_count += (rmi_fd.intr_src_count & MASK_3BIT);
+	}
+
+	if (!f01found || !f34found) {
 		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to write flash command\n",
+				"%s: Failed to find both F01 and F34\n",
 				__func__);
-		return retval;
+		return -EINVAL;
 	}
 
 	return 0;
 }
 
-static int fwu_write_f34_v5v6_command(unsigned char cmd)
+static int fwu_write_blocks(unsigned char *block_ptr, unsigned short block_cnt,
+		unsigned char command)
 {
 	int retval;
-	unsigned char base;
-	unsigned char command;
+	unsigned char block_offset[] = {0, 0};
+	unsigned short block_num;
 	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+	unsigned int progress;
+	unsigned char command_str[10];
 
-	base = fwu->f34_fd.data_base_addr;
-
-	switch (cmd) {
-	case CMD_IDLE:
-		command = CMD_V5V6_IDLE;
+	switch (command) {
+	case CMD_WRITE_CONFIG_BLOCK:
+		progress = 10;
+		strlcpy(command_str, "config", 10);
 		break;
-	case CMD_WRITE_FW:
-		command = CMD_V5V6_WRITE_FW;
+	case CMD_WRITE_FW_BLOCK:
+		progress = 100;
+		strlcpy(command_str, "firmware", 10);
 		break;
-	case CMD_WRITE_CONFIG:
-		command = CMD_V5V6_WRITE_CONFIG;
-		break;
-	case CMD_WRITE_LOCKDOWN:
-		command = CMD_V5V6_WRITE_LOCKDOWN;
-		break;
-	case CMD_WRITE_GUEST_CODE:
-		command = CMD_V5V6_WRITE_GUEST_CODE;
-		break;
-	case CMD_READ_CONFIG:
-		command = CMD_V5V6_READ_CONFIG;
-		break;
-	case CMD_ERASE_ALL:
-		command = CMD_V5V6_ERASE_ALL;
-		break;
-	case CMD_ERASE_UI_CONFIG:
-		command = CMD_V5V6_ERASE_UI_CONFIG;
-		break;
-	case CMD_ERASE_DISP_CONFIG:
-		command = CMD_V5V6_ERASE_DISP_CONFIG;
-		break;
-	case CMD_ERASE_GUEST_CODE:
-		command = CMD_V5V6_ERASE_GUEST_CODE;
-		break;
-	case CMD_ENABLE_FLASH_PROG:
-		command = CMD_V5V6_ENABLE_FLASH_PROG;
+	case CMD_WRITE_LOCKDOWN_BLOCK:
+		progress = 1;
+		strlcpy(command_str, "lockdown", 10);
 		break;
 	default:
+		progress = 1;
+		strlcpy(command_str, "unknown", 10);
+		break;
+	}
+
+	block_offset[1] |= (fwu->config_area << 5);
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			fwu->f34_fd.data_base_addr + BLOCK_NUMBER_OFFSET,
+			block_offset,
+			sizeof(block_offset));
+	if (retval < 0) {
 		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Invalid command 0x%02x\n",
-				__func__, cmd);
-		return -EINVAL;
+				"%s: Failed to write to block number registers\n",
+				__func__);
+		return retval;
 	}
 
-	switch (cmd) {
-	case CMD_ERASE_ALL:
-	case CMD_ERASE_UI_CONFIG:
-	case CMD_ERASE_DISP_CONFIG:
-	case CMD_ERASE_GUEST_CODE:
-	case CMD_ENABLE_FLASH_PROG:
+	for (block_num = 0; block_num < block_cnt; block_num++) {
+		if (block_num % progress == 0)
+			dev_info(rmi4_data->pdev->dev.parent,
+				"%s: update %s %3d / %3d\n",
+				__func__, command_str, block_num, block_cnt);
+
 		retval = synaptics_rmi4_reg_write(rmi4_data,
-				base + fwu->off.payload,
-				fwu->bootloader_id,
-				sizeof(fwu->bootloader_id));
+				fwu->f34_fd.data_base_addr + fwu->blk_data_off,
+				block_ptr,
+				fwu->block_size);
 		if (retval < 0) {
 			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to write bootloader ID\n",
-					__func__);
+					"%s: Failed to write block data (block %d)\n",
+					__func__, block_num);
+			return retval;
+		}
+
+		retval = fwu_write_f34_command(command);
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to write command for block %d\n",
+					__func__, block_num);
 			return retval;
 		}
-		break;
-	default:
-		break;
-	};
 
-	fwu->command = command;
+		retval = fwu_wait_for_idle(WRITE_WAIT_MS);
+		if (retval < 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Failed to wait for idle status (block %d)\n",
+					__func__, block_num);
+			return retval;
+		}
 
-	retval = synaptics_rmi4_reg_write(rmi4_data,
-			base + fwu->off.flash_cmd,
-			&command,
-			sizeof(command));
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to write command 0x%02x\n",
-				__func__, command);
-		return retval;
+		block_ptr += fwu->block_size;
 	}
 
+	dev_info(rmi4_data->pdev->dev.parent,
+		"updated %d/%d blocks\n", block_num, block_cnt);
+
 	return 0;
 }
 
-static int fwu_write_f34_command(unsigned char cmd)
+static int fwu_write_firmware(void)
 {
-	int retval;
+	return fwu_write_blocks((unsigned char *)fwu->firmware_data,
+		fwu->fw_block_count, CMD_WRITE_FW_BLOCK);
+}
 
-	if (fwu->bl_version == BL_V7 || fwu->bl_version == BL_V8)
-		retval = fwu_write_f34_v7_command(cmd);
-	else
-		retval = fwu_write_f34_v5v6_command(cmd);
+static int fwu_write_configuration(void)
+{
+	return fwu_write_blocks((unsigned char *)fwu->config_data,
+		fwu->config_block_count, CMD_WRITE_CONFIG_BLOCK);
+}
 
-	return retval;
+static int fwu_write_lockdown(void)
+{
+	return fwu_write_blocks((unsigned char *)fwu->lockdown_data,
+		fwu->lockdown_block_count, CMD_WRITE_LOCKDOWN_BLOCK);
 }
 
-static int fwu_write_f34_v7_partition_id(unsigned char cmd)
+static int fwu_write_bootloader_id(void)
 {
 	int retval;
-	unsigned char base;
-	unsigned char partition;
 	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
 
-	base = fwu->f34_fd.data_base_addr;
-
-	switch (cmd) {
-	case CMD_WRITE_FW:
-		partition = CORE_CODE_PARTITION;
-		break;
-	case CMD_WRITE_CONFIG:
-	case CMD_READ_CONFIG:
-		if (fwu->config_area == UI_CONFIG_AREA)
-			partition = CORE_CONFIG_PARTITION;
-		else if (fwu->config_area == DP_CONFIG_AREA)
-			partition = DISPLAY_CONFIG_PARTITION;
-		else if (fwu->config_area == PM_CONFIG_AREA)
-			partition = GUEST_SERIALIZATION_PARTITION;
-		else if (fwu->config_area == BL_CONFIG_AREA)
-			partition = GLOBAL_PARAMETERS_PARTITION;
-		else if (fwu->config_area == FLASH_CONFIG_AREA)
-			partition = FLASH_CONFIG_PARTITION;
-		break;
-	case CMD_WRITE_LOCKDOWN:
-		partition = DEVICE_CONFIG_PARTITION;
-		break;
-	case CMD_WRITE_GUEST_CODE:
-		partition = GUEST_CODE_PARTITION;
-		break;
-	case CMD_ERASE_ALL:
-		partition = CORE_CODE_PARTITION;
-		break;
-	case CMD_ERASE_BL_CONFIG:
-		partition = GLOBAL_PARAMETERS_PARTITION;
-		break;
-	case CMD_ERASE_UI_CONFIG:
-		partition = CORE_CONFIG_PARTITION;
-		break;
-	case CMD_ERASE_DISP_CONFIG:
-		partition = DISPLAY_CONFIG_PARTITION;
-		break;
-	case CMD_ERASE_FLASH_CONFIG:
-		partition = FLASH_CONFIG_PARTITION;
-		break;
-	case CMD_ERASE_GUEST_CODE:
-		partition = GUEST_CODE_PARTITION;
-		break;
-	case CMD_ENABLE_FLASH_PROG:
-		partition = BOOTLOADER_PARTITION;
-		break;
-	default:
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Invalid command 0x%02x\n",
-				__func__, cmd);
-		return -EINVAL;
-	};
-
 	retval = synaptics_rmi4_reg_write(rmi4_data,
-			base + fwu->off.partition_id,
-			&partition,
-			sizeof(partition));
+			fwu->f34_fd.data_base_addr + fwu->blk_data_off,
+			fwu->bootloader_id,
+			sizeof(fwu->bootloader_id));
 	if (retval < 0) {
 		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to write partition ID\n",
+				"%s: Failed to write bootloader ID\n",
 				__func__);
 		return retval;
 	}
@@ -1510,2219 +1026,417 @@ static int fwu_write_f34_v7_partition_id(unsigned char cmd)
 	return 0;
 }
 
-static int fwu_write_f34_partition_id(unsigned char cmd)
-{
-	int retval;
-
-	if (fwu->bl_version == BL_V7 || fwu->bl_version == BL_V8)
-		retval = fwu_write_f34_v7_partition_id(cmd);
-	else
-		retval = 0;
-
-	return retval;
-}
-
-static int fwu_read_f34_v7_partition_table(unsigned char *partition_table)
+static int fwu_enter_flash_prog(void)
 {
 	int retval;
-	unsigned char base;
-	unsigned char length[2];
-	unsigned short block_number = 0;
+	struct f01_device_status f01_device_status;
+	struct f01_device_control f01_device_control;
 	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
 
-	base = fwu->f34_fd.data_base_addr;
+	retval = fwu_write_bootloader_id();
+	if (retval < 0)
+		return retval;
 
-	fwu->config_area = FLASH_CONFIG_AREA;
+	retval = fwu_write_f34_command(CMD_ENABLE_FLASH_PROG);
+	if (retval < 0)
+		return retval;
 
-	retval = fwu_write_f34_partition_id(CMD_READ_CONFIG);
+	retval = fwu_wait_for_idle(ENABLE_WAIT_MS);
 	if (retval < 0)
 		return retval;
 
-	retval = synaptics_rmi4_reg_write(rmi4_data,
-			base + fwu->off.block_number,
-			(unsigned char *)&block_number,
-			sizeof(block_number));
-	if (retval < 0) {
+	if (!fwu->program_enabled) {
 		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to write block number\n",
+				"%s: Program enabled bit not set\n",
 				__func__);
-		return retval;
+		return -EINVAL;
 	}
 
-	length[0] = (unsigned char)(fwu->flash_config_length & MASK_8BIT);
-	length[1] = (unsigned char)(fwu->flash_config_length >> 8);
+	retval = fwu_scan_pdt();
+	if (retval < 0)
+		return retval;
 
-	retval = synaptics_rmi4_reg_write(rmi4_data,
-			base + fwu->off.transfer_length,
-			length,
-			sizeof(length));
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to write transfer length\n",
-				__func__);
+	retval = fwu_read_f01_device_status(&f01_device_status);
+	if (retval < 0)
 		return retval;
-	}
 
-	retval = fwu_write_f34_command(CMD_READ_CONFIG);
-	if (retval < 0) {
+	if (!f01_device_status.flash_prog) {
 		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to write command\n",
+				"%s: Not in flash prog mode\n",
 				__func__);
-		return retval;
+		return -EINVAL;
 	}
 
-	retval = fwu_wait_for_idle(WRITE_WAIT_MS, true);
+	retval = fwu_read_f34_queries();
+	if (retval < 0)
+		return retval;
+
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			rmi4_data->f01_ctrl_base_addr,
+			f01_device_control.data,
+			sizeof(f01_device_control.data));
 	if (retval < 0) {
 		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to wait for idle status\n",
+				"%s: Failed to read F01 device control\n",
 				__func__);
 		return retval;
 	}
 
-	retval = synaptics_rmi4_reg_read(rmi4_data,
-			base + fwu->off.payload,
-			partition_table,
-			fwu->partition_table_bytes);
+	f01_device_control.nosleep = true;
+	f01_device_control.sleep_mode = SLEEP_MODE_NORMAL;
+
+	retval = synaptics_rmi4_reg_write(rmi4_data,
+			rmi4_data->f01_ctrl_base_addr,
+			f01_device_control.data,
+			sizeof(f01_device_control.data));
 	if (retval < 0) {
 		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to read block data\n",
+				"%s: Failed to write F01 device control\n",
 				__func__);
 		return retval;
 	}
 
-	return 0;
+	return retval;
 }
 
-static int fwu_read_f34_v7_queries(void)
+static int fwu_do_reflash(void)
 {
 	int retval;
-	unsigned char ii;
-	unsigned char base;
-	unsigned char index;
-	unsigned char offset;
-	unsigned char *ptable;
-	struct f34_v7_query_0 query_0;
-	struct f34_v7_query_1_7 query_1_7;
 	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
 
-	base = fwu->f34_fd.query_base_addr;
-
-	retval = synaptics_rmi4_reg_read(rmi4_data,
-			base,
-			query_0.data,
-			sizeof(query_0.data));
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to read query 0\n",
-				__func__);
+	retval = fwu_enter_flash_prog();
+	if (retval < 0)
 		return retval;
-	}
 
-	offset = query_0.subpacket_1_size + 1;
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Entered flash prog mode\n",
+			__func__);
 
-	retval = synaptics_rmi4_reg_read(rmi4_data,
-			base + offset,
-			query_1_7.data,
-			sizeof(query_1_7.data));
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to read queries 1 to 7\n",
-				__func__);
+	retval = fwu_write_bootloader_id();
+	if (retval < 0)
 		return retval;
-	}
 
-	fwu->bootloader_id[0] = query_1_7.bl_minor_revision;
-	fwu->bootloader_id[1] = query_1_7.bl_major_revision;
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Bootloader ID written\n",
+			__func__);
+
+	retval = fwu_write_f34_command(CMD_ERASE_ALL);
+	if (retval < 0)
+		return retval;
 
-	if (fwu->bootloader_id[1] == BL_V8)
-		fwu->bl_version = BL_V8;
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Erase all command written\n",
+			__func__);
 
-	fwu->block_size = query_1_7.block_size_15_8 << 8 |
-			query_1_7.block_size_7_0;
+	retval = fwu_wait_for_idle(ERASE_WAIT_MS);
+	if (retval < 0)
+		return retval;
 
-	fwu->flash_config_length = query_1_7.flash_config_length_15_8 << 8 |
-			query_1_7.flash_config_length_7_0;
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Idle status detected\n",
+			__func__);
 
-	fwu->payload_length = query_1_7.payload_length_15_8 << 8 |
-			query_1_7.payload_length_7_0;
+	if (fwu->firmware_data) {
+		retval = fwu_write_firmware();
+		if (retval < 0)
+			return retval;
+		pr_notice("%s: Firmware programmed\n", __func__);
+	}
 
-	fwu->off.flash_status = V7_FLASH_STATUS_OFFSET;
-	fwu->off.partition_id = V7_PARTITION_ID_OFFSET;
-	fwu->off.block_number = V7_BLOCK_NUMBER_OFFSET;
-	fwu->off.transfer_length = V7_TRANSFER_LENGTH_OFFSET;
-	fwu->off.flash_cmd = V7_COMMAND_OFFSET;
-	fwu->off.payload = V7_PAYLOAD_OFFSET;
+	if (fwu->config_data) {
+		retval = fwu_write_configuration();
+		if (retval < 0)
+			return retval;
+		pr_notice("%s: Configuration programmed\n", __func__);
+	}
 
-	index = sizeof(query_1_7.data) - V7_PARTITION_SUPPORT_BYTES;
+	return retval;
+}
 
-	fwu->partitions = 0;
-	for (offset = 0; offset < V7_PARTITION_SUPPORT_BYTES; offset++) {
-		for (ii = 0; ii < 8; ii++) {
-			if (query_1_7.data[index + offset] & (1 << ii))
-				fwu->partitions++;
-		}
+static int fwu_do_write_config(void)
+{
+	int retval;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
 
-		dev_dbg(rmi4_data->pdev->dev.parent,
-				"%s: Supported partitions: 0x%02x\n",
-				__func__, query_1_7.data[index + offset]);
-	}
+	retval = fwu_enter_flash_prog();
+	if (retval < 0)
+		return retval;
 
-	fwu->partition_table_bytes = fwu->partitions * 8 + 2;
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Entered flash prog mode\n",
+			__func__);
 
-	ptable = kzalloc(fwu->partition_table_bytes, GFP_KERNEL);
-	if (!ptable) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to alloc mem for partition table\n",
-				__func__);
-		return -ENOMEM;
+	if (fwu->config_area == PERM_CONFIG_AREA) {
+		fwu->config_block_count = fwu->perm_config_block_count;
+		goto write_config;
 	}
 
-	retval = fwu_read_f34_v7_partition_table(ptable);
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to read partition table\n",
-				__func__);
-		kfree(ptable);
+	retval = fwu_write_bootloader_id();
+	if (retval < 0)
 		return retval;
-	}
 
-	fwu_parse_partition_table(ptable, &fwu->blkcount, &fwu->phyaddr);
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Bootloader ID written\n",
+			__func__);
 
-	if (fwu->blkcount.dp_config)
-		fwu->flash_properties.has_disp_config = 1;
-	else
-		fwu->flash_properties.has_disp_config = 0;
+	switch (fwu->config_area) {
+	case UI_CONFIG_AREA:
+		retval = fwu_write_f34_command(CMD_ERASE_CONFIG);
+		break;
+	case BL_CONFIG_AREA:
+		retval = fwu_write_f34_command(CMD_ERASE_BL_CONFIG);
+		fwu->config_block_count = fwu->bl_config_block_count;
+		break;
+	case DISP_CONFIG_AREA:
+		retval = fwu_write_f34_command(CMD_ERASE_DISP_CONFIG);
+		fwu->config_block_count = fwu->disp_config_block_count;
+		break;
+	}
+	if (retval < 0)
+		return retval;
 
-	if (fwu->blkcount.pm_config)
-		fwu->flash_properties.has_pm_config = 1;
-	else
-		fwu->flash_properties.has_pm_config = 0;
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Erase command written\n",
+			__func__);
 
-	if (fwu->blkcount.bl_config)
-		fwu->flash_properties.has_bl_config = 1;
-	else
-		fwu->flash_properties.has_bl_config = 0;
+	retval = fwu_wait_for_idle(ERASE_WAIT_MS);
+	if (retval < 0)
+		return retval;
 
-	if (fwu->blkcount.guest_code)
-		fwu->has_guest_code = 1;
-	else
-		fwu->has_guest_code = 0;
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Idle status detected\n",
+			__func__);
 
-	kfree(ptable);
+write_config:
+	retval = fwu_write_configuration();
+	if (retval < 0)
+		return retval;
 
-	return 0;
+	pr_notice("%s: Config written\n", __func__);
+
+	return retval;
 }
 
-static int fwu_read_f34_v5v6_queries(void)
+static int fwu_start_write_config(void)
 {
 	int retval;
-	unsigned char count;
-	unsigned char base;
-	unsigned char buf[10];
-	struct f34_v5v6_flash_properties_2 properties_2;
+	unsigned short block_count;
+	struct image_header_data header;
 	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
 
-	base = fwu->f34_fd.query_base_addr;
+	switch (fwu->config_area) {
+	case UI_CONFIG_AREA:
+		block_count = fwu->config_block_count;
+		break;
+	case PERM_CONFIG_AREA:
+		if (!fwu->has_perm_config)
+			return -EINVAL;
+		block_count = fwu->perm_config_block_count;
+		break;
+	case BL_CONFIG_AREA:
+		if (!fwu->has_bl_config)
+			return -EINVAL;
+		block_count = fwu->bl_config_block_count;
+		break;
+	case DISP_CONFIG_AREA:
+		if (!fwu->has_disp_config)
+			return -EINVAL;
+		block_count = fwu->disp_config_block_count;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (fwu->ext_data_source)
+		fwu->config_data = fwu->ext_data_source;
+	else
+		return -EINVAL;
 
-	retval = synaptics_rmi4_reg_read(rmi4_data,
-			base + V5V6_BOOTLOADER_ID_OFFSET,
-			fwu->bootloader_id,
-			sizeof(fwu->bootloader_id));
+	fwu->config_size = fwu->block_size * block_count;
+
+	/* Jump to the config area if given a packrat image */
+	if ((fwu->config_area == UI_CONFIG_AREA) &&
+			(fwu->config_size != fwu->image_size)) {
+		parse_header(&header, fwu->ext_data_source);
+
+		if (header.config_size) {
+			fwu->config_data = fwu->ext_data_source +
+					FW_IMAGE_OFFSET +
+					header.firmware_size;
+		} else {
+			return -EINVAL;
+		}
+	}
+
+	pr_notice("%s: Start of write config process\n", __func__);
+
+	retval = fwu_do_write_config();
 	if (retval < 0) {
 		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to read bootloader ID\n",
+				"%s: Failed to write config\n",
 				__func__);
-		return retval;
 	}
 
-	if (fwu->bl_version == BL_V5) {
-		fwu->off.properties = V5_PROPERTIES_OFFSET;
-		fwu->off.block_size = V5_BLOCK_SIZE_OFFSET;
-		fwu->off.block_count = V5_BLOCK_COUNT_OFFSET;
-		fwu->off.block_number = V5_BLOCK_NUMBER_OFFSET;
-		fwu->off.payload = V5_BLOCK_DATA_OFFSET;
-	} else if (fwu->bl_version == BL_V6) {
-		fwu->off.properties = V6_PROPERTIES_OFFSET;
-		fwu->off.properties_2 = V6_PROPERTIES_2_OFFSET;
-		fwu->off.block_size = V6_BLOCK_SIZE_OFFSET;
-		fwu->off.block_count = V6_BLOCK_COUNT_OFFSET;
-		fwu->off.gc_block_count = V6_GUEST_CODE_BLOCK_COUNT_OFFSET;
-		fwu->off.block_number = V6_BLOCK_NUMBER_OFFSET;
-		fwu->off.payload = V6_BLOCK_DATA_OFFSET;
-	}
+	rmi4_data->reset_device(rmi4_data);
 
-	retval = synaptics_rmi4_reg_read(rmi4_data,
-			base + fwu->off.block_size,
-			buf,
-			2);
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to read block size info\n",
-				__func__);
-		return retval;
-	}
-
-	batohs(&fwu->block_size, &(buf[0]));
-
-	if (fwu->bl_version == BL_V5) {
-		fwu->off.flash_cmd = fwu->off.payload + fwu->block_size;
-		fwu->off.flash_status = fwu->off.flash_cmd;
-	} else if (fwu->bl_version == BL_V6) {
-		fwu->off.flash_cmd = V6_FLASH_COMMAND_OFFSET;
-		fwu->off.flash_status = V6_FLASH_STATUS_OFFSET;
-	}
-
-	retval = synaptics_rmi4_reg_read(rmi4_data,
-			base + fwu->off.properties,
-			fwu->flash_properties.data,
-			sizeof(fwu->flash_properties.data));
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to read flash properties\n",
-				__func__);
-		return retval;
-	}
-
-	count = 4;
-
-	if (fwu->flash_properties.has_pm_config)
-		count += 2;
-
-	if (fwu->flash_properties.has_bl_config)
-		count += 2;
-
-	if (fwu->flash_properties.has_disp_config)
-		count += 2;
-
-	retval = synaptics_rmi4_reg_read(rmi4_data,
-			base + fwu->off.block_count,
-			buf,
-			count);
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to read block count info\n",
-				__func__);
-		return retval;
-	}
-
-	batohs(&fwu->blkcount.ui_firmware, &(buf[0]));
-	batohs(&fwu->blkcount.ui_config, &(buf[2]));
-
-	count = 4;
-
-	if (fwu->flash_properties.has_pm_config) {
-		batohs(&fwu->blkcount.pm_config, &(buf[count]));
-		count += 2;
-	}
-
-	if (fwu->flash_properties.has_bl_config) {
-		batohs(&fwu->blkcount.bl_config, &(buf[count]));
-		count += 2;
-	}
-
-	if (fwu->flash_properties.has_disp_config)
-		batohs(&fwu->blkcount.dp_config, &(buf[count]));
-
-	fwu->has_guest_code = false;
-
-	if (fwu->flash_properties.has_query4) {
-		retval = synaptics_rmi4_reg_read(rmi4_data,
-				base + fwu->off.properties_2,
-				properties_2.data,
-				sizeof(properties_2.data));
-		if (retval < 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to read flash properties 2\n",
-					__func__);
-			return retval;
-		}
-
-		if (properties_2.has_guest_code) {
-			retval = synaptics_rmi4_reg_read(rmi4_data,
-					base + fwu->off.gc_block_count,
-					buf,
-					2);
-			if (retval < 0) {
-				dev_err(rmi4_data->pdev->dev.parent,
-						"%s: Failed to read guest code block count\n",
-						__func__);
-				return retval;
-			}
-
-			batohs(&fwu->blkcount.guest_code, &(buf[0]));
-			fwu->has_guest_code = true;
-		}
-	}
-
-	return 0;
-}
-
-static int fwu_read_f34_queries(void)
-{
-	int retval;
-
-	memset(&fwu->blkcount, 0x00, sizeof(fwu->blkcount));
-	memset(&fwu->phyaddr, 0x00, sizeof(fwu->phyaddr));
-
-	if (fwu->bl_version == BL_V7)
-		retval = fwu_read_f34_v7_queries();
-	else
-		retval = fwu_read_f34_v5v6_queries();
+	pr_notice("%s: End of write config process\n", __func__);
 
 	return retval;
 }
 
-static int fwu_write_f34_v7_blocks(unsigned char *block_ptr,
-		unsigned short block_cnt, unsigned char command)
+static int fwu_do_read_config(void)
 {
 	int retval;
-	unsigned char base;
-	unsigned char length[2];
-	unsigned short transfer;
-	unsigned short max_transfer;
-	unsigned short remaining = block_cnt;
-	unsigned short block_number = 0;
+	unsigned char block_offset[] = {0, 0};
+	unsigned short block_num;
+	unsigned short block_count;
+	unsigned short index = 0;
 	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
 
-	base = fwu->f34_fd.data_base_addr;
-
-	retval = fwu_write_f34_partition_id(command);
+	retval = fwu_enter_flash_prog();
 	if (retval < 0)
-		return retval;
-
-	retval = synaptics_rmi4_reg_write(rmi4_data,
-			base + fwu->off.block_number,
-			(unsigned char *)&block_number,
-			sizeof(block_number));
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to write block number\n",
-				__func__);
-		return retval;
-	}
-
-	if (fwu->payload_length > (PAGE_SIZE / fwu->block_size))
-		max_transfer = PAGE_SIZE / fwu->block_size;
-	else
-		max_transfer = fwu->payload_length;
-
-	do {
-		if (remaining / max_transfer)
-			transfer = max_transfer;
-		else
-			transfer = remaining;
-
-		length[0] = (unsigned char)(transfer & MASK_8BIT);
-		length[1] = (unsigned char)(transfer >> 8);
-
-		retval = synaptics_rmi4_reg_write(rmi4_data,
-				base + fwu->off.transfer_length,
-				length,
-				sizeof(length));
-		if (retval < 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to write transfer length (%d blocks remaining)\n",
-					__func__, remaining);
-			return retval;
-		}
-
-		retval = fwu_write_f34_command(command);
-		if (retval < 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to write command (%d blocks remaining)\n",
-					__func__, remaining);
-			return retval;
-		}
-
-		retval = synaptics_rmi4_reg_write(rmi4_data,
-				base + fwu->off.payload,
-				block_ptr,
-				transfer * fwu->block_size);
-		if (retval < 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to write block data (%d blocks remaining)\n",
-					__func__, remaining);
-			return retval;
-		}
-
-		retval = fwu_wait_for_idle(WRITE_WAIT_MS, false);
-		if (retval < 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to wait for idle status (%d blocks remaining)\n",
-					__func__, remaining);
-			return retval;
-		}
-
-		block_ptr += (transfer * fwu->block_size);
-		remaining -= transfer;
-	} while (remaining);
-
-	return 0;
-}
-
-static int fwu_write_f34_v5v6_blocks(unsigned char *block_ptr,
-		unsigned short block_cnt, unsigned char command)
-{
-	int retval;
-	unsigned char base;
-	unsigned char block_number[] = {0, 0};
-	unsigned short blk;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	base = fwu->f34_fd.data_base_addr;
-
-	block_number[1] |= (fwu->config_area << 5);
+		goto exit;
 
-	retval = synaptics_rmi4_reg_write(rmi4_data,
-			base + fwu->off.block_number,
-			block_number,
-			sizeof(block_number));
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to write block number\n",
-				__func__);
-		return retval;
-	}
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: Entered flash prog mode\n",
+			__func__);
 
-	for (blk = 0; blk < block_cnt; blk++) {
-		retval = synaptics_rmi4_reg_write(rmi4_data,
-				base + fwu->off.payload,
-				block_ptr,
-				fwu->block_size);
-		if (retval < 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to write block data (block %d)\n",
-					__func__, blk);
-			return retval;
+	switch (fwu->config_area) {
+	case UI_CONFIG_AREA:
+		block_count = fwu->config_block_count;
+		break;
+	case PERM_CONFIG_AREA:
+		if (!fwu->has_perm_config) {
+			retval = -EINVAL;
+			goto exit;
 		}
-
-		retval = fwu_write_f34_command(command);
-		if (retval < 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to write command for block %d\n",
-					__func__, blk);
-			return retval;
+		block_count = fwu->perm_config_block_count;
+		break;
+	case BL_CONFIG_AREA:
+		if (!fwu->has_bl_config) {
+			retval = -EINVAL;
+			goto exit;
 		}
-
-		retval = fwu_wait_for_idle(WRITE_WAIT_MS, false);
-		if (retval < 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to wait for idle status (block %d)\n",
-					__func__, blk);
-			return retval;
+		block_count = fwu->bl_config_block_count;
+		break;
+	case DISP_CONFIG_AREA:
+		if (!fwu->has_disp_config) {
+			retval = -EINVAL;
+			goto exit;
 		}
-
-		block_ptr += fwu->block_size;
+		block_count = fwu->disp_config_block_count;
+		break;
+	default:
+		retval = -EINVAL;
+		goto exit;
 	}
 
-	return 0;
-}
-
-static int fwu_write_f34_blocks(unsigned char *block_ptr,
-		unsigned short block_cnt, unsigned char cmd)
-{
-	int retval;
-
-	if (fwu->bl_version == BL_V7 || fwu->bl_version == BL_V8)
-		retval = fwu_write_f34_v7_blocks(block_ptr, block_cnt, cmd);
-	else
-		retval = fwu_write_f34_v5v6_blocks(block_ptr, block_cnt, cmd);
-
-	return retval;
-}
-
-static int fwu_read_f34_v7_blocks(unsigned short block_cnt,
-		unsigned char command)
-{
-	int retval;
-	unsigned char base;
-	unsigned char length[2];
-	unsigned short transfer;
-	unsigned short max_transfer;
-	unsigned short remaining = block_cnt;
-	unsigned short block_number = 0;
-	unsigned short index = 0;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	base = fwu->f34_fd.data_base_addr;
-
-	retval = fwu_write_f34_partition_id(command);
-	if (retval < 0)
-		return retval;
+	fwu->config_size = fwu->block_size * block_count;
 
-	retval = synaptics_rmi4_reg_write(rmi4_data,
-			base + fwu->off.block_number,
-			(unsigned char *)&block_number,
-			sizeof(block_number));
-	if (retval < 0) {
+	kfree(fwu->read_config_buf);
+	fwu->read_config_buf = kzalloc(fwu->config_size, GFP_KERNEL);
+	if (!fwu->read_config_buf) {
 		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to write block number\n",
-				__func__);
-		return retval;
+			"%s: Failed to alloc memory for config buffer\n",
+			__func__);
+		retval = -ENOMEM;
+		goto exit;
 	}
 
-	if (fwu->payload_length > (PAGE_SIZE / fwu->block_size))
-		max_transfer = PAGE_SIZE / fwu->block_size;
-	else
-		max_transfer = fwu->payload_length;
-
-	do {
-		if (remaining / max_transfer)
-			transfer = max_transfer;
-		else
-			transfer = remaining;
-
-		length[0] = (unsigned char)(transfer & MASK_8BIT);
-		length[1] = (unsigned char)(transfer >> 8);
-
-		retval = synaptics_rmi4_reg_write(rmi4_data,
-				base + fwu->off.transfer_length,
-				length,
-				sizeof(length));
-		if (retval < 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to write transfer length (%d blocks remaining)\n",
-					__func__, remaining);
-			return retval;
-		}
-
-		retval = fwu_write_f34_command(command);
-		if (retval < 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to write command (%d blocks remaining)\n",
-					__func__, remaining);
-			return retval;
-		}
-
-		retval = fwu_wait_for_idle(WRITE_WAIT_MS, false);
-		if (retval < 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to wait for idle status (%d blocks remaining)\n",
-					__func__, remaining);
-			return retval;
-		}
-
-		retval = synaptics_rmi4_reg_read(rmi4_data,
-				base + fwu->off.payload,
-				&fwu->read_config_buf[index],
-				transfer * fwu->block_size);
-		if (retval < 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to read block data (%d blocks remaining)\n",
-					__func__, remaining);
-			return retval;
-		}
-
-		index += (transfer * fwu->block_size);
-		remaining -= transfer;
-	} while (remaining);
-
-	return 0;
-}
-
-static int fwu_read_f34_v5v6_blocks(unsigned short block_cnt,
-		unsigned char command)
-{
-	int retval;
-	unsigned char base;
-	unsigned char block_number[] = {0, 0};
-	unsigned short blk;
-	unsigned short index = 0;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	base = fwu->f34_fd.data_base_addr;
-
-	block_number[1] |= (fwu->config_area << 5);
+	block_offset[1] |= (fwu->config_area << 5);
 
 	retval = synaptics_rmi4_reg_write(rmi4_data,
-			base + fwu->off.block_number,
-			block_number,
-			sizeof(block_number));
+			fwu->f34_fd.data_base_addr + BLOCK_NUMBER_OFFSET,
+			block_offset,
+			sizeof(block_offset));
 	if (retval < 0) {
 		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to write block number\n",
+				"%s: Failed to write to block number registers\n",
 				__func__);
-		return retval;
+		goto exit;
 	}
 
-	for (blk = 0; blk < block_cnt; blk++) {
-		retval = fwu_write_f34_command(command);
+	for (block_num = 0; block_num < block_count; block_num++) {
+		retval = fwu_write_f34_command(CMD_READ_CONFIG_BLOCK);
 		if (retval < 0) {
 			dev_err(rmi4_data->pdev->dev.parent,
 					"%s: Failed to write read config command\n",
 					__func__);
-			return retval;
+			goto exit;
 		}
 
-		retval = fwu_wait_for_idle(WRITE_WAIT_MS, false);
+		retval = fwu_wait_for_idle(WRITE_WAIT_MS);
 		if (retval < 0) {
 			dev_err(rmi4_data->pdev->dev.parent,
 					"%s: Failed to wait for idle status\n",
 					__func__);
-			return retval;
+			goto exit;
 		}
 
 		retval = synaptics_rmi4_reg_read(rmi4_data,
-				base + fwu->off.payload,
+				fwu->f34_fd.data_base_addr + fwu->blk_data_off,
 				&fwu->read_config_buf[index],
 				fwu->block_size);
 		if (retval < 0) {
 			dev_err(rmi4_data->pdev->dev.parent,
 					"%s: Failed to read block data (block %d)\n",
-					__func__, blk);
-			return retval;
+					__func__, block_num);
+			goto exit;
 		}
 
 		index += fwu->block_size;
 	}
 
-	return 0;
+exit:
+	rmi4_data->reset_device(rmi4_data);
+
+	return retval;
 }
 
-static int fwu_read_f34_blocks(unsigned short block_cnt, unsigned char cmd)
+static int fwu_do_lockdown(void)
 {
 	int retval;
-
-	if (fwu->bl_version == BL_V7 || fwu->bl_version == BL_V8)
-		retval = fwu_read_f34_v7_blocks(block_cnt, cmd);
-	else
-		retval = fwu_read_f34_v5v6_blocks(block_cnt, cmd);
-
-	return retval;
-}
-
-static int fwu_get_image_firmware_id(unsigned int *fw_id)
-{
-	int retval;
-	unsigned char index = 0;
-	char *strptr;
-	char *firmware_id;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	if (fwu->img.contains_firmware_id) {
-		*fw_id = fwu->img.firmware_id;
-	} else {
-		strptr = strnstr(fwu->image_name, "PR", MAX_IMAGE_NAME_LEN);
-		if (!strptr) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: No valid PR number (PRxxxxxxx) found in image file name (%s)\n",
-					__func__, fwu->image_name);
-			return -EINVAL;
-		}
-
-		strptr += 2;
-		firmware_id = kzalloc(MAX_FIRMWARE_ID_LEN, GFP_KERNEL);
-		if (!firmware_id) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to alloc mem for firmware_id\n",
-					__func__);
-			return -ENOMEM;
-		}
-		while (strptr[index] >= '0' && strptr[index] <= '9') {
-			firmware_id[index] = strptr[index];
-			index++;
-		}
-
-		retval = sstrtoul(firmware_id, 10, (unsigned long *)fw_id);
-		kfree(firmware_id);
-		if (retval) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to obtain image firmware ID\n",
-					__func__);
-			return -EINVAL;
-		}
-	}
-
-	return 0;
-}
-
-static int fwu_get_device_config_id(void)
-{
-	int retval;
-	unsigned char config_id_size;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	if (fwu->bl_version == BL_V7 || fwu->bl_version == BL_V8)
-		config_id_size = V7_CONFIG_ID_SIZE;
-	else
-		config_id_size = V5V6_CONFIG_ID_SIZE;
-
-	retval = synaptics_rmi4_reg_read(rmi4_data,
-				fwu->f34_fd.ctrl_base_addr,
-				fwu->config_id,
-				config_id_size);
-	if (retval < 0)
-		return retval;
-
-	return 0;
-}
-
-static enum flash_area fwu_go_nogo(void)
-{
-	int retval;
-	enum flash_area flash_area = NONE;
-	unsigned char ii;
-	unsigned char config_id_size;
-	unsigned int device_fw_id;
-	unsigned int image_fw_id;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	if (fwu->force_update) {
-		flash_area = UI_FIRMWARE;
-		goto exit;
-	}
-
-	/* Update both UI and config if device is in bootloader mode */
-	if (fwu->in_bl_mode) {
-		flash_area = UI_FIRMWARE;
-		goto exit;
-	}
-
-	/* Get device firmware ID */
-	device_fw_id = rmi4_data->firmware_id;
-	dev_info(rmi4_data->pdev->dev.parent,
-			"%s: Device firmware ID = %d\n",
-			__func__, device_fw_id);
-
-	/* Get image firmware ID */
-	retval = fwu_get_image_firmware_id(&image_fw_id);
-	if (retval < 0) {
-		flash_area = NONE;
-		goto exit;
-	}
-	dev_info(rmi4_data->pdev->dev.parent,
-			"%s: Image firmware ID = %d\n",
-			__func__, image_fw_id);
-
-	if (image_fw_id > device_fw_id) {
-		flash_area = UI_FIRMWARE;
-		goto exit;
-	} else if (image_fw_id < device_fw_id) {
-		dev_info(rmi4_data->pdev->dev.parent,
-				"%s: Image firmware ID older than device firmware ID\n",
-				__func__);
-		flash_area = NONE;
-		goto exit;
-	}
-
-	/* Get device config ID */
-	retval = fwu_get_device_config_id();
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to read device config ID\n",
-				__func__);
-		flash_area = NONE;
-		goto exit;
-	}
-
-	if (fwu->bl_version == BL_V7 || fwu->bl_version == BL_V8)
-		config_id_size = V7_CONFIG_ID_SIZE;
-	else
-		config_id_size = V5V6_CONFIG_ID_SIZE;
-
-	for (ii = 0; ii < config_id_size; ii++) {
-		if (fwu->img.ui_config.data[ii] > fwu->config_id[ii]) {
-			flash_area = UI_CONFIG;
-			goto exit;
-		} else if (fwu->img.ui_config.data[ii] < fwu->config_id[ii]) {
-			flash_area = NONE;
-			goto exit;
-		}
-	}
-
-	flash_area = NONE;
-
-exit:
-	if (flash_area == NONE) {
-		dev_info(rmi4_data->pdev->dev.parent,
-				"%s: No need to do reflash\n",
-				__func__);
-	} else {
-		dev_info(rmi4_data->pdev->dev.parent,
-				"%s: Updating %s\n",
-				__func__,
-				flash_area == UI_FIRMWARE ?
-				"UI firmware and config" :
-				"UI config only");
-	}
-
-	return flash_area;
-}
-
-static int fwu_scan_pdt(void)
-{
-	int retval;
-	unsigned char ii;
-	unsigned char intr_count = 0;
-	unsigned char intr_off;
-	unsigned char intr_src;
-	unsigned short addr;
-	bool f01found = false;
-	bool f34found = false;
-	bool f35found = false;
-	struct synaptics_rmi4_fn_desc rmi_fd;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	fwu->in_ub_mode = false;
-
-	for (addr = PDT_START; addr > PDT_END; addr -= PDT_ENTRY_SIZE) {
-		retval = synaptics_rmi4_reg_read(rmi4_data,
-				addr,
-				(unsigned char *)&rmi_fd,
-				sizeof(rmi_fd));
-		if (retval < 0)
-			return retval;
-
-		if (rmi_fd.fn_number) {
-			dev_dbg(rmi4_data->pdev->dev.parent,
-					"%s: Found F%02x\n",
-					__func__, rmi_fd.fn_number);
-			switch (rmi_fd.fn_number) {
-			case SYNAPTICS_RMI4_F01:
-				f01found = true;
-
-				rmi4_data->f01_query_base_addr =
-						rmi_fd.query_base_addr;
-				rmi4_data->f01_ctrl_base_addr =
-						rmi_fd.ctrl_base_addr;
-				rmi4_data->f01_data_base_addr =
-						rmi_fd.data_base_addr;
-				rmi4_data->f01_cmd_base_addr =
-						rmi_fd.cmd_base_addr;
-				break;
-			case SYNAPTICS_RMI4_F34:
-				f34found = true;
-				fwu->f34_fd.query_base_addr =
-						rmi_fd.query_base_addr;
-				fwu->f34_fd.ctrl_base_addr =
-						rmi_fd.ctrl_base_addr;
-				fwu->f34_fd.data_base_addr =
-						rmi_fd.data_base_addr;
-
-				switch (rmi_fd.fn_version) {
-				case F34_V0:
-					fwu->bl_version = BL_V5;
-					break;
-				case F34_V1:
-					fwu->bl_version = BL_V6;
-					break;
-				case F34_V2:
-					fwu->bl_version = BL_V7;
-					break;
-				default:
-					dev_err(rmi4_data->pdev->dev.parent,
-							"%s: Unrecognized F34 version\n",
-							__func__);
-					return -EINVAL;
-				}
-
-				fwu->intr_mask = 0;
-				intr_src = rmi_fd.intr_src_count;
-				intr_off = intr_count % 8;
-				for (ii = intr_off;
-						ii < (intr_src + intr_off);
-						ii++) {
-					fwu->intr_mask |= 1 << ii;
-				}
-				break;
-			case SYNAPTICS_RMI4_F35:
-				f35found = true;
-				fwu->f35_fd.query_base_addr =
-						rmi_fd.query_base_addr;
-				fwu->f35_fd.ctrl_base_addr =
-						rmi_fd.ctrl_base_addr;
-				fwu->f35_fd.data_base_addr =
-						rmi_fd.data_base_addr;
-				break;
-			}
-		} else {
-			break;
-		}
-
-		intr_count += rmi_fd.intr_src_count;
-	}
-
-	if (!f01found || !f34found) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to find both F01 and F34\n",
-				__func__);
-		if (!f35found) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to find F35\n",
-					__func__);
-			return -EINVAL;
-		} else {
-			fwu->in_ub_mode = true;
-			dev_dbg(rmi4_data->pdev->dev.parent,
-					"%s: In microbootloader mode\n",
-					__func__);
-			fwu_recovery_check_status();
-			return 0;
-		}
-	}
-
-	rmi4_data->intr_mask[0] |= fwu->intr_mask;
-
-	addr = rmi4_data->f01_ctrl_base_addr + 1;
-
-	retval = synaptics_rmi4_reg_write(rmi4_data,
-			addr,
-			&(rmi4_data->intr_mask[0]),
-			sizeof(rmi4_data->intr_mask[0]));
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to set interrupt enable bit\n",
-				__func__);
-		return retval;
-	}
-
-	return 0;
-}
-
-static int fwu_enter_flash_prog(void)
-{
-	int retval;
-	struct f01_device_control f01_device_control;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	retval = fwu_read_flash_status();
-	if (retval < 0)
-		return retval;
-
-	if (fwu->in_bl_mode)
-		return 0;
-
-	retval = rmi4_data->irq_enable(rmi4_data, false, true);
-	if (retval < 0)
-		return retval;
-
-	msleep(INT_DISABLE_WAIT_MS);
-
-	retval = fwu_write_f34_command(CMD_ENABLE_FLASH_PROG);
-	if (retval < 0)
-		return retval;
-
-	retval = fwu_wait_for_idle(ENABLE_WAIT_MS, false);
-	if (retval < 0)
-		return retval;
-
-	if (!fwu->in_bl_mode) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: BL mode not entered\n",
-				__func__);
-		return -EINVAL;
-	}
-
-	if (rmi4_data->hw_if->bl_hw_init) {
-		retval = rmi4_data->hw_if->bl_hw_init(rmi4_data);
-		if (retval < 0)
-			return retval;
-	}
-
-	retval = fwu_scan_pdt();
-	if (retval < 0)
-		return retval;
-
-	retval = fwu_read_f34_queries();
-	if (retval < 0)
-		return retval;
-
-	retval = synaptics_rmi4_reg_read(rmi4_data,
-			rmi4_data->f01_ctrl_base_addr,
-			f01_device_control.data,
-			sizeof(f01_device_control.data));
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to read F01 device control\n",
-				__func__);
-		return retval;
-	}
-
-	f01_device_control.nosleep = true;
-	f01_device_control.sleep_mode = SLEEP_MODE_NORMAL;
-
-	retval = synaptics_rmi4_reg_write(rmi4_data,
-			rmi4_data->f01_ctrl_base_addr,
-			f01_device_control.data,
-			sizeof(f01_device_control.data));
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to write F01 device control\n",
-				__func__);
-		return retval;
-	}
-
-	msleep(ENTER_FLASH_PROG_WAIT_MS);
-
-	return retval;
-}
-
-static int fwu_check_ui_firmware_size(void)
-{
-	unsigned short block_count;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	block_count = fwu->img.ui_firmware.size / fwu->block_size;
-
-	if (block_count != fwu->blkcount.ui_firmware) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: UI firmware size mismatch\n",
-				__func__);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int fwu_check_ui_configuration_size(void)
-{
-	unsigned short block_count;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	block_count = fwu->img.ui_config.size / fwu->block_size;
-
-	if (block_count != fwu->blkcount.ui_config) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: UI configuration size mismatch\n",
-				__func__);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int fwu_check_dp_configuration_size(void)
-{
-	unsigned short block_count;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	block_count = fwu->img.dp_config.size / fwu->block_size;
-
-	if (block_count != fwu->blkcount.dp_config) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Display configuration size mismatch\n",
-				__func__);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int fwu_check_pm_configuration_size(void)
-{
-	unsigned short block_count;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	block_count = fwu->img.pm_config.size / fwu->block_size;
-
-	if (block_count != fwu->blkcount.pm_config) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Permanent configuration size mismatch\n",
-				__func__);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int fwu_check_bl_configuration_size(void)
-{
-	unsigned short block_count;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	block_count = fwu->img.bl_config.size / fwu->block_size;
-
-	if (block_count != fwu->blkcount.bl_config) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Bootloader configuration size mismatch\n",
-				__func__);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int fwu_check_guest_code_size(void)
-{
-	unsigned short block_count;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	block_count = fwu->img.guest_code.size / fwu->block_size;
-	if (block_count != fwu->blkcount.guest_code) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Guest code size mismatch\n",
-				__func__);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int fwu_write_firmware(void)
-{
-	unsigned short firmware_block_count;
-
-	firmware_block_count = fwu->img.ui_firmware.size / fwu->block_size;
-
-	return fwu_write_f34_blocks((unsigned char *)fwu->img.ui_firmware.data,
-			firmware_block_count, CMD_WRITE_FW);
-}
-
-static int fwu_erase_configuration(void)
-{
-	int retval;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	switch (fwu->config_area) {
-	case UI_CONFIG_AREA:
-		retval = fwu_write_f34_command(CMD_ERASE_UI_CONFIG);
-		if (retval < 0)
-			return retval;
-		break;
-	case DP_CONFIG_AREA:
-		retval = fwu_write_f34_command(CMD_ERASE_DISP_CONFIG);
-		if (retval < 0)
-			return retval;
-		break;
-	case BL_CONFIG_AREA:
-		retval = fwu_write_f34_command(CMD_ERASE_BL_CONFIG);
-		if (retval < 0)
-			return retval;
-		break;
-	}
-
-	dev_dbg(rmi4_data->pdev->dev.parent,
-			"%s: Erase command written\n",
-			__func__);
-
-	retval = fwu_wait_for_idle(ERASE_WAIT_MS, false);
-	if (retval < 0)
-		return retval;
-
-	dev_dbg(rmi4_data->pdev->dev.parent,
-			"%s: Idle status detected\n",
-			__func__);
-
-	return retval;
-}
-
-static int fwu_erase_guest_code(void)
-{
-	int retval;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	retval = fwu_write_f34_command(CMD_ERASE_GUEST_CODE);
-	if (retval < 0)
-		return retval;
-
-	dev_dbg(rmi4_data->pdev->dev.parent,
-			"%s: Erase command written\n",
-			__func__);
-
-	retval = fwu_wait_for_idle(ERASE_WAIT_MS, false);
-	if (retval < 0)
-		return retval;
-
-	dev_dbg(rmi4_data->pdev->dev.parent,
-			"%s: Idle status detected\n",
-			__func__);
-
-	return 0;
-}
-
-static int fwu_erase_all(void)
-{
-	int retval;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	if (fwu->bl_version == BL_V7) {
-		retval = fwu_write_f34_command(CMD_ERASE_UI_FIRMWARE);
-		if (retval < 0)
-			return retval;
-
-		dev_dbg(rmi4_data->pdev->dev.parent,
-				"%s: Erase command written\n",
-				__func__);
-
-		retval = fwu_wait_for_idle(ERASE_WAIT_MS, false);
-		if (retval < 0)
-			return retval;
-
-		dev_dbg(rmi4_data->pdev->dev.parent,
-				"%s: Idle status detected\n",
-				__func__);
-
-		fwu->config_area = UI_CONFIG_AREA;
-		retval = fwu_erase_configuration();
-		if (retval < 0)
-			return retval;
-	} else {
-		retval = fwu_write_f34_command(CMD_ERASE_ALL);
-		if (retval < 0)
-			return retval;
-
-		dev_dbg(rmi4_data->pdev->dev.parent,
-				"%s: Erase all command written\n",
-				__func__);
-
-		retval = fwu_wait_for_idle(ERASE_WAIT_MS, false);
-		if (!(fwu->bl_version == BL_V8 &&
-				fwu->flash_status == BAD_PARTITION_TABLE)) {
-			if (retval < 0)
-				return retval;
-		}
-
-		dev_dbg(rmi4_data->pdev->dev.parent,
-				"%s: Idle status detected\n",
-				__func__);
-
-		if (fwu->bl_version == BL_V8)
-			return 0;
-	}
-
-	if (fwu->flash_properties.has_disp_config &&
-			fwu->img.contains_disp_config) {
-		fwu->config_area = DP_CONFIG_AREA;
-		retval = fwu_erase_configuration();
-		if (retval < 0)
-			return retval;
-	}
-
-	if (fwu->has_guest_code && fwu->img.contains_guest_code) {
-		retval = fwu_erase_guest_code();
-		if (retval < 0)
-			return retval;
-	}
-
-	return 0;
-}
-
-static int fwu_write_configuration(void)
-{
-	return fwu_write_f34_blocks((unsigned char *)fwu->config_data,
-			fwu->config_block_count, CMD_WRITE_CONFIG);
-}
-
-static int fwu_write_ui_configuration(void)
-{
-	fwu->config_area = UI_CONFIG_AREA;
-	fwu->config_data = fwu->img.ui_config.data;
-	fwu->config_size = fwu->img.ui_config.size;
-	fwu->config_block_count = fwu->config_size / fwu->block_size;
-
-	return fwu_write_configuration();
-}
-
-static int fwu_write_dp_configuration(void)
-{
-	fwu->config_area = DP_CONFIG_AREA;
-	fwu->config_data = fwu->img.dp_config.data;
-	fwu->config_size = fwu->img.dp_config.size;
-	fwu->config_block_count = fwu->config_size / fwu->block_size;
-
-	return fwu_write_configuration();
-}
-
-static int fwu_write_pm_configuration(void)
-{
-	fwu->config_area = PM_CONFIG_AREA;
-	fwu->config_data = fwu->img.pm_config.data;
-	fwu->config_size = fwu->img.pm_config.size;
-	fwu->config_block_count = fwu->config_size / fwu->block_size;
-
-	return fwu_write_configuration();
-}
-
-static int fwu_write_flash_configuration(void)
-{
-	int retval;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	fwu->config_area = FLASH_CONFIG_AREA;
-	fwu->config_data = fwu->img.fl_config.data;
-	fwu->config_size = fwu->img.fl_config.size;
-	fwu->config_block_count = fwu->config_size / fwu->block_size;
-
-	if (fwu->config_block_count != fwu->blkcount.fl_config) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Flash configuration size mismatch\n",
-				__func__);
-		return -EINVAL;
-	}
-
-	retval = fwu_write_f34_command(CMD_ERASE_FLASH_CONFIG);
-	if (retval < 0)
-		return retval;
-
-	dev_dbg(rmi4_data->pdev->dev.parent,
-			"%s: Erase flash configuration command written\n",
-			__func__);
-
-	retval = fwu_wait_for_idle(ERASE_WAIT_MS, false);
-	if (retval < 0)
-		return retval;
-
-	dev_dbg(rmi4_data->pdev->dev.parent,
-			"%s: Idle status detected\n",
-			__func__);
-
-	retval = fwu_write_configuration();
-	if (retval < 0)
-		return retval;
-
-	rmi4_data->reset_device(rmi4_data, false);
-
-	return 0;
-}
-
-static int fwu_write_guest_code(void)
-{
-	int retval;
-	unsigned short guest_code_block_count;
-
-	guest_code_block_count = fwu->img.guest_code.size / fwu->block_size;
-
-	retval = fwu_write_f34_blocks((unsigned char *)fwu->img.guest_code.data,
-			guest_code_block_count, CMD_WRITE_GUEST_CODE);
-	if (retval < 0)
-		return retval;
-
-	return 0;
-}
-
-static int fwu_write_lockdown(void)
-{
-	unsigned short lockdown_block_count;
-
-	lockdown_block_count = fwu->img.lockdown.size / fwu->block_size;
-
-	return fwu_write_f34_blocks((unsigned char *)fwu->img.lockdown.data,
-			lockdown_block_count, CMD_WRITE_LOCKDOWN);
-}
-
-static int fwu_write_partition_table_v8(void)
-{
-	int retval;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	fwu->config_area = FLASH_CONFIG_AREA;
-	fwu->config_data = fwu->img.fl_config.data;
-	fwu->config_size = fwu->img.fl_config.size;
-	fwu->config_block_count = fwu->config_size / fwu->block_size;
-
-	if (fwu->config_block_count != fwu->blkcount.fl_config) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Flash configuration size mismatch\n",
-				__func__);
-		return -EINVAL;
-	}
-
-	retval = fwu_write_configuration();
-	if (retval < 0)
-		return retval;
-
-	rmi4_data->reset_device(rmi4_data, false);
-
-	return 0;
-}
-
-static int fwu_write_partition_table_v7(void)
-{
-	int retval;
-	unsigned short block_count;
-
-	block_count = fwu->blkcount.bl_config;
-	fwu->config_area = BL_CONFIG_AREA;
-	fwu->config_size = fwu->block_size * block_count;
-
-	retval = fwu_allocate_read_config_buf(fwu->config_size);
-	if (retval < 0)
-		return retval;
-
-	retval = fwu_read_f34_blocks(block_count, CMD_READ_CONFIG);
-	if (retval < 0)
-		return retval;
-
-	retval = fwu_erase_configuration();
-	if (retval < 0)
-		return retval;
-
-	retval = fwu_write_flash_configuration();
-	if (retval < 0)
-		return retval;
-
-	fwu->config_area = BL_CONFIG_AREA;
-	fwu->config_data = fwu->read_config_buf;
-	fwu->config_size = fwu->img.bl_config.size;
-	fwu->config_block_count = fwu->config_size / fwu->block_size;
-
-	retval = fwu_write_configuration();
-	if (retval < 0)
-		return retval;
-
-	return 0;
-}
-
-static int fwu_do_reflash(void)
-{
-	int retval;
-
-	if (!fwu->new_partition_table) {
-		retval = fwu_check_ui_firmware_size();
-		if (retval < 0)
-			return retval;
-
-		retval = fwu_check_ui_configuration_size();
-		if (retval < 0)
-			return retval;
-
-		if (fwu->flash_properties.has_disp_config &&
-				fwu->img.contains_disp_config) {
-			retval = fwu_check_dp_configuration_size();
-			if (retval < 0)
-				return retval;
-		}
-
-		if (fwu->has_guest_code && fwu->img.contains_guest_code) {
-			retval = fwu_check_guest_code_size();
-			if (retval < 0)
-				return retval;
-		}
-	} else if (fwu->bl_version == BL_V7) {
-		retval = fwu_check_bl_configuration_size();
-		if (retval < 0)
-			return retval;
-	}
-
-	retval = fwu_erase_all();
-	if (retval < 0)
-		return retval;
-
-	if (fwu->bl_version == BL_V7 && fwu->new_partition_table) {
-		retval = fwu_write_partition_table_v7();
-		if (retval < 0)
-			return retval;
-		pr_notice("%s: Partition table programmed\n", __func__);
-	} else if (fwu->bl_version == BL_V8) {
-		retval = fwu_write_partition_table_v8();
-		if (retval < 0)
-			return retval;
-		pr_notice("%s: Partition table programmed\n", __func__);
-	}
-
-	retval = fwu_write_firmware();
-	if (retval < 0)
-		return retval;
-	pr_notice("%s: Firmware programmed\n", __func__);
-
-	fwu->config_area = UI_CONFIG_AREA;
-	retval = fwu_write_ui_configuration();
-	if (retval < 0)
-		return retval;
-	pr_notice("%s: Configuration programmed\n", __func__);
-
-	if (fwu->flash_properties.has_disp_config &&
-			fwu->img.contains_disp_config) {
-		retval = fwu_write_dp_configuration();
-		if (retval < 0)
-			return retval;
-		pr_notice("%s: Display configuration programmed\n", __func__);
-	}
-
-	if (fwu->has_guest_code && fwu->img.contains_guest_code) {
-		retval = fwu_write_guest_code();
-		if (retval < 0)
-			return retval;
-		pr_notice("%s: Guest code programmed\n", __func__);
-	}
-
-	return retval;
-}
-
-static int fwu_do_read_config(void)
-{
-	int retval;
-	unsigned short block_count;
-	unsigned short config_area;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	switch (fwu->config_area) {
-	case UI_CONFIG_AREA:
-		block_count = fwu->blkcount.ui_config;
-		break;
-	case DP_CONFIG_AREA:
-		if (!fwu->flash_properties.has_disp_config) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Display configuration not supported\n",
-					__func__);
-			return -EINVAL;
-		}
-		block_count = fwu->blkcount.dp_config;
-		break;
-	case PM_CONFIG_AREA:
-		if (!fwu->flash_properties.has_pm_config) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Permanent configuration not supported\n",
-					__func__);
-			return -EINVAL;
-		}
-		block_count = fwu->blkcount.pm_config;
-		break;
-	case BL_CONFIG_AREA:
-		if (!fwu->flash_properties.has_bl_config) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Bootloader configuration not supported\n",
-					__func__);
-			return -EINVAL;
-		}
-		block_count = fwu->blkcount.bl_config;
-		break;
-	default:
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Invalid config area\n",
-				__func__);
-		return -EINVAL;
-	}
-
-	if (block_count == 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Invalid block count\n",
-				__func__);
-		return -EINVAL;
-	}
-
-	mutex_lock(&rmi4_data->rmi4_exp_init_mutex);
-
-	config_area = fwu->config_area;
-
-	retval = fwu_enter_flash_prog();
-	if (retval < 0)
-		goto exit;
-
-	fwu->config_area = config_area;
-
-	fwu->config_size = fwu->block_size * block_count;
-
-	retval = fwu_allocate_read_config_buf(fwu->config_size);
-	if (retval < 0)
-		goto exit;
-
-	retval = fwu_read_f34_blocks(block_count, CMD_READ_CONFIG);
-
-exit:
-	rmi4_data->reset_device(rmi4_data, false);
-
-	mutex_unlock(&rmi4_data->rmi4_exp_init_mutex);
-
-	return retval;
-}
-
-static int fwu_do_lockdown_v7(void)
-{
-	int retval;
-	struct f34_v7_data0 status;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	retval = fwu_enter_flash_prog();
-	if (retval < 0)
-		return retval;
-
-	retval = synaptics_rmi4_reg_read(rmi4_data,
-			fwu->f34_fd.data_base_addr + fwu->off.flash_status,
-			status.data,
-			sizeof(status.data));
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to read flash status\n",
-				__func__);
-		return retval;
-	}
-
-	if (status.device_cfg_status == 2) {
-		dev_info(rmi4_data->pdev->dev.parent,
-				"%s: Device already locked down\n",
-				__func__);
-		return 0;
-	}
-
-	retval = fwu_write_lockdown();
-	if (retval < 0)
-		return retval;
-
-	pr_notice("%s: Lockdown programmed\n", __func__);
-
-	return retval;
-}
-
-static int fwu_do_lockdown_v5v6(void)
-{
-	int retval;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	retval = fwu_enter_flash_prog();
-	if (retval < 0)
-		return retval;
-
-	retval = synaptics_rmi4_reg_read(rmi4_data,
-			fwu->f34_fd.query_base_addr + fwu->off.properties,
-			fwu->flash_properties.data,
-			sizeof(fwu->flash_properties.data));
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to read flash properties\n",
-				__func__);
-		return retval;
-	}
-
-	if (fwu->flash_properties.unlocked == 0) {
-		dev_info(rmi4_data->pdev->dev.parent,
-				"%s: Device already locked down\n",
-				__func__);
-		return 0;
-	}
-
-	retval = fwu_write_lockdown();
-	if (retval < 0)
-		return retval;
-
-	pr_notice("%s: Lockdown programmed\n", __func__);
-
-	return retval;
-}
-
-static int fwu_start_write_guest_code(void)
-{
-	int retval;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	retval = fwu_parse_image_info();
-	if (retval < 0)
-		return -EINVAL;
-
-	if (!fwu->has_guest_code) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Guest code not supported\n",
-				__func__);
-		return -EINVAL;
-	}
-
-	if (!fwu->img.contains_guest_code) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: No guest code in firmware image\n",
-				__func__);
-		return -EINVAL;
-	}
-
-	if (rmi4_data->sensor_sleep) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Sensor sleeping\n",
-				__func__);
-		return -ENODEV;
-	}
-
-	rmi4_data->stay_awake = true;
-
-	mutex_lock(&rmi4_data->rmi4_exp_init_mutex);
-
-	pr_notice("%s: Start of write guest code process\n", __func__);
-
-	retval = fwu_enter_flash_prog();
-	if (retval < 0)
-		goto exit;
-
-	retval = fwu_check_guest_code_size();
-	if (retval < 0)
-		goto exit;
-
-	retval = fwu_erase_guest_code();
-	if (retval < 0)
-		goto exit;
-
-	retval = fwu_write_guest_code();
-	if (retval < 0)
-		goto exit;
-
-	pr_notice("%s: Guest code programmed\n", __func__);
-
-exit:
-	rmi4_data->reset_device(rmi4_data, false);
-
-	pr_notice("%s: End of write guest code process\n", __func__);
-
-	mutex_unlock(&rmi4_data->rmi4_exp_init_mutex);
-
-	rmi4_data->stay_awake = false;
-
-	return retval;
-}
-
-static int fwu_start_write_config(void)
-{
-	int retval;
-	unsigned short config_area;
-	unsigned int device_fw_id;
-	unsigned int image_fw_id;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	retval = fwu_parse_image_info();
-	if (retval < 0)
-		return -EINVAL;
-
-	switch (fwu->config_area) {
-	case UI_CONFIG_AREA:
-		device_fw_id = rmi4_data->firmware_id;
-		retval = fwu_get_image_firmware_id(&image_fw_id);
-		if (retval < 0)
-			return retval;
-		if (device_fw_id != image_fw_id) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Device and image firmware IDs don't match\n",
-					__func__);
-			return -EINVAL;
-		}
-		retval = fwu_check_ui_configuration_size();
-		if (retval < 0)
-			return retval;
-		break;
-	case DP_CONFIG_AREA:
-		if (!fwu->flash_properties.has_disp_config) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Display configuration not supported\n",
-					__func__);
-			return -EINVAL;
-		}
-		if (!fwu->img.contains_disp_config) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: No display configuration in firmware image\n",
-					__func__);
-			return -EINVAL;
-		}
-		retval = fwu_check_dp_configuration_size();
-		if (retval < 0)
-			return retval;
-		break;
-	case PM_CONFIG_AREA:
-		if (!fwu->flash_properties.has_pm_config) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Permanent configuration not supported\n",
-					__func__);
-			return -EINVAL;
-		}
-		if (!fwu->img.contains_perm_config) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: No permanent configuration in firmware image\n",
-					__func__);
-			return -EINVAL;
-		}
-		retval = fwu_check_pm_configuration_size();
-		if (retval < 0)
-			return retval;
-		break;
-	default:
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Configuration not supported\n",
-				__func__);
-		return -EINVAL;
-	}
-
-	if (rmi4_data->sensor_sleep) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Sensor sleeping\n",
-				__func__);
-		return -ENODEV;
-	}
-
-	rmi4_data->stay_awake = true;
-
-	mutex_lock(&rmi4_data->rmi4_exp_init_mutex);
-
-	pr_notice("%s: Start of write config process\n", __func__);
-
-	config_area = fwu->config_area;
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
 
 	retval = fwu_enter_flash_prog();
 	if (retval < 0)
-		goto exit;
-
-	fwu->config_area = config_area;
-
-	if (fwu->config_area != PM_CONFIG_AREA) {
-		retval = fwu_erase_configuration();
-		if (retval < 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to erase config\n",
-					__func__);
-			goto exit;
-		}
-	}
-
-	switch (fwu->config_area) {
-	case UI_CONFIG_AREA:
-		retval = fwu_write_ui_configuration();
-		if (retval < 0)
-			goto exit;
-		break;
-	case DP_CONFIG_AREA:
-		retval = fwu_write_dp_configuration();
-		if (retval < 0)
-			goto exit;
-		break;
-	case PM_CONFIG_AREA:
-		retval = fwu_write_pm_configuration();
-		if (retval < 0)
-			goto exit;
-		break;
-	}
-
-	pr_notice("%s: Config written\n", __func__);
-
-exit:
-	switch (fwu->config_area) {
-	case UI_CONFIG_AREA:
-		rmi4_data->reset_device(rmi4_data, true);
-		break;
-	case DP_CONFIG_AREA:
-	case PM_CONFIG_AREA:
-		rmi4_data->reset_device(rmi4_data, false);
-		break;
-	}
-
-	pr_notice("%s: End of write config process\n", __func__);
-
-	mutex_unlock(&rmi4_data->rmi4_exp_init_mutex);
-
-	rmi4_data->stay_awake = false;
-
-	return retval;
-}
-
-static int fwu_start_reflash(void)
-{
-	int retval = 0;
-	enum flash_area flash_area;
-	const struct firmware *fw_entry = NULL;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	if (rmi4_data->sensor_sleep) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Sensor sleeping\n",
-				__func__);
-		return -ENODEV;
-	}
-
-	rmi4_data->stay_awake = true;
-
-	mutex_lock(&rmi4_data->rmi4_exp_init_mutex);
-
-	pr_notice("%s: Start of reflash process\n", __func__);
-
-	if (fwu->image == NULL) {
-		retval = secure_memcpy(fwu->image_name, MAX_IMAGE_NAME_LEN,
-				FW_IMAGE_NAME, sizeof(FW_IMAGE_NAME),
-				sizeof(FW_IMAGE_NAME));
-		if (retval < 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to copy image file name\n",
-					__func__);
-			goto exit;
-		}
-		dev_dbg(rmi4_data->pdev->dev.parent,
-				"%s: Requesting firmware image %s\n",
-				__func__, fwu->image_name);
-
-		retval = request_firmware(&fw_entry, fwu->image_name,
-				rmi4_data->pdev->dev.parent);
-		if (retval != 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Firmware image %s not available\n",
-					__func__, fwu->image_name);
-			retval = -EINVAL;
-			goto exit;
-		}
-
-		dev_dbg(rmi4_data->pdev->dev.parent,
-				"%s: Firmware image size = %d\n",
-				__func__, (unsigned int)fw_entry->size);
-
-		fwu->image = fw_entry->data;
-	}
-
-	retval = fwu_parse_image_info();
-	if (retval < 0)
-		goto exit;
-
-	if (fwu->blkcount.total_count != fwu->img.blkcount.total_count) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Flash size mismatch\n",
-				__func__);
-		retval = -EINVAL;
-		goto exit;
-	}
-
-	if (fwu->bl_version != fwu->img.bl_version) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Bootloader version mismatch\n",
-				__func__);
-		retval = -EINVAL;
-		goto exit;
-	}
-
-	if (!fwu->force_update && fwu->new_partition_table) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Partition table mismatch\n",
-				__func__);
-		retval = -EINVAL;
-		goto exit;
-	}
-
-	retval = fwu_read_flash_status();
-	if (retval < 0)
-		goto exit;
-
-	if (fwu->in_bl_mode) {
-		dev_info(rmi4_data->pdev->dev.parent,
-				"%s: Device in bootloader mode\n",
-				__func__);
-	}
-
-	flash_area = fwu_go_nogo();
-
-	if (flash_area != NONE) {
-		retval = fwu_enter_flash_prog();
-		if (retval < 0) {
-			rmi4_data->reset_device(rmi4_data, false);
-			goto exit;
-		}
-	}
-
-	switch (flash_area) {
-	case UI_FIRMWARE:
-		retval = fwu_do_reflash();
-		rmi4_data->reset_device(rmi4_data, true);
-		break;
-	case UI_CONFIG:
-		retval = fwu_check_ui_configuration_size();
-		if (retval < 0)
-			break;
-		fwu->config_area = UI_CONFIG_AREA;
-		retval = fwu_erase_configuration();
-		if (retval < 0)
-			break;
-		retval = fwu_write_ui_configuration();
-		rmi4_data->reset_device(rmi4_data, true);
-		break;
-	case NONE:
-	default:
-		rmi4_data->reset_device(rmi4_data, false);
-		break;
-	}
-
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to do reflash\n",
-				__func__);
-		goto exit;
-	}
-
-	if (fwu->do_lockdown && (fwu->img.lockdown.data != NULL)) {
-		switch (fwu->bl_version) {
-		case BL_V5:
-		case BL_V6:
-			retval = fwu_do_lockdown_v5v6();
-			if (retval < 0) {
-				dev_err(rmi4_data->pdev->dev.parent,
-						"%s: Failed to do lockdown\n",
-						__func__);
-			}
-			rmi4_data->reset_device(rmi4_data, false);
-			break;
-		case BL_V7:
-		case BL_V8:
-			retval = fwu_do_lockdown_v7();
-			if (retval < 0) {
-				dev_err(rmi4_data->pdev->dev.parent,
-						"%s: Failed to do lockdown\n",
-						__func__);
-			}
-			rmi4_data->reset_device(rmi4_data, false);
-			break;
-		default:
-			break;
-		}
-	}
-
-exit:
-	if (fw_entry)
-		release_firmware(fw_entry);
-
-	pr_notice("%s: End of reflash process\n", __func__);
-
-	mutex_unlock(&rmi4_data->rmi4_exp_init_mutex);
-
-	rmi4_data->stay_awake = false;
-
-	return retval;
-}
-
-static int fwu_recovery_check_status(void)
-{
-	int retval;
-	unsigned char base;
-	unsigned char status;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	base = fwu->f35_fd.data_base_addr;
-
-	retval = synaptics_rmi4_reg_read(rmi4_data,
-			base + F35_ERROR_CODE_OFFSET,
-			&status,
-			1);
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to read status\n",
-				__func__);
-		return retval;
-	}
-
-	status = status & MASK_7BIT;
-
-	if (status != 0x00) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Recovery mode status = %d\n",
-				__func__, status);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int fwu_recovery_erase_all(void)
-{
-	int retval;
-	unsigned char base;
-	unsigned char command = CMD_F35_ERASE_ALL;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	base = fwu->f35_fd.ctrl_base_addr;
-
-	retval = synaptics_rmi4_reg_write(rmi4_data,
-			base + F35_CHUNK_COMMAND_OFFSET,
-			&command,
-			sizeof(command));
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to issue erase all command\n",
-				__func__);
-		return retval;
-	}
-
-	msleep(F35_ERASE_ALL_WAIT_MS);
-
-	retval = fwu_recovery_check_status();
-	if (retval < 0)
-		return retval;
-
-	return 0;
-}
-
-static int fwu_recovery_write_chunk(void)
-{
-	int retval;
-	unsigned char base;
-	unsigned char chunk_number[] = {0, 0};
-	unsigned char chunk_spare;
-	unsigned char chunk_size;
-	unsigned char buf[F35_CHUNK_SIZE + 1];
-	unsigned short chunk;
-	unsigned short chunk_total;
-	unsigned short bytes_written = 0;
-	unsigned char *chunk_ptr = (unsigned char *)fwu->image;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	base = fwu->f35_fd.ctrl_base_addr;
-
-	retval = synaptics_rmi4_reg_write(rmi4_data,
-			base + F35_CHUNK_NUM_LSB_OFFSET,
-			chunk_number,
-			sizeof(chunk_number));
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to write chunk number\n",
-				__func__);
-		return retval;
-	}
-
-	buf[sizeof(buf) - 1] = CMD_F35_WRITE_CHUNK;
-
-	chunk_total = fwu->image_size / F35_CHUNK_SIZE;
-	chunk_spare = fwu->image_size % F35_CHUNK_SIZE;
-	if (chunk_spare)
-		chunk_total++;
-
-	for (chunk = 0; chunk < chunk_total; chunk++) {
-		if (chunk_spare && chunk == chunk_total - 1)
-			chunk_size = chunk_spare;
-		else
-			chunk_size = F35_CHUNK_SIZE;
-
-		memset(buf, 0x00, F35_CHUNK_SIZE);
-		secure_memcpy(buf, sizeof(buf), chunk_ptr,
-					fwu->image_size - bytes_written,
-					chunk_size);
-
-		retval = synaptics_rmi4_reg_write(rmi4_data,
-				base + F35_CHUNK_DATA_OFFSET,
-				buf,
-				sizeof(buf));
-		if (retval < 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to write chunk data (chunk %d)\n",
-					__func__, chunk);
-			return retval;
-		}
-		chunk_ptr += chunk_size;
-		bytes_written += chunk_size;
-	}
-
-	retval = fwu_recovery_check_status();
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to write chunk data\n",
-				__func__);
-		return retval;
-	}
-
-	return 0;
-}
-
-static int fwu_recovery_reset(void)
-{
-	int retval;
-	unsigned char base;
-	unsigned char command = CMD_F35_RESET;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	base = fwu->f35_fd.ctrl_base_addr;
+		return retval;
 
-	retval = synaptics_rmi4_reg_write(rmi4_data,
-			base + F35_CHUNK_COMMAND_OFFSET,
-			&command,
-			sizeof(command));
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			fwu->f34_fd.query_base_addr + fwu->properties_off,
+			&fwu->flash_properties,
+			sizeof(fwu->flash_properties));
 	if (retval < 0) {
 		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to issue reset command\n",
+				"%s: Failed to read flash properties\n",
+				__func__);
+		return retval;
+	}
+
+	if ((fwu->flash_properties & UNLOCKED) == 0) {
+		dev_info(rmi4_data->pdev->dev.parent,
+				"%s: Device already locked down\n",
 				__func__);
 		return retval;
 	}
 
-	msleep(F35_RESET_WAIT_MS);
+	retval = fwu_write_lockdown();
+	if (retval < 0)
+		return retval;
 
-	return 0;
+	pr_notice("%s: Lockdown programmed\n", __func__);
+
+	return retval;
 }
 
-static int fwu_start_recovery(void)
+static int fwu_start_reflash(void)
 {
-	int retval;
+	int retval = 0;
+	enum flash_area flash_area;
+	struct image_header_data header;
+	struct f01_device_status f01_device_status;
+	const unsigned char *fw_image;
+	const struct firmware *fw_entry = NULL;
 	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
 
 	if (rmi4_data->sensor_sleep) {
@@ -3734,63 +1448,113 @@ static int fwu_start_recovery(void)
 
 	rmi4_data->stay_awake = true;
 
-	mutex_lock(&rmi4_data->rmi4_exp_init_mutex);
+	pr_notice("%s: Start of reflash process\n", __func__);
 
-	pr_notice("%s: Start of recovery process\n", __func__);
+	if (fwu->ext_data_source) {
+		fw_image = fwu->ext_data_source;
+	} else {
+		dev_dbg(rmi4_data->pdev->dev.parent,
+				"%s: Requesting firmware image %s\n",
+				__func__, fwu->image_name);
 
-	retval = rmi4_data->irq_enable(rmi4_data, false, false);
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to disable interrupt\n",
-				__func__);
-		goto exit;
+		retval = request_firmware(&fw_entry, fwu->image_name,
+				rmi4_data->pdev->dev.parent);
+		if (retval != 0) {
+			dev_err(rmi4_data->pdev->dev.parent,
+					"%s: Firmware image %s not available\n",
+					__func__, fwu->image_name);
+			rmi4_data->stay_awake = false;
+			return retval;
+		}
+
+		dev_dbg(rmi4_data->pdev->dev.parent,
+				"%s: Firmware image size = %zu\n",
+				__func__, fw_entry->size);
+
+		fw_image = fw_entry->data;
 	}
 
-	retval = fwu_recovery_erase_all();
-	if (retval < 0) {
+	parse_header(&header, fw_image);
+
+	if (fwu->bl_version != header.bootloader_version) {
 		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to do erase all in recovery mode\n",
+				"%s: Bootloader version mismatch\n",
 				__func__);
+		retval = -EINVAL;
 		goto exit;
 	}
 
-	pr_notice("%s: External flash erased\n", __func__);
+	retval = fwu_read_f01_device_status(&f01_device_status);
+	if (retval < 0)
+		goto exit;
 
-	retval = fwu_recovery_write_chunk();
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to write chunk data in recovery mode\n",
+	if (f01_device_status.flash_prog) {
+		dev_info(rmi4_data->pdev->dev.parent,
+				"%s: In flash prog mode\n",
 				__func__);
-		goto exit;
+		fwu->in_flash_prog_mode = true;
+	} else {
+		fwu->in_flash_prog_mode = false;
+	}
+
+	if (fwu->do_lockdown) {
+		switch (fwu->bl_version) {
+		case V5:
+		case V6:
+			fwu->lockdown_data = fw_image + LOCKDOWN_OFFSET;
+			fwu->lockdown_block_count = LOCKDOWN_BLOCK_COUNT;
+			retval = fwu_do_lockdown();
+			if (retval < 0) {
+				dev_err(rmi4_data->pdev->dev.parent,
+						"%s: Failed to do lockdown\n",
+						__func__);
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (header.firmware_size)
+		fwu->firmware_data = fw_image + FW_IMAGE_OFFSET;
+	if (header.config_size) {
+		fwu->config_data = fw_image + FW_IMAGE_OFFSET +
+				header.firmware_size;
 	}
 
-	pr_notice("%s: Chunk data programmed\n", __func__);
+	flash_area = fwu_go_nogo(&header);
+	switch (flash_area) {
+	case UI_FIRMWARE:
+		retval = fwu_do_reflash();
+		break;
+	case CONFIG_AREA:
+		retval = fwu_do_write_config();
+		break;
+	case NONE:
+	default:
+		goto exit;
+	}
 
-	retval = fwu_recovery_reset();
 	if (retval < 0) {
 		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to reset device in recovery mode\n",
+				"%s: Failed to do reflash\n",
 				__func__);
-		goto exit;
 	}
 
-	pr_notice("%s: Recovery mode reset issued\n", __func__);
-
-	rmi4_data->reset_device(rmi4_data, true);
-
-	retval = 0;
-
 exit:
-	pr_notice("%s: End of recovery process\n", __func__);
+	rmi4_data->reset_device(rmi4_data);
+
+	if (fw_entry)
+		release_firmware(fw_entry);
 
-	mutex_unlock(&rmi4_data->rmi4_exp_init_mutex);
+	pr_notice("%s: End of reflash process\n", __func__);
 
 	rmi4_data->stay_awake = false;
 
 	return retval;
 }
 
-int synaptics_fw_updater(const unsigned char *fw_data)
+int synaptics_dsx_fw_updater(unsigned char *fw_data)
 {
 	int retval;
 
@@ -3800,75 +1564,39 @@ int synaptics_fw_updater(const unsigned char *fw_data)
 	if (!fwu->initialized)
 		return -ENODEV;
 
-	if (fwu->in_ub_mode)
-		return -ENODEV;
+	fwu->rmi4_data->fw_updating = true;
+	if (fwu->rmi4_data->suspended == true) {
+		fwu->rmi4_data->fw_updating = false;
+		dev_err(fwu->rmi4_data->pdev->dev.parent,
+			"Cannot start fw upgrade: Device is in suspend\n");
+		return -EBUSY;
+	}
 
-	fwu->image = fw_data;
+	fwu->ext_data_source = fw_data;
+	fwu->config_area = UI_CONFIG_AREA;
 
 	retval = fwu_start_reflash();
 
-	fwu->image = NULL;
+	fwu->rmi4_data->fw_updating = false;
 
 	return retval;
 }
-EXPORT_SYMBOL(synaptics_fw_updater);
-
-#ifdef DO_STARTUP_FW_UPDATE
-static void fwu_startup_fw_update_work(struct work_struct *work)
-{
-	static unsigned char do_once = 1;
-#ifdef WAIT_FOR_FB_READY
-	unsigned int timeout;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-#endif
-
-	if (!do_once)
-		return;
-	do_once = 0;
-
-#ifdef WAIT_FOR_FB_READY
-	timeout = FB_READY_TIMEOUT_S * 1000 / FB_READY_WAIT_MS + 1;
-
-	while (!rmi4_data->fb_ready) {
-		msleep(FB_READY_WAIT_MS);
-		timeout--;
-		if (timeout == 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Timed out waiting for FB ready\n",
-					__func__);
-			return;
-		}
-	}
-#endif
-
-	synaptics_fw_updater(NULL);
-
-	return;
-}
-#endif
+EXPORT_SYMBOL(synaptics_dsx_fw_updater);
 
 static ssize_t fwu_sysfs_show_image(struct file *data_file,
 		struct kobject *kobj, struct bin_attribute *attributes,
 		char *buf, loff_t pos, size_t count)
 {
-	int retval;
 	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
 
 	if (count < fwu->config_size) {
 		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Not enough space (%d bytes) in buffer\n",
-				__func__, (unsigned int)count);
+				"%s: Not enough space (%zu bytes) in buffer\n",
+				__func__, count);
 		return -EINVAL;
 	}
 
-	retval = secure_memcpy(buf, count, fwu->read_config_buf,
-			fwu->read_config_buf_size, fwu->config_size);
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to copy config data\n",
-				__func__);
-		return retval;
-	}
+	memcpy(buf, fwu->read_config_buf, fwu->config_size);
 
 	return fwu->config_size;
 }
@@ -3877,62 +1605,50 @@ static ssize_t fwu_sysfs_store_image(struct file *data_file,
 		struct kobject *kobj, struct bin_attribute *attributes,
 		char *buf, loff_t pos, size_t count)
 {
-	int retval;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	retval = secure_memcpy(&fwu->ext_data_source[fwu->data_pos],
-			fwu->image_size - fwu->data_pos, buf, count, count);
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to copy image data\n",
-				__func__);
-		return retval;
-	}
+	memcpy((void *)(&fwu->ext_data_source[fwu->data_pos]),
+			(const void *)buf,
+			count);
 
 	fwu->data_pos += count;
 
 	return count;
 }
 
-static ssize_t fwu_sysfs_do_recovery_store(struct device *dev,
+static ssize_t fwu_sysfs_force_reflash_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t count)
 {
 	int retval;
 	unsigned int input;
 	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
 
-	if (sscanf(buf, "%u", &input) != 1) {
+	if (kstrtouint(buf, 10, &input) != 1) {
 		retval = -EINVAL;
 		goto exit;
 	}
 
-	if (!fwu->in_ub_mode) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Not in microbootloader mode\n",
-				__func__);
+	if (input != 1) {
 		retval = -EINVAL;
 		goto exit;
 	}
 
-	if (!fwu->ext_data_source)
-		return -EINVAL;
-	else
-		fwu->image = fwu->ext_data_source;
+	if (LOCKDOWN)
+		fwu->do_lockdown = true;
 
-	retval = fwu_start_recovery();
+	fwu->force_update = true;
+	retval = synaptics_dsx_fw_updater(fwu->ext_data_source);
 	if (retval < 0) {
 		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to do recovery\n",
+				"%s: Failed to do reflash\n",
 				__func__);
 		goto exit;
 	}
 
 	retval = count;
-
 exit:
 	kfree(fwu->ext_data_source);
 	fwu->ext_data_source = NULL;
-	fwu->image = NULL;
+	fwu->force_update = FORCE_UPDATE;
+	fwu->do_lockdown = DO_LOCKDOWN;
 	return retval;
 }
 
@@ -3943,24 +1659,11 @@ static ssize_t fwu_sysfs_do_reflash_store(struct device *dev,
 	unsigned int input;
 	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
 
-	if (sscanf(buf, "%u", &input) != 1) {
-		retval = -EINVAL;
-		goto exit;
-	}
-
-	if (fwu->in_ub_mode) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: In microbootloader mode\n",
-				__func__);
+	if (kstrtouint(buf, 10, &input) != 1) {
 		retval = -EINVAL;
 		goto exit;
 	}
 
-	if (!fwu->ext_data_source)
-		return -EINVAL;
-	else
-		fwu->image = fwu->ext_data_source;
-
 	if (input & LOCKDOWN) {
 		fwu->do_lockdown = true;
 		input &= ~LOCKDOWN;
@@ -3974,7 +1677,7 @@ static ssize_t fwu_sysfs_do_reflash_store(struct device *dev,
 	if (input == FORCE)
 		fwu->force_update = true;
 
-	retval = synaptics_fw_updater(fwu->image);
+	retval = synaptics_dsx_fw_updater(fwu->ext_data_source);
 	if (retval < 0) {
 		dev_err(rmi4_data->pdev->dev.parent,
 				"%s: Failed to do reflash\n",
@@ -3987,7 +1690,6 @@ static ssize_t fwu_sysfs_do_reflash_store(struct device *dev,
 exit:
 	kfree(fwu->ext_data_source);
 	fwu->ext_data_source = NULL;
-	fwu->image = NULL;
 	fwu->force_update = FORCE_UPDATE;
 	fwu->do_lockdown = DO_LOCKDOWN;
 	return retval;
@@ -4000,7 +1702,7 @@ static ssize_t fwu_sysfs_write_config_store(struct device *dev,
 	unsigned int input;
 	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
 
-	if (sscanf(buf, "%u", &input) != 1) {
+	if (kstrtouint(buf, 10, &input) != 1) {
 		retval = -EINVAL;
 		goto exit;
 	}
@@ -4010,19 +1712,6 @@ static ssize_t fwu_sysfs_write_config_store(struct device *dev,
 		goto exit;
 	}
 
-	if (fwu->in_ub_mode) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: In microbootloader mode\n",
-				__func__);
-		retval = -EINVAL;
-		goto exit;
-	}
-
-	if (!fwu->ext_data_source)
-		return -EINVAL;
-	else
-		fwu->image = fwu->ext_data_source;
-
 	retval = fwu_start_write_config();
 	if (retval < 0) {
 		dev_err(rmi4_data->pdev->dev.parent,
@@ -4036,7 +1725,6 @@ static ssize_t fwu_sysfs_write_config_store(struct device *dev,
 exit:
 	kfree(fwu->ext_data_source);
 	fwu->ext_data_source = NULL;
-	fwu->image = NULL;
 	return retval;
 }
 
@@ -4047,19 +1735,12 @@ static ssize_t fwu_sysfs_read_config_store(struct device *dev,
 	unsigned int input;
 	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
 
-	if (sscanf(buf, "%u", &input) != 1)
+	if (kstrtouint(buf, 10, &input) != 1)
 		return -EINVAL;
 
 	if (input != 1)
 		return -EINVAL;
 
-	if (fwu->in_ub_mode) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: In microbootloader mode\n",
-				__func__);
-		return -EINVAL;
-	}
-
 	retval = fwu_do_read_config();
 	if (retval < 0) {
 		dev_err(rmi4_data->pdev->dev.parent,
@@ -4086,20 +1767,21 @@ static ssize_t fwu_sysfs_config_area_store(struct device *dev,
 	return count;
 }
 
+static ssize_t fwu_sysfs_image_name_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	if (strnlen(fwu->rmi4_data->fw_name, SYNA_FW_NAME_MAX_LEN) > 0)
+		return snprintf(buf, PAGE_SIZE, "%s\n",
+					fwu->rmi4_data->fw_name);
+	else
+		return snprintf(buf, PAGE_SIZE, "No firmware name given\n");
+}
+
 static ssize_t fwu_sysfs_image_name_store(struct device *dev,
 		struct device_attribute *attr, const char *buf, size_t count)
 {
-	int retval;
-	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
-
-	retval = secure_memcpy(fwu->image_name, MAX_IMAGE_NAME_LEN,
-			buf, count, count);
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to copy image file name\n",
-				__func__);
-		return retval;
-	}
+	if (sscanf(buf, "%s", fwu->image_name) != 1)
+		return -EINVAL;
 
 	return count;
 }
@@ -4139,84 +1821,79 @@ static ssize_t fwu_sysfs_block_size_show(struct device *dev,
 static ssize_t fwu_sysfs_firmware_block_count_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
-	return snprintf(buf, PAGE_SIZE, "%u\n", fwu->blkcount.ui_firmware);
+	return snprintf(buf, PAGE_SIZE, "%u\n", fwu->fw_block_count);
 }
 
 static ssize_t fwu_sysfs_configuration_block_count_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
-	return snprintf(buf, PAGE_SIZE, "%u\n", fwu->blkcount.ui_config);
-}
-
-static ssize_t fwu_sysfs_disp_config_block_count_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	return snprintf(buf, PAGE_SIZE, "%u\n", fwu->blkcount.dp_config);
+	return snprintf(buf, PAGE_SIZE, "%u\n", fwu->config_block_count);
 }
 
 static ssize_t fwu_sysfs_perm_config_block_count_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
-	return snprintf(buf, PAGE_SIZE, "%u\n", fwu->blkcount.pm_config);
+	return snprintf(buf, PAGE_SIZE, "%u\n", fwu->perm_config_block_count);
 }
 
 static ssize_t fwu_sysfs_bl_config_block_count_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
-	return snprintf(buf, PAGE_SIZE, "%u\n", fwu->blkcount.bl_config);
+	return snprintf(buf, PAGE_SIZE, "%u\n", fwu->bl_config_block_count);
 }
 
-static ssize_t fwu_sysfs_guest_code_block_count_show(struct device *dev,
+static ssize_t fwu_sysfs_disp_config_block_count_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
-	return snprintf(buf, PAGE_SIZE, "%u\n", fwu->blkcount.guest_code);
+	return snprintf(buf, PAGE_SIZE, "%u\n", fwu->disp_config_block_count);
 }
 
-static ssize_t fwu_sysfs_write_guest_code_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
+static ssize_t fwu_sysfs_config_id_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
 {
-	int retval;
-	unsigned int input;
 	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+	unsigned char config_id[4];
+	int retval;
 
-	if (sscanf(buf, "%u", &input) != 1) {
-		retval = -EINVAL;
-		goto exit;
-	}
-
-	if (input != 1) {
-		retval = -EINVAL;
-		goto exit;
-	}
-
-	if (fwu->in_ub_mode) {
+	/* device config id */
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+				fwu->f34_fd.ctrl_base_addr,
+				config_id,
+				sizeof(config_id));
+	if (retval < 0) {
 		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: In microbootloader mode\n",
+				"%s: Failed to read device config ID\n",
 				__func__);
-		retval = -EINVAL;
-		goto exit;
+		return retval;
 	}
 
-	if (!fwu->ext_data_source)
-		return -EINVAL;
-	else
-		fwu->image = fwu->ext_data_source;
+	return snprintf(buf, PAGE_SIZE, "%d.%d.%d.%d\n",
+		config_id[0], config_id[1], config_id[2], config_id[3]);
+}
+
+static ssize_t fwu_sysfs_package_id_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	int retval;
+	unsigned char package_id[PACKAGE_ID_SIZE];
+	struct synaptics_rmi4_data *rmi4_data = fwu->rmi4_data;
+
+	/* read device package id */
+	retval = synaptics_rmi4_reg_read(rmi4_data,
+			rmi4_data->f01_query_base_addr + F01_PACKAGE_ID_OFFSET,
+			package_id,
+			sizeof(package_id));
 
-	retval = fwu_start_write_guest_code();
 	if (retval < 0) {
 		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to write guest code\n",
+				"%s: Failed to read device package ID\n",
 				__func__);
-		goto exit;
+		return retval;
 	}
 
-	retval = count;
-
-exit:
-	kfree(fwu->ext_data_source);
-	fwu->ext_data_source = NULL;
-	fwu->image = NULL;
-	return retval;
+	return snprintf(buf, PAGE_SIZE, "%d rev %d\n",
+			(package_id[1] << 8) | package_id[0],
+			(package_id[3] << 8) | package_id[2]);
 }
 
 static void synaptics_rmi4_fwu_attn(struct synaptics_rmi4_data *rmi4_data,
@@ -4226,9 +1903,7 @@ static void synaptics_rmi4_fwu_attn(struct synaptics_rmi4_data *rmi4_data,
 		return;
 
 	if (fwu->intr_mask & intr_mask)
-		fwu_read_flash_status();
-
-	return;
+		fwu_read_f34_flash_status();
 }
 
 static int synaptics_rmi4_fwu_init(struct synaptics_rmi4_data *rmi4_data)
@@ -4237,30 +1912,13 @@ static int synaptics_rmi4_fwu_init(struct synaptics_rmi4_data *rmi4_data)
 	unsigned char attr_count;
 	struct pdt_properties pdt_props;
 
-	if (fwu) {
-		dev_dbg(rmi4_data->pdev->dev.parent,
-				"%s: Handle already exists\n",
-				__func__);
-		return 0;
-	}
-
 	fwu = kzalloc(sizeof(*fwu), GFP_KERNEL);
 	if (!fwu) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to alloc mem for fwu\n",
-				__func__);
 		retval = -ENOMEM;
 		goto exit;
 	}
 
-	fwu->image_name = kzalloc(MAX_IMAGE_NAME_LEN, GFP_KERNEL);
-	if (!fwu->image_name) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to alloc mem for image name\n",
-				__func__);
-		retval = -ENOMEM;
-		goto exit_free_fwu;
-	}
+	fwu->image_name = rmi4_data->fw_name;
 
 	fwu->rmi4_data = rmi4_data;
 
@@ -4277,26 +1935,29 @@ static int synaptics_rmi4_fwu_init(struct synaptics_rmi4_data *rmi4_data)
 				"%s: Reflash for LTS not currently supported\n",
 				__func__);
 		retval = -ENODEV;
-		goto exit_free_mem;
+		goto exit_free_fwu;
 	}
 
 	retval = fwu_scan_pdt();
 	if (retval < 0)
-		goto exit_free_mem;
+		goto exit_free_fwu;
 
-	if (!fwu->in_ub_mode) {
-		retval = fwu_read_f34_queries();
-		if (retval < 0)
-			goto exit_free_mem;
+	fwu->productinfo1 = rmi4_data->rmi4_mod_info.product_info[0];
+	fwu->productinfo2 = rmi4_data->rmi4_mod_info.product_info[1];
+	memcpy(fwu->product_id, rmi4_data->rmi4_mod_info.product_id_string,
+			SYNAPTICS_RMI4_PRODUCT_ID_SIZE);
+	fwu->product_id[SYNAPTICS_RMI4_PRODUCT_ID_SIZE] = 0;
 
-		retval = fwu_get_device_config_id();
-		if (retval < 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to read device config ID\n",
-					__func__);
-			goto exit_free_mem;
-		}
-	}
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: F01 product info: 0x%04x 0x%04x\n",
+			__func__, fwu->productinfo1, fwu->productinfo2);
+	dev_dbg(rmi4_data->pdev->dev.parent,
+			"%s: F01 product ID: %s\n",
+			__func__, fwu->product_id);
+
+	retval = fwu_read_f34_queries();
+	if (retval < 0)
+		goto exit_free_fwu;
 
 	fwu->force_update = FORCE_UPDATE;
 	fwu->do_lockdown = DO_LOCKDOWN;
@@ -4308,7 +1969,7 @@ static int synaptics_rmi4_fwu_init(struct synaptics_rmi4_data *rmi4_data)
 		dev_err(rmi4_data->pdev->dev.parent,
 				"%s: Failed to create sysfs bin file\n",
 				__func__);
-		goto exit_free_mem;
+		goto exit_free_fwu;
 	}
 
 	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++) {
@@ -4323,13 +1984,6 @@ static int synaptics_rmi4_fwu_init(struct synaptics_rmi4_data *rmi4_data)
 		}
 	}
 
-#ifdef DO_STARTUP_FW_UPDATE
-	fwu->fwu_workqueue = create_singlethread_workqueue("fwu_workqueue");
-	INIT_WORK(&fwu->fwu_work, fwu_startup_fw_update_work);
-	queue_work(fwu->fwu_workqueue,
-			&fwu->fwu_work);
-#endif
-
 	return 0;
 
 exit_remove_attrs:
@@ -4340,9 +1994,6 @@ exit_remove_attrs:
 
 	sysfs_remove_bin_file(&rmi4_data->input_dev->dev.kobj, &dev_attr_data);
 
-exit_free_mem:
-	kfree(fwu->image_name);
-
 exit_free_fwu:
 	kfree(fwu);
 	fwu = NULL;
@@ -4358,12 +2009,6 @@ static void synaptics_rmi4_fwu_remove(struct synaptics_rmi4_data *rmi4_data)
 	if (!fwu)
 		goto exit;
 
-#ifdef DO_STARTUP_FW_UPDATE
-	cancel_work_sync(&fwu->fwu_work);
-	flush_workqueue(fwu->fwu_workqueue);
-	destroy_workqueue(fwu->fwu_workqueue);
-#endif
-
 	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++) {
 		sysfs_remove_file(&rmi4_data->input_dev->dev.kobj,
 				&attrs[attr_count].attr);
@@ -4372,40 +2017,18 @@ static void synaptics_rmi4_fwu_remove(struct synaptics_rmi4_data *rmi4_data)
 	sysfs_remove_bin_file(&rmi4_data->input_dev->dev.kobj, &dev_attr_data);
 
 	kfree(fwu->read_config_buf);
-	kfree(fwu->image_name);
 	kfree(fwu);
 	fwu = NULL;
 
 exit:
-	complete(&fwu_remove_complete);
-
-	return;
-}
-
-static void synaptics_rmi4_fwu_reset(struct synaptics_rmi4_data *rmi4_data)
-{
-	int retval;
-
-	if (!fwu) {
-		synaptics_rmi4_fwu_init(rmi4_data);
-		return;
-	}
-
-	retval = fwu_scan_pdt();
-	if (retval < 0)
-		return;
-
-	if (!fwu->in_ub_mode)
-		fwu_read_f34_queries();
-
-	return;
+	complete(&fwu_dsx_remove_complete);
 }
 
 static struct synaptics_rmi4_exp_fn fwu_module = {
 	.fn_type = RMI_FW_UPDATER,
 	.init = synaptics_rmi4_fwu_init,
 	.remove = synaptics_rmi4_fwu_remove,
-	.reset = synaptics_rmi4_fwu_reset,
+	.reset = NULL,
 	.reinit = NULL,
 	.early_suspend = NULL,
 	.suspend = NULL,
@@ -4416,18 +2039,16 @@ static struct synaptics_rmi4_exp_fn fwu_module = {
 
 static int __init rmi4_fw_update_module_init(void)
 {
-	synaptics_rmi4_new_function(&fwu_module, true);
+	synaptics_rmi4_dsx_new_function(&fwu_module, true);
 
 	return 0;
 }
 
 static void __exit rmi4_fw_update_module_exit(void)
 {
-	synaptics_rmi4_new_function(&fwu_module, false);
-
-	wait_for_completion(&fwu_remove_complete);
+	synaptics_rmi4_dsx_new_function(&fwu_module, false);
 
-	return;
+	wait_for_completion(&fwu_dsx_remove_complete);
 }
 
 module_init(rmi4_fw_update_module_init);
diff --git a/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_i2c.c b/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_i2c.c
index f936f3c..5d099c4 100644
--- a/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_i2c.c
+++ b/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_i2c.c
@@ -1,11 +1,16 @@
 /*
  * Synaptics DSX touchscreen driver
  *
- * Copyright (C) 2012-2015 Synaptics Incorporated. All rights reserved.
+ * Copyright (c) 2014-2016, The Linux Foundation.  All rights reserved.
+ *
+ * Linux foundation chooses to take subject only to the GPLv2 license terms,
+ * and distributes only under these terms.
+ *
+ * Copyright (C) 2012-2016 Synaptics Incorporated
+ *
+ * Copyright (C) 2012-2016 Alexandra Chin <alexandra.chin@tw.synaptics.com>
+ * Copyright (C) 2012-2016 Scott Lin <scott.lin@tw.synaptics.com>
  *
- * Copyright (C) 2012 Alexandra Chin <alexandra.chin@tw.synaptics.com>
- * Copyright (C) 2012 Scott Lin <scott.lin@tw.synaptics.com>
- * Copyright (C) 2016, The Linux Foundation.  All rights reserved.
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
@@ -15,22 +20,7 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  * GNU General Public License for more details.
- *
- * INFORMATION CONTAINED IN THIS DOCUMENT IS PROVIDED "AS-IS," AND SYNAPTICS
- * EXPRESSLY DISCLAIMS ALL EXPRESS AND IMPLIED WARRANTIES, INCLUDING ANY
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE,
- * AND ANY WARRANTIES OF NON-INFRINGEMENT OF ANY INTELLECTUAL PROPERTY RIGHTS.
- * IN NO EVENT SHALL SYNAPTICS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES ARISING OUT OF OR IN CONNECTION
- * WITH THE USE OF THE INFORMATION CONTAINED IN THIS DOCUMENT, HOWEVER CAUSED
- * AND BASED ON ANY THEORY OF LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * NEGLIGENCE OR OTHER TORTIOUS ACTION, AND EVEN IF SYNAPTICS WAS ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE. IF A TRIBUNAL OF COMPETENT JURISDICTION DOES
- * NOT PERMIT THE DISCLAIMER OF DIRECT DAMAGES OR ANY OTHER DAMAGES, SYNAPTICS'
- * TOTAL CUMULATIVE LIABILITY TO ANY PARTY SHALL NOT EXCEED ONE HUNDRED U.S.
- * DOLLARS.
  */
-
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
@@ -38,291 +28,40 @@
 #include <linux/delay.h>
 #include <linux/input.h>
 #include <linux/types.h>
-#include <linux/of_gpio.h>
 #include <linux/platform_device.h>
-#include <linux/input/synaptics_dsx_v2_6.h>
+#include <linux/input/synaptics_dsx_v2.h>
 #include "synaptics_dsx_core.h"
-
-#define SYN_I2C_RETRY_TIMES 10
-
-/*
-#define I2C_BURST_LIMIT 255
-*/
-/*
-#define XFER_MSGS_LIMIT 8
-*/
-
-static unsigned char *wr_buf;
-
-static struct synaptics_dsx_hw_interface hw_if;
-
-static struct platform_device *synaptics_dsx_i2c_device;
-
-#ifdef CONFIG_OF
-static int parse_dt(struct device *dev, struct synaptics_dsx_board_data *bdata)
-{
-	int retval;
-	u32 value;
-	const char *name;
-	struct property *prop;
-	struct device_node *np = dev->of_node;
-
-	bdata->irq_gpio = of_get_named_gpio_flags(np,
-			"synaptics,irq-gpio", 0,
-			(enum of_gpio_flags *)&bdata->irq_flags);
-
-	retval = of_property_read_u32(np, "synaptics,irq-on-state",
-			&value);
-	if (retval < 0)
-		bdata->irq_on_state = 0;
-	else
-		bdata->irq_on_state = value;
-
-	bdata->resume_in_workqueue = of_property_read_bool(np,
-			"synaptics,resume-in-workqueue");
-
-	retval = of_property_read_string(np, "synaptics,pwr-reg-name", &name);
-	if (retval < 0)
-		bdata->pwr_reg_name = NULL;
-	else
-		bdata->pwr_reg_name = name;
-
-	retval = of_property_read_string(np, "synaptics,bus-reg-name", &name);
-	if (retval < 0)
-		bdata->bus_reg_name = NULL;
-	else
-		bdata->bus_reg_name = name;
-
-	prop = of_find_property(np, "synaptics,power-gpio", NULL);
-	if (prop && prop->length) {
-		bdata->power_gpio = of_get_named_gpio_flags(np,
-				"synaptics,power-gpio", 0, NULL);
-		retval = of_property_read_u32(np, "synaptics,power-on-state",
-				&value);
-		if (retval < 0) {
-			dev_err(dev, "%s: Unable to read synaptics,power-on-state property\n",
-					__func__);
-			return retval;
-		} else {
-			bdata->power_on_state = value;
-		}
-	} else {
-		bdata->power_gpio = -1;
-	}
-
-	prop = of_find_property(np, "synaptics,power-delay-ms", NULL);
-	if (prop && prop->length) {
-		retval = of_property_read_u32(np, "synaptics,power-delay-ms",
-				&value);
-		if (retval < 0) {
-			dev_err(dev, "%s: Unable to read synaptics,power-delay-ms property\n",
-					__func__);
-			return retval;
-		} else {
-			bdata->power_delay_ms = value;
-		}
-	} else {
-		bdata->power_delay_ms = 0;
-	}
-
-	prop = of_find_property(np, "synaptics,reset-gpio", NULL);
-	if (prop && prop->length) {
-		bdata->reset_gpio = of_get_named_gpio_flags(np,
-				"synaptics,reset-gpio", 0, NULL);
-		retval = of_property_read_u32(np, "synaptics,reset-on-state",
-				&value);
-		if (retval < 0) {
-			dev_err(dev, "%s: Unable to read synaptics,reset-on-state property\n",
-					__func__);
-			return retval;
-		} else {
-			bdata->reset_on_state = value;
-		}
-		retval = of_property_read_u32(np, "synaptics,reset-active-ms",
-				&value);
-		if (retval < 0) {
-			dev_err(dev, "%s: Unable to read synaptics,reset-active-ms property\n",
-					__func__);
-			return retval;
-		} else {
-			bdata->reset_active_ms = value;
-		}
-	} else {
-		bdata->reset_gpio = -1;
-	}
-
-	prop = of_find_property(np, "synaptics,reset-delay-ms", NULL);
-	if (prop && prop->length) {
-		retval = of_property_read_u32(np, "synaptics,reset-delay-ms",
-				&value);
-		if (retval < 0) {
-			dev_err(dev, "%s: Unable to read synaptics,reset-delay-ms property\n",
-					__func__);
-			return retval;
-		} else {
-			bdata->reset_delay_ms = value;
-		}
-	} else {
-		bdata->reset_delay_ms = 0;
-	}
-
-	prop = of_find_property(np, "synaptics,max-y-for-2d", NULL);
-	if (prop && prop->length) {
-		retval = of_property_read_u32(np, "synaptics,max-y-for-2d",
-				&value);
-		if (retval < 0) {
-			dev_err(dev, "%s: Unable to read synaptics,max-y-for-2d property\n",
-					__func__);
-			return retval;
-		} else {
-			bdata->max_y_for_2d = value;
-		}
-	} else {
-		bdata->max_y_for_2d = -1;
-	}
-
-	prop = of_find_property(np, "synaptics,swap-axes", NULL);
-	bdata->swap_axes = prop > 0 ? true : false;
-
-	prop = of_find_property(np, "synaptics,x-flip", NULL);
-	bdata->x_flip = prop > 0 ? true : false;
-
-	prop = of_find_property(np, "synaptics,y-flip", NULL);
-	bdata->y_flip = prop > 0 ? true : false;
-
-	prop = of_find_property(np, "synaptics,ub-i2c-addr", NULL);
-	if (prop && prop->length) {
-		retval = of_property_read_u32(np, "synaptics,ub-i2c-addr",
-				&value);
-		if (retval < 0) {
-			dev_err(dev, "%s: Unable to read synaptics,ub-i2c-addr property\n",
-					__func__);
-			return retval;
-		} else {
-			bdata->ub_i2c_addr = (unsigned short)value;
-		}
-	} else {
-		bdata->ub_i2c_addr = -1;
-	}
-
-	prop = of_find_property(np, "synaptics,cap-button-codes", NULL);
-	if (prop && prop->length) {
-		bdata->cap_button_map->map = devm_kzalloc(dev,
-				prop->length,
-				GFP_KERNEL);
-		if (!bdata->cap_button_map->map)
-			return -ENOMEM;
-		bdata->cap_button_map->nbuttons = prop->length / sizeof(u32);
-		retval = of_property_read_u32_array(np,
-				"synaptics,cap-button-codes",
-				bdata->cap_button_map->map,
-				bdata->cap_button_map->nbuttons);
-		if (retval < 0) {
-			bdata->cap_button_map->nbuttons = 0;
-			bdata->cap_button_map->map = NULL;
-		}
-	} else {
-		bdata->cap_button_map->nbuttons = 0;
-		bdata->cap_button_map->map = NULL;
-	}
-
-	prop = of_find_property(np, "synaptics,vir-button-codes", NULL);
-	if (prop && prop->length) {
-		bdata->vir_button_map->map = devm_kzalloc(dev,
-				prop->length,
-				GFP_KERNEL);
-		if (!bdata->vir_button_map->map)
-			return -ENOMEM;
-		bdata->vir_button_map->nbuttons = prop->length / sizeof(u32);
-		bdata->vir_button_map->nbuttons /= 5;
-		retval = of_property_read_u32_array(np,
-				"synaptics,vir-button-codes",
-				bdata->vir_button_map->map,
-				bdata->vir_button_map->nbuttons * 5);
-		if (retval < 0) {
-			bdata->vir_button_map->nbuttons = 0;
-			bdata->vir_button_map->map = NULL;
-		}
-	} else {
-		bdata->vir_button_map->nbuttons = 0;
-		bdata->vir_button_map->map = NULL;
-	}
-
-	return 0;
-}
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#if defined(CONFIG_SECURE_TOUCH_SYNAPTICS_DSX_V26)
+#include <linux/pm_runtime.h>
 #endif
 
-static int synaptics_rmi4_i2c_alloc_buf(struct synaptics_rmi4_data *rmi4_data,
-		unsigned int count)
-{
-	static unsigned int buf_size;
-
-	if (count > buf_size) {
-		if (buf_size)
-			kfree(wr_buf);
-		wr_buf = kzalloc(count, GFP_KERNEL);
-		if (!wr_buf) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to alloc mem for buffer\n",
-					__func__);
-			buf_size = 0;
-			return -ENOMEM;
-		}
-		buf_size = count;
-	}
-
-	return 0;
-}
-
-static void synaptics_rmi4_i2c_check_addr(struct synaptics_rmi4_data *rmi4_data,
-		struct i2c_client *i2c)
-{
-	if (hw_if.board_data->ub_i2c_addr == -1)
-		return;
-
-	if (hw_if.board_data->i2c_addr == i2c->addr)
-		hw_if.board_data->i2c_addr = hw_if.board_data->ub_i2c_addr;
-	else
-		hw_if.board_data->i2c_addr = i2c->addr;
-
-	return;
-}
+#define SYN_I2C_RETRY_TIMES 10
+#define RESET_DELAY 100
+#define DSX_COORDS_ARR_SIZE	4
 
 static int synaptics_rmi4_i2c_set_page(struct synaptics_rmi4_data *rmi4_data,
 		unsigned short addr)
 {
-	int retval = 0;
+	int retval;
 	unsigned char retry;
 	unsigned char buf[PAGE_SELECT_LEN];
 	unsigned char page;
 	struct i2c_client *i2c = to_i2c_client(rmi4_data->pdev->dev.parent);
-	struct i2c_msg msg[1];
-
-	msg[0].addr = hw_if.board_data->i2c_addr;
-	msg[0].flags = 0;
-	msg[0].len = PAGE_SELECT_LEN;
-	msg[0].buf = buf;
 
 	page = ((addr >> 8) & MASK_8BIT);
-	buf[0] = MASK_8BIT;
-	buf[1] = page;
-
 	if (page != rmi4_data->current_page) {
+		buf[0] = MASK_8BIT;
+		buf[1] = page;
 		for (retry = 0; retry < SYN_I2C_RETRY_TIMES; retry++) {
-			if (i2c_transfer(i2c->adapter, msg, 1) == 1) {
+			retval = i2c_master_send(i2c, buf, PAGE_SELECT_LEN);
+			if (retval != PAGE_SELECT_LEN)
+				msleep(20);
+			else {
 				rmi4_data->current_page = page;
-				retval = PAGE_SELECT_LEN;
 				break;
 			}
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: I2C retry %d\n",
-					__func__, retry + 1);
-			msleep(20);
-
-			if (retry == SYN_I2C_RETRY_TIMES / 2) {
-				synaptics_rmi4_i2c_check_addr(rmi4_data, i2c);
-				msg[0].addr = hw_if.board_data->i2c_addr;
-			}
 		}
 	} else {
 		retval = PAGE_SELECT_LEN;
@@ -337,21 +76,23 @@ static int synaptics_rmi4_i2c_read(struct synaptics_rmi4_data *rmi4_data,
 	int retval;
 	unsigned char retry;
 	unsigned char buf;
-#ifdef I2C_BURST_LIMIT
-	unsigned char ii;
-	unsigned char rd_msgs = ((length - 1) / I2C_BURST_LIMIT) + 1;
-#else
-	unsigned char rd_msgs = 1;
-#endif
-	unsigned char index = 0;
-	unsigned char xfer_msgs;
-	unsigned char remaining_msgs;
-	unsigned short i2c_addr;
-	unsigned short data_offset = 0;
-	unsigned short remaining_length = length;
 	struct i2c_client *i2c = to_i2c_client(rmi4_data->pdev->dev.parent);
-	struct i2c_adapter *adap = i2c->adapter;
-	struct i2c_msg msg[rd_msgs + 1];
+	struct i2c_msg msg[] = {
+		{
+			.addr = i2c->addr,
+			.flags = 0,
+			.len = 1,
+			.buf = &buf,
+		},
+		{
+			.addr = i2c->addr,
+			.flags = I2C_M_RD,
+			.len = length,
+			.buf = data,
+		},
+	};
+
+	buf = addr & MASK_8BIT;
 
 	mutex_lock(&rmi4_data->rmi4_io_ctrl_mutex);
 
@@ -361,75 +102,23 @@ static int synaptics_rmi4_i2c_read(struct synaptics_rmi4_data *rmi4_data,
 		goto exit;
 	}
 
-	msg[0].addr = hw_if.board_data->i2c_addr;
-	msg[0].flags = 0;
-	msg[0].len = 1;
-	msg[0].buf = &buf;
-
-#ifdef I2C_BURST_LIMIT
-	for (ii = 0; ii < (rd_msgs - 1); ii++) {
-		msg[ii + 1].addr = hw_if.board_data->i2c_addr;
-		msg[ii + 1].flags = I2C_M_RD;
-		msg[ii + 1].len = I2C_BURST_LIMIT;
-		msg[ii + 1].buf = &data[data_offset];
-		data_offset += I2C_BURST_LIMIT;
-		remaining_length -= I2C_BURST_LIMIT;
-	}
-#endif
-
-	msg[rd_msgs].addr = hw_if.board_data->i2c_addr;
-	msg[rd_msgs].flags = I2C_M_RD;
-	msg[rd_msgs].len = remaining_length;
-	msg[rd_msgs].buf = &data[data_offset];
-
-	buf = addr & MASK_8BIT;
-
-	remaining_msgs = rd_msgs + 1;
-
-	while (remaining_msgs) {
-#ifdef XFER_MSGS_LIMIT
-		if (remaining_msgs > XFER_MSGS_LIMIT)
-			xfer_msgs = XFER_MSGS_LIMIT;
-		else
-			xfer_msgs = remaining_msgs;
-#else
-		xfer_msgs = remaining_msgs;
-#endif
-		for (retry = 0; retry < SYN_I2C_RETRY_TIMES; retry++) {
-			retval = i2c_transfer(adap, &msg[index], xfer_msgs);
-			if (retval == xfer_msgs)
-				break;
-
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: I2C retry %d\n",
-					__func__, retry + 1);
-			msleep(20);
-
-			if (retry == SYN_I2C_RETRY_TIMES / 2) {
-				synaptics_rmi4_i2c_check_addr(rmi4_data, i2c);
-				i2c_addr = hw_if.board_data->i2c_addr;
-				msg[0].addr = i2c_addr;
-#ifdef I2C_BURST_LIMIT
-				for (ii = 0; ii < (rd_msgs - 1); ii++)
-					msg[ii + 1].addr = i2c_addr;
-#endif
-				msg[rd_msgs].addr = i2c_addr;
-			}
-		}
-
-		if (retry == SYN_I2C_RETRY_TIMES) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: I2C read over retry limit\n",
-					__func__);
-			retval = -EIO;
-			goto exit;
+	for (retry = 0; retry < SYN_I2C_RETRY_TIMES; retry++) {
+		if (i2c_transfer(i2c->adapter, msg, 2) == 2) {
+			retval = length;
+			break;
 		}
-
-		remaining_msgs -= xfer_msgs;
-		index += xfer_msgs;
+/*		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: I2C retry %d\n",
+				__func__, retry + 1);
+*/		msleep(20);
 	}
 
-	retval = length;
+	if (retry == SYN_I2C_RETRY_TIMES) {
+		dev_err(rmi4_data->pdev->dev.parent,
+				"%s: I2C read over retry limit\n",
+				__func__);
+		retval = -EIO;
+	}
 
 exit:
 	mutex_unlock(&rmi4_data->rmi4_io_ctrl_mutex);
@@ -442,12 +131,16 @@ static int synaptics_rmi4_i2c_write(struct synaptics_rmi4_data *rmi4_data,
 {
 	int retval;
 	unsigned char retry;
+	unsigned char buf[length + 1];
 	struct i2c_client *i2c = to_i2c_client(rmi4_data->pdev->dev.parent);
-	struct i2c_msg msg[1];
-
-	retval = synaptics_rmi4_i2c_alloc_buf(rmi4_data, length + 1);
-	if (retval < 0)
-		return retval;
+	struct i2c_msg msg[] = {
+		{
+			.addr = i2c->addr,
+			.flags = 0,
+			.len = length + 1,
+			.buf = buf,
+		}
+	};
 
 	mutex_lock(&rmi4_data->rmi4_io_ctrl_mutex);
 
@@ -457,19 +150,8 @@ static int synaptics_rmi4_i2c_write(struct synaptics_rmi4_data *rmi4_data,
 		goto exit;
 	}
 
-	msg[0].addr = hw_if.board_data->i2c_addr;
-	msg[0].flags = 0;
-	msg[0].len = length + 1;
-	msg[0].buf = wr_buf;
-
-	wr_buf[0] = addr & MASK_8BIT;
-	retval = secure_memcpy(&wr_buf[1], length, &data[0], length, length);
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to copy data\n",
-				__func__);
-		goto exit;
-	}
+	buf[0] = addr & MASK_8BIT;
+	memcpy(&buf[1], &data[0], length);
 
 	for (retry = 0; retry < SYN_I2C_RETRY_TIMES; retry++) {
 		if (i2c_transfer(i2c->adapter, msg, 1) == 1) {
@@ -480,11 +162,6 @@ static int synaptics_rmi4_i2c_write(struct synaptics_rmi4_data *rmi4_data,
 				"%s: I2C retry %d\n",
 				__func__, retry + 1);
 		msleep(20);
-
-		if (retry == SYN_I2C_RETRY_TIMES / 2) {
-			synaptics_rmi4_i2c_check_addr(rmi4_data, i2c);
-			msg[0].addr = hw_if.board_data->i2c_addr;
-		}
 	}
 
 	if (retry == SYN_I2C_RETRY_TIMES) {
@@ -536,8 +213,7 @@ static int synaptics_rmi4_i2c_get(struct synaptics_rmi4_data *rmi4_data)
 
 	mutex_lock(&rmi4_data->rmi4_io_ctrl_mutex);
 	retval = pm_runtime_get_sync(i2c->adapter->dev.parent);
-	if (retval >= 0 && rmi4_data->core_clk != NULL &&
-				rmi4_data->iface_clk != NULL) {
+	if (retval >= 0) {
 		retval = synaptics_rmi4_clk_prepare_enable(rmi4_data);
 		if (retval)
 			pm_runtime_put_sync(i2c->adapter->dev.parent);
@@ -552,8 +228,7 @@ static void synaptics_rmi4_i2c_put(struct synaptics_rmi4_data *rmi4_data)
 	struct i2c_client *i2c = to_i2c_client(rmi4_data->pdev->dev.parent);
 
 	mutex_lock(&rmi4_data->rmi4_io_ctrl_mutex);
-	if (rmi4_data->core_clk != NULL && rmi4_data->iface_clk != NULL)
-		synaptics_rmi4_clk_disable_unprepare(rmi4_data);
+	synaptics_rmi4_clk_disable_unprepare(rmi4_data);
 	pm_runtime_put_sync(i2c->adapter->dev.parent);
 	mutex_unlock(&rmi4_data->rmi4_io_ctrl_mutex);
 }
@@ -569,17 +244,170 @@ static struct synaptics_dsx_bus_access bus_access = {
 #endif
 };
 
+static struct synaptics_dsx_hw_interface hw_if;
+
+static struct platform_device *synaptics_dsx_i2c_device;
+
 static void synaptics_rmi4_i2c_dev_release(struct device *dev)
 {
 	kfree(synaptics_dsx_i2c_device);
+}
+#ifdef CONFIG_OF
+int synaptics_dsx_get_dt_coords(struct device *dev, char *name,
+				struct synaptics_dsx_board_data *pdata,
+				struct device_node *node)
+{
+	u32 coords[DSX_COORDS_ARR_SIZE];
+	struct property *prop;
+	struct device_node *np = (node == NULL) ? (dev->of_node) : (node);
+	int coords_size, rc;
+
+	prop = of_find_property(np, name, NULL);
+	if (!prop)
+		return -EINVAL;
+	if (!prop->value)
+		return -ENODATA;
+
+	coords_size = prop->length / sizeof(u32);
+	if (coords_size != DSX_COORDS_ARR_SIZE) {
+		dev_err(dev, "invalid %s\n", name);
+		return -EINVAL;
+	}
+
+	rc = of_property_read_u32_array(np, name, coords, coords_size);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read %s\n", name);
+		return rc;
+	}
+
+	if (strcmp(name, "synaptics,panel-coords") == 0) {
+		pdata->panel_minx = coords[0];
+		pdata->panel_miny = coords[1];
+		pdata->panel_maxx = coords[2];
+		pdata->panel_maxy = coords[3];
+	} else if (strcmp(name, "synaptics,display-coords") == 0) {
+		pdata->disp_minx = coords[0];
+		pdata->disp_miny = coords[1];
+		pdata->disp_maxx = coords[2];
+		pdata->disp_maxy = coords[3];
+	} else {
+		dev_err(dev, "unsupported property %s\n", name);
+		return -EINVAL;
+	}
 
-	return;
+	return 0;
 }
 
+static int synaptics_dsx_parse_dt(struct device *dev,
+				struct synaptics_dsx_board_data *rmi4_pdata)
+{
+	struct device_node *np = dev->of_node;
+	struct property *prop;
+	u32 temp_val, num_buttons;
+	u32 button_map[MAX_NUMBER_OF_BUTTONS];
+	int rc, i;
+
+	rmi4_pdata->x_flip = of_property_read_bool(np, "synaptics,x-flip");
+	rmi4_pdata->y_flip = of_property_read_bool(np, "synaptics,y-flip");
+
+	rmi4_pdata->disable_gpios = of_property_read_bool(np,
+			"synaptics,disable-gpios");
+
+	rmi4_pdata->bypass_packrat_id_check = of_property_read_bool(np,
+			"synaptics,bypass-packrat-id-check");
+
+	rmi4_pdata->reset_delay_ms = RESET_DELAY;
+	rc = of_property_read_u32(np, "synaptics,reset-delay-ms", &temp_val);
+	if (!rc)
+		rmi4_pdata->reset_delay_ms = temp_val;
+	else if (rc != -EINVAL) {
+		dev_err(dev, "Unable to read reset delay\n");
+		return rc;
+	}
+
+	rc = of_property_read_u32(np, "synaptics,config-id",
+					&rmi4_pdata->config_id);
+	if (rc && (rc != -EINVAL))
+		dev_err(dev, "Unable to read config id from DT\n");
+
+	rmi4_pdata->fw_name = "PRXXX_fw.img";
+	rc = of_property_read_string(np, "synaptics,fw-name",
+					&rmi4_pdata->fw_name);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read fw name\n");
+		return rc;
+	}
+
+	/* reset, irq gpio info */
+	rmi4_pdata->reset_gpio = of_get_named_gpio_flags(np,
+			"synaptics,reset-gpio", 0, &rmi4_pdata->reset_flags);
+	rmi4_pdata->irq_gpio = of_get_named_gpio_flags(np,
+			"synaptics,irq-gpio", 0, &rmi4_pdata->irq_flags);
+
+	rc = synaptics_dsx_get_dt_coords(dev, "synaptics,display-coords",
+				rmi4_pdata, NULL);
+	if (rc && (rc != -EINVAL))
+		return rc;
+
+	rc = synaptics_dsx_get_dt_coords(dev, "synaptics,panel-coords",
+				rmi4_pdata, NULL);
+	if (rc && (rc != -EINVAL))
+		return rc;
+
+	rmi4_pdata->detect_device = of_property_read_bool(np,
+				"synaptics,detect-device");
+
+	if (rmi4_pdata->detect_device)
+		return 0;
+
+	prop = of_find_property(np, "synaptics,button-map", NULL);
+	if (prop) {
+		num_buttons = prop->length / sizeof(temp_val);
+
+		rmi4_pdata->cap_button_map = devm_kzalloc(dev,
+			sizeof(*rmi4_pdata->cap_button_map),
+			GFP_KERNEL);
+		if (!rmi4_pdata->cap_button_map)
+			return -ENOMEM;
+
+		rmi4_pdata->cap_button_map->map = devm_kzalloc(dev,
+			sizeof(*rmi4_pdata->cap_button_map->map) *
+			MAX_NUMBER_OF_BUTTONS, GFP_KERNEL);
+		if (!rmi4_pdata->cap_button_map->map)
+			return -ENOMEM;
+
+		if (num_buttons <= MAX_NUMBER_OF_BUTTONS) {
+			rc = of_property_read_u32_array(np,
+				"synaptics,button-map", button_map,
+				num_buttons);
+			if (rc) {
+				dev_err(dev, "Unable to read key codes\n");
+				return rc;
+			}
+			for (i = 0; i < num_buttons; i++)
+				rmi4_pdata->cap_button_map->map[i] =
+					button_map[i];
+			rmi4_pdata->cap_button_map->nbuttons =
+				num_buttons;
+		} else {
+			return -EINVAL;
+		}
+	}
+	return 0;
+}
+#else
+static inline int synaptics_dsx_parse_dt(struct device *dev,
+				struct synaptics_dsx_board_data *rmi4_pdata)
+{
+	return 0;
+}
+#endif
+
 static int synaptics_rmi4_i2c_probe(struct i2c_client *client,
 		const struct i2c_device_id *dev_id)
 {
 	int retval;
+	struct synaptics_dsx_board_data *platform_data;
 
 	if (!i2c_check_functionality(client->adapter,
 			I2C_FUNC_SMBUS_BYTE_DATA)) {
@@ -589,6 +417,29 @@ static int synaptics_rmi4_i2c_probe(struct i2c_client *client,
 		return -EIO;
 	}
 
+	if (client->dev.of_node) {
+		platform_data = devm_kzalloc(&client->dev,
+			sizeof(struct synaptics_dsx_board_data),
+			GFP_KERNEL);
+		if (!platform_data) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			return -ENOMEM;
+		}
+
+		retval = synaptics_dsx_parse_dt(&client->dev, platform_data);
+		if (retval)
+			return retval;
+	} else {
+		platform_data = client->dev.platform_data;
+	}
+
+	if (!platform_data) {
+		dev_err(&client->dev,
+				"%s: No platform data found\n",
+				__func__);
+		return -EINVAL;
+	}
+
 	synaptics_dsx_i2c_device = kzalloc(
 			sizeof(struct platform_device),
 			GFP_KERNEL);
@@ -599,43 +450,8 @@ static int synaptics_rmi4_i2c_probe(struct i2c_client *client,
 		return -ENOMEM;
 	}
 
-#ifdef CONFIG_OF
-	if (client->dev.of_node) {
-		hw_if.board_data = devm_kzalloc(&client->dev,
-				sizeof(struct synaptics_dsx_board_data),
-				GFP_KERNEL);
-		if (!hw_if.board_data) {
-			dev_err(&client->dev,
-					"%s: Failed to allocate memory for board data\n",
-					__func__);
-			return -ENOMEM;
-		}
-		hw_if.board_data->cap_button_map = devm_kzalloc(&client->dev,
-				sizeof(struct synaptics_dsx_button_map),
-				GFP_KERNEL);
-		if (!hw_if.board_data->cap_button_map) {
-			dev_err(&client->dev,
-					"%s: Failed to allocate memory for 0D button map\n",
-					__func__);
-			return -ENOMEM;
-		}
-		hw_if.board_data->vir_button_map = devm_kzalloc(&client->dev,
-				sizeof(struct synaptics_dsx_button_map),
-				GFP_KERNEL);
-		if (!hw_if.board_data->vir_button_map) {
-			dev_err(&client->dev,
-					"%s: Failed to allocate memory for virtual button map\n",
-					__func__);
-			return -ENOMEM;
-		}
-		parse_dt(&client->dev, hw_if.board_data);
-	}
-#else
-	hw_if.board_data = client->dev.platform_data;
-#endif
-
+	hw_if.board_data = platform_data;
 	hw_if.bus_access = &bus_access;
-	hw_if.board_data->i2c_addr = client->addr;
 
 	synaptics_dsx_i2c_device->name = PLATFORM_DRIVER_NAME;
 	synaptics_dsx_i2c_device->id = 0;
@@ -669,43 +485,36 @@ static const struct i2c_device_id synaptics_rmi4_id_table[] = {
 MODULE_DEVICE_TABLE(i2c, synaptics_rmi4_id_table);
 
 #ifdef CONFIG_OF
-static struct of_device_id synaptics_rmi4_of_match_table[] = {
-	{
-		.compatible = "synaptics,dsx-i2c",
-	},
-	{},
+static struct of_device_id dsx_match_table[] = {
+	{ .compatible = "synaptics,dsx",},
+	{ },
 };
-MODULE_DEVICE_TABLE(of, synaptics_rmi4_of_match_table);
 #else
-#define synaptics_rmi4_of_match_table NULL
+#define dsx_match_table NULL
 #endif
 
 static struct i2c_driver synaptics_rmi4_i2c_driver = {
 	.driver = {
 		.name = I2C_DRIVER_NAME,
 		.owner = THIS_MODULE,
-		.of_match_table = synaptics_rmi4_of_match_table,
+		.of_match_table = dsx_match_table,
 	},
 	.probe = synaptics_rmi4_i2c_probe,
 	.remove = synaptics_rmi4_i2c_remove,
 	.id_table = synaptics_rmi4_id_table,
 };
 
-int synaptics_rmi4_bus_init_v26(void)
+int synaptics_rmi4_bus_init(void)
 {
 	return i2c_add_driver(&synaptics_rmi4_i2c_driver);
 }
-EXPORT_SYMBOL(synaptics_rmi4_bus_init_v26);
+EXPORT_SYMBOL(synaptics_rmi4_bus_init);
 
-void synaptics_rmi4_bus_exit_v26(void)
+void synaptics_rmi4_bus_exit(void)
 {
-	kfree(wr_buf);
-
 	i2c_del_driver(&synaptics_rmi4_i2c_driver);
-
-	return;
 }
-EXPORT_SYMBOL(synaptics_rmi4_bus_exit_v26);
+EXPORT_SYMBOL(synaptics_rmi4_bus_exit);
 
 MODULE_AUTHOR("Synaptics, Inc.");
 MODULE_DESCRIPTION("Synaptics DSX I2C Bus Support Module");
diff --git a/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_rmi_dev.c b/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_rmi_dev.c
index 111b26c..2a374ec 100644
--- a/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_rmi_dev.c
+++ b/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_rmi_dev.c
@@ -1,10 +1,10 @@
 /*
  * Synaptics DSX touchscreen driver
  *
- * Copyright (C) 2012-2015 Synaptics Incorporated. All rights reserved.
+ * Copyright (C) 2012-2016 Synaptics Incorporated
  *
- * Copyright (C) 2012 Alexandra Chin <alexandra.chin@tw.synaptics.com>
- * Copyright (C) 2012 Scott Lin <scott.lin@tw.synaptics.com>
+ * Copyright (C) 2012-2016 Alexandra Chin <alexandra.chin@tw.synaptics.com>
+ * Copyright (C) 2012-2016 Scott Lin <scott.lin@tw.synaptics.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -15,35 +15,18 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  * GNU General Public License for more details.
- *
- * INFORMATION CONTAINED IN THIS DOCUMENT IS PROVIDED "AS-IS," AND SYNAPTICS
- * EXPRESSLY DISCLAIMS ALL EXPRESS AND IMPLIED WARRANTIES, INCLUDING ANY
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE,
- * AND ANY WARRANTIES OF NON-INFRINGEMENT OF ANY INTELLECTUAL PROPERTY RIGHTS.
- * IN NO EVENT SHALL SYNAPTICS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES ARISING OUT OF OR IN CONNECTION
- * WITH THE USE OF THE INFORMATION CONTAINED IN THIS DOCUMENT, HOWEVER CAUSED
- * AND BASED ON ANY THEORY OF LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * NEGLIGENCE OR OTHER TORTIOUS ACTION, AND EVEN IF SYNAPTICS WAS ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE. IF A TRIBUNAL OF COMPETENT JURISDICTION DOES
- * NOT PERMIT THE DISCLAIMER OF DIRECT DAMAGES OR ANY OTHER DAMAGES, SYNAPTICS'
- * TOTAL CUMULATIVE LIABILITY TO ANY PARTY SHALL NOT EXCEED ONE HUNDRED U.S.
- * DOLLARS.
  */
-
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>
 #include <linux/input.h>
-#include <linux/signal.h>
-#include <linux/sched.h>
 #include <linux/gpio.h>
 #include <linux/uaccess.h>
 #include <linux/cdev.h>
 #include <linux/platform_device.h>
-#include <linux/input/synaptics_dsx_v2_6.h>
+#include <linux/input/synaptics_dsx_v2.h>
 #include "synaptics_dsx_core.h"
 
 #define CHAR_DEVICE_NAME "rmi"
@@ -69,42 +52,13 @@ static ssize_t rmidev_sysfs_release_store(struct device *dev,
 static ssize_t rmidev_sysfs_attn_state_show(struct device *dev,
 		struct device_attribute *attr, char *buf);
 
-static ssize_t rmidev_sysfs_pid_show(struct device *dev,
-		struct device_attribute *attr, char *buf);
-
-static ssize_t rmidev_sysfs_pid_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count);
-
-static ssize_t rmidev_sysfs_term_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count);
-
-static ssize_t rmidev_sysfs_intr_mask_show(struct device *dev,
-		struct device_attribute *attr, char *buf);
-
-static ssize_t rmidev_sysfs_intr_mask_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count);
-
-static ssize_t rmidev_sysfs_concurrent_show(struct device *dev,
-		struct device_attribute *attr, char *buf);
-
-static ssize_t rmidev_sysfs_concurrent_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count);
-
 struct rmidev_handle {
 	dev_t dev_no;
-	pid_t pid;
-	unsigned char intr_mask;
-	unsigned char *tmpbuf;
-	unsigned int tmpbuf_size;
 	struct device dev;
 	struct synaptics_rmi4_data *rmi4_data;
 	struct kobject *sysfs_dir;
-	struct siginfo interrupt_signal;
-	struct siginfo terminate_signal;
-	struct task_struct *task;
 	void *data;
 	bool irq_enabled;
-	bool concurrent;
 };
 
 struct rmidev_data {
@@ -134,19 +88,7 @@ static struct device_attribute attrs[] = {
 			rmidev_sysfs_release_store),
 	__ATTR(attn_state, S_IRUGO,
 			rmidev_sysfs_attn_state_show,
-			NULL),
-	__ATTR(pid, S_IRUGO | S_IRUGO | S_IWUSR | S_IWGRP,
-			rmidev_sysfs_pid_show,
-			rmidev_sysfs_pid_store),
-	__ATTR(term, S_IWUSR | S_IWGRP,
-			NULL,
-			rmidev_sysfs_term_store),
-	__ATTR(intr_mask, S_IRUGO,
-			rmidev_sysfs_intr_mask_show,
-			rmidev_sysfs_intr_mask_store),
-	__ATTR(concurrent, S_IRUGO,
-			rmidev_sysfs_concurrent_show,
-			rmidev_sysfs_concurrent_store),
+			synaptics_rmi4_store_error),
 };
 
 static int rmidev_major_num;
@@ -155,7 +97,7 @@ static struct class *rmidev_device_class;
 
 static struct rmidev_handle *rmidev;
 
-DECLARE_COMPLETION(rmidev_remove_complete_v26);
+DECLARE_COMPLETION(rmidev_remove_complete);
 
 static irqreturn_t rmidev_sysfs_irq(int irq, void *data)
 {
@@ -172,8 +114,7 @@ static int rmidev_sysfs_irq_enable(struct synaptics_rmi4_data *rmi4_data,
 {
 	int retval = 0;
 	unsigned char intr_status[MAX_INTR_REGISTERS];
-	unsigned long irq_flags = IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING |
-			IRQF_ONESHOT;
+	unsigned long irq_flags = IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING;
 
 	if (enable) {
 		if (rmidev->irq_enabled)
@@ -189,7 +130,7 @@ static int rmidev_sysfs_irq_enable(struct synaptics_rmi4_data *rmi4_data,
 
 		retval = request_threaded_irq(rmi4_data->irq, NULL,
 				rmidev_sysfs_irq, irq_flags,
-				PLATFORM_DRIVER_NAME, rmi4_data);
+				"synaptics_dsx_rmidev", rmi4_data);
 		if (retval < 0) {
 			dev_err(rmi4_data->pdev->dev.parent,
 					"%s: Failed to create irq thread\n",
@@ -214,15 +155,10 @@ static ssize_t rmidev_sysfs_data_show(struct file *data_file,
 		char *buf, loff_t pos, size_t count)
 {
 	int retval;
-	unsigned char intr_status = 0;
 	unsigned int length = (unsigned int)count;
 	unsigned short address = (unsigned short)pos;
-	struct synaptics_rmi4_fn *fhandler;
-	struct synaptics_rmi4_device_info *rmi;
 	struct synaptics_rmi4_data *rmi4_data = rmidev->rmi4_data;
 
-	rmi = &(rmi4_data->rmi4_mod_info);
-
 	if (length > (REG_ADDR_LIMIT - address)) {
 		dev_err(rmi4_data->pdev->dev.parent,
 				"%s: Out of register map limit\n",
@@ -245,29 +181,6 @@ static ssize_t rmidev_sysfs_data_show(struct file *data_file,
 		return -EINVAL;
 	}
 
-	if (!rmidev->concurrent)
-		goto exit;
-
-	if (address != rmi4_data->f01_data_base_addr)
-		goto exit;
-
-	if (length <= 1)
-		goto exit;
-
-	intr_status = buf[1];
-
-	if (!list_empty(&rmi->support_fn_list)) {
-		list_for_each_entry(fhandler, &rmi->support_fn_list, link) {
-			if (fhandler->num_of_data_sources) {
-				if (fhandler->intr_mask & intr_status) {
-					rmi4_data->report_touch(rmi4_data,
-							fhandler);
-				}
-			}
-		}
-	}
-
-exit:
 	return length;
 }
 
@@ -311,22 +224,13 @@ static ssize_t rmidev_sysfs_open_store(struct device *dev,
 	unsigned int input;
 	struct synaptics_rmi4_data *rmi4_data = rmidev->rmi4_data;
 
-	if (sscanf(buf, "%u", &input) != 1)
+	if (kstrtouint(buf, 10, &input) != 1)
 		return -EINVAL;
 
 	if (input != 1)
 		return -EINVAL;
 
-	if (rmi4_data->sensor_sleep) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Sensor sleeping\n",
-				__func__);
-		return -ENODEV;
-	}
-
-	rmi4_data->stay_awake = true;
-
-	rmi4_data->irq_enable(rmi4_data, false, false);
+	rmi4_data->irq_enable(rmi4_data, false);
 	rmidev_sysfs_irq_enable(rmi4_data, true);
 
 	dev_dbg(rmi4_data->pdev->dev.parent,
@@ -342,23 +246,21 @@ static ssize_t rmidev_sysfs_release_store(struct device *dev,
 	unsigned int input;
 	struct synaptics_rmi4_data *rmi4_data = rmidev->rmi4_data;
 
-	if (sscanf(buf, "%u", &input) != 1)
+	if (kstrtouint(buf, 10, &input) != 1)
 		return -EINVAL;
 
 	if (input != 1)
 		return -EINVAL;
 
+	rmi4_data->reset_device(rmi4_data);
+
 	rmidev_sysfs_irq_enable(rmi4_data, false);
-	rmi4_data->irq_enable(rmi4_data, true, false);
+	rmi4_data->irq_enable(rmi4_data, true);
 
 	dev_dbg(rmi4_data->pdev->dev.parent,
 			"%s: Attention interrupt enabled\n",
 			__func__);
 
-	rmi4_data->reset_device(rmi4_data, false);
-
-	rmi4_data->stay_awake = false;
-
 	return count;
 }
 
@@ -375,121 +277,18 @@ static ssize_t rmidev_sysfs_attn_state_show(struct device *dev,
 	return snprintf(buf, PAGE_SIZE, "%u\n", attn_state);
 }
 
-static ssize_t rmidev_sysfs_pid_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	return snprintf(buf, PAGE_SIZE, "%u\n", rmidev->pid);
-}
-
-static ssize_t rmidev_sysfs_pid_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	unsigned int input;
-	struct synaptics_rmi4_data *rmi4_data = rmidev->rmi4_data;
-
-	if (sscanf(buf, "%u", &input) != 1)
-		return -EINVAL;
-
-	rmidev->pid = input;
-
-	if (rmidev->pid) {
-		rmidev->task = pid_task(find_vpid(rmidev->pid), PIDTYPE_PID);
-		if (!rmidev->task) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to locate PID of data logging tool\n",
-					__func__);
-			return -EINVAL;
-		}
-	}
-
-	return count;
-}
-
-static ssize_t rmidev_sysfs_term_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	unsigned int input;
-
-	if (sscanf(buf, "%u", &input) != 1)
-		return -EINVAL;
-
-	if (input != 1)
-		return -EINVAL;
-
-	if (rmidev->pid)
-		send_sig_info(SIGTERM, &rmidev->terminate_signal, rmidev->task);
-
-	return count;
-}
-
-static ssize_t rmidev_sysfs_intr_mask_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	return snprintf(buf, PAGE_SIZE, "0x%02x\n", rmidev->intr_mask);
-}
-
-static ssize_t rmidev_sysfs_intr_mask_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	unsigned int input;
-
-	if (sscanf(buf, "%u", &input) != 1)
-		return -EINVAL;
-
-	rmidev->intr_mask = (unsigned char)input;
-
-	return count;
-}
-
-static ssize_t rmidev_sysfs_concurrent_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	return snprintf(buf, PAGE_SIZE, "%d\n", rmidev->concurrent);
-}
-
-static ssize_t rmidev_sysfs_concurrent_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	unsigned int input;
-
-	if (sscanf(buf, "%u", &input) != 1)
-		return -EINVAL;
-
-	rmidev->concurrent = input > 0 ? true : false;
-
-	return count;
-}
-
-static int rmidev_allocate_buffer(int count)
-{
-	if (count + 1 > rmidev->tmpbuf_size) {
-		if (rmidev->tmpbuf_size)
-			kfree(rmidev->tmpbuf);
-		rmidev->tmpbuf = kzalloc(count + 1, GFP_KERNEL);
-		if (!rmidev->tmpbuf) {
-			dev_err(rmidev->rmi4_data->pdev->dev.parent,
-					"%s: Failed to alloc mem for buffer\n",
-					__func__);
-			rmidev->tmpbuf_size = 0;
-			return -ENOMEM;
-		}
-		rmidev->tmpbuf_size = count + 1;
-	}
-
-	return 0;
-}
-
 /*
- * rmidev_llseek - set register address to access for RMI device
+ * rmidev_llseek - used to set up register address
  *
- * @filp: pointer to file structure
- * @off:
- *	if whence == SEEK_SET,
- *		off: 16-bit RMI register address
- *	if whence == SEEK_CUR,
- *		off: offset from current position
- *	if whence == SEEK_END,
- *		off: offset from end position (0xFFFF)
+ * @filp: file structure for seek
+ * @off: offset
+ *   if whence == SEEK_SET,
+ *     high 16 bits: page address
+ *     low 16 bits: register address
+ *   if whence == SEEK_CUR,
+ *     offset from current position
+ *   if whence == SEEK_END,
+ *     offset from end position (0xFFFF)
  * @whence: SEEK_SET, SEEK_CUR, or SEEK_END
  */
 static loff_t rmidev_llseek(struct file *filp, loff_t off, int whence)
@@ -537,25 +336,19 @@ clean_up:
 }
 
 /*
- * rmidev_read: read register data from RMI device
+ * rmidev_read: - use to read data from rmi device
  *
- * @filp: pointer to file structure
- * @buf: pointer to user space buffer
+ * @filp: file structure for read
+ * @buf: user space buffer pointer
  * @count: number of bytes to read
- * @f_pos: starting RMI register address
+ * @f_pos: offset (starting register address)
  */
 static ssize_t rmidev_read(struct file *filp, char __user *buf,
 		size_t count, loff_t *f_pos)
 {
 	ssize_t retval;
-	unsigned char intr_status = 0;
-	unsigned short address;
+	unsigned char tmpbuf[count + 1];
 	struct rmidev_data *dev_data = filp->private_data;
-	struct synaptics_rmi4_fn *fhandler;
-	struct synaptics_rmi4_device_info *rmi;
-	struct synaptics_rmi4_data *rmi4_data = rmidev->rmi4_data;
-
-	rmi = &(rmi4_data->rmi4_mod_info);
 
 	if (IS_ERR(dev_data)) {
 		pr_err("%s: Pointer of char device data is invalid", __func__);
@@ -568,46 +361,20 @@ static ssize_t rmidev_read(struct file *filp, char __user *buf,
 	if (count > (REG_ADDR_LIMIT - *f_pos))
 		count = REG_ADDR_LIMIT - *f_pos;
 
-	address = (unsigned short)(*f_pos);
-
-	rmidev_allocate_buffer(count);
-
 	mutex_lock(&(dev_data->file_mutex));
 
 	retval = synaptics_rmi4_reg_read(rmidev->rmi4_data,
 			*f_pos,
-			rmidev->tmpbuf,
+			tmpbuf,
 			count);
 	if (retval < 0)
 		goto clean_up;
 
-	if (copy_to_user(buf, rmidev->tmpbuf, count))
+	if (copy_to_user(buf, tmpbuf, count))
 		retval = -EFAULT;
 	else
 		*f_pos += retval;
 
-	if (!rmidev->concurrent)
-		goto clean_up;
-
-	if (address != rmi4_data->f01_data_base_addr)
-		goto clean_up;
-
-	if (count <= 1)
-		goto clean_up;
-
-	intr_status = rmidev->tmpbuf[1];
-
-	if (!list_empty(&rmi->support_fn_list)) {
-		list_for_each_entry(fhandler, &rmi->support_fn_list, link) {
-			if (fhandler->num_of_data_sources) {
-				if (fhandler->intr_mask & intr_status) {
-					rmi4_data->report_touch(rmi4_data,
-							fhandler);
-				}
-			}
-		}
-	}
-
 clean_up:
 	mutex_unlock(&(dev_data->file_mutex));
 
@@ -615,17 +382,18 @@ clean_up:
 }
 
 /*
- * rmidev_write: write register data to RMI device
+ * rmidev_write: - used to write data to rmi device
  *
- * @filp: pointer to file structure
- * @buf: pointer to user space buffer
+ * @filep: file structure for write
+ * @buf: user space buffer pointer
  * @count: number of bytes to write
- * @f_pos: starting RMI register address
+ * @f_pos: offset (starting register address)
  */
 static ssize_t rmidev_write(struct file *filp, const char __user *buf,
 		size_t count, loff_t *f_pos)
 {
 	ssize_t retval;
+	unsigned char tmpbuf[count + 1];
 	struct rmidev_data *dev_data = filp->private_data;
 
 	if (IS_ERR(dev_data)) {
@@ -639,16 +407,14 @@ static ssize_t rmidev_write(struct file *filp, const char __user *buf,
 	if (count > (REG_ADDR_LIMIT - *f_pos))
 		count = REG_ADDR_LIMIT - *f_pos;
 
-	rmidev_allocate_buffer(count);
-
-	if (copy_from_user(rmidev->tmpbuf, buf, count))
+	if (copy_from_user(tmpbuf, buf, count))
 		return -EFAULT;
 
 	mutex_lock(&(dev_data->file_mutex));
 
 	retval = synaptics_rmi4_reg_write(rmidev->rmi4_data,
 			*f_pos,
-			rmidev->tmpbuf,
+			tmpbuf,
 			count);
 	if (retval >= 0)
 		*f_pos += retval;
@@ -658,6 +424,11 @@ static ssize_t rmidev_write(struct file *filp, const char __user *buf,
 	return retval;
 }
 
+/*
+ * rmidev_open: enable access to rmi device
+ * @inp: inode struture
+ * @filp: file structure
+ */
 static int rmidev_open(struct inode *inp, struct file *filp)
 {
 	int retval = 0;
@@ -668,20 +439,11 @@ static int rmidev_open(struct inode *inp, struct file *filp)
 	if (!dev_data)
 		return -EACCES;
 
-	if (rmi4_data->sensor_sleep) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Sensor sleeping\n",
-				__func__);
-		return -ENODEV;
-	}
-
-	rmi4_data->stay_awake = true;
-
 	filp->private_data = dev_data;
 
 	mutex_lock(&(dev_data->file_mutex));
 
-	rmi4_data->irq_enable(rmi4_data, false, false);
+	rmi4_data->irq_enable(rmi4_data, false);
 	dev_dbg(rmi4_data->pdev->dev.parent,
 			"%s: Attention interrupt disabled\n",
 			__func__);
@@ -696,6 +458,11 @@ static int rmidev_open(struct inode *inp, struct file *filp)
 	return retval;
 }
 
+/*
+ * rmidev_release: - release access to rmi device
+ * @inp: inode structure
+ * @filp: file structure
+ */
 static int rmidev_release(struct inode *inp, struct file *filp)
 {
 	struct synaptics_rmi4_data *rmi4_data = rmidev->rmi4_data;
@@ -705,23 +472,21 @@ static int rmidev_release(struct inode *inp, struct file *filp)
 	if (!dev_data)
 		return -EACCES;
 
+	rmi4_data->reset_device(rmi4_data);
+
 	mutex_lock(&(dev_data->file_mutex));
 
 	dev_data->ref_count--;
 	if (dev_data->ref_count < 0)
 		dev_data->ref_count = 0;
 
-	rmi4_data->irq_enable(rmi4_data, true, false);
+	rmi4_data->irq_enable(rmi4_data, true);
 	dev_dbg(rmi4_data->pdev->dev.parent,
 			"%s: Attention interrupt enabled\n",
 			__func__);
 
 	mutex_unlock(&(dev_data->file_mutex));
 
-	rmi4_data->reset_device(rmi4_data, false);
-
-	rmi4_data->stay_awake = false;
-
 	return 0;
 }
 
@@ -753,8 +518,6 @@ static void rmidev_device_cleanup(struct rmidev_data *dev_data)
 				"%s: rmidev device removed\n",
 				__func__);
 	}
-
-	return;
 }
 
 static char *rmi_char_devnode(struct device *dev, umode_t *mode)
@@ -769,9 +532,6 @@ static char *rmi_char_devnode(struct device *dev, umode_t *mode)
 
 static int rmidev_create_device_class(void)
 {
-	if (rmidev_device_class != NULL)
-		return 0;
-
 	rmidev_device_class = class_create(THIS_MODULE, DEVICE_CLASS_NAME);
 
 	if (IS_ERR(rmidev_device_class)) {
@@ -785,18 +545,6 @@ static int rmidev_create_device_class(void)
 	return 0;
 }
 
-static void rmidev_attn(struct synaptics_rmi4_data *rmi4_data,
-		unsigned char intr_mask)
-{
-	if (!rmidev)
-		return;
-
-	if (rmidev->pid && (rmidev->intr_mask & intr_mask))
-		send_sig_info(SIGIO, &rmidev->interrupt_signal, rmidev->task);
-
-	return;
-}
-
 static int rmidev_init_device(struct synaptics_rmi4_data *rmi4_data)
 {
 	int retval;
@@ -805,34 +553,16 @@ static int rmidev_init_device(struct synaptics_rmi4_data *rmi4_data)
 	struct rmidev_data *dev_data;
 	struct device *device_ptr;
 	const struct synaptics_dsx_board_data *bdata =
-			rmi4_data->hw_if->board_data;
-
-	if (rmidev) {
-		dev_dbg(rmi4_data->pdev->dev.parent,
-				"%s: Handle already exists\n",
-				__func__);
-		return 0;
-	}
+				rmi4_data->hw_if->board_data;
 
 	rmidev = kzalloc(sizeof(*rmidev), GFP_KERNEL);
 	if (!rmidev) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to alloc mem for rmidev\n",
-				__func__);
 		retval = -ENOMEM;
 		goto err_rmidev;
 	}
 
 	rmidev->rmi4_data = rmi4_data;
 
-	memset(&rmidev->interrupt_signal, 0, sizeof(rmidev->interrupt_signal));
-	rmidev->interrupt_signal.si_signo = SIGIO;
-	rmidev->interrupt_signal.si_code = SI_USER;
-
-	memset(&rmidev->terminate_signal, 0, sizeof(rmidev->terminate_signal));
-	rmidev->terminate_signal.si_signo = SIGTERM;
-	rmidev->terminate_signal.si_code = SI_USER;
-
 	retval = rmidev_create_device_class();
 	if (retval < 0) {
 		dev_err(rmi4_data->pdev->dev.parent,
@@ -861,9 +591,6 @@ static int rmidev_init_device(struct synaptics_rmi4_data *rmi4_data)
 
 	dev_data = kzalloc(sizeof(*dev_data), GFP_KERNEL);
 	if (!dev_data) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to alloc mem for dev_data\n",
-				__func__);
 		retval = -ENOMEM;
 		goto err_dev_data;
 	}
@@ -965,10 +692,7 @@ err_dev_data:
 	unregister_chrdev_region(dev_no, 1);
 
 err_device_region:
-	if (rmidev_device_class != NULL) {
-		class_destroy(rmidev_device_class);
-		rmidev_device_class = NULL;
-	}
+	class_destroy(rmidev_device_class);
 
 err_device_class:
 	kfree(rmidev);
@@ -982,8 +706,6 @@ static void rmidev_remove_device(struct synaptics_rmi4_data *rmi4_data)
 {
 	unsigned char attr_count;
 	struct rmidev_data *dev_data;
-	const struct synaptics_dsx_board_data *bdata =
-			rmi4_data->hw_if->board_data;
 
 	if (!rmidev)
 		goto exit;
@@ -995,8 +717,6 @@ static void rmidev_remove_device(struct synaptics_rmi4_data *rmi4_data)
 
 	kobject_put(rmidev->sysfs_dir);
 
-	gpio_unexport(bdata->irq_gpio);
-
 	dev_data = rmidev->data;
 	if (dev_data) {
 		rmidev_device_cleanup(dev_data);
@@ -1005,20 +725,13 @@ static void rmidev_remove_device(struct synaptics_rmi4_data *rmi4_data)
 
 	unregister_chrdev_region(rmidev->dev_no, 1);
 
-	if (rmidev_device_class != NULL) {
-		class_destroy(rmidev_device_class);
-		rmidev_device_class = NULL;
-	}
-
-	kfree(rmidev->tmpbuf);
+	class_destroy(rmidev_device_class);
 
 	kfree(rmidev);
 	rmidev = NULL;
 
 exit:
-	complete(&rmidev_remove_complete_v26);
-
-	return;
+	complete(&rmidev_remove_complete);
 }
 
 static struct synaptics_rmi4_exp_fn rmidev_module = {
@@ -1031,23 +744,21 @@ static struct synaptics_rmi4_exp_fn rmidev_module = {
 	.suspend = NULL,
 	.resume = NULL,
 	.late_resume = NULL,
-	.attn = rmidev_attn,
+	.attn = NULL,
 };
 
 static int __init rmidev_module_init(void)
 {
-	synaptics_rmi4_new_function(&rmidev_module, true);
+	synaptics_rmi4_dsx_new_function(&rmidev_module, true);
 
 	return 0;
 }
 
 static void __exit rmidev_module_exit(void)
 {
-	synaptics_rmi4_new_function(&rmidev_module, false);
-
-	wait_for_completion(&rmidev_remove_complete_v26);
+	synaptics_rmi4_dsx_new_function(&rmidev_module, false);
 
-	return;
+	wait_for_completion(&rmidev_remove_complete);
 }
 
 module_init(rmidev_module_init);
diff --git a/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_spi.c b/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_spi.c
index 382a3dd..7bab860 100644
--- a/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_spi.c
+++ b/drivers/input/touchscreen/synaptics_dsx_2.6/synaptics_dsx_spi.c
@@ -1,10 +1,10 @@
 /*
  * Synaptics DSX touchscreen driver
  *
- * Copyright (C) 2012-2015 Synaptics Incorporated. All rights reserved.
+ * Copyright (C) 2012-2016 Synaptics Incorporated
  *
- * Copyright (C) 2012 Alexandra Chin <alexandra.chin@tw.synaptics.com>
- * Copyright (C) 2012 Scott Lin <scott.lin@tw.synaptics.com>
+ * Copyright (C) 2012-2016 Alexandra Chin <alexandra.chin@tw.synaptics.com>
+ * Copyright (C) 2012-2016 Scott Lin <scott.lin@tw.synaptics.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -15,22 +15,7 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  * GNU General Public License for more details.
- *
- * INFORMATION CONTAINED IN THIS DOCUMENT IS PROVIDED "AS-IS," AND SYNAPTICS
- * EXPRESSLY DISCLAIMS ALL EXPRESS AND IMPLIED WARRANTIES, INCLUDING ANY
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE,
- * AND ANY WARRANTIES OF NON-INFRINGEMENT OF ANY INTELLECTUAL PROPERTY RIGHTS.
- * IN NO EVENT SHALL SYNAPTICS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES ARISING OUT OF OR IN CONNECTION
- * WITH THE USE OF THE INFORMATION CONTAINED IN THIS DOCUMENT, HOWEVER CAUSED
- * AND BASED ON ANY THEORY OF LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * NEGLIGENCE OR OTHER TORTIOUS ACTION, AND EVEN IF SYNAPTICS WAS ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE. IF A TRIBUNAL OF COMPETENT JURISDICTION DOES
- * NOT PERMIT THE DISCLAIMER OF DIRECT DAMAGES OR ANY OTHER DAMAGES, SYNAPTICS'
- * TOTAL CUMULATIVE LIABILITY TO ANY PARTY SHALL NOT EXCEED ONE HUNDRED U.S.
- * DOLLARS.
  */
-
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
@@ -38,235 +23,13 @@
 #include <linux/delay.h>
 #include <linux/input.h>
 #include <linux/types.h>
-#include <linux/of_gpio.h>
 #include <linux/platform_device.h>
-#include <linux/input/synaptics_dsx_v2_6.h>
+#include <linux/input/synaptics_dsx.h>
 #include "synaptics_dsx_core.h"
 
 #define SPI_READ 0x80
 #define SPI_WRITE 0x00
 
-#ifdef CONFIG_OF
-static int parse_dt(struct device *dev, struct synaptics_dsx_board_data *bdata)
-{
-	int retval;
-	u32 value;
-	const char *name;
-	struct property *prop;
-	struct device_node *np = dev->of_node;
-
-	bdata->irq_gpio = of_get_named_gpio_flags(np,
-			"synaptics,irq-gpio", 0,
-			(enum of_gpio_flags *)&bdata->irq_flags);
-
-	retval = of_property_read_u32(np, "synaptics,irq-on-state",
-			&value);
-	if (retval < 0)
-		bdata->irq_on_state = 0;
-	else
-		bdata->irq_on_state = value;
-
-	retval = of_property_read_string(np, "synaptics,pwr-reg-name", &name);
-	if (retval < 0)
-		bdata->pwr_reg_name = NULL;
-	else
-		bdata->pwr_reg_name = name;
-
-	retval = of_property_read_string(np, "synaptics,bus-reg-name", &name);
-	if (retval < 0)
-		bdata->bus_reg_name = NULL;
-	else
-		bdata->bus_reg_name = name;
-
-	prop = of_find_property(np, "synaptics,power-gpio", NULL);
-	if (prop && prop->length) {
-		bdata->power_gpio = of_get_named_gpio_flags(np,
-				"synaptics,power-gpio", 0, NULL);
-		retval = of_property_read_u32(np, "synaptics,power-on-state",
-				&value);
-		if (retval < 0) {
-			dev_err(dev, "%s: Unable to read synaptics,power-on-state property\n",
-					__func__);
-			return retval;
-		} else {
-			bdata->power_on_state = value;
-		}
-	} else {
-		bdata->power_gpio = -1;
-	}
-
-	prop = of_find_property(np, "synaptics,power-delay-ms", NULL);
-	if (prop && prop->length) {
-		retval = of_property_read_u32(np, "synaptics,power-delay-ms",
-				&value);
-		if (retval < 0) {
-			dev_err(dev, "%s: Unable to read synaptics,power-delay-ms property\n",
-					__func__);
-			return retval;
-		} else {
-			bdata->power_delay_ms = value;
-		}
-	} else {
-		bdata->power_delay_ms = 0;
-	}
-
-	prop = of_find_property(np, "synaptics,reset-gpio", NULL);
-	if (prop && prop->length) {
-		bdata->reset_gpio = of_get_named_gpio_flags(np,
-				"synaptics,reset-gpio", 0, NULL);
-		retval = of_property_read_u32(np, "synaptics,reset-on-state",
-				&value);
-		if (retval < 0) {
-			dev_err(dev, "%s: Unable to read synaptics,reset-on-state property\n",
-					__func__);
-			return retval;
-		} else {
-			bdata->reset_on_state = value;
-		}
-		retval = of_property_read_u32(np, "synaptics,reset-active-ms",
-				&value);
-		if (retval < 0) {
-			dev_err(dev, "%s: Unable to read synaptics,reset-active-ms property\n",
-					__func__);
-			return retval;
-		} else {
-			bdata->reset_active_ms = value;
-		}
-	} else {
-		bdata->reset_gpio = -1;
-	}
-
-	prop = of_find_property(np, "synaptics,reset-delay-ms", NULL);
-	if (prop && prop->length) {
-		retval = of_property_read_u32(np, "synaptics,reset-delay-ms",
-				&value);
-		if (retval < 0) {
-			dev_err(dev, "%s: Unable to read synaptics,reset-delay-ms property\n",
-					__func__);
-			return retval;
-		} else {
-			bdata->reset_delay_ms = value;
-		}
-	} else {
-		bdata->reset_delay_ms = 0;
-	}
-
-	prop = of_find_property(np, "synaptics,byte-delay-us", NULL);
-	if (prop && prop->length) {
-		retval = of_property_read_u32(np, "synaptics,byte-delay-us",
-				&value);
-		if (retval < 0) {
-			dev_err(dev, "%s: Unable to read synaptics,byte-delay-us property\n",
-					__func__);
-			return retval;
-		} else {
-			bdata->byte_delay_us = value;
-		}
-	} else {
-		bdata->byte_delay_us = 0;
-	}
-
-	prop = of_find_property(np, "synaptics,block-delay-us", NULL);
-	if (prop && prop->length) {
-		retval = of_property_read_u32(np, "synaptics,block-delay-us",
-				&value);
-		if (retval < 0) {
-			dev_err(dev, "%s: Unable to read synaptics,block-delay-us property\n",
-					__func__);
-			return retval;
-		} else {
-			bdata->block_delay_us = value;
-		}
-	} else {
-		bdata->block_delay_us = 0;
-	}
-
-	prop = of_find_property(np, "synaptics,max-y-for-2d", NULL);
-	if (prop && prop->length) {
-		retval = of_property_read_u32(np, "synaptics,max-y-for-2d",
-				&value);
-		if (retval < 0) {
-			dev_err(dev, "%s: Unable to read synaptics,max-y-for-2d property\n",
-					__func__);
-			return retval;
-		} else {
-			bdata->max_y_for_2d = value;
-		}
-	} else {
-		bdata->max_y_for_2d = -1;
-	}
-
-	prop = of_find_property(np, "synaptics,swap-axes", NULL);
-	bdata->swap_axes = prop > 0 ? true : false;
-
-	prop = of_find_property(np, "synaptics,x-flip", NULL);
-	bdata->x_flip = prop > 0 ? true : false;
-
-	prop = of_find_property(np, "synaptics,y-flip", NULL);
-	bdata->y_flip = prop > 0 ? true : false;
-
-	prop = of_find_property(np, "synaptics,ub-i2c-addr", NULL);
-	if (prop && prop->length) {
-		retval = of_property_read_u32(np, "synaptics,ub-i2c-addr",
-				&value);
-		if (retval < 0) {
-			dev_err(dev, "%s: Unable to read synaptics,ub-i2c-addr property\n",
-					__func__);
-			return retval;
-		} else {
-			bdata->ub_i2c_addr = (unsigned short)value;
-		}
-	} else {
-		bdata->ub_i2c_addr = -1;
-	}
-
-	prop = of_find_property(np, "synaptics,cap-button-codes", NULL);
-	if (prop && prop->length) {
-		bdata->cap_button_map->map = devm_kzalloc(dev,
-				prop->length,
-				GFP_KERNEL);
-		if (!bdata->cap_button_map->map)
-			return -ENOMEM;
-		bdata->cap_button_map->nbuttons = prop->length / sizeof(u32);
-		retval = of_property_read_u32_array(np,
-				"synaptics,cap-button-codes",
-				bdata->cap_button_map->map,
-				bdata->cap_button_map->nbuttons);
-		if (retval < 0) {
-			bdata->cap_button_map->nbuttons = 0;
-			bdata->cap_button_map->map = NULL;
-		}
-	} else {
-		bdata->cap_button_map->nbuttons = 0;
-		bdata->cap_button_map->map = NULL;
-	}
-
-	prop = of_find_property(np, "synaptics,vir-button-codes", NULL);
-	if (prop && prop->length) {
-		bdata->vir_button_map->map = devm_kzalloc(dev,
-				prop->length,
-				GFP_KERNEL);
-		if (!bdata->vir_button_map->map)
-			return -ENOMEM;
-		bdata->vir_button_map->nbuttons = prop->length / sizeof(u32);
-		bdata->vir_button_map->nbuttons /= 5;
-		retval = of_property_read_u32_array(np,
-				"synaptics,vir-button-codes",
-				bdata->vir_button_map->map,
-				bdata->vir_button_map->nbuttons * 5);
-		if (retval < 0) {
-			bdata->vir_button_map->nbuttons = 0;
-			bdata->vir_button_map->map = NULL;
-		}
-	} else {
-		bdata->vir_button_map->nbuttons = 0;
-		bdata->vir_button_map->map = NULL;
-	}
-
-	return 0;
-}
-#endif
-
 static int synaptics_rmi4_spi_set_page(struct synaptics_rmi4_data *rmi4_data,
 		unsigned short addr)
 {
@@ -334,9 +97,6 @@ static int synaptics_rmi4_spi_read(struct synaptics_rmi4_data *rmi4_data,
 
 	xfers = kcalloc(xfer_count, sizeof(struct spi_transfer), GFP_KERNEL);
 	if (!xfers) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to allocate memory for xfers\n",
-				__func__);
 		retval = -ENOMEM;
 		goto exit;
 	}
@@ -346,9 +106,6 @@ static int synaptics_rmi4_spi_read(struct synaptics_rmi4_data *rmi4_data,
 
 	rxbuf = kmalloc(length, GFP_KERNEL);
 	if (!rxbuf) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to allocate memory for rxbuf\n",
-				__func__);
 		retval = -ENOMEM;
 		goto exit;
 	}
@@ -357,7 +114,6 @@ static int synaptics_rmi4_spi_read(struct synaptics_rmi4_data *rmi4_data,
 
 	retval = synaptics_rmi4_spi_set_page(rmi4_data, addr);
 	if (retval != PAGE_SELECT_LEN) {
-		mutex_unlock(&rmi4_data->rmi4_io_ctrl_mutex);
 		retval = -EIO;
 		goto exit;
 	}
@@ -377,14 +133,8 @@ static int synaptics_rmi4_spi_read(struct synaptics_rmi4_data *rmi4_data,
 
 	retval = spi_sync(spi, &msg);
 	if (retval == 0) {
-		retval = secure_memcpy(data, length, rxbuf, length, length);
-		if (retval < 0) {
-			dev_err(rmi4_data->pdev->dev.parent,
-					"%s: Failed to copy data\n",
-					__func__);
-		} else {
-			retval = length;
-		}
+		retval = length;
+		memcpy(data, rxbuf, length);
 	} else {
 		dev_err(rmi4_data->pdev->dev.parent,
 				"%s: Failed to complete SPI transfer, error = %d\n",
@@ -417,38 +167,24 @@ static int synaptics_rmi4_spi_write(struct synaptics_rmi4_data *rmi4_data,
 
 	xfers = kcalloc(xfer_count, sizeof(struct spi_transfer), GFP_KERNEL);
 	if (!xfers) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to allocate memory for xfers\n",
-				__func__);
 		retval = -ENOMEM;
 		goto exit;
 	}
 
 	txbuf = kmalloc(xfer_count, GFP_KERNEL);
 	if (!txbuf) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to allocate memory for txbuf\n",
-				__func__);
 		retval = -ENOMEM;
 		goto exit;
 	}
 
 	txbuf[0] = (addr >> 8) & ~SPI_READ;
 	txbuf[1] = addr & MASK_8BIT;
-	retval = secure_memcpy(&txbuf[ADDRESS_WORD_LEN],
-			xfer_count - ADDRESS_WORD_LEN, data, length, length);
-	if (retval < 0) {
-		dev_err(rmi4_data->pdev->dev.parent,
-				"%s: Failed to copy data\n",
-				__func__);
-		goto exit;
-	}
+	memcpy(&txbuf[ADDRESS_WORD_LEN], data, length);
 
 	mutex_lock(&rmi4_data->rmi4_io_ctrl_mutex);
 
 	retval = synaptics_rmi4_spi_set_page(rmi4_data, addr);
 	if (retval != PAGE_SELECT_LEN) {
-		mutex_unlock(&rmi4_data->rmi4_io_ctrl_mutex);
 		retval = -EIO;
 		goto exit;
 	}
@@ -494,8 +230,6 @@ static struct platform_device *synaptics_dsx_spi_device;
 static void synaptics_rmi4_spi_dev_release(struct device *dev)
 {
 	kfree(synaptics_dsx_spi_device);
-
-	return;
 }
 
 static int synaptics_rmi4_spi_probe(struct spi_device *spi)
@@ -519,43 +253,6 @@ static int synaptics_rmi4_spi_probe(struct spi_device *spi)
 		return -ENOMEM;
 	}
 
-#ifdef CONFIG_OF
-	if (spi->dev.of_node) {
-		hw_if.board_data = devm_kzalloc(&spi->dev,
-				sizeof(struct synaptics_dsx_board_data),
-				GFP_KERNEL);
-		if (!hw_if.board_data) {
-			dev_err(&spi->dev,
-					"%s: Failed to allocate memory for board data\n",
-					__func__);
-			return -ENOMEM;
-		}
-		hw_if.board_data->cap_button_map = devm_kzalloc(&spi->dev,
-				sizeof(struct synaptics_dsx_button_map),
-				GFP_KERNEL);
-		if (!hw_if.board_data->cap_button_map) {
-			dev_err(&spi->dev,
-					"%s: Failed to allocate memory for 0D button map\n",
-					__func__);
-			return -ENOMEM;
-		}
-		hw_if.board_data->vir_button_map = devm_kzalloc(&spi->dev,
-				sizeof(struct synaptics_dsx_button_map),
-				GFP_KERNEL);
-		if (!hw_if.board_data->vir_button_map) {
-			dev_err(&spi->dev,
-					"%s: Failed to allocate memory for virtual button map\n",
-					__func__);
-			return -ENOMEM;
-		}
-		parse_dt(&spi->dev, hw_if.board_data);
-	}
-#else
-	hw_if.board_data = spi->dev.platform_data;
-#endif
-
-	hw_if.bus_access = &bus_access;
-
 	spi->bits_per_word = 8;
 	spi->mode = SPI_MODE_3;
 
@@ -567,6 +264,9 @@ static int synaptics_rmi4_spi_probe(struct spi_device *spi)
 		return retval;
 	}
 
+	hw_if.board_data = spi->dev.platform_data;
+	hw_if.bus_access = &bus_access;
+
 	synaptics_dsx_spi_device->name = PLATFORM_DRIVER_NAME;
 	synaptics_dsx_spi_device->id = 0;
 	synaptics_dsx_spi_device->num_resources = 0;
@@ -592,42 +292,27 @@ static int synaptics_rmi4_spi_remove(struct spi_device *spi)
 	return 0;
 }
 
-#ifdef CONFIG_OF
-static struct of_device_id synaptics_rmi4_of_match_table[] = {
-	{
-		.compatible = "synaptics,dsx-spi",
-	},
-	{},
-};
-MODULE_DEVICE_TABLE(of, synaptics_rmi4_of_match_table);
-#else
-#define synaptics_rmi4_of_match_table NULL
-#endif
-
 static struct spi_driver synaptics_rmi4_spi_driver = {
 	.driver = {
 		.name = SPI_DRIVER_NAME,
 		.owner = THIS_MODULE,
-		.of_match_table = synaptics_rmi4_of_match_table,
 	},
 	.probe = synaptics_rmi4_spi_probe,
-	.remove = synaptics_rmi4_spi_remove,
+	.remove = __devexit_p(synaptics_rmi4_spi_remove),
 };
 
 
-int synaptics_rmi4_bus_init_v26(void)
+int synaptics_rmi4_bus_init(void)
 {
 	return spi_register_driver(&synaptics_rmi4_spi_driver);
 }
-EXPORT_SYMBOL(synaptics_rmi4_bus_init_v26);
+EXPORT_SYMBOL(synaptics_rmi4_bus_init);
 
-void synaptics_rmi4_bus_exit_v26(void)
+void synaptics_rmi4_bus_exit(void)
 {
 	spi_unregister_driver(&synaptics_rmi4_spi_driver);
-
-	return;
 }
-EXPORT_SYMBOL(synaptics_rmi4_bus_exit_v26);
+EXPORT_SYMBOL(synaptics_rmi4_bus_exit);
 
 MODULE_AUTHOR("Synaptics, Inc.");
 MODULE_DESCRIPTION("Synaptics DSX SPI Bus Support Module");
-- 
1.9.1

