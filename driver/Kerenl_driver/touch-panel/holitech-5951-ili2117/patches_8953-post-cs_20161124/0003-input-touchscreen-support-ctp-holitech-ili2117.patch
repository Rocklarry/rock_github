From b27857d8278dccbb21c62624a9045d2a6eceb8d1 Mon Sep 17 00:00:00 2001
From: Li Zhanchao <lizc1023@thundersoft.com>
Date: Mon, 12 Dec 2016 14:13:10 +0800
Subject: [PATCH 3/3] input:touchscreen: support ctp holitech ili2117

Add CTP HOLITECH@5951@ILI2117 driver

Change-Id: I1487bdc224c9b5fdeaa53036df9e2a1bd6bf22b8
Signed-off-by: Li Zhanchao <lizc1023@thundersoft.com>
---
 drivers/input/touchscreen/Makefile        |    3 +-
 drivers/input/touchscreen/ilitek_aimv20.c | 3254 +++++++++++++++++++++++++++++
 drivers/input/touchscreen/ilitek_ts.h     |  313 +++
 3 files changed, 3569 insertions(+), 1 deletion(-)
 create mode 100644 drivers/input/touchscreen/ilitek_aimv20.c
 create mode 100644 drivers/input/touchscreen/ilitek_ts.h

diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 8dacb2e..2f44db2 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -37,7 +37,8 @@ obj-$(CONFIG_TOUCHSCREEN_EGALAX)	+= egalax_ts.o
 obj-$(CONFIG_TOUCHSCREEN_FT5X06)	+= ft5x06_ts.o
 obj-$(CONFIG_TOUCHSCREEN_FUJITSU)	+= fujitsu_ts.o
 obj-$(CONFIG_TOUCHSCREEN_GEN_VKEYS)	+= gen_vkeys.o
-obj-$(CONFIG_TOUCHSCREEN_ILI210X)	+= ili210x.o
+#obj-$(CONFIG_TOUCHSCREEN_ILI210X)	+= ili210x.o
+obj-$(CONFIG_TOUCHSCREEN_ILI210X)	+= ilitek_aimv20.o
 obj-$(CONFIG_TOUCHSCREEN_INEXIO)	+= inexio.o
 obj-$(CONFIG_TOUCHSCREEN_INTEL_MID)	+= intel-mid-touch.o
 obj-$(CONFIG_TOUCHSCREEN_IT7260_I2C)    += it7258_ts_i2c.o
diff --git a/drivers/input/touchscreen/ilitek_aimv20.c b/drivers/input/touchscreen/ilitek_aimv20.c
new file mode 100644
index 0000000..68d11e3
--- /dev/null
+++ b/drivers/input/touchscreen/ilitek_aimv20.c
@@ -0,0 +1,3254 @@
+/*
+	Copyright (c) 2015-2016 by ilitek Technology.
+	All rights reserved.
+
+	ilitek I2C touch screen driver for Android platform
+
+	Author:	 Steward Fu
+	Maintain:Michael Hsu
+	Version: 1
+	History:
+		2010/10/26 Firstly released
+		2010/10/28 Combine both i2c and hid function together
+		2010/11/02 Support interrupt trigger for I2C interface
+		2010/11/10 Rearrange code and add new IOCTL command
+		2010/11/23 Support dynamic to change I2C address
+		2010/12/21 Support resume and suspend functions
+		2010/12/23 Fix synchronous problem when
+		application and driver work at the same time
+		2010/12/28 Add erasing background before calibrating touch panel
+		2011/01/13 Rearrange code and add interrupt with polling method
+		2011/01/14 Add retry mechanism
+		2011/01/17 Support multi-point touch
+		2011/01/21 Support early suspend function
+		2011/02/14 Support key button function
+		2011/02/18 Rearrange code
+		2011/03/21 Fix counld not report first point
+		2011/03/25 Support linux 2.36.x
+		2011/06/21 Avoid button is pressed when press AA
+		2011/08/03 Added ilitek_i2c_calibration function
+		2011/08/18 Fixed multi-point tracking id
+		2011/09/29 Added Stop Polling in Interrupt mode
+		2011/10/26 Fixed ROTATE bug
+		2011/11/09 Fixed release last point issue
+		2011/11/28 implement protocol 2.1.
+		2012/02/10 Added muti_touch key.
+*/
+#include "ilitek_ts.h"
+
+#define DRIVER_VERSION "aimvF"
+
+int khold;
+int kcode[] = {
+	KEY_MENU, KEY_HOMEPAGE, KEY_BACK, KEY_VOLUMEDOWN, KEY_VOLUMEUP};
+int kpress[] = { 0, 0, 0, 0, 0 };
+
+unsigned long touch_time;
+int driver_information[] = {
+	DERVER_VERSION_MAJOR, DERVER_VERSION_MINOR, CUSTOMER_ID, MODULE_ID,
+PLATFORM_ID, PLATFORM_MODULE, ENGINEER_ID };
+
+#define VIRTUAL_KEY_PAD
+#define VIRTUAL_FUN_1	1
+#define VIRTUAL_FUN_2	2
+#define VIRTUAL_FUN_3	3
+#define VIRTUAL_FUN		VIRTUAL_FUN_1
+#define BTN_DELAY_TIME	500
+
+#define TOUCH_POINT    0x80
+#define TOUCH_KEY      0xC0
+#define RELEASE_KEY    0x40
+#define RELEASE_POINT    0x00
+
+#define VTG_MIN_UV		2600000
+#define VTG_MAX_UV		3300000
+#define I2C_VTG_MIN_UV		1800000
+#define I2C_VTG_MAX_UV		1800000
+
+#define KEYPAD01_X1	0
+#define KEYPAD01_X2	1000
+#define KEYPAD02_X1	1000
+#define KEYPAD02_X2	2000
+#define KEYPAD03_X1	2000
+#define KEYPAD03_X2	3000
+#define KEYPAD04_X1	3000
+#define KEYPAD04_X2	3968
+#define KEYPAD_Y	2100
+/* definitions */
+#define ILITEK_I2C_RETRY_COUNT			3
+#define ILITEK_I2C_DRIVER_NAME			"ili2117"
+#define ILITEK_FILE_DRIVER_NAME			"ilitek_file"
+/*
+#define ILITEK_DEBUG_LEVEL			KERN_INFO
+#define ILITEK_ERROR_LEVEL			KERN_ALERT
+*/
+
+/*i2c command for ilitek touch screen*/
+#define ILITEK_TP_CMD_READ_DATA			    0x10
+#define ILITEK_TP_CMD_READ_SUB_DATA		    0x11
+#define ILITEK_TP_CMD_GET_RESOLUTION		0x20
+
+#define ILITEK_TP_CMD_GET_KEY_INFORMATION	0x22
+
+#define ILITEK_TP_CMD_SLEEP                 0x30
+#define ILITEK_TP_CMD_GET_FIRMWARE_VERSION	0x40
+#define ILITEK_TP_CMD_GET_PROTOCOL_VERSION	0x42
+#define	ILITEK_TP_CMD_CALIBRATION			0xCC
+#define	ILITEK_TP_CMD_CALIBRATION_STATUS	0xCD
+#define ILITEK_TP_CMD_ERASE_BACKGROUND		0xCE
+
+/*define the application command*/
+#define ILITEK_IOCTL_BASE             100
+#define ILITEK_IOCTL_I2C_WRITE_DATA \
+_IOWR(ILITEK_IOCTL_BASE, 0, unsigned char*)
+#define ILITEK_IOCTL_I2C_WRITE_LENGTH \
+_IOWR(ILITEK_IOCTL_BASE, 1, int)
+#define ILITEK_IOCTL_I2C_READ_DATA \
+_IOWR(ILITEK_IOCTL_BASE, 2, unsigned char*)
+#define ILITEK_IOCTL_I2C_READ_LENGTH \
+_IOWR(ILITEK_IOCTL_BASE, 3, int)
+#define ILITEK_IOCTL_USB_WRITE_DATA \
+_IOWR(ILITEK_IOCTL_BASE, 4, unsigned char*)
+#define ILITEK_IOCTL_USB_WRITE_LENGTH \
+_IOWR(ILITEK_IOCTL_BASE, 5, int)
+#define ILITEK_IOCTL_USB_READ_DATA \
+_IOWR(ILITEK_IOCTL_BASE, 6, unsigned char*)
+#define ILITEK_IOCTL_USB_READ_LENGTH \
+_IOWR(ILITEK_IOCTL_BASE, 7, int)
+
+#define ILITEK_IOCTL_DRIVER_INFORMATION \
+_IOWR(ILITEK_IOCTL_BASE, 8, int)
+#define ILITEK_IOCTL_USB_UPDATE_RESOLUTION \
+_IOWR(ILITEK_IOCTL_BASE, 9, int)
+
+#define ILITEK_IOCTL_I2C_INT_FLAG \
+_IOWR(ILITEK_IOCTL_BASE, 10, int)
+#define ILITEK_IOCTL_I2C_UPDATE \
+_IOWR(ILITEK_IOCTL_BASE, 11, int)
+#define ILITEK_IOCTL_STOP_READ_DATA \
+_IOWR(ILITEK_IOCTL_BASE, 12, int)
+#define ILITEK_IOCTL_START_READ_DATA \
+_IOWR(ILITEK_IOCTL_BASE, 13, int)
+#define ILITEK_IOCTL_GET_INTERFANCE \
+_IOWR(ILITEK_IOCTL_BASE, 14, int)
+#define ILITEK_IOCTL_I2C_SWITCH_IRQ \
+_IOWR(ILITEK_IOCTL_BASE, 15, int)
+#define ILITEK_IOCTL_UPDATE_FLAG \
+_IOWR(ILITEK_IOCTL_BASE, 16, int)
+#define ILITEK_IOCTL_I2C_UPDATE_FW \
+_IOWR(ILITEK_IOCTL_BASE, 18, int)
+
+#define DEBUG_DIR_NAME		"ts_debug"
+#define TS_INFO_MAX_LEN		512
+
+#define STORE_TS_INFO(buf, max_tch, driver_ver, fw_ver, fw_vkey_support) \
+			snprintf(buf, TS_INFO_MAX_LEN, \
+				"controller     = ILITEK\n" \
+				"chip name      = %s\n" \
+				"max_touches    = %d\n" \
+				"driver_ver     = %s\n" \
+				"fw_ver         = 0x%x\n" \
+				"fw_vkey_support= %s\n", \
+				ILITEK_I2C_DRIVER_NAME,	max_tch,\
+				 driver_ver, fw_ver, fw_vkey_support)
+
+/* module information */
+MODULE_AUTHOR("Steward_Fu");
+MODULE_DESCRIPTION("ILITEK I2C touch driver for Android platform");
+MODULE_LICENSE("GPL");
+
+/*
+   all implemented global functions must be defined in here
+ in order to know how many function we had implemented
+*/
+/* device data */
+struct dev_data {
+	/*device number */
+	dev_t devno;
+	/*character device */
+	struct cdev cdev;
+	/*class device */
+	struct class *class;
+};
+
+/*global variables*/
+static struct dev_data dev;
+
+static char Report_Flag;
+
+static char int_Flag;
+static char update_Flag;
+static int update_timeout;
+unsigned char kn = sizeof(kcode) / sizeof(kcode[0]);
+
+static const struct i2c_device_id ilitek_i2c_id[] = {
+	{ILITEK_I2C_DRIVER_NAME, 0}, {}
+};
+
+MODULE_DEVICE_TABLE(i2c, ilitek_i2c_id);
+
+static struct of_device_id ilitek_match_table[] = {
+	{.compatible = "ilitek",}, {},
+};
+
+/*declare i2c function table*/
+static struct i2c_driver ilitek_i2c_driver = {
+	.id_table = ilitek_i2c_id,
+	.driver = {
+		   .name = ILITEK_I2C_DRIVER_NAME,
+		   .owner = THIS_MODULE,
+		   .of_match_table = ilitek_match_table,
+		   },
+	.resume = ilitek_i2c_resume,
+	.suspend = ilitek_i2c_suspend,
+	.shutdown = ilitek_i2c_shutdown,
+	.probe = ilitek_i2c_probe,
+	.remove = ilitek_i2c_remove,
+};
+
+/* declare file operations */
+const struct file_operations ilitek_fops = {
+	.unlocked_ioctl = ilitek_file_ioctl,
+	.read = ilitek_file_read,
+	.write = ilitek_file_write,
+	.open = ilitek_file_open,
+	.release = ilitek_file_close,
+};
+
+/*
+description
+	open function for character device driver
+prarmeters
+	inode
+	    inode
+	filp
+	    file pointer
+return
+	status
+*/
+static int ilitek_file_open(struct inode *inode, struct file *filp)
+{
+	DBG("%s\n", __func__);
+	return 0;
+}
+
+/*
+description
+	calibration function
+prarmeters
+	count
+	    buffer length
+return
+	status
+*/
+static int ilitek_i2c_calibration(size_t count)
+{
+	int ret;
+	unsigned char buffer[128] = { 0 };
+	struct i2c_msg msgs[] = {
+		{.addr = i2c.client->addr,
+			.flags = 0,
+			.len = count,
+			.buf = buffer,}
+	};
+
+	buffer[0] = ILITEK_TP_CMD_ERASE_BACKGROUND;
+	msgs[0].len = 1;
+	ret = ilitek_i2c_transfer(i2c.client, msgs, 1);
+	if (ret < 0) {
+		pr_info(ILITEK_DEBUG_LEVEL "%s, i2c erase background, failed\n",
+		       __func__);
+	} else {
+		pr_info(ILITEK_DEBUG_LEVEL "%s, i2c erase background, success\n",
+		       __func__);
+	}
+
+	buffer[0] = ILITEK_TP_CMD_CALIBRATION;
+	msgs[0].len = 1;
+	msleep(2000);
+	ret = ilitek_i2c_transfer(i2c.client, msgs, 1);
+	msleep(1000);
+	return ret;
+}
+
+/*
+description
+	read calibration status
+prarmeters
+	count
+	    buffer length
+return
+	status
+*/
+static int ilitek_i2c_calibration_status(size_t count)
+{
+	int ret;
+	unsigned char buffer[128] = { 0 };
+	struct i2c_msg msgs[] = {
+		{.addr = i2c.client->addr,
+			.flags = 0,
+			.len = count,
+			.buf = buffer,}
+	};
+	buffer[0] = ILITEK_TP_CMD_CALIBRATION_STATUS;
+	ilitek_i2c_transfer(i2c.client, msgs, 1);
+	msleep(500);
+	ilitek_i2c_read(i2c.client, ILITEK_TP_CMD_CALIBRATION_STATUS, buffer,
+			1);
+	ret = buffer[0];
+	return ret;
+}
+
+/*
+description
+	write function for character device driver
+prarmeters
+	filp
+	    file pointer
+	buf
+	    buffer
+	count
+	    buffer length
+	f_pos
+	    offset
+return
+	status
+*/
+static ssize_t
+ilitek_file_write(struct file *filp, const char *buf, size_t count,
+		  loff_t *f_pos)
+{
+	int ret;
+	unsigned char buffer[128] = { 0 };
+
+	if (i2c.valid_i2c_register == 0) {
+		pr_info(ILITEK_ERROR_LEVEL
+		       "%s, i2c device driver doesn't be registered\n",
+		       __func__);
+		return -EINVAL;
+	}
+
+	if (count > 128) {
+		pr_info(ILITEK_ERROR_LEVEL "%s, buffer exceed 128 bytes\n",
+		       __func__);
+		return -EINVAL;
+	}
+
+	ret = copy_from_user(buffer, buf, count - 1);
+	if (ret < 0) {
+		pr_info(ILITEK_ERROR_LEVEL
+		       "%s, copy data from user space, failed", __func__);
+		return -EINVAL;
+	}
+
+	if (strcmp(buffer, "calibrate") == 0) {
+		ret = ilitek_i2c_calibration(count);
+		if (ret < 0) {
+			pr_info(ILITEK_DEBUG_LEVEL
+			       "%s, i2c send calibration command, failed\n",
+			       __func__);
+		} else {
+			pr_info(ILITEK_DEBUG_LEVEL
+			       "%s, i2c send calibration command, success\n",
+			       __func__);
+		}
+		ret = ilitek_i2c_calibration_status(count);
+		if (ret == 0x5A) {
+			pr_info(ILITEK_DEBUG_LEVEL
+			       "%s, i2c calibration, success\n", __func__);
+		} else if (ret == 0xA5) {
+			pr_info(ILITEK_DEBUG_LEVEL
+			       "%s, i2c calibration, failed\n", __func__);
+		} else {
+			pr_info(ILITEK_DEBUG_LEVEL
+			       "%s, i2c calibration, i2c protoco failed\n",
+			       __func__);
+		}
+		return count;
+	} else if (strcmp(buffer, "dbg") == 0) {
+		DBG_FLAG = !DBG_FLAG;
+		pr_info(ILITEK_DEBUG_LEVEL
+				"%s, %s DBG message(%X).\n", __func__,
+		       DBG_FLAG ? "Enabled" : "Disabled", DBG_FLAG);
+	} else if (strcmp(buffer, "dbgco") == 0) {
+		DBG_COR = !DBG_COR;
+	} else if (strcmp(buffer, "info") == 0) {
+		ilitek_i2c_read_tp_info();
+	} else if (strcmp(buffer, "report") == 0) {
+		Report_Flag = !Report_Flag;
+	} else if (strcmp(buffer, "chxy") == 0) {
+		EXCHANG_XY = !EXCHANG_XY;
+	} else if (strcmp(buffer, "revx") == 0) {
+		REVERT_X = !REVERT_X;
+	} else if (strcmp(buffer, "revy") == 0) {
+		REVERT_Y = !REVERT_Y;
+	} else if (strcmp(buffer, "suspd") == 0) {
+		pm_message_t pmsg;
+
+		pmsg.event = 0;
+		ilitek_i2c_suspend(i2c.client, pmsg);
+	} else if (strcmp(buffer, "resm") == 0) {
+		ilitek_i2c_resume(i2c.client);
+	}
+	/*
+	   else if(strcmp(buffer, "reset") == 0){
+	   ilitek_reset(i2c.reset_gpio);
+	   ilitek_i2c_reread_tp_info();
+	   } */
+	else if (strcmp(buffer, "stop_report") == 0) {
+		i2c.report_status = 0;
+		pr_info(ILITEK_DEBUG_LEVEL
+				"The report point function is disable.\n");
+	} else if (strcmp(buffer, "start_report") == 0) {
+		i2c.report_status = 1;
+		pr_info(ILITEK_DEBUG_LEVEL
+				"The report point function is enable.\n");
+	} else if (strcmp(buffer, "update_flag") == 0) {
+		pr_info(ILITEK_DEBUG_LEVEL
+				"update_Flag=%d\n", update_Flag);
+	} else if (strcmp(buffer, "reset") == 0) {
+		pr_info(ILITEK_DEBUG_LEVEL
+				"start reset\n");
+		if (i2c.reset_request_success)
+			ilitek_reset(i2c.reset_gpio);
+		pr_info(ILITEK_DEBUG_LEVEL "end reset\n");
+	}
+
+	return -EINVAL;
+}
+
+/*
+description
+	ioctl function for character device driver
+prarmeters
+	inode
+		file node
+		filp
+			file pointer
+		cmd
+			command
+		arg
+			arguments
+return
+		status
+*/
+/*#if LINUX_VERSION_CODE >=
+  KERNEL_VERSION(2, 6, 36)
+*/
+static long
+ilitek_file_ioctl(struct file *filp,
+					unsigned int cmd,
+					unsigned long arg)
+/*
+#else
+static int ilitek_file_ioctl(struct inode *inode, struct file *filp,
+			     unsigned int cmd, unsigned long arg)
+#endif
+*/
+{
+	static unsigned char buffer[64] = { 0 };
+	static int len = 0, i;
+	int ret;
+	struct i2c_msg msgs[] = {
+		{.addr = i2c.client->addr,
+			.flags = 0,
+			.len = len,
+			.buf = buffer,}
+	};
+
+	switch (cmd) {
+	case ILITEK_IOCTL_I2C_WRITE_DATA:
+		ret = copy_from_user(buffer, (unsigned char *)arg, len);
+		if (ret < 0) {
+			pr_info(ILITEK_ERROR_LEVEL
+			       "%s, copy data from user space, failed\n",
+			       __func__);
+			return -EINVAL;
+		}
+/*
+#ifdef	SET_RESET
+			if(buffer[0] == 0x60){
+				ilitek_i2c_reset();
+			}
+#endif
+*/
+		ret = ilitek_i2c_transfer(i2c.client, msgs, 1);
+		if (ret < 0) {
+			pr_info(ILITEK_ERROR_LEVEL "%s, i2c write, failed\n",
+			       __func__);
+			return -EINVAL;
+		}
+		break;
+	case ILITEK_IOCTL_I2C_READ_DATA:
+		msgs[0].flags = I2C_M_RD;
+
+		ret = ilitek_i2c_transfer(i2c.client, msgs, 1);
+		if (ret < 0) {
+			pr_info(ILITEK_ERROR_LEVEL "%s, i2c read, failed\n",
+			       __func__);
+			return -EINVAL;
+		}
+		ret = copy_to_user((unsigned char *)arg, buffer, len);
+
+		if (ret < 0) {
+			pr_info(ILITEK_ERROR_LEVEL
+			       "%s, copy data to user space, failed\n",
+			       __func__);
+			return -EINVAL;
+		}
+		break;
+	case ILITEK_IOCTL_I2C_WRITE_LENGTH:
+	case ILITEK_IOCTL_I2C_READ_LENGTH:
+		len = arg;
+		break;
+	case ILITEK_IOCTL_DRIVER_INFORMATION:
+		for (i = 0; i < 7; i++)
+			buffer[i] = driver_information[i];
+
+		ret = copy_to_user((unsigned char *)arg, buffer, 7);
+		break;
+	case ILITEK_IOCTL_I2C_UPDATE:
+		break;
+	case ILITEK_IOCTL_I2C_INT_FLAG:
+		if (update_timeout == 1) {
+			buffer[0] = int_Flag;
+			ret = copy_to_user((unsigned char *)arg, buffer, 1);
+			if (ret < 0) {
+				pr_info(ILITEK_ERROR_LEVEL
+				       "%s, copy data to user space, failed\n",
+				       __func__);
+				return -EINVAL;
+			}
+		} else
+			update_timeout = 1;
+
+		break;
+	case ILITEK_IOCTL_START_READ_DATA:
+		i2c.stop_polling = 0;
+		if (i2c.client->irq != 0)
+			ilitek_i2c_irq_enable();
+		i2c.report_status = 1;
+		break;
+	case ILITEK_IOCTL_STOP_READ_DATA:
+		i2c.stop_polling = 1;
+		if (i2c.client->irq != 0)
+			ilitek_i2c_irq_disable();
+		i2c.report_status = 0;
+		break;
+	case ILITEK_IOCTL_I2C_SWITCH_IRQ:
+		ret = copy_from_user(buffer, (unsigned char *)arg, 1);
+		if (buffer[0] == 0) {
+			if (i2c.client->irq != 0)
+				ilitek_i2c_irq_disable();
+		} else {
+			if (i2c.client->irq != 0)
+				ilitek_i2c_irq_enable();
+		}
+		break;
+	case ILITEK_IOCTL_UPDATE_FLAG:
+		update_timeout = 1;
+		update_Flag = arg;
+		DBG("%s,update_Flag=%d\n", __func__, update_Flag);
+		break;
+	case ILITEK_IOCTL_I2C_UPDATE_FW:
+		ret = copy_from_user(buffer, (unsigned char *)arg, 35);
+		if (ret < 0) {
+			pr_info(ILITEK_ERROR_LEVEL
+			       "%s, copy data from user space, failed\n",
+			       __func__);
+			return -EINVAL;
+		}
+		int_Flag = 0;
+		update_timeout = 0;
+		msgs[0].len = buffer[34];
+		ret = ilitek_i2c_transfer(i2c.client, msgs, 1);
+#ifndef CLOCK_INTERRUPT
+		ilitek_i2c_irq_enable();
+#endif
+		if (ret < 0) {
+			pr_info(ILITEK_ERROR_LEVEL "%s, i2c write, failed\n",
+			       __func__);
+			return -EINVAL;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/*
+description
+	read function for character device driver
+prarmeters
+	filp
+	    file pointer
+	buf
+	    buffer
+	count
+	    buffer length
+	f_pos
+	    offset
+return
+	status
+*/
+static ssize_t
+ilitek_file_read(struct file *filp, char *buf, size_t count, loff_t *f_pos)
+{
+	return 0;
+}
+
+/*
+description
+	close function
+prarmeters
+	inode
+	    inode
+	filp
+	    file pointer
+return
+	status
+*/
+static int ilitek_file_close(struct inode *inode, struct file *filp)
+{
+	DBG("%s\n", __func__);
+	return 0;
+}
+
+/*
+description
+	set input device's parameter
+prarmeters
+	input
+		input device data
+	max_tp
+		single touch or multi touch
+	max_x
+		maximum	x value
+	max_y
+		maximum y value
+return
+	nothing
+*/
+
+static void
+ilitek_set_input_param(struct input_dev *input,
+		       int max_tp, int max_x, int max_y)
+{
+	int key;
+
+	__set_bit(INPUT_PROP_DIRECT, input->propbit);
+	input->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+#ifndef ROTATE_FLAG
+	input_set_abs_params(input, ABS_MT_POSITION_X, 0, max_x + 2, 0, 0);
+	input_set_abs_params(input, ABS_MT_POSITION_Y, 0, max_y + 2, 0, 0);
+#else
+	input_set_abs_params(input, ABS_MT_POSITION_X, 0, max_y + 2, 0, 0);
+	input_set_abs_params(input, ABS_MT_POSITION_Y, 0, max_x + 2, 0, 0);
+#endif
+	input_set_abs_params(input, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(input, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(input, ABS_MT_TRACKING_ID, 0, max_tp, 0, 0);
+	for (key = 0; key < kn;
+	     key++) {
+		if (kcode[key] <= 0)
+			continue;
+
+		set_bit(kcode[key], input->keybit);
+	}
+	input->name = ILITEK_I2C_DRIVER_NAME;
+	input->id.bustype = BUS_I2C;
+	input->dev.parent = &(i2c.client)->dev;
+}
+
+/*
+description
+	send message to i2c adaptor
+parameter
+	client
+		i2c client
+	msgs
+		i2c message
+	cnt
+		i2c message count
+return
+	>= 0 if success
+	others if error
+*/
+static int ilitek_i2c_transfer(struct i2c_client *client, struct i2c_msg *msgs,
+		int cnt)
+{
+	int ret, count = ILITEK_I2C_RETRY_COUNT;
+
+	while (count >= 0) {
+		count -= 1;
+		ret = down_interruptible(&i2c.wr_sem);
+		ret = i2c_transfer(client->adapter, msgs, cnt);
+		up(&i2c.wr_sem);
+		if (ret < 0) {
+			msleep(500);
+			continue;
+		}
+		break;
+	}
+	return ret;
+}
+
+/*
+description
+	read data from i2c device
+parameter
+	client
+		i2c client data
+	addr
+		i2c address
+	data
+		data for transmission
+	length
+		data length
+return
+	status
+*/
+static int
+ilitek_i2c_read(struct i2c_client *client,
+		uint8_t cmd, uint8_t *data, int length)
+{
+	int ret;
+	struct i2c_msg msgs_cmd[] = {
+		{.addr = client->addr, .flags = 0, .len = 1, .buf = &cmd,},
+	};
+
+	struct i2c_msg msgs_ret[] = {
+		{.addr = client->addr, .flags = I2C_M_RD, .len = length, .buf =
+		 data,}
+	};
+
+	ret = ilitek_i2c_transfer(client, msgs_cmd, 1);
+	if (ret < 0) {
+		pr_info(ILITEK_ERROR_LEVEL "%s, i2c read error, ret %d\n",
+		       __func__, ret);
+	}
+
+	ret = ilitek_i2c_transfer(client, msgs_ret, 1);
+	if (ret < 0) {
+		pr_info(ILITEK_ERROR_LEVEL "%s, i2c read error, ret %d\n",
+		       __func__, ret);
+	}
+
+	return ret;
+}
+
+/*
+description
+	read data from i2c device
+parameter
+	client
+		i2c client data
+	addr
+		i2c address
+	data
+		data for transmission
+	length
+		data length
+return
+	status
+*/
+static int
+ilitek_i2c_only_read(struct i2c_client *client, uint8_t *data, int length)
+{
+	int ret;
+	struct i2c_msg msgs[] = {
+		{.addr = client->addr, .flags = I2C_M_RD, .len = length, .buf =
+		 data,}
+	};
+
+	ret = ilitek_i2c_transfer(client, msgs, 1);
+	if (ret < 0) {
+		pr_info(ILITEK_ERROR_LEVEL "%s, i2c read error, ret %d\n",
+		       __func__, ret);
+	}
+	return ret;
+}
+
+static int ilitek_power_on(struct i2c_data *data, bool on)
+{
+	int rc;
+
+	if (!on)
+		goto power_off;
+
+	rc = regulator_enable(data->vdd);
+	if (rc) {
+		dev_err(&data->client->dev,
+			"Regulator vdd enable failed rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = regulator_enable(data->vcc_i2c);
+	if (rc) {
+		dev_err(&data->client->dev,
+			"Regulator vcc_i2c enable failed rc=%d\n", rc);
+		regulator_disable(data->vdd);
+	}
+
+	return rc;
+
+power_off:
+	rc = regulator_disable(data->vdd);
+	if (rc) {
+		dev_err(&data->client->dev,
+			"Regulator vdd disable failed rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = regulator_disable(data->vcc_i2c);
+	if (rc) {
+		dev_err(&data->client->dev,
+			"Regulator vcc_i2c disable failed rc=%d\n", rc);
+		rc = regulator_enable(data->vdd);
+	}
+
+	return rc;
+}
+
+static int ilitek_power_init(struct i2c_data *data, bool on)
+{
+	int rc;
+
+	if (!on)
+		goto pwr_deinit;
+
+	data->vdd = regulator_get(&data->client->dev, "vdd");
+	if (IS_ERR(data->vdd)) {
+		rc = PTR_ERR(data->vdd);
+		dev_err(&data->client->dev,
+			"Regulator get failed vdd rc=%d\n", rc);
+		return rc;
+	}
+
+	if (regulator_count_voltages(data->vdd) > 0) {
+		rc = regulator_set_voltage(data->vdd, VTG_MIN_UV, VTG_MAX_UV);
+		if (rc) {
+			dev_err(&data->client->dev,
+				"Regulator set_vtg failed vdd rc=%d\n", rc);
+			goto reg_vdd_put;
+		}
+	}
+
+	data->vcc_i2c = regulator_get(&data->client->dev, "vcc_i2c");
+	if (IS_ERR(data->vcc_i2c)) {
+		rc = PTR_ERR(data->vcc_i2c);
+		dev_err(&data->client->dev,
+			"Regulator get failed vcc_i2c rc=%d\n", rc);
+		goto reg_vdd_set_vtg;
+	}
+
+	if (regulator_count_voltages(data->vcc_i2c) > 0) {
+		rc = regulator_set_voltage(data->vcc_i2c, I2C_VTG_MIN_UV,
+					   I2C_VTG_MAX_UV);
+		if (rc) {
+			dev_err(&data->client->dev,
+				"Regulator set_vtg failed vcc_i2c rc=%d\n", rc);
+			goto reg_vcc_i2c_put;
+		}
+	}
+
+	return 0;
+
+reg_vcc_i2c_put:
+	regulator_put(data->vcc_i2c);
+reg_vdd_set_vtg:
+	if (regulator_count_voltages(data->vdd) > 0)
+		regulator_set_voltage(data->vdd, 0, VTG_MAX_UV);
+reg_vdd_put:
+	regulator_put(data->vdd);
+	return rc;
+pwr_deinit:
+	if (regulator_count_voltages(data->vdd) > 0)
+		regulator_set_voltage(data->vdd, 0, VTG_MAX_UV);
+	regulator_put(data->vdd);
+	return 0;
+}
+
+/*
+description
+	process i2c data and then report to kernel
+parameters
+	none
+return
+	status
+*/
+
+static int ilitek_i2c_process_and_report(void)
+{
+#ifdef ROTATE_FLAG
+	int org_x = 0, org_y = 0;
+#endif
+	int i, len = 0, ret, x = 0, y = 0, key, mult_tp_id, packet =
+	    0, tp_status = 0, release_flag[10] = { 0 };
+#ifdef VIRTUAL_KEY_PAD
+	unsigned char key_id = 0, key_flag = 1;
+#endif
+	static unsigned char last_id;
+	struct input_dev *input = i2c.input_dev;
+	unsigned char buf[64] = { 0 };
+	unsigned char tp_id, max_point = 6;
+	unsigned char release_counter = 0;
+
+	if (i2c.report_status == 0)
+		return 1;
+
+	if ((i2c.protocol_ver & 0xFF00) == 0x300) {
+		ret =
+		    ilitek_i2c_read(i2c.client,
+			ILITEK_TP_CMD_READ_DATA, buf, 31);
+		if (ret < 0)
+			return ret;
+
+		packet = buf[0];
+		ret = 1;
+		if (packet == 2) {
+			ret = ilitek_i2c_only_read(i2c.client, buf + 31, 20);
+			if (ret < 0)
+				return ret;
+
+			max_point = 10;
+		}
+		/* read touch point */
+		for (i = 0; i < max_point; i++) {
+			tp_status = buf[i * 5 + 1] >> 7;
+#ifndef ROTATE_FLAG
+			x = (((buf[i * 5 + 1] & 0x3F) << 8) + buf[i * 5 + 2]);
+			y = (buf[i * 5 + 3] << 8) + buf[i * 5 + 4];
+#else
+			org_x =
+			    (((buf[i * 5 + 1] & 0x3F) << 8) + buf[i * 5 + 2]);
+			org_y = (buf[i * 5 + 3] << 8) + buf[i * 5 + 4];
+			x = i2c.max_y - org_y + 1;
+			y = org_x + 1;
+#endif
+			if (EXCHANG_XY) {
+				int temp = x;
+
+				x = y;
+				y = temp;
+			}
+
+			if (REVERT_X)
+				x = i2c.max_x - x;
+			if (REVERT_Y)
+				y = i2c.max_y - y;
+
+			if (tp_status) {
+				if (i2c.keyflag == 0) {
+					/*for (j = 0;
+					j <= i2c.keycount;
+					j++) {*/
+					if ((x >= i2c.ki[0].x
+						&& x <= i2c.ki[0].x +
+						i2c.key_xlen)
+						&& (y >= i2c.ki[0].y
+						&& y <=
+						i2c.ki[0].y +
+						i2c.key_ylen)) {
+						input_report_key(input,
+							i2c.ki[0].id, 1);
+							i2c.ki[0].st = 1;
+							khold = 1;
+							release_flag[0] = 1;
+							break;
+						}
+					/*}*/
+				}
+				if (khold == 0) {
+					input_report_key(i2c.input_dev,
+							 BTN_TOUCH, 1);
+					input_event(i2c.input_dev, EV_ABS,
+						    ABS_MT_TRACKING_ID, i);
+					input_event(i2c.input_dev, EV_ABS,
+						    ABS_MT_POSITION_X, x);
+					input_event(i2c.input_dev, EV_ABS,
+						    ABS_MT_POSITION_Y, y);
+					input_event(i2c.input_dev, EV_ABS,
+						    ABS_MT_TOUCH_MAJOR, 1);
+					input_mt_sync(i2c.input_dev);
+					release_flag[i] = 1;
+					i2c.keyflag = 1;
+				}
+				if (khold == 1) {
+					int st, o, p, s, t;
+
+					st = i2c.ki[0].st;
+					o = i2c.ki[0].x;
+					p = i2c.key_xlen;
+					s = i2c.ki[0].y;
+					t = i2c.key_ylen;
+					/*for (j = 0;
+					j <= i2c.keycount;
+					j++) {*/
+					if ((st == 1) && (x < o || x >
+						o + p || y < s
+						|| y > s + t)) {
+						input_report_key(input,
+						i2c.ki[0].id, 0);
+						i2c.ki[0].st = 0;
+						khold = 0;
+						break;
+					}
+					/*}*/
+				}
+
+				ret = 0;
+			} else {
+				release_flag[i] = 0;
+				input_mt_sync(i2c.input_dev);
+			}
+
+		}
+		if (packet == 0) {
+			i2c.keyflag = 0;
+			input_report_key(i2c.input_dev, BTN_TOUCH, 0);
+			input_mt_sync(i2c.input_dev);
+		} else {
+			for (i = 0; i < max_point; i++) {
+				if (release_flag[i] == 0)
+					release_counter++;
+			}
+			if (release_counter == max_point) {
+				input_report_key(i2c.input_dev, BTN_TOUCH, 0);
+				input_mt_sync(i2c.input_dev);
+				i2c.keyflag = 0;
+				if (khold == 1) {
+					/*for (i = 0; i < i2c.keycount; i++) {*/
+					if (i2c.ki[0].st) {
+						input_report_key(input,
+						i2c.ki[0].id, 0);
+						i2c.ki[0].st = 0;
+						khold = 0;
+					}
+					/*}*/
+				}
+			}
+			DBG("release_counter=%d,packet=%d\n", release_counter,
+			    packet);
+		}
+	} else if ((i2c.protocol_ver & 0xFF00) == 0x200) {
+		ret =
+			ilitek_i2c_read(i2c.client,
+			ILITEK_TP_CMD_READ_DATA, buf, 1);
+		if (ret < 0)
+			return ret;
+
+		len = buf[0];
+		ret = 1;
+		if (len > 20)
+			return ret;
+
+		for (i = 0; i < len; i++) {
+			if (ilitek_i2c_read
+			    (i2c.client, ILITEK_TP_CMD_READ_SUB_DATA, buf, 5)) {
+				x = (((int)buf[1]) << 8) + buf[2];
+				y = (((int)buf[3]) << 8) + buf[4];
+
+				if (EXCHANG_XY) {
+					int temp = x;
+
+					x = y;
+					y = temp;
+				}
+
+				if (REVERT_X)
+					x = i2c.max_x - x;
+				if (REVERT_Y)
+					y = i2c.max_y - y;
+
+				DBG_CO("id = %d,x = %d,y = %d\n", buf[0], x, y);
+
+				mult_tp_id = buf[0];
+				switch ((mult_tp_id & 0xC0)) {
+#ifdef VIRTUAL_KEY_PAD
+				case RELEASE_KEY:
+				DBG("Key: Release\n");
+				for (key = 0;
+					key <
+					sizeof(kcode) /
+					sizeof(kcode[0]); key++) {
+					if (kpress[key]) {
+						input_report_key(input,
+						kcode[key], 0);
+						kpress[key] = 0;
+					}
+					khold = 0;
+				}
+
+					break;
+
+				case TOUCH_KEY:
+#if VIRTUAL_FUN == VIRTUAL_FUN_1
+					key_id = buf[1] - 1;
+#endif
+#if VIRTUAL_FUN == VIRTUAL_FUN_2
+				if (abs(jiffies - touch_time) <
+					msecs_to_jiffies(BTN_DELAY_TIME))
+					break;
+				x = (((int)buf[4]) << 8) + buf[3];
+
+				if (x > KEYPAD01_X1 &&
+						x < KEYPAD01_X2)
+					key_id = 0;
+				else if (x > KEYPAD02_X1
+						&& x < KEYPAD02_X2)
+					key_id = 1;
+				else if (x > KEYPAD03_X1
+						&& x < KEYPAD03_X2)
+					key_id = 2;
+				else if (x > KEYPAD04_X1
+						&& x < KEYPAD04_X2)
+					key_id = 3;
+				else
+					key_flag = 0
+#endif
+				if ((kpress[key_id] == 0) &&
+					(khold == 0 &&
+						key_flag)) {
+						input_report_key(input,
+						kcode[key_id], 1);
+						kpress[key_id] = 1;
+						khold = 1;
+				}
+					break;
+#endif
+				case TOUCH_POINT:
+
+#ifdef VIRTUAL_KEY_PAD
+#if VIRTUAL_FUN == VIRTUAL_FUN_3
+				if ((buf[0] & 0x80) != 0
+					&& (y > KEYPAD_Y) && i == 0) {
+					DBG("%s,touch key\n", __func__);
+					if ((x > KEYPAD01_X1) &&
+						(x < KEYPAD01_X2)) {
+						input_report_key(input,
+							kcode[0], 1);
+						kpress[0] = 1;
+						khold = 1;
+					} else if ((x > KEYPAD02_X1) &&
+							(x < KEYPAD02_X2)) {
+						input_report_key(input,
+							kcode[1], 1);
+						kpress[1] = 1;
+						khold = 1;
+					} else if ((x > KEYPAD03_X1) &&
+							(x < KEYPAD03_X2)) {
+						input_report_key(input,
+							kcode[2], 1);
+						kpress[2] = 1;
+						khold = 1;
+					} else {
+						input_report_key(input,
+							kcode[3], 1);
+						kpress[3] = 1;
+						khold = 1;
+					}
+				}
+				if ((buf[0] & 0x80) != 0
+						&& y <= KEYPAD_Y)
+					khold = 0;
+				if ((buf[0] & 0x80) != 0
+					&& y <= KEYPAD_Y) {
+#endif
+#endif
+					/* report to android system */
+					input_report_key(input, BTN_TOUCH, 1);
+					input_event(input,
+						EV_ABS, ABS_MT_TRACKING_ID,
+						(buf[0] & 0x3F) - 1);
+					input_event(input,
+						EV_ABS, ABS_MT_POSITION_X,
+						x + 1);
+					input_event(input,
+						EV_ABS, ABS_MT_POSITION_Y,
+						y + 1);
+					input_event(input,
+						EV_ABS, ABS_MT_TOUCH_MAJOR, 1);
+					input_mt_sync(input);
+					ret = 0;
+#ifdef VIRTUAL_KEY_PAD
+#if VIRTUAL_FUN == VIRTUAL_FUN_3
+			}
+#endif
+#endif
+				break;
+
+				case RELEASE_POINT:
+				if (khold != 0 && i == 0) {
+					/*for (key = 0; key < kn; key++) {*/
+					if (kpress[0]) {
+						input_report_key(input,
+							kcode[0], 0);
+						kpress[0] = 0;
+					}
+
+					if (kpress[1]) {
+						input_report_key(input,
+							kcode[1], 0);
+						kpress[1] = 0;
+					}
+
+					if (kpress[2]) {
+						input_report_key(input,
+							kcode[2], 0);
+						kpress[2] = 0;
+					}
+
+					if (kpress[3]) {
+						input_report_key(input,
+							kcode[3], 0);
+						kpress[3] = 0;
+					}
+					if (kpress[4]) {
+						input_report_key(input,
+							kcode[4], 0);
+						kpress[4] = 0;
+					}
+
+					khold = 0;
+					/*}*/
+				}
+#ifdef CLOCK_INTERRUPT
+					release_counter++;
+					if (release_counter == len) {
+						input_report_key(input,
+								 BTN_TOUCH, 0);
+						input_mt_sync(input);
+					}
+#endif
+					ret = 0;
+					break;
+
+				default:
+					break;
+				}
+			}
+		}
+
+		if (len == 0) {
+			DBG("Release3, ID=%02X, X=%04d, Y=%04d\n",
+			    buf[0] & 0x3F, x, y);
+			input_report_key(input, BTN_TOUCH, 0);
+			input_mt_sync(input);
+			ret = 1;
+			if (khold != 0) {
+				for (key = 0;
+				     key <
+				     sizeof(kcode) /
+				     sizeof(kcode[0]); key++) {
+					if (kpress[key]) {
+						input_report_key(input,
+								 kcode
+								 [key], 0);
+						kpress[key] = 0;
+						DBG("Key:%d ID:%d release\n",
+						    kcode[key], key);
+						DBG(ILITEK_DEBUG_LEVEL
+						    "%s key release, %X, %d, %d\n",
+						    __func__, buf[0], x, y);
+					}
+					khold = 0;
+				}
+			}
+		}
+		DBG("%s,ret=%d\n", __func__, ret);
+	} else {
+		ret =
+		    ilitek_i2c_read(i2c.client, ILITEK_TP_CMD_READ_DATA, buf,
+				    9);
+		if (ret < 0)
+			return ret;
+
+		if (buf[0] > 20) {
+			ret = 1;
+			return ret;
+		}
+		ret = 0;
+
+		tp_id = buf[0];
+		if (Report_Flag != 0) {
+			for (i = 0; i < 9; i++)
+				DBG("%02X,", buf[i]);
+		}
+		switch (tp_id) {
+		case 0:	/*release point */
+#ifdef VIRTUAL_KEY_PAD
+			if (khold != 0) {
+				for (key = 0;
+				     key <
+				     sizeof(kcode) /
+				     sizeof(kcode[0]); key++) {
+					if (kpress[key]) {
+						kpress[key] = 0;
+						DBG("Key:%d ID:%d release\n",
+						    kcode[key], key);
+					}
+				}
+				khold = 0;
+			} else
+#endif
+			{
+				for (i = 0; i < i2c.max_tp; i++) {
+					if (!(last_id & (1 << i)))
+						continue;
+
+#ifndef ROTATE_FLAG
+				x = (int)buf[1 + (i * 4)] +
+				    ((int)buf[2 + (i * 4)] * 256);
+				y = (int)buf[3 + (i * 4)] +
+				    ((int)buf[4 + (i * 4)] * 256);
+#else
+				org_x =
+				    (int)buf[1 + (i * 4)] +
+				    ((int)buf[2 + (i * 4)] * 256);
+				org_y =
+				    (int)buf[3 + (i * 4)] +
+				    ((int)buf[4 + (i * 4)] * 256);
+				x = i2c.max_y - org_y + 1;
+				y = org_x + 1;
+#endif
+
+				if (EXCHANG_XY) {
+					int temp = x;
+
+					x = y;
+					y = temp;
+				}
+
+				if (REVERT_X)
+					x = i2c.max_x - x;
+				if (REVERT_Y)
+					y = i2c.max_y - y;
+
+				khold = 2;
+				input_report_key(input, BTN_TOUCH, 1);
+				input_event(i2c.input_dev, EV_ABS,
+					    ABS_MT_TRACKING_ID, i);
+				input_event(i2c.input_dev, EV_ABS,
+					    ABS_MT_POSITION_X, x + 1);
+				input_event(i2c.input_dev, EV_ABS,
+					    ABS_MT_POSITION_Y, y + 1);
+				input_event(i2c.input_dev, EV_ABS,
+					    ABS_MT_TOUCH_MAJOR, 1);
+				input_mt_sync(i2c.input_dev);
+				DBG("Last Point[%d]= %d, %d\n",
+				    buf[0] & 0x3F, x, y);
+				last_id = 0;
+			}
+			input_sync(i2c.input_dev);
+			input_event(i2c.input_dev, EV_ABS,
+				    ABS_MT_TOUCH_MAJOR, 0);
+			input_mt_sync(i2c.input_dev);
+			ret = 1;
+		}
+		break;
+#ifdef VIRTUAL_KEY_PAD
+		case 0x81:
+			if (abs(jiffies - touch_time) <
+			    msecs_to_jiffies(BTN_DELAY_TIME))
+				break;
+			DBG("Key: Enter\n");
+
+#if VIRTUAL_FUN == VIRTUAL_FUN_1
+			key_id = buf[1] - 1;
+#endif
+
+#if VIRTUAL_FUN == VIRTUAL_FUN_2
+			x = (int)buf[1] + ((int)buf[2] * 256);
+			if (x > KEYPAD01_X1 && x < KEYPAD01_X2)
+				key_id = 0;
+			else if (x > KEYPAD02_X1 && x < KEYPAD02_X2)
+				key_id = 1;
+			else if (x > KEYPAD03_X1 && x < KEYPAD03_X2)
+				key_id = 2;
+			else if (x > KEYPAD04_X1 && x < KEYPAD04_X2)
+				key_id = 3;
+			else
+				key_flag = 0;
+#endif
+			input_report_abs(input, ABS_MT_TOUCH_MAJOR, 0);
+			input_mt_sync(input);
+			if ((kpress[key_id] == 0)
+			    && (khold == 0 && key_flag)) {
+				input_report_key(input, kcode[key_id],
+						 1);
+				kpress[key_id] = 1;
+				khold = 1;
+				DBG("Key:%d ID:%d press\n",
+				    kcode[key_id], key_id);
+			}
+			break;
+		case 0x80:
+			DBG("Key: Release\n");
+			for (key = 0;
+			     key < kn; key++) {
+				if (kpress[key]) {
+					input_report_key(input,
+							 kcode[key],
+							 0);
+					kpress[key] = 0;
+					DBG("Key:%d ID:%d release\n",
+					    kcode[key], key);
+				}
+			}
+			khold = 0;
+			ret = 1;
+			break;
+#endif
+		default:
+			last_id = buf[0];
+			for (i = 0; i < i2c.max_tp; i++) {
+				if (!(buf[0] & (1 << i)))
+					continue;
+
+#ifndef ROTATE_FLAG
+				x = (int)buf[1 + (i * 4)] +
+				    ((int)buf[2 + (i * 4)] * 256);
+				y = (int)buf[3 + (i * 4)] +
+				    ((int)buf[4 + (i * 4)] * 256);
+#else
+				org_x =
+				    (int)buf[1 + (i * 4)] +
+				    ((int)buf[2 + (i * 4)] * 256);
+				org_y =
+				    (int)buf[3 + (i * 4)] +
+				    ((int)buf[4 + (i * 4)] * 256);
+				x = i2c.max_y - org_y + 1;
+				y = org_x + 1;
+#endif
+
+				if (EXCHANG_XY) {
+					int temp = x;
+
+					x = y;
+					y = temp;
+				}
+
+				if (REVERT_X)
+					x = i2c.max_x - x;
+				if (REVERT_Y)
+					y = i2c.max_y - y;
+
+#ifdef VIRTUAL_KEY_PAD
+#if VIRTUAL_FUN == VIRTUAL_FUN_3
+				if (y > KEYPAD_Y) {
+					if (abs(jiffies - touch_time) <
+					    msecs_to_jiffies(BTN_DELAY_TIME))
+						break;
+					x = (int)buf[1] + ((int)buf[2] * 256);
+					if (x > KEYPAD01_X1 && x < KEYPAD01_X2)
+						key_id = 0;
+					else if (x > KEYPAD02_X1
+						 && x < KEYPAD02_X2)
+						key_id = 1;
+					else if (x > KEYPAD03_X1
+						 && x < KEYPAD03_X2)
+						key_id = 2;
+					else if (x > KEYPAD04_X1
+						 && x < KEYPAD04_X2)
+						key_id = 3;
+					else
+						key_flag = 0;
+					if (khold == 2) {
+						input_report_key(input,
+								 BTN_TOUCH, 0);
+						input_event(i2c.input_dev,
+							    EV_ABS,
+							    ABS_MT_TOUCH_MAJOR,
+							    0);
+						input_mt_sync(i2c.input_dev);
+						khold = 0;
+					}
+					if ((kpress[key_id] == 0)
+					    && (khold == 0
+						&& key_flag)) {
+						kpress[key_id] = 1;
+						khold = 1;
+						DBG("Key:%d ID:%d press\n",
+						    kcode[key_id],
+						    key_id);
+					}
+				} else if (khold) {
+					/*for (key = 0; key < kn; key++) {*/
+					if (kpress[0])
+						kpress[0] = 0;
+					if (kpress[1])
+						kpress[1] = 0;
+					if (kpress[2])
+						kpress[2] = 0;
+					if (kpress[3])
+						kpress[3] = 0;
+					if (kpress[4])
+						kpress[4] = 0;
+					/*}*/
+						khold = 0;
+				} else
+#endif
+					touch_time =
+					    jiffies +
+					    msecs_to_jiffies(BTN_DELAY_TIME);
+#endif
+				{
+					khold = 2;
+					input_report_key(input, BTN_TOUCH, 1);
+					input_event(i2c.input_dev, EV_ABS,
+						    ABS_MT_TRACKING_ID, i);
+					input_event(i2c.input_dev, EV_ABS,
+						    ABS_MT_POSITION_X, x + 1);
+					input_event(i2c.input_dev, EV_ABS,
+						    ABS_MT_POSITION_Y, y + 1);
+					input_event(i2c.input_dev, EV_ABS,
+						    ABS_MT_TOUCH_MAJOR, 1);
+					input_mt_sync(i2c.input_dev);
+					DBG("Point[%d]= %d, %d\n",
+					    buf[0] & 0x3F, x, y);
+				}
+
+			}
+			break;
+		}
+	}
+	input_sync(i2c.input_dev);
+	return ret;
+}
+
+/*
+static void ilitek_i2c_timer(unsigned long handle)
+{
+    struct i2c_data *priv = (void *)handle;
+    DBG("Enter\n");
+
+    schedule_work(&priv->irq_work);
+}
+*/
+
+/*
+description
+	work queue function for irq use
+parameter
+	work
+		work queue
+return
+	nothing
+*/
+static void ilitek_i2c_irq_work_queue_func(struct work_struct *work)
+{
+	int ret;
+
+	DBG("Enter\n");
+
+	ret = ilitek_i2c_process_and_report();
+
+#ifdef CLOCK_INTERRUPT
+	ilitek_i2c_irq_enable();
+#else
+
+	if (ret == 0) {
+		if (!i2c.stop_polling)
+			mod_timer(&priv->timer, jiffies + msecs_to_jiffies(0));
+	} else if (ret == 1) {
+		if (!i2c.stop_polling)
+			ilitek_i2c_irq_enable();
+
+		DBG("stop_polling\n");
+	} else if (ret < 0) {
+		msleep(100);
+		DBG(ILITEK_ERROR_LEVEL "%s, process error\n", __func__);
+		ilitek_i2c_irq_enable();
+	}
+#endif
+
+}
+
+/*
+description
+	i2c interrupt service routine
+parameters
+	irq
+		interrupt number
+	dev_id
+		device parameter
+return
+	return status
+*/
+
+static irqreturn_t ilitek_i2c_isr(int irq, void *dev_id)
+{
+	DBG("Enter\n");
+	if (i2c.irq_status == 1) {
+		disable_irq_nosync(i2c.client->irq);
+		DBG("disable nosync\n");
+		i2c.irq_status = 0;
+	}
+	if (update_Flag == 1)
+		int_Flag = 1;
+	else
+		queue_work(i2c.irq_work_queue, &i2c.irq_work);
+
+	return IRQ_HANDLED;
+}
+
+/*
+description
+		i2c polling thread
+parameters
+		arg
+		arguments
+return
+		return status
+
+static int
+ilitek_i2c_polling_thread(
+	void *arg)
+{
+
+	int ret=0;
+	DBG("Enter\n");
+	// check input parameter
+	pr_info(ILITEK_DEBUG_LEVEL "%s, enter\n", __func__);
+
+	// mainloop
+	while(1){
+		// check whether we should exit or not
+		if(kthread_should_stop()){
+			pr_info(ILITEK_DEBUG_LEVEL "%s, stop\n", __func__);
+			break;
+		}
+
+		// this delay will influence the CPU usage and response latency
+		msleep(10);
+
+		// when i2c is in suspend or shutdown mode, we do nothing
+		if(i2c.stop_polling){
+			msleep(1000);
+			continue;
+		}
+
+		// read i2c data
+		if(ilitek_i2c_process_and_report() < 0){
+			msleep(3000);
+			pr_info(ILITEK_ERROR_LEVEL "%s,
+			process error\n", __func__);
+		}
+	}
+	pr_info(ILITEK_DEBUG_LEVEL "%s, exit\n", __func__);
+	return ret;
+}
+*/
+
+/*
+description
+	i2c early suspend function
+parameters
+	h
+		early suspend pointer
+return
+	nothing
+*/
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void ilitek_i2c_early_suspend(struct early_suspend *h)
+{
+	ilitek_i2c_suspend(i2c.client, PMSG_SUSPEND);
+	pr_info(ILITEK_DEBUG_LEVEL "%s\n", __func__);
+}
+#endif
+
+/*
+description
+		i2c later resume function
+parameters
+		early suspend pointer
+return
+		nothing
+*/
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void ilitek_i2c_late_resume(struct early_suspend *h)
+{
+	ilitek_i2c_resume(i2c.client);
+	pr_info(ILITEK_DEBUG_LEVEL "%s\n", __func__);
+}
+#endif
+/*
+description
+		i2c irq enable function
+*/
+static void ilitek_i2c_irq_enable(void)
+{
+	if (i2c.irq_status == 0) {
+		i2c.irq_status = 1;
+		enable_irq(i2c.client->irq);
+		DBG("enable\n");
+
+	} else
+		DBG("no enable\n");
+}
+
+/*
+description
+		i2c irq disable function
+*/
+static void ilitek_i2c_irq_disable(void)
+{
+	if (i2c.irq_status == 1) {
+		i2c.irq_status = 0;
+		disable_irq(i2c.client->irq);
+		DBG("disable\n");
+	} else
+		DBG("no disable\n");
+}
+
+/*
+description
+		i2c suspend function
+parameters
+		client
+		i2c client data
+	mesg
+		suspend data
+return
+		return status
+*/
+
+static int ilitek_i2c_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	uint8_t cmd = ILITEK_TP_CMD_SLEEP;
+	int ret = 0;
+	struct i2c_msg msgs_cmd[] = {
+		{.addr = client->addr, .flags = 0, .len = 1, .buf = &cmd,},
+	};
+
+	DBG("Enter\n");
+	if (i2c.valid_irq_request != 0) {
+		ilitek_i2c_irq_disable();
+	} else {
+		i2c.stop_polling = 1;
+		pr_info(ILITEK_DEBUG_LEVEL "%s, stop i2c thread polling\n",
+		       __func__);
+	}
+
+	if (i2c.reset_request_success) {
+		ret = ilitek_i2c_transfer(client, msgs_cmd, 1);
+		if (ret < 0) {
+			pr_info(ILITEK_ERROR_LEVEL
+			       "%s, set tp suspend err, ret %d\n", __func__,
+			       ret);
+		}
+	}
+
+	return 0;
+}
+
+/*
+description
+		i2c resume function
+parameters
+		client
+		i2c client data
+return
+		return status
+*/
+static int ilitek_i2c_resume(struct i2c_client *client)
+{
+	DBG("Enter\n");
+	if (i2c.reset_request_success)
+		ilitek_reset(i2c.reset_gpio);
+
+	if (i2c.valid_irq_request != 0)
+		ilitek_i2c_irq_enable();
+	else{
+		i2c.stop_polling = 0;
+		pr_info(ILITEK_DEBUG_LEVEL "%s, start i2c thread polling\n",
+		       __func__);
+	}
+
+	return 0;
+}
+
+/*
+description
+	reset touch ic
+prarmeters
+	reset_pin
+	    reset pin
+return
+	status
+*/
+/*
+static int ilitek_i2c_reset(void)
+{
+	int ret = 0;
+	#ifndef SET_RESET
+	static unsigned char buffer[64]={0};
+	struct i2c_msg msgs[] = {
+		{.addr = i2c.client->addr, .flags = 0, .len = 1, .buf = buffer,}
+    };
+	buffer[0] = 0x60;
+	ret = ilitek_i2c_transfer(i2c.client, msgs, 1);
+	#else
+
+	#endif
+	msleep(100);
+	return ret;
+}
+*/
+/*
+description
+		i2c shutdown function
+parameters
+		client
+		i2c client data
+return
+		nothing
+*/
+static void ilitek_i2c_shutdown(struct i2c_client *client)
+{
+	pr_info(ILITEK_DEBUG_LEVEL "%s\n", __func__);
+	i2c.stop_polling = 1;
+}
+
+static ssize_t update_fw_show(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+/*	struct i2c_data *data = dev_get_drvdata(dev); */
+
+	return snprintf(buf, 8, "%s\n", "N/A\n");
+}
+
+static ssize_t update_fw_store(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+/*	struct i2c_data *data = dev_get_drvdata(dev); */
+
+	return size;
+}
+
+static DEVICE_ATTR(update_fw, 0664, update_fw_show, update_fw_store);
+
+static ssize_t force_update_fw_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+/*	struct i2c_data *data = dev_get_drvdata(dev); */
+
+	return size;
+}
+
+static DEVICE_ATTR(force_update_fw, 0664, update_fw_show,
+		   force_update_fw_store);
+
+static ssize_t fw_name_show(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+/*	struct i2c_data *data = dev_get_drvdata(dev); */
+
+	return snprintf(buf, 8, "%s\n", "N/A\n");
+}
+
+static ssize_t fw_name_store(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf, size_t size)
+{
+/*	struct i2c_data *data = dev_get_drvdata(dev); */
+
+	return size;
+}
+
+static DEVICE_ATTR(fw_name, 0664, fw_name_show, fw_name_store);
+
+static ssize_t ts_info_show(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, TS_INFO_MAX_LEN, "%s\n", i2c.ts_info);
+}
+
+static DEVICE_ATTR(ts_info, 0444, ts_info_show, NULL);
+
+static ssize_t ts_mt_protocol_type_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	return snprintf(buf, 16, "%s\n", "MT Protocal B");
+}
+
+static DEVICE_ATTR(mt_protocol_type, 0664, ts_mt_protocol_type_show, NULL);
+
+static ssize_t ts_enable_store(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	unsigned long val;
+	int rc;
+
+	if (size > 2)
+		return -EINVAL;
+
+	rc = kstrtoul(buf, 10, &val);
+	if (rc != 0)
+		return rc;
+
+	if (val) {
+		i2c.enable = true;
+		ilitek_i2c_resume(i2c.client);
+	} else {
+		i2c.enable = false;
+		ilitek_i2c_suspend(i2c.client, PMSG_SUSPEND);
+	}
+
+	return size;
+}
+
+static ssize_t ts_enable_show(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, 4, "%s\n", i2c.enable ? "1" : "0");
+}
+
+static DEVICE_ATTR(enable, 0664, ts_enable_show, ts_enable_store);
+
+static int debug_dump_info(struct seq_file *m, void *v)
+{
+	seq_printf(m, "%s\n", i2c.ts_info);
+
+	return 0;
+}
+
+static int debugfs_dump_info_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, debug_dump_info, inode->i_private);
+}
+
+static const struct file_operations debug_dump_info_fops = {
+	.owner = THIS_MODULE,
+	.open = debugfs_dump_info_open,
+	.read = seq_read,
+	.release = single_release,
+};
+
+static int debug_suspend_set(void *_data, u64 val)
+{
+	mutex_lock(&i2c.input_dev->mutex);
+
+	if (val) {
+		i2c.enable = false;
+		ilitek_i2c_suspend(i2c.client, PMSG_SUSPEND);
+	} else {
+		i2c.enable = true;
+		ilitek_i2c_resume(i2c.client);
+	}
+	mutex_unlock(&i2c.input_dev->mutex);
+
+	return 0;
+}
+
+static int debug_suspend_get(void *_data, u64 *val)
+{
+	if (i2c.enable)
+		*val = 0;
+	else
+		*val = 1;
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(debug_suspend_fops, debug_suspend_get,
+			debug_suspend_set, "%lld\n");
+
+static bool debug_addr_is_valid(int addr)
+{
+	if (addr < 0 || addr > 0xFF) {
+		pr_err("ilitek reg address is invalid: 0x%x\n", addr);
+		return false;
+	}
+
+	return true;
+}
+
+static int debug_data_set(void *_data, u64 val)
+{
+	mutex_lock(&i2c.input_dev->mutex);
+
+	if (debug_addr_is_valid(i2c.addr))
+		dev_info(&i2c.client->dev,
+			 "Writing into registers not supported\n");
+
+	mutex_unlock(&i2c.input_dev->mutex);
+
+	return 0;
+}
+
+static int debug_data_get(void *_data, u64 *val)
+{
+	int rc;
+	u8 reg = 0;
+
+	mutex_lock(&i2c.input_dev->mutex);
+
+	if (debug_addr_is_valid(i2c.addr)) {
+		rc = ilitek_i2c_read(i2c.client, i2c.addr, &reg, 1);
+		if (rc < 0)
+			dev_err(&i2c.client->dev,
+				"read register 0x%x failed (%d)\n",
+				i2c.addr, rc);
+		else
+			*val = reg;
+	}
+
+	mutex_unlock(&i2c.input_dev->mutex);
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(debug_data_fops, debug_data_get,
+			debug_data_set, "0x%02llX\n");
+
+static int debug_addr_set(void *_data, u64 val)
+{
+	if (debug_addr_is_valid(val)) {
+		mutex_lock(&i2c.input_dev->mutex);
+		i2c.addr = val;
+		mutex_unlock(&i2c.input_dev->mutex);
+	}
+
+	return 0;
+}
+
+static int debug_addr_get(void *_data, u64 *val)
+{
+	mutex_lock(&i2c.input_dev->mutex);
+
+	if (debug_addr_is_valid(i2c.addr))
+		*val = i2c.addr;
+
+	mutex_unlock(&i2c.input_dev->mutex);
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(debug_addr_fops, debug_addr_get,
+			debug_addr_set, "0x%02llX\n");
+
+static int ilitek_parse_dt(struct device *dev, struct i2c_data *i2c)
+{
+	struct device_node *np = dev->of_node;
+	u32 tempval;
+
+	i2c->reset_gpio = of_get_named_gpio_flags(np, "ilitek,reset-gpio",
+						  0, &tempval);
+	if (i2c->reset_gpio < 0)
+		return i2c->reset_gpio;
+
+	i2c->irq_gpio = of_get_named_gpio_flags(np, "ilitek,irq-gpio",
+						0, &tempval);
+	if (i2c->irq_gpio < 0)
+		return i2c->irq_gpio;
+
+	return 0;
+}
+
+/*
+description
+	when adapter detects the i2c device, this function will be invoked.
+parameters
+	client
+		i2c client data
+	id
+		i2c data
+return
+	status
+*/
+#if defined(CONFIG_FB)
+static void fb_notify_resume_work(struct work_struct *work)
+{
+	struct i2c_data *ilitek_data =
+		container_of(work, struct i2c_data, fb_notify_work);
+	ilitek_i2c_resume(ilitek_data->client);
+}
+
+static int fb_notifier_callback(struct notifier_block *self,
+				unsigned long event, void *data)
+{
+	struct fb_event *evdata = data;
+	int *blank;
+	struct i2c_data *ilitek_data =
+		container_of(self, struct i2c_data, fb_notif);
+
+	if (evdata && evdata->data && ilitek_data && ilitek_data->client) {
+		blank = evdata->data;
+		if (event == FB_EARLY_EVENT_BLANK &&
+				 *blank == FB_BLANK_UNBLANK)
+			schedule_work(&ilitek_data->fb_notify_work);
+		else if (event == FB_EVENT_BLANK &&
+				 *blank == FB_BLANK_POWERDOWN) {
+			flush_work(&ilitek_data->fb_notify_work);
+			ilitek_i2c_suspend(
+					ilitek_data->client,
+					PMSG_SUSPEND);
+		} else if (event == FB_EVENT_BLANK) {
+			if (*blank == FB_BLANK_UNBLANK)
+				ilitek_i2c_resume(
+					ilitek_data->client);
+			else if (*blank == FB_BLANK_POWERDOWN)
+				ilitek_i2c_suspend(
+				ilitek_data->client, PMSG_SUSPEND);
+		}
+	}
+
+		return 0;
+	}
+#endif
+
+
+static int
+ilitek_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int ret;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+		return -EINVAL;
+	memset(&dev, 0, sizeof(struct dev_data));
+	memset(&i2c, 0, sizeof(struct i2c_data));
+	sema_init(&i2c.wr_sem, 1);
+	i2c.wr_sem.count = 1;
+	i2c.report_status = 1;
+	i2c.client = client;
+
+	ret = ilitek_parse_dt(&client->dev, &i2c);
+	if (ret)
+		dev_err(&client->dev, "DT parsing failed\n");
+
+	ret = ilitek_power_init(&i2c, true);
+	if (ret) {
+		dev_err(&client->dev, "ilitek power init failed\n");
+		return ret;
+	}
+
+	ret = ilitek_power_on(&i2c, true);
+	if (ret) {
+		dev_err(&client->dev, "ilitek power on failed\n");
+		goto exit_deinit_power;
+	}
+
+	if (gpio_is_valid(i2c.irq_gpio)) {
+		ret = gpio_request(i2c.irq_gpio, "ilitek_irq_gpio");
+	if (ret)
+		dev_err(&client->dev, "irq gpio request failed\n");
+	   ret = gpio_direction_input(i2c.irq_gpio);
+		if (ret)
+			dev_err(&client->dev,
+				"set_direction for irq gpio failed\n");
+	}
+
+	ret = ilitek_request_init_reset();
+	if (ret < 0)
+		i2c.reset_request_success = 0;
+	else
+		i2c.reset_request_success = 1;
+	msleep(200);
+
+	ret = ilitek_i2c_read_tp_info();
+	if (ret < 0)
+		return ret;
+
+	i2c.input_dev = input_allocate_device();
+	if (i2c.input_dev == NULL)
+		return -EINVAL;
+
+	ilitek_set_input_param(i2c.input_dev,
+		i2c.max_tp, i2c.max_x, i2c.max_y);
+	ret = input_register_device(i2c.input_dev);
+	if (ret)
+		return ret;
+	i2c.valid_input_register = 1;
+
+#if defined(CONFIG_FB)
+		INIT_WORK(&i2c.fb_notify_work, fb_notify_resume_work);
+		i2c.fb_notif.notifier_call = fb_notifier_callback;
+
+		ret = fb_register_client(&i2c.fb_notif);
+
+		if (ret)
+			dev_err(&client->dev, "Unable to register fb_notifier: %d\n",
+			ret);
+	#endif
+#ifndef POLLING_MODE
+
+			ret = ilitek_set_irq();
+			if (ret < 0)
+				pr_info(ILITEK_DEBUG_LEVEL "ilitek set irq fail\n");
+
+			if (i2c.client->irq != 0) {
+				i2c.irq_work_queue =
+				create_singlethread_workqueue(
+					"ilitek_i2c_irq_queue");
+				if (i2c.irq_work_queue) {
+					INIT_WORK(&i2c.irq_work,
+					ilitek_i2c_irq_work_queue_func);
+#ifdef CLOCK_INTERRUPT
+					if (Request_IRQ()) {
+						pr_info(ILITEK_ERROR_LEVEL
+						"%s, request irq, error\n",
+							__func__);
+					} else {
+						ret = ilitek_config_irq();
+
+						i2c.valid_irq_request = 1;
+						i2c.irq_status = 1;
+					}
+#else
+					init_timer(&i2c.timer);
+					i2c.timer.data = (unsigned long)&i2c;
+					i2c.timer.function = ilitek_i2c_timer;
+					if (Request_IRQ()) {
+						pr_info(ILITEK_ERROR_LEVEL
+						" request irq, error\n");
+					} else {
+						ret = ilitek_config_irq();
+
+						i2c.valid_irq_request = 1;
+						i2c.irq_status = 1;
+					}
+#endif
+
+				}
+			}
+#endif
+
+		/* allocate character device driver buffer */
+	/*ret = alloc_chrdev_region(&dev.devno, 0, 1, ILITEK_FILE_DRIVER_NAME);
+	if (ret) {
+		pr_info(ILITEK_ERROR_LEVEL "%s, can't allocate chrdev\n",
+		       __func__);
+		return ret;
+	}
+	pr_info(ILITEK_DEBUG_LEVEL "%s, register chrdev(%d, %d)\n", __func__,
+	       MAJOR(dev.devno), MINOR(dev.devno));*/
+
+	/* initialize character device driver */
+	/*cdev_init(&dev.cdev, &ilitek_fops);
+	dev.cdev.owner = THIS_MODULE;
+	ret = cdev_add(&dev.cdev, dev.devno, 1);
+	if (ret < 0) {
+		pr_info(ILITEK_ERROR_LEVEL
+		       "%s, add character device error, ret %d\n", __func__,
+		       ret);
+		return ret;
+	}
+	dev.class = class_create(THIS_MODULE, ILITEK_FILE_DRIVER_NAME);
+	if (IS_ERR(dev.class)) {
+		pr_info(ILITEK_ERROR_LEVEL "%s, create class, error\n",
+		       __func__);
+		return ret;
+	}
+	device_create(dev.class, NULL, dev.devno, NULL, "ilitek_ctrl");
+	Report_Flag = 0;*/
+	Report_Flag = 0;
+
+	/*ret = device_create_file(&client->dev, &dev_attr_fw_name);
+	if (ret) {
+		dev_err(&i2c.client->dev, "sys file creation failed\n");
+		goto free_fw_name;
+	}*/
+/*printk("ilitek attr_fw_name!\n");
+	ret = device_create_file(&client->dev, &dev_attr_update_fw);
+	if (ret) {
+		pr_info(ILITEK_DEBUG_LEVEL "sys file creation failed\n");
+		dev_err(&i2c.client->dev, "sys file creation failed\n");
+		goto free_update_fw;
+	}
+	printk("ilitek attr_update_fw\n");
+
+	ret = device_create_file(&client->dev, &dev_attr_force_update_fw);
+	if (ret) {
+		dev_err(&i2c.client->dev, "sys file creation failed\n");
+		goto free_force_update_fw;
+	}
+
+	ret = device_create_file(&client->dev, &dev_attr_ts_info);
+	if (ret) {
+		dev_err(&i2c.client->dev, "sys file creation failed\n");
+		goto err_free_info;
+	}
+
+	ret = device_create_file(&client->dev, &dev_attr_mt_protocol_type);
+	if (ret) {
+		dev_err(&i2c.client->dev, "sys file creation failed\n");
+		goto err_free_type;
+	}
+
+	ret = device_create_file(&client->dev, &dev_attr_enable);
+	if (ret) {
+		dev_err(&i2c.client->dev, "sys file creation failed\n");
+		goto err_free_enable;
+	}
+
+	i2c.dir = debugfs_create_dir(DEBUG_DIR_NAME, NULL);
+	if (i2c.dir == NULL || IS_ERR(i2c.dir)) {
+		pr_err("debugfs_create_dir failed(%ld)\n", PTR_ERR(i2c.dir));
+		ret = PTR_ERR(i2c.dir);
+		goto err_create_debug;
+	}
+	printk("ilitek debugfs_create_dir!\n");
+
+	temp = debugfs_create_file("addr", S_IRUSR | S_IWUSR, i2c.dir, &i2c,
+				   &debug_addr_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		pr_err("debugfs_create_file failed: rc=%ld\n", PTR_ERR(temp));
+		ret = PTR_ERR(temp);
+		goto err_create_debug_dir;
+	}
+
+	temp = debugfs_create_file("data", S_IRUSR | S_IWUSR, i2c.dir, &i2c,
+				   &debug_data_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		pr_err("debugfs_create_file failed: rc=%ld\n", PTR_ERR(temp));
+		ret = PTR_ERR(temp);
+		goto err_create_debug_dir;
+	}
+
+	temp = debugfs_create_file("suspend", S_IRUSR | S_IWUSR, i2c.dir,
+				   &i2c, &debug_suspend_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		pr_err("debugfs_create_file failed: rc=%ld\n", PTR_ERR(temp));
+		ret = PTR_ERR(temp);
+		goto err_create_debug_dir;
+	}
+
+	temp = debugfs_create_file("dump_info", S_IRUSR | S_IWUSR, i2c.dir,
+				   &i2c, &debug_dump_info_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		pr_err("debugfs_create_file failed: rc=%ld\n", PTR_ERR(temp));
+		ret = PTR_ERR(temp);
+		goto err_create_debug_dir;
+	}
+
+	i2c.ts_info =
+		devm_kzalloc(&i2c.client->dev, TS_INFO_MAX_LEN, GFP_KERNEL);
+	if (!i2c.ts_info) {
+		dev_err(&i2c.client->dev, "Not enough memory\n");
+		goto err_create_debug_dir;
+	}
+
+	i2c.num_max_touches = 5;
+	i2c.fw_vkey_support = true;
+	STORE_TS_INFO(i2c.ts_info, i2c.num_max_touches, DRIVER_VERSION,
+		      i2c.fw_ver, i2c.fw_vkey_support ? "yes" : "no");
+	err_create_debug_dir:
+	debugfs_remove_recursive(i2c.dir);
+	err_create_debug:
+	device_remove_file(&i2c.client->dev, &dev_attr_enable);
+	err_free_enable:
+	device_remove_file(&i2c.client->dev, &dev_attr_mt_protocol_type);
+	err_free_type:
+	device_remove_file(&i2c.client->dev, &dev_attr_ts_info);
+	err_free_info:
+	device_remove_file(&i2c.client->dev, &dev_attr_force_update_fw);
+	free_force_update_fw:
+	device_remove_file(&i2c.client->dev, &dev_attr_update_fw);
+	free_update_fw:
+	device_remove_file(&i2c.client->dev, &dev_attr_fw_name);
+	//free_fw_name:
+	//   return 0; */
+
+exit_deinit_power:
+	ilitek_power_init(&i2c, false);
+
+	return 0;
+}
+
+/*
+description
+	when the i2c device want to detach from adapter,
+	this function will be invoked.
+parameters
+	client
+		i2c client data
+return
+	status
+*/
+static int ilitek_i2c_remove(struct i2c_client *client)
+{
+	pr_info(ILITEK_DEBUG_LEVEL "%s\n", __func__);
+	i2c.stop_polling = 1;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&i2c.early_suspend);
+#endif
+
+	if (i2c.client->irq != 0) {
+		if (i2c.valid_irq_request != 0) {
+			free_irq(i2c.client->irq, &i2c);
+			pr_info(ILITEK_DEBUG_LEVEL "%s, free irq\n", __func__);
+			if (i2c.irq_work_queue)
+				destroy_workqueue(i2c.irq_work_queue);
+		}
+	} else {
+		if (i2c.thread != NULL) {
+			kthread_stop(i2c.thread);
+			pr_info(ILITEK_DEBUG_LEVEL "%s, stop i2c thread\n",
+			       __func__);
+		}
+	}
+	if (i2c.valid_input_register != 0) {
+		input_unregister_device(i2c.input_dev);
+		pr_info(ILITEK_DEBUG_LEVEL "%s, unregister i2c input device\n",
+		       __func__);
+	}
+
+	cdev_del(&dev.cdev);
+	unregister_chrdev_region(dev.devno, 1);
+	device_destroy(dev.class, dev.devno);
+	class_destroy(dev.class);
+	pr_info(ILITEK_DEBUG_LEVEL "%s\n", __func__);
+	return 0;
+}
+
+/*
+description
+	read data from i2c device with delay between cmd & return data
+parameter
+	client
+		i2c client data
+	addr
+		i2c address
+	data
+		data for transmission
+	length
+		data length
+return
+	status
+*/
+static int
+ilitek_i2c_read_info(struct i2c_client *client,
+		     uint8_t cmd, uint8_t *data, int length)
+{
+	int ret;
+	struct i2c_msg msgs_cmd[] = {
+		{.addr = client->addr, .flags = 0, .len = 1, .buf = &cmd,},
+	};
+
+	struct i2c_msg msgs_ret[] = {
+		{.addr = client->addr, .flags = I2C_M_RD, .len = length, .buf =
+		 data,}
+	};
+
+	ret = ilitek_i2c_transfer(client, msgs_cmd, 1);
+	if (ret < 0) {
+		pr_info(ILITEK_ERROR_LEVEL "%s, i2c read error, ret %d\n",
+		       __func__, ret);
+	}
+
+	msleep(20);
+	ret = ilitek_i2c_transfer(client, msgs_ret, 1);
+	if (ret < 0) {
+		pr_info(ILITEK_ERROR_LEVEL "%s, i2c read error, ret %d\n",
+		       __func__, ret);
+	}
+
+	pr_info(ILITEK_ERROR_LEVEL "%s, Driver Vesrion: %s\n", __func__,
+	       DRIVER_VERSION);
+	return ret;
+}
+
+/*
+description
+	read touch information
+parameters
+	none
+return
+	status
+*/
+static int ilitek_i2c_read_tp_info(void)
+{
+	int res_len, i;
+	unsigned char buf[64] = { 0 };
+
+	/* read driver version */
+	pr_info(ILITEK_DEBUG_LEVEL "%s, Driver Version:%d.%d\n", __func__,
+	       driver_information[0], driver_information[1]);
+	pr_info(ILITEK_DEBUG_LEVEL "%s, customer information:%d.%d.%d.%d\n",
+	       __func__, driver_information[2], driver_information[3],
+	       driver_information[4], driver_information[5]);
+	pr_info(ILITEK_DEBUG_LEVEL "%s, Engineer id:%d\n", __func__,
+	       driver_information[6]);
+	/* read firmware version */
+	if (ilitek_i2c_read_info
+	    (i2c.client, ILITEK_TP_CMD_GET_FIRMWARE_VERSION, buf, 4) < 0) {
+		return -EINVAL;
+	}
+	for (i = 0; i < 4; i++)
+		i2c.firmware_ver[i] = buf[i];
+	pr_info(ILITEK_DEBUG_LEVEL "%s, firmware version %d.%d.%d.%d\n",
+	       __func__, buf[0], buf[1], buf[2], buf[3]);
+	i2c.fw_ver = buf[0] * 1000 + buf[1] * 100 + buf[2] * 10 + buf[3];
+	/* read protocol version */
+	res_len = 6;
+	if (ilitek_i2c_read_info
+	    (i2c.client, ILITEK_TP_CMD_GET_PROTOCOL_VERSION, buf, 2) < 0) {
+		return -EINVAL;
+	}
+	i2c.protocol_ver = (((int)buf[0]) << 8) + buf[1];
+	pr_info(ILITEK_DEBUG_LEVEL "%s, protocol version: %d.%d\n", __func__,
+	       buf[0], buf[1]);
+	if ((i2c.protocol_ver & 0xFF00) == 0x200)
+		res_len = 8;
+	else if ((i2c.protocol_ver & 0xFF00) == 0x300)
+		res_len = 10;
+
+	/* read touch resolution */
+	i2c.max_tp = 2;
+	if (ilitek_i2c_read_info
+	    (i2c.client, ILITEK_TP_CMD_GET_RESOLUTION, buf, res_len) < 0)
+		return -EINVAL;
+
+	if ((i2c.protocol_ver & 0xFF00) == 0x200) {
+		/* maximum touch point */
+		i2c.max_tp = buf[6];
+		/* maximum button number */
+		i2c.max_btn = buf[7];
+	} else if ((i2c.protocol_ver & 0xFF00) == 0x300) {
+		/* maximum touch point */
+		i2c.max_tp = buf[6];
+		/* maximum button number */
+		i2c.max_btn = buf[7];
+		/* key count */
+		i2c.keycount = buf[8];
+	}
+
+	/* calculate the resolution for x and y direction */
+	i2c.max_x = buf[0];
+	i2c.max_x += ((int)buf[1]) * 256;
+	i2c.max_y = buf[2];
+	i2c.max_y += ((int)buf[3]) * 256;
+	i2c.x_ch = buf[4];
+	i2c.y_ch = buf[5];
+
+	if (EXCHANG_XY) {
+		int temp = i2c.max_x;
+
+		i2c.max_x = i2c.max_y;
+		i2c.max_y = temp;
+	}
+	pr_info(ILITEK_DEBUG_LEVEL
+	       "%s, max_x: %d, max_y: %d, ch_x: %d, ch_y: %d\n", __func__,
+	       i2c.max_x, i2c.max_y, i2c.x_ch, i2c.y_ch);
+
+	if ((i2c.protocol_ver & 0xFF00) == 0x200) {
+		pr_info(ILITEK_DEBUG_LEVEL "%s, max_tp: %d, max_btn: %d\n",
+		       __func__, i2c.max_tp, i2c.max_btn);
+	} else if ((i2c.protocol_ver & 0xFF00) == 0x300) {
+		pr_info(ILITEK_DEBUG_LEVEL
+		       "%s, max_tp: %d, max_btn: %d, key_count: %d\n", __func__,
+		       i2c.max_tp, i2c.max_btn, i2c.keycount);
+
+		/*get key infotmation */
+		if (ilitek_i2c_read(i2c.client,
+					ILITEK_TP_CMD_GET_KEY_INFORMATION,
+					buf, 29) < 0)
+			return -EINVAL;
+
+		if (i2c.keycount > 5) {
+			if (ilitek_i2c_only_read(i2c.client, buf + 29, 25) < 0)
+				return -EINVAL;
+		}
+
+		i2c.key_xlen = (buf[0] << 8) + buf[1];
+		i2c.key_ylen = (buf[2] << 8) + buf[3];
+		pr_info(ILITEK_DEBUG_LEVEL "%s, key_xlen: %d, key_ylen: %d\n",
+		       __func__, i2c.key_xlen, i2c.key_ylen);
+
+		/*print key information */
+		for (i = 0; i < i2c.keycount; i++) {
+			i2c.ki[i].id = buf[i * 5 + 4];
+			i2c.ki[i].x =
+			    (buf[i * 5 + 5] << 8) + buf[i * 5 + 6];
+			i2c.ki[i].y =
+			    (buf[i * 5 + 7] << 8) + buf[i * 5 + 8];
+			i2c.ki[i].st = 0;
+			pr_info(ILITEK_DEBUG_LEVEL
+			       "%s, key_id: %d, key_x: %d, key_y: %d, key_status: %d\n",
+			       __func__, i2c.ki[i].id, i2c.ki[i].x,
+			       i2c.ki[i].y, i2c.ki[i].st);
+		}
+	}
+
+	return 0;
+}
+
+/*
+description
+	read touch information
+parameters
+	none
+return
+	status
+*/
+
+/*
+static int
+ilitek_i2c_reread_tp_info(
+	void)
+{
+	int res_len;
+	int res_len,i;
+	int ret, count=ILITEK_I2C_RETRY_COUNT;
+	int count=ILITEK_I2C_RETRY_COUNT;
+	unsigned char buf[32]={0};
+
+	// read protocol version
+		res_len = 6;
+
+	for(count = ILITEK_I2C_RETRY_COUNT;count >= 0;count --){
+		if(ilitek_i2c_read_info(i2c.client,
+			ILITEK_TP_CMD_GET_PROTOCOL_VERSION,
+			buf, 2) < 0){
+			pr_info("%s : i2c read error",__func__);
+			return -1;
+		}
+		if((buf[0] == 0xff)&&(buf[1] == 0xff)){
+			continue;
+		}
+		else{
+			i2c.protocol_ver = (((int)buf[0]) << 8) + buf[1];
+		}
+		break;
+	}
+	pr_info(ILITEK_DEBUG_LEVEL "%s,
+	protocol version: %d.%d\n", __func__,buf[0],buf[1]);
+
+	if(i2c.protocol_ver < 0x200){
+		i2c.max_tp = 2;
+	}
+
+	return 0;
+}
+*/
+
+#ifdef ILI_UPDATE_FW
+
+/*
+description
+	upgrade F/W
+prarmeters
+
+return
+	status
+*/
+static int ilitek_upgrade_firmware(void)
+{
+	int ret = 0, upgrade_status = 0, i, j, k = 0, ap_len = 0, df_len = 0;
+	unsigned char buffer[128] = { 0 };
+	unsigned char buf[10] = { 0 };
+	unsigned long ap_startaddr, df_startaddr, ap_endaddr, df_endaddr,
+	    ap_checksum = 0, df_checksum = 0;
+	unsigned char firmware_ver[4];
+	unsigned int bl_ver = 0, flow_flag = 0;
+	struct i2c_msg msgs[] = {
+		{.addr = i2c.client->addr, .flags = 0, .len = 0, .buf = buffer,}
+	};
+	ap_startaddr = (CTPM_FW[0] << 16) + (CTPM_FW[1] << 8) + CTPM_FW[2];
+	ap_endaddr = (CTPM_FW[3] << 16) + (CTPM_FW[4] << 8) + CTPM_FW[5];
+	ap_checksum = (CTPM_FW[6] << 16) + (CTPM_FW[7] << 8) + CTPM_FW[8];
+	df_startaddr = (CTPM_FW[9] << 16) + (CTPM_FW[10] << 8) + CTPM_FW[11];
+	df_endaddr = (CTPM_FW[12] << 16) + (CTPM_FW[13] << 8) + CTPM_FW[14];
+	df_checksum = (CTPM_FW[15] << 16) + (CTPM_FW[16] << 8) + CTPM_FW[17];
+	firmware_ver[0] = CTPM_FW[18];
+	firmware_ver[1] = CTPM_FW[19];
+	firmware_ver[2] = CTPM_FW[20];
+	firmware_ver[3] = CTPM_FW[21];
+	df_len = (CTPM_FW[22] << 16) + (CTPM_FW[23] << 8) + CTPM_FW[24];
+	ap_len = (CTPM_FW[25] << 16) + (CTPM_FW[26] << 8) + CTPM_FW[27];
+	pr_info(ILITEK_DEBUG_LEVEL
+			"ap_startaddr=0x%d,ap_endaddr=0x%d,ap_checksum=0x%d\n",
+	       ap_startaddr, ap_endaddr, ap_checksum);
+	pr_info(ILITEK_DEBUG_LEVEL
+			"df_startaddr=0x%d,df_endaddr=0x%d,df_checksum=0x%d\n",
+	       df_startaddr, df_endaddr, df_checksum);
+	buffer[0] = 0xc0;
+	msgs[0].len = 1;
+	ret = ilitek_i2c_read(i2c.client, 0xc0, buffer, 1);
+	if (ret < 0)
+		return 3;
+
+	msleep(30);
+	pr_info(ILITEK_DEBUG_LEVEL "ic. mode =%d\n", buffer[0]);
+
+	if (buffer[0] != 0x55) {
+		for (i = 0; i < 4; i++) {
+			pr_info(ILITEK_DEBUG_LEVEL
+				"i2c.firmware_ver[%d]=%d,firmware_ver[%d]=%d\n",
+				i, i2c.firmware_ver[i],
+				i, firmware_ver[i]);
+
+			if ((i2c.firmware_ver[i] > firmware_ver[i])
+			    || ((i == 3)
+				&& (i2c.firmware_ver[3] == firmware_ver[3]))) {
+				return 1;
+			} else if (i2c.firmware_ver[i] < firmware_ver[i]) {
+				break;
+			}
+		}
+
+		/*
+		   buffer[0]=0xc4;
+		   msgs[0].len = 1;
+		 */
+		buffer[0] = 0xc4;
+		buffer[1] = 0x5A;
+		buffer[2] = 0xA5;
+		msgs[0].len = 3;
+
+		ret = ilitek_i2c_transfer(i2c.client, msgs, 1);
+		if (ret < 0)
+			return 3;
+
+		msleep(30);
+		buffer[0] = 0xc2;
+		ret = ilitek_i2c_transfer(i2c.client, msgs, 1);
+		if (ret < 0)
+			return 3;
+
+		msleep(100);
+	}
+
+	if (ilitek_i2c_read_info
+	    (i2c.client, ILITEK_TP_CMD_GET_FIRMWARE_VERSION, buf, 4) < 0) {
+		return 3;
+	}
+	pr_info(ILITEK_DEBUG_LEVEL "%s, bl version %d.%d.%d.%d\n", __func__,
+	       buf[0], buf[1], buf[2], buf[3]);
+	msleep(100);
+	bl_ver = buf[3] + (buf[2] << 8) + (buf[1] << 16) + (buf[0] << 24);
+	if (bl_ver) {
+		if (bl_ver < 0x01000100)
+			flow_flag = 1;
+		else
+			flow_flag = 2;
+	} else
+		return 3;
+
+	buffer[0] = 0xc0;
+	msgs[0].len = 1;
+	ret = ilitek_i2c_read(i2c.client, 0xc0, buffer, 1);
+	if (ret < 0)
+		return 3;
+
+	msleep(30);
+	pr_info(ILITEK_DEBUG_LEVEL
+			"ILITEK:%s, upgrade firmware...\n",
+			__func__);
+	buffer[0] = 0xc4;
+	msgs[0].len = 10;
+	buffer[1] = 0x5A;
+	buffer[2] = 0xA5;
+	buffer[3] = 0;
+	buffer[4] = CTPM_FW[3];
+	buffer[5] = CTPM_FW[4];
+	buffer[6] = CTPM_FW[5];
+	buffer[7] = CTPM_FW[6];
+	buffer[8] = CTPM_FW[7];
+	buffer[9] = CTPM_FW[8];
+	ret = ilitek_i2c_transfer(i2c.client, msgs, 1);
+	if (ret < 0)
+		return 3;
+
+	msleep(30);
+
+	buffer[0] = 0xc4;
+	msgs[0].len = 10;
+	buffer[1] = 0x5A;
+	buffer[2] = 0xA5;
+	buffer[3] = 1;
+	buffer[4] = 0;
+	buffer[5] = 0;
+	buffer[6] = 0;
+	buffer[7] = 0;
+	buffer[8] = 0;
+	buffer[9] = 0;
+	ret = ilitek_i2c_transfer(i2c.client, msgs, 1);
+	if (ret < 0)
+		return 3;
+
+	msleep(30);
+
+	j = 0;
+	for (i = 0; i < df_len; i += 32) {
+		j += 1;
+		if (flow_flag == 1) {
+			if ((j % 16) == 1)
+				msleep(60);
+		} else if (flow_flag == 2) {
+			if ((j % 8) == 2)
+				msleep(30);
+		}
+
+		for (k = 0; k < 32; k++)
+			buffer[1 + k] = CTPM_FW[i + 32 + k];
+
+		buffer[0] = 0xc3;
+		msgs[0].len = 33;
+		ret = ilitek_i2c_transfer(i2c.client, msgs, 1);
+		if (ret < 0)
+			return 3;
+
+		upgrade_status = (i * 100) / df_len;
+		if (flow_flag == 1)
+			msleep(20);
+		else if (flow_flag == 2)
+			msleep(20);
+	}
+
+	buffer[0] = 0xc4;
+	msgs[0].len = 10;
+	buffer[1] = 0x5A;
+	buffer[2] = 0xA5;
+	buffer[3] = 0;
+	buffer[4] = CTPM_FW[3];
+	buffer[5] = CTPM_FW[4];
+	buffer[6] = CTPM_FW[5];
+	buffer[7] = CTPM_FW[6];
+	buffer[8] = CTPM_FW[7];
+	buffer[9] = CTPM_FW[8];
+	ret = ilitek_i2c_transfer(i2c.client, msgs, 1);
+	if (ret < 0)
+		return 3;
+
+	msleep(30);
+
+	j = 0;
+	for (i = 0; i < ap_len; i += 32) {
+		j += 1;
+		if (flow_flag == 1) {
+			if ((j % 16) == 1)
+				msleep(60);
+		} else if (flow_flag == 2) {
+			if ((j % 8) == 2)
+				msleep(30);
+		}
+
+		for (k = 0; k < 32; k++)
+			buffer[1 + k] = CTPM_FW[i + df_len + 32 + k];
+
+		buffer[0] = 0xc3;
+		msgs[0].len = 33;
+		ret = ilitek_i2c_transfer(i2c.client, msgs, 1);
+		if (ret < 0)
+			return 3;
+
+		upgrade_status = (i * 100) / ap_len;
+		if (flow_flag == 1)
+			msleep(20);
+		else if (flow_flag == 2)
+			msleep(20);
+	}
+	/*
+	   buffer[0]=0xc4;
+	   msgs[0].len = 1;
+	 */
+	buffer[0] = 0xc4;
+	buffer[1] = 0x5A;
+	buffer[2] = 0xA5;
+	msgs[0].len = 3;
+
+	ret = ilitek_i2c_transfer(i2c.client, msgs, 1);
+	if (ret < 0)
+		return 3;
+
+	msleep(30);
+	buffer[0] = 0xc1;
+	ret = ilitek_i2c_transfer(i2c.client, msgs, 1);
+	if (ret < 0)
+		return 3;
+
+	buffer[0] = 0xc0;
+	msgs[0].len = 1;
+	ret = ilitek_i2c_read(i2c.client, 0xc0, buffer, 1);
+	if (ret < 0)
+		return 3;
+
+	msleep(30);
+
+	msleep(100);
+	return 2;
+}
+
+#endif
+
+/*
+description
+	register i2c device and its input device
+parameters
+	none
+return
+	status
+*/
+/*
+static int ilitek_i2c_register_device(void)
+{
+	int ret;
+
+	DBG("Enter\n");
+
+	ret = i2c_add_driver(&ilitek_i2c_driver);
+	if (ret == 0) {
+		i2c.valid_i2c_register = 1;
+		pr_info(ILITEK_DEBUG_LEVEL "%s, add i2c device, success\n",
+		       __func__);
+	}
+
+	if (i2c.client == NULL) {
+		pr_info(ILITEK_ERROR_LEVEL "%s, no i2c board information\n",
+		       __func__);
+		return -ENODEV;
+	}
+
+	pr_info(ILITEK_DEBUG_LEVEL "%s, client.addr: 0x%X\n", __func__,
+	       (unsigned int)i2c.client->addr);
+	pr_info(ILITEK_DEBUG_LEVEL "%s, client.adapter: 0x%X\n", __func__,
+	       (unsigned int)i2c.client->adapter);
+	pr_info(ILITEK_DEBUG_LEVEL "%s, client.driver: 0x%X\n", __func__,
+	       (unsigned int)i2c.client->driver);
+	if ((i2c.client->addr == 0) || (i2c.client->adapter == 0)
+	    || (i2c.client->driver == 0)) {
+		pr_info(ILITEK_ERROR_LEVEL "%s, invalid register\n", __func__);
+		return ret;
+	}
+
+	ret = ilitek_request_init_reset();
+	if (ret < 0) {
+		pr_info(ILITEK_DEBUG_LEVEL "ilitek request reset err\n");
+		i2c.reset_request_success = 0;
+		return -EINVAL;
+	} else {
+		pr_info(ILITEK_DEBUG_LEVEL "ilitek request reset success\n");
+		i2c.reset_request_success = 1;
+	}
+
+	msleep(200);
+
+
+	ret = ilitek_i2c_read_tp_info();
+	if (ret < 0) {
+		pr_info(ILITEK_DEBUG_LEVEL "ilitek read tp info fail\n");
+		return ret;
+	}
+
+#ifdef ILI_UPDATE_FW
+	ret = ilitek_upgrade_firmware();
+	if (ret == 1)
+		pr_info(ILITEK_DEBUG_LEVEL "Do not need update\n");
+	else if (ret == 2)
+		pr_info(ILITEK_DEBUG_LEVEL "update end\n");
+	else if (ret == 3)
+		pr_info(ILITEK_DEBUG_LEVEL "i2c communication error\n");
+
+	if (i2c.reset_request_success)
+		ilitek_reset(i2c.reset_gpio);
+
+	ret = ilitek_i2c_read_tp_info();
+	if (ret < 0)
+		return ret;
+
+#endif
+
+
+	i2c.input_dev = input_allocate_device();
+	if (i2c.input_dev == NULL) {
+		pr_info(ILITEK_ERROR_LEVEL "%s, allocate input device, error\n",
+		       __func__);
+		return -ENOMEM;
+	}
+	ilitek_set_input_param(i2c.input_dev, i2c.max_tp, i2c.max_x, i2c.max_y);
+	ret = input_register_device(i2c.input_dev);
+	if (ret) {
+		pr_info(ILITEK_ERROR_LEVEL "%s, register input device, error\n",
+		       __func__);
+		return ret;
+	}
+	pr_info(ILITEK_ERROR_LEVEL "%s, register input device, success\n",
+	       __func__);
+	i2c.valid_input_register = 1;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	i2c.early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	i2c.early_suspend.suspend = ilitek_i2c_early_suspend;
+	i2c.early_suspend.resume = ilitek_i2c_late_resume;
+	register_early_suspend(&i2c.early_suspend);
+#endif
+
+#ifndef POLLING_MODE
+
+	ret = ilitek_set_irq();
+	if (ret < 0)
+		pr_info(ILITEK_DEBUG_LEVEL "ilitek set irq fail\n");
+
+	if (i2c.client->irq != 0) {
+		i2c.irq_work_queue =
+		    create_singlethread_workqueue("ilitek_i2c_irq_queue");
+		if (i2c.irq_work_queue) {
+			INIT_WORK(&i2c.irq_work,
+				  ilitek_i2c_irq_work_queue_func);
+#ifdef CLOCK_INTERRUPT
+			if (Request_IRQ()) {
+				pr_info(ILITEK_ERROR_LEVEL
+				       "%s, request irq, error\n", __func__);
+			} else {
+				ret = ilitek_config_irq();
+				if (ret < 0)
+					pr_info("ilitek config irq fail\n");
+
+				i2c.valid_irq_request = 1;
+				i2c.irq_status = 1;
+				pr_info(ILITEK_ERROR_LEVEL
+				       "%s, request irq, success\n", __func__);
+			}
+#else
+			init_timer(&i2c.timer);
+			i2c.timer.data = (unsigned long)&i2c;
+			i2c.timer.function = ilitek_i2c_timer;
+			if (Request_IRQ()) {
+				pr_info(ILITEK_ERROR_LEVEL
+				       "%s, request irq, error\n", __func__);
+			} else {
+				ret = ilitek_config_irq();
+				if (ret < 0)
+					pr_info("ilitek config irq fail\n");
+
+				i2c.valid_irq_request = 1;
+				i2c.irq_status = 1;
+				pr_info(ILITEK_ERROR_LEVEL
+				       "%s, request irq, success\n", __func__);
+			}
+#endif
+
+		}
+	} else
+#endif
+
+#ifdef POLLING_MODE
+	if (i2c.set_polling_mode != 1)
+		goto seting_polling_mode;
+#endif
+
+	return 0;
+}*/
+
+/*
+	else{
+		pr_info(ILITEK_ERROR_LEVEL "%s,
+		add i2c device, error\n", __func__);
+		return ret;
+	}
+
+	return 0;
+}
+*/
+/*
+description
+	initiali function for driver to invoke.
+parameters
+
+	nothing
+return
+	status
+*/
+static int __init ilitek_init(void)
+{
+	int ret, err;
+	struct dentry *temp;
+
+	ret = i2c_add_driver(&ilitek_i2c_driver);
+	if (ret == 0) {
+		i2c.valid_i2c_register = 1;
+		if (i2c.client == NULL)
+			return -EINVAL;
+
+		if ((i2c.client->addr == 0) || (i2c.client->adapter == 0))
+			return ret;
+	}
+
+	cdev_init(&dev.cdev, &ilitek_fops);
+	dev.cdev.owner = THIS_MODULE;
+	ret = cdev_add(&dev.cdev, dev.devno, 1);
+	if (ret < 0) {
+		pr_info(ILITEK_ERROR_LEVEL
+		       "%s, add character device error, ret %d\n", __func__,
+		       ret);
+		return ret;
+	}
+	dev.class = class_create(THIS_MODULE, ILITEK_FILE_DRIVER_NAME);
+	if (IS_ERR(dev.class)) {
+		pr_info(ILITEK_ERROR_LEVEL "%s, create class, error\n",
+		       __func__);
+		return ret;
+	}
+	device_create(dev.class, NULL, dev.devno, NULL, "ilitek_ctrl");
+	Report_Flag = 0;
+
+	err = device_create_file(&i2c.client->dev, &dev_attr_fw_name);
+	if (err) {
+		dev_err(&i2c.client->dev, "sys file creation failed\n");
+		goto free_fw_name;
+	}
+
+	err = device_create_file(&i2c.client->dev, &dev_attr_update_fw);
+	if (err) {
+		pr_info(ILITEK_DEBUG_LEVEL "sys file creation failed\n");
+		dev_err(&i2c.client->dev, "sys file creation failed\n");
+		goto free_update_fw;
+	}
+
+	err = device_create_file(&i2c.client->dev, &dev_attr_force_update_fw);
+	if (err) {
+		dev_err(&i2c.client->dev, "sys file creation failed\n");
+		goto free_force_update_fw;
+	}
+
+	err = device_create_file(&i2c.client->dev, &dev_attr_ts_info);
+	if (err) {
+		dev_err(&i2c.client->dev, "sys file creation failed\n");
+		goto err_free_info;
+	}
+
+	err = device_create_file(&i2c.client->dev, &dev_attr_mt_protocol_type);
+	if (err) {
+		dev_err(&i2c.client->dev, "sys file creation failed\n");
+		goto err_free_type;
+	}
+
+	err = device_create_file(&i2c.client->dev, &dev_attr_enable);
+	if (err) {
+		dev_err(&i2c.client->dev, "sys file creation failed\n");
+		goto err_free_enable;
+	}
+
+	i2c.dir = debugfs_create_dir(DEBUG_DIR_NAME, NULL);
+	if (i2c.dir == NULL || IS_ERR(i2c.dir)) {
+		pr_err("debugfs_create_dir failed(%ld)\n", PTR_ERR(i2c.dir));
+		err = PTR_ERR(i2c.dir);
+		goto err_create_debug;
+	}
+
+	temp = debugfs_create_file("addr", S_IRUSR | S_IWUSR, i2c.dir, &i2c,
+				   &debug_addr_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		pr_err("debugfs_create_file failed: rc=%ld\n", PTR_ERR(temp));
+		err = PTR_ERR(temp);
+		goto err_create_debug_dir;
+	}
+
+	temp = debugfs_create_file("data", S_IRUSR | S_IWUSR, i2c.dir, &i2c,
+				   &debug_data_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		pr_err("debugfs_create_file failed: rc=%ld\n", PTR_ERR(temp));
+		err = PTR_ERR(temp);
+		goto err_create_debug_dir;
+	}
+
+	temp = debugfs_create_file("suspend", S_IRUSR | S_IWUSR, i2c.dir,
+				   &i2c, &debug_suspend_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		pr_err("debugfs_create_file failed: rc=%ld\n", PTR_ERR(temp));
+		err = PTR_ERR(temp);
+		goto err_create_debug_dir;
+	}
+
+	temp = debugfs_create_file("dump_info", S_IRUSR | S_IWUSR, i2c.dir,
+				   &i2c, &debug_dump_info_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		pr_err("debugfs_create_file failed: rc=%ld\n", PTR_ERR(temp));
+		err = PTR_ERR(temp);
+		goto err_create_debug_dir;
+	}
+
+	i2c.ts_info =
+	    devm_kzalloc(&i2c.client->dev, TS_INFO_MAX_LEN, GFP_KERNEL);
+	if (!i2c.ts_info) {
+		dev_err(&i2c.client->dev, "Not enough memory\n");
+		goto err_create_debug_dir;
+	}
+
+	i2c.num_max_touches = 5;
+	i2c.fw_vkey_support = true;
+	STORE_TS_INFO(i2c.ts_info, i2c.num_max_touches, DRIVER_VERSION,
+		      i2c.fw_ver, i2c.fw_vkey_support ? "yes" : "no");
+
+	return 0;
+
+err_create_debug_dir:
+	debugfs_remove_recursive(i2c.dir);
+err_create_debug:
+	device_remove_file(&i2c.client->dev, &dev_attr_enable);
+err_free_enable:
+	device_remove_file(&i2c.client->dev, &dev_attr_mt_protocol_type);
+err_free_type:
+	device_remove_file(&i2c.client->dev, &dev_attr_ts_info);
+err_free_info:
+	device_remove_file(&i2c.client->dev, &dev_attr_force_update_fw);
+free_force_update_fw:
+	device_remove_file(&i2c.client->dev, &dev_attr_update_fw);
+free_update_fw:
+	device_remove_file(&i2c.client->dev, &dev_attr_fw_name);
+free_fw_name:
+	return 0;
+}
+
+/*
+description
+	driver exit function
+parameters
+	none
+return
+	nothing
+*/
+static void __exit ilitek_exit(void)
+{
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&i2c.early_suspend);
+#endif
+	/* delete i2c driver */
+	if (i2c.client->irq != 0) {
+		if (i2c.valid_irq_request != 0) {
+			free_irq(i2c.client->irq, &i2c);
+			pr_info(ILITEK_DEBUG_LEVEL "%s, free irq\n", __func__);
+			if (i2c.irq_work_queue)
+				destroy_workqueue(i2c.irq_work_queue);
+		}
+	} else {
+		if (i2c.thread != NULL) {
+			kthread_stop(i2c.thread);
+			pr_info(ILITEK_DEBUG_LEVEL "%s, stop i2c thread\n",
+			       __func__);
+		}
+	}
+	if (i2c.valid_i2c_register != 0) {
+		i2c_del_driver(&ilitek_i2c_driver);
+		pr_info(ILITEK_DEBUG_LEVEL "%s, delete i2c driver\n", __func__);
+	}
+	if (i2c.valid_input_register != 0) {
+		input_unregister_device(i2c.input_dev);
+		pr_info(ILITEK_DEBUG_LEVEL "%s, unregister i2c input device\n",
+		       __func__);
+	}
+
+	/* delete character device driver */
+	cdev_del(&dev.cdev);
+	unregister_chrdev_region(dev.devno, 1);
+	device_destroy(dev.class, dev.devno);
+	class_destroy(dev.class);
+	pr_info(ILITEK_DEBUG_LEVEL "%s\n", __func__);
+}
+
+/* set init and exit function for this module */
+module_init(ilitek_init);
+module_exit(ilitek_exit);
+
+MODULE_DESCRIPTION("ilitek TouchScreen driver");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/input/touchscreen/ilitek_ts.h b/drivers/input/touchscreen/ilitek_ts.h
new file mode 100644
index 0000000..1d4d7dc
--- /dev/null
+++ b/drivers/input/touchscreen/ilitek_ts.h
@@ -0,0 +1,313 @@
+#define QUALCOMM     1
+
+#define PLAT      QUALCOMM
+
+/*#define ILI_UPDATE_FW*/
+#define CLOCK_INTERRUPT
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/kthread.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/version.h>
+#include <linux/gpio.h>
+#include <linux/regulator/consumer.h>
+#include <linux/of_gpio.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/debugfs.h>
+#include <linux/kobject.h>
+#include <linux/sysfs.h>
+#include <linux/fs.h>
+#if defined(CONFIG_FB)
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#include <linux/wakelock.h>
+#endif
+/*driver information*/
+#define DERVER_VERSION_MAJOR		2
+#define DERVER_VERSION_MINOR		0
+#define CUSTOMER_ID					0
+#define MODULE_ID					0
+#define PLATFORM_ID					0
+#define PLATFORM_MODULE				0
+#define ENGINEER_ID					0
+
+#define ILITEK_DEBUG_LEVEL			KERN_INFO
+#define ILITEK_ERROR_LEVEL			KERN_ALERT
+
+#ifdef ILI_UPDATE_FW
+unsigned char CTPM_FW[] = {
+#include "ilitek_fw.h"
+};
+
+
+#endif
+/*
+#ifdef RESET_GPIO
+	static int reset_pin = RESET_GPIO;
+#else
+	static int reset_pin = 0;
+#endif
+*/
+static char EXCHANG_XY;
+static char REVERT_X;
+static char REVERT_Y;
+static char DBG_FLAG, DBG_COR;
+
+#define DBG(fmt, args...) do {		\
+	if (DBG_FLAG)					\
+		pr_info(ILITEK_DEBUG_LEVEL	\
+				"%s(%d): " fmt,		\
+				__func__, __LINE__,	\
+				## args);			\
+		} while (0)
+
+#define DBG_CO(fmt, args...) do {	\
+	if (DBG_FLAG || DBG_COR)		\
+		pr_info(ILITEK_DEBUG_LEVEL	\
+				"%s: " fmt,			\
+				"ilitek",			\
+				## args);			\
+		} while (0)
+
+#ifdef ILI_UPDATE_FW
+static int ilitek_upgrade_firmware(void);
+#endif
+
+/*static int ilitek_i2c_reset(void);*/
+/*static int ilitek_i2c_reread_tp_info(void);*/
+/*static int ilitek_i2c_register_device(void);*/
+
+/*static void ilitek_set_input_param(struct input_dev*, int, int, int);*/
+static int ilitek_i2c_read_tp_info(void);
+
+/*static int ilitek_i2c_reread_tp_info(void);*/
+static int ilitek_init(void);
+static void ilitek_exit(void);
+
+/* i2c functions */
+static int ilitek_i2c_transfer(struct i2c_client *, struct i2c_msg *, int);
+static int ilitek_i2c_read(struct i2c_client *, uint8_t, uint8_t *, int);
+
+/*static int ilitek_i2c_process_and_report(void);*/
+static int ilitek_i2c_suspend(struct i2c_client *, pm_message_t);
+static int ilitek_i2c_resume(struct i2c_client *);
+static void ilitek_i2c_shutdown(struct i2c_client *);
+static int ilitek_i2c_probe(struct i2c_client *, const struct i2c_device_id *);
+static int ilitek_i2c_remove(struct i2c_client *);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void ilitek_i2c_early_suspend(struct early_suspend *h);
+static void ilitek_i2c_late_resume(struct early_suspend *h);
+#endif
+/*static int ilitek_i2c_polling_thread(void*);*/
+static irqreturn_t ilitek_i2c_isr(int, void *);
+
+/*static void ilitek_i2c_irq_work_queue_func(struct work_struct*);*/
+
+/* file operation functions */
+static int ilitek_file_open(struct inode *, struct file *);
+
+/*#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)*/
+static long ilitek_file_ioctl(struct file *filp, unsigned int cmd,
+			      unsigned long arg);
+/*
+#else
+static int ilitek_file_ioctl(struct inode *inode, struct file *filp,
+			     unsigned int cmd, unsigned long arg);
+#endif
+*/
+static int ilitek_file_open(struct inode *, struct file *);
+static ssize_t ilitek_file_write(struct file *, const char *, size_t,
+				  loff_t *);
+static ssize_t ilitek_file_read(struct file *, char *, size_t, loff_t *);
+static int ilitek_file_close(struct inode *, struct file *);
+static void ilitek_i2c_irq_enable(void);
+static void ilitek_i2c_irq_disable(void);
+
+/*static int Request_IRQ(void);*/
+
+/* declare touch point data
+struct touch_data {
+	// x, y value
+	int x, y;
+	// check wehther this point is valid or not
+	int valid;
+	// id information
+	int id;
+};
+*/
+	struct key_info {
+	int id;
+	int x;
+	int y;
+	int st;
+	int flag;
+};
+
+/* declare i2c data member */
+	struct i2c_data {
+	uint16_t addr;
+
+	/* input device */
+	struct input_dev *input_dev;
+
+	/* i2c client */
+	struct i2c_client *client;
+
+	/* polling thread */
+	struct task_struct *thread;
+
+	/*firmware version */
+	unsigned char firmware_ver[4];
+
+	/* maximum x */
+	int max_x;
+
+	/* maximum y */
+	int max_y;
+
+	/* maximum touch point */
+	int max_tp;
+
+	/* maximum key button */
+	int max_btn;
+
+	/* the total number of x channel */
+	int x_ch;
+
+	/* the total number of y channel */
+	int y_ch;
+
+	/* check whether i2c driver is registered success */
+	int valid_i2c_register;
+
+	/* check whether input driver is registered success */
+	int valid_input_register;
+
+	/* check whether the i2c enter suspend or not */
+	int stop_polling;
+
+	/* read semaphore */
+	struct semaphore wr_sem;
+
+	/* protocol version */
+	int protocol_ver;
+	int set_polling_mode;
+
+	/* valid irq request */
+	int valid_irq_request;
+
+	/*reset request flag */
+	int reset_request_success;
+
+	/* work queue for interrupt use only */
+	struct workqueue_struct *irq_work_queue;
+
+	/* work struct for work queue */
+	struct work_struct irq_work;
+	struct timer_list timer;
+	struct regulator *vdd;
+	struct regulator *vcc_i2c;
+	int report_status;
+	int reset_gpio;
+	int irq_gpio;
+	int irq_status;
+	    /*irq_status enable:1 disable:0 */
+	struct completion complete;
+#if defined(CONFIG_FB)
+	struct work_struct fb_notify_work;
+	struct notifier_block fb_notif;
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+#endif
+	int keyflag;
+	int keycount;
+	int key_xlen;
+	int key_ylen;
+	struct key_info ki[10];
+	char *ts_info;
+	int fw_ver;
+	bool fw_vkey_support;
+	char num_max_touches;
+	bool enable;
+	struct dentry *dir;
+};
+static struct i2c_data i2c;
+static int ilitek_parse_dt(struct device *dev, struct i2c_data *i2c);
+static int ilitek_power_on(struct i2c_data *data, bool on);
+static int ilitek_power_init(struct i2c_data *data, bool on);
+static void ilitek_reset(int reset_gpio)
+{
+	DBG("Enter\n");
+	gpio_direction_output(reset_gpio, 1);
+	msleep(100);
+	gpio_direction_output(reset_gpio, 0);
+	msleep(100);
+	gpio_direction_output(reset_gpio, 1);
+	msleep(100);
+}
+
+
+
+
+
+/*
+request reset gpio and reset tp,
+return value < 0 means fail
+*/
+static int ilitek_request_init_reset(void)
+{
+	s32 ret = 0;
+
+	ilitek_reset(i2c.reset_gpio);
+	pr_info("reset-gpio = %d\n", i2c.reset_gpio);
+	return ret;
+}
+
+static int Request_IRQ(void)
+{
+	int ret = 0;
+	 ret = request_irq(i2c.client->irq, ilitek_i2c_isr,
+			IRQF_TRIGGER_FALLING /*| IRQF_SHARED */ ,
+			"ilitek_i2c_irq", &i2c);
+	return ret;
+}
+
+/*
+set the value of i2c.client->irq,
+could add some other work about irq here
+return value < 0 means fail
+*/
+static int ilitek_set_irq(void)
+{
+	return 0;
+}
+
+/*
+  irq here
+return value < 0 means fail
+*/
+
+static int ilitek_config_irq(void)
+{
+	return 0;
+}
+/*
+void ilitek_set_finish_init_flag(void)
+{
+	return;
+}*/
-- 
1.9.1

