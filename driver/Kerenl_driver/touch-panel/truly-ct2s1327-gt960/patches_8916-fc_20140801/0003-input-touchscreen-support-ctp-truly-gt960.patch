From 23ff0f31e26675e467a105c0143b41ff2d127f68 Mon Sep 17 00:00:00 2001
From: Deng Yequan <dengyq0603@thundersoft.com>
Date: Fri, 25 Jul 2014 17:12:39 +0800
Subject: [PATCH 3/4] input:touchscreen: support ctp truly gt960

Add CTP IHV-TRULY@CT2S1327@GT960 driver

Change-Id: Iab83c4b6224169872bf8b7bd304b81fb253d8f46
Signed-off-by: Yequan Deng <dengyq0603@thundersoft.com>
---
 drivers/input/touchscreen/gt9xx/goodix_tool.c    |  607 ++-
 drivers/input/touchscreen/gt9xx/gt9xx.c          | 3594 +++++++++++------
 drivers/input/touchscreen/gt9xx/gt9xx.h          |  409 +-
 drivers/input/touchscreen/gt9xx/gt9xx_firmware.h | 4638 ++++++++++++++++++++++
 drivers/input/touchscreen/gt9xx/gt9xx_update.c   | 3193 +++++++++++----
 5 files changed, 10062 insertions(+), 2379 deletions(-)
 create mode 100644 drivers/input/touchscreen/gt9xx/gt9xx_firmware.h

diff --git a/drivers/input/touchscreen/gt9xx/goodix_tool.c b/drivers/input/touchscreen/gt9xx/goodix_tool.c
index 8e202fc..a0a04a1 100644
--- a/drivers/input/touchscreen/gt9xx/goodix_tool.c
+++ b/drivers/input/touchscreen/gt9xx/goodix_tool.c
@@ -1,7 +1,7 @@
 /* drivers/input/touchscreen/goodix_tool.c
  *
- * 2010 - 2012 Goodix Technology.
- * Copyright (c) 2013, The Linux Foundation. All rights reserved.
+ * 2010 - 2014 Goodix Technology.
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,132 +14,122 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * General Public License for more details.
  *
- * Version:1.6
+ * Version:2.2
  *        V1.0:2012/05/01,create file.
  *        V1.2:2012/06/08,modify some warning.
  *        V1.4:2012/08/28,modified to support GT9XX
  *        V1.6:new proc name
+ *        V2.2: compatible with Linux 3.10, 2014/01/14
  */
 
 #include "gt9xx.h"
-#include <linux/mutex.h>
-#include <linux/proc_fs.h>
-#include <linux/debugfs.h>
 
 #define DATA_LENGTH_UINT    512
 #define CMD_HEAD_LENGTH     (sizeof(struct st_cmd_head) - sizeof(u8 *))
 static char procname[20] = {0};
 
+#pragma pack(1)
 struct st_cmd_head {
-	u8  wr;		/* write read flag 0:R 1:W 2:PID 3: */
-	u8  flag;	/* 0:no need flag/int 1: need flag  2:need int */
-	u8 flag_addr[2];/* flag address */
-	u8  flag_val;	/* flag val */
-	u8  flag_relation; /* flag_val:flag 0:not equal 1:equal 2:> 3:< */
-	u16 circle;	/* polling cycle */
-	u8  times;	/* plling times */
-	u8  retry;	/* I2C retry times */
-	u16 delay;	/* delay befor read or after write */
-	u16 data_len;	/* data length */
-	u8  addr_len;	/* address length */
-	u8  addr[2];	/* address */
-	u8  res[3];	/* reserved */
-	u8  *data;	/* data pointer */
-} __packed;
-
-static struct st_cmd_head cmd_head;
+	u8 wr;			/* write read flag£¬0:R  1:W  2:PID 3: */
+	u8 flag;		/* 0:no need flag 1: need flag 2:need int */
+	u8 flag_addr[2];	/* flag address */
+	u8 flag_val;		/* flag val */
+	u8 flag_relation;	/* flag_val:flag 0:not equal 1:equal 2:> 3:< */
+	u16 circle;		/* polling cycle */
+	u8 times;		/* plling times */
+	u8 retry;		/* I2C retry times */
+	u16 delay;		/* delay befor read or after write */
+	u16 data_len;		/* data length */
+	u8 addr_len;		/* address length */
+	u8 addr[2];		/* address */
+	u8 res[3];		/* reserved */
+	u8 *data;		/* data pointer */
+};
+#pragma pack()
+struct st_cmd_head cmd_head;
 
 static struct i2c_client *gt_client;
 
 static struct proc_dir_entry *goodix_proc_entry;
 
-static struct mutex lock;
+static ssize_t goodix_tool_read(struct file *, char __user *, size_t, loff_t *);
+static ssize_t goodix_tool_write(struct file *, const char __user *, size_t,
+				 loff_t *);
+static const struct file_operations tool_ops = {
+	.owner = THIS_MODULE,
+	.read = goodix_tool_read,
+	.write = goodix_tool_write,
+};
 
-static s32 (*tool_i2c_read)(u8 *, u16);
-static s32 (*tool_i2c_write)(u8 *, u16);
+static s32(*tool_i2c_read) (u8 *, u16);
+static s32(*tool_i2c_write) (u8 *, u16);
 
-s32 data_length;
-s8 ic_type[16] = {0};
+s32 DATA_LENGTH;
+s8 IC_TYPE[16] = "GT9XX";
 
 static void tool_set_proc_name(char *procname)
 {
 	char *months[12] = {"Jan", "Feb", "Mar", "Apr", "May",
-	"Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
+		"Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
+	};
 	char date[20] = {0};
 	char month[4] = {0};
 	int i = 0, n_month = 1, n_day = 0, n_year = 0;
-	snprintf(date, 20, "%s", __DATE__);
 
-	/* pr_debug("compile date: %s", date); */
+	snprintf(date, 20, "%s", __DATE__);
 
 	sscanf(date, "%s %d %d", month, &n_day, &n_year);
 
 	for (i = 0; i < 12; ++i) {
 		if (!memcmp(months[i], month, 3)) {
-			n_month = i+1;
+			n_month = i + 1;
 			break;
 		}
 	}
 
 	snprintf(procname, 20, "gmnode%04d%02d%02d", n_year, n_month, n_day);
-	/* pr_debug("procname = %s", procname); */
 }
 
 static s32 tool_i2c_read_no_extra(u8 *buf, u16 len)
 {
 	s32 ret = -1;
-	u8 i = 0;
-	struct i2c_msg msgs[2] = {
-		{
-			.flags = !I2C_M_RD,
-			.addr  = gt_client->addr,
-			.len   = cmd_head.addr_len,
-			.buf   = &buf[0],
-		},
-		{
-			.flags = I2C_M_RD,
-			.addr  = gt_client->addr,
-			.len   = len,
-			.buf   = &buf[GTP_ADDR_LENGTH],
-		},
-	};
+	s32 i = 0;
+	struct i2c_msg msgs[2];
+
+	msgs[0].flags = !I2C_M_RD;
+	msgs[0].addr = gt_client->addr;
+	msgs[0].len = cmd_head.addr_len;
+	msgs[0].buf = &buf[0];
+
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].addr = gt_client->addr;
+	msgs[1].len = len;
+	msgs[1].buf = &buf[GTP_ADDR_LENGTH];
 
 	for (i = 0; i < cmd_head.retry; i++) {
 		ret = i2c_transfer(gt_client->adapter, msgs, 2);
 		if (ret > 0)
 			break;
 	}
-
-	if (i == cmd_head.retry) {
-		dev_err(&gt_client->dev, "I2C read retry limit over.\n");
-		ret = -EIO;
-	}
-
 	return ret;
 }
 
 static s32 tool_i2c_write_no_extra(u8 *buf, u16 len)
 {
 	s32 ret = -1;
-	u8 i = 0;
-	struct i2c_msg msg = {
-		.flags = !I2C_M_RD,
-		.addr  = gt_client->addr,
-		.len   = len,
-		.buf   = buf,
-	};
+	s32 i = 0;
+	struct i2c_msg msg;
+
+	msg.flags = !I2C_M_RD;
+	msg.addr = gt_client->addr;
+	msg.len = len;
+	msg.buf = buf;
 
 	for (i = 0; i < cmd_head.retry; i++) {
 		ret = i2c_transfer(gt_client->adapter, &msg, 1);
 		if (ret > 0)
 			break;
 	}
-
-	if (i == cmd_head.retry) {
-		dev_err(&gt_client->dev, "I2C write retry limit over.\n");
-		ret = -EIO;
-	}
-
 	return ret;
 }
 
@@ -171,17 +161,17 @@ static s32 tool_i2c_write_with_extra(u8 *buf, u16 len)
 
 static void register_i2c_func(void)
 {
-	if (strcmp(ic_type, "GT8110") && strcmp(ic_type, "GT8105")
-	&& strcmp(ic_type, "GT801") && strcmp(ic_type, "GT800")
-	&& strcmp(ic_type, "GT801PLUS") && strcmp(ic_type, "GT811")
-	&& strcmp(ic_type, "GTxxx")) {
+	if (strncmp(IC_TYPE, "GT8110", 6) && strncmp(IC_TYPE, "GT8105", 6)
+	    && strncmp(IC_TYPE, "GT801", 5) && strncmp(IC_TYPE, "GT800", 5)
+	    && strncmp(IC_TYPE, "GT801PLUS", 9) && strncmp(IC_TYPE, "GT811", 5)
+	    && strncmp(IC_TYPE, "GTxxx", 5) && strncmp(IC_TYPE, "GT9XX", 5)) {
 		tool_i2c_read = tool_i2c_read_with_extra;
 		tool_i2c_write = tool_i2c_write_with_extra;
-		pr_debug("I2C function: with pre and end cmd!");
+		GTP_DEBUG("I2C function: with pre and end cmd!");
 	} else {
 		tool_i2c_read = tool_i2c_read_no_extra;
 		tool_i2c_write = tool_i2c_write_no_extra;
-		pr_info("I2C function: without pre and end cmd!");
+		GTP_INFO("I2C function: without pre and end cmd!");
 	}
 }
 
@@ -189,14 +179,55 @@ static void unregister_i2c_func(void)
 {
 	tool_i2c_read = NULL;
 	tool_i2c_write = NULL;
-	pr_info("I2C function: unregister i2c transfer function!");
+	GTP_INFO("I2C function: unregister i2c transfer function!");
+}
+
+s32 init_wr_node(struct i2c_client *client)
+{
+	s32 i;
+
+	gt_client = client;
+	memset(&cmd_head, 0, sizeof(cmd_head));
+	cmd_head.data = NULL;
+
+	i = 5;
+	while ((!cmd_head.data) && i) {
+		cmd_head.data = kzalloc(i * DATA_LENGTH_UINT, GFP_KERNEL);
+		if (NULL != cmd_head.data)
+			break;
+		i--;
+	}
+	if (i) {
+		DATA_LENGTH = i * DATA_LENGTH_UINT + GTP_ADDR_LENGTH;
+		GTP_INFO("Applied memory size:%d.", DATA_LENGTH);
+	} else {
+		GTP_ERROR("Apply for memory failed.");
+		return FAIL;
+	}
+
+	cmd_head.addr_len = 2;
+	cmd_head.retry = 5;
+
+	register_i2c_func();
+
+	tool_set_proc_name(procname);
+
+	goodix_proc_entry = proc_create(procname, 0666, NULL, &tool_ops);
+	if (goodix_proc_entry == NULL) {
+		GTP_ERROR("Couldn't create proc entry!");
+		return FAIL;
+	}
+	GTP_INFO("Create proc entry success!");
+
+	return SUCCESS;
 }
 
 void uninit_wr_node(void)
 {
+	kfree(cmd_head.data);
 	cmd_head.data = NULL;
 	unregister_i2c_func();
-	proc_remove(goodix_proc_entry);
+	remove_proc_entry(procname, NULL);
 }
 
 static u8 relation(u8 src, u8 dst, u8 rlt)
@@ -204,15 +235,14 @@ static u8 relation(u8 src, u8 dst, u8 rlt)
 	u8 ret = 0;
 
 	switch (rlt) {
-
 	case 0:
 		ret = (src != dst) ? true : false;
 		break;
 
 	case 1:
 		ret = (src == dst) ? true : false;
-		pr_debug("equal:src:0x%02x   dst:0x%02x  ret:%d.",
-					src, dst, (s32)ret);
+		GTP_DEBUG("equal:src:0x%02x   dst:0x%02x   ret:%d.", src, dst,
+			  (s32)ret);
 		break;
 
 	case 2:
@@ -256,14 +286,14 @@ static u8 comfirm(void)
 
 	for (i = 0; i < cmd_head.times; i++) {
 		if (tool_i2c_read(buf, 1) <= 0) {
-			dev_err(&gt_client->dev, "Read flag data failed!");
+			GTP_ERROR("Read flag data failed!");
 			return FAIL;
 		}
-		if (true == relation(buf[GTP_ADDR_LENGTH], cmd_head.flag_val,
-						cmd_head.flag_relation)) {
-			pr_debug("value at flag addr:0x%02x.",
-						buf[GTP_ADDR_LENGTH]);
-			pr_debug("flag value:0x%02x.", cmd_head.flag_val);
+		if (relation(buf[GTP_ADDR_LENGTH], cmd_head.flag_val,
+			     cmd_head.flag_relation)) {
+			GTP_DEBUG("value at flag addr:0x%02x.",
+				  buf[GTP_ADDR_LENGTH]);
+			GTP_DEBUG("flag value:0x%02x.", cmd_head.flag_val);
 			break;
 		}
 
@@ -271,330 +301,243 @@ static u8 comfirm(void)
 	}
 
 	if (i >= cmd_head.times) {
-		dev_err(&gt_client->dev, "Didn't get the flag to continue!");
+		GTP_ERROR("Didn't get the flag to continue!");
 		return FAIL;
 	}
 
 	return SUCCESS;
 }
 
-#ifdef CONFIG_GT9XX_TOUCHPANEL_UPDATE
-static s32 fill_update_info(char __user *user_buf,
-				    size_t count, loff_t *ppos)
-{
-	u8 buf[4];
-
-	buf[0] = show_len >> 8;
-	buf[1] = show_len & 0xff;
-	buf[2] = total_len >> 8;
-	buf[3] = total_len & 0xff;
-	return simple_read_from_buffer(user_buf, count, ppos,
-			buf, sizeof(buf));
-}
-#else
-static s32 fill_update_info(char __user *user_buf,
-				    size_t count, loff_t *ppos)
-{
-	return -ENODEV;
-}
-#endif
-
-/********************************************************
+/*******************************************************
 Function:
     Goodix tool write function.
-nput:
+Input:
   standard proc write function param.
 Output:
     Return write length.
 ********************************************************/
-static s32 goodix_tool_write(struct file *filp, const char __user *userbuf,
-						size_t count, loff_t *ppos)
+ssize_t goodix_tool_write(struct file *filp, const char __user *buff,
+			  size_t len, loff_t *off)
 {
 	s32 ret = 0;
 
-	mutex_lock(&lock);
-	ret = copy_from_user(&cmd_head, userbuf, CMD_HEAD_LENGTH);
-	if (ret) {
-		dev_err(&gt_client->dev, "copy_from_user failed.");
-		ret = -EACCES;
-		goto exit;
-	}
+	GTP_DEBUG_FUNC();
+	GTP_DEBUG_ARRAY((u8 *) buff, len);
 
-	dev_dbg(&gt_client->dev, "wr:0x%02x, flag:0x%02x, flag addr:0x%02x%02x, flag val:0x%02x, flag rel:0x%02x, circle:%d, times:%d, retry:%d, delay:%d, data len:%d, addr len:%d, addr:0x%02x%02x, write len: %d.",
-		cmd_head.wr, cmd_head.flag, cmd_head.flag_addr[0],
-		cmd_head.flag_addr[1], cmd_head.flag_val,
-		cmd_head.flag_relation,	(s32)cmd_head.circle,
-		(s32)cmd_head.times, (s32)cmd_head.retry, (s32)cmd_head.delay,
-		(s32)cmd_head.data_len, (s32)cmd_head.addr_len,
-		cmd_head.addr[0], cmd_head.addr[1], (s32)count);
-
-	if (cmd_head.data_len > (data_length - GTP_ADDR_LENGTH)) {
-		dev_err(&gt_client->dev, "data len %d > data buff %d, rejected!\n",
-			cmd_head.data_len, (data_length - GTP_ADDR_LENGTH));
-		ret = -EINVAL;
-		goto exit;
-	}
-	if (cmd_head.addr_len > GTP_ADDR_LENGTH) {
-		dev_err(&gt_client->dev, "addr len %d > data buff %d, rejected!\n",
-			cmd_head.addr_len, GTP_ADDR_LENGTH);
-		ret = -EINVAL;
-		goto exit;
+	ret = copy_from_user(&cmd_head, buff, CMD_HEAD_LENGTH);
+	if (ret) {
+		GTP_ERROR("copy_from_user failed.");
+		return -EPERM;
 	}
 
-	if (cmd_head.wr == GTP_RW_WRITE) {
+	GTP_DEBUG("[Operation]wr: %02X", cmd_head.wr);
+	GTP_DEBUG
+	    ("[Flag]flag: %02X, addr: %02X%02X, value: %02X, relation: %02X",
+	     cmd_head.flag, cmd_head.flag_addr[0], cmd_head.flag_addr[1],
+	     cmd_head.flag_val, cmd_head.flag_relation);
+	GTP_DEBUG("[Retry]circle: %d, times: %d, retry: %d, delay: %d",
+		  (s32)cmd_head.circle, (s32)cmd_head.times,
+		  (s32)cmd_head.retry, (s32)cmd_head.delay);
+	GTP_DEBUG
+	    ("[Data]data len: %d, addr len: %d, addr: %02X%02X",
+	     (s32)cmd_head.data_len, (s32)cmd_head.addr_len,
+	     cmd_head.addr[0], cmd_head.addr[1]);
+	GTP_DEBUG
+	    ("[Data]buffer len: %d, data[0]: %02X",
+	     (s32)len, buff[CMD_HEAD_LENGTH]);
+
+	if (1 == cmd_head.wr) {
 		ret = copy_from_user(&cmd_head.data[GTP_ADDR_LENGTH],
-				&userbuf[CMD_HEAD_LENGTH], cmd_head.data_len);
+				&buff[CMD_HEAD_LENGTH], cmd_head.data_len);
 		if (ret) {
-			dev_err(&gt_client->dev, "copy_from_user failed.");
-			goto exit;
+			GTP_ERROR("copy_from_user failed.");
+			return -EPERM;
 		}
-
 		memcpy(&cmd_head.data[GTP_ADDR_LENGTH - cmd_head.addr_len],
-					cmd_head.addr, cmd_head.addr_len);
+		       cmd_head.addr, cmd_head.addr_len);
 
-		if (cmd_head.flag == GTP_NEED_FLAG) {
-			if (comfirm() ==  FAIL) {
-				dev_err(&gt_client->dev, "Comfirm fail!");
-				ret = -EINVAL;
-				goto exit;
+		GTP_DEBUG_ARRAY(cmd_head.data,
+				cmd_head.data_len + cmd_head.addr_len);
+		GTP_DEBUG_ARRAY((u8 *)&buff[CMD_HEAD_LENGTH],
+				cmd_head.data_len);
+
+		if (1 == cmd_head.flag) {
+			if (FAIL == comfirm()) {
+				GTP_ERROR("[WRITE]Comfirm fail!");
+				return -EPERM;
 			}
-		} else if (cmd_head.flag == GTP_NEED_INTERRUPT) {
+		} else if (2 == cmd_head.flag) {
 			/* Need interrupt! */
 		}
-		if (tool_i2c_write(
-		&cmd_head.data[GTP_ADDR_LENGTH - cmd_head.addr_len],
-		cmd_head.data_len + cmd_head.addr_len) <= 0) {
-			dev_err(&gt_client->dev, "Write data failed!");
-			ret = -EIO;
-			goto exit;
+		if (tool_i2c_write
+		    (&cmd_head.data[GTP_ADDR_LENGTH - cmd_head.addr_len],
+		     cmd_head.data_len + cmd_head.addr_len) <= 0) {
+			GTP_ERROR("[WRITE]Write data failed!");
+			return -EPERM;
 		}
 
+		GTP_DEBUG_ARRAY(&cmd_head.
+				data[GTP_ADDR_LENGTH - cmd_head.addr_len],
+				cmd_head.data_len + cmd_head.addr_len);
 		if (cmd_head.delay)
 			msleep(cmd_head.delay);
-
-		ret = cmd_head.data_len + CMD_HEAD_LENGTH;
-		goto exit;
-	} else if (cmd_head.wr == GTP_RW_WRITE_IC_TYPE) {  /* Write ic type */
-		ret = copy_from_user(&cmd_head.data[0],
-				&userbuf[CMD_HEAD_LENGTH],
-				cmd_head.data_len);
+	} else if (3 == cmd_head.wr) {
+		ret =
+		    copy_from_user(&cmd_head.data[0], &buff[CMD_HEAD_LENGTH],
+				   cmd_head.data_len);
 		if (ret) {
-			dev_err(&gt_client->dev, "copy_from_user failed.");
-			goto exit;
+			GTP_ERROR("copy_from_user failed.");
+			return -EPERM;
 		}
-
-		if (cmd_head.data_len > sizeof(ic_type)) {
-			dev_err(&gt_client->dev,
-				"data len %d > data buff %d, rejected!\n",
-				cmd_head.data_len, sizeof(ic_type));
-			ret = -EINVAL;
-			goto exit;
-		}
-		memcpy(ic_type, cmd_head.data, cmd_head.data_len);
+		memcpy(IC_TYPE, cmd_head.data, cmd_head.data_len);
 
 		register_i2c_func();
-
-		ret = cmd_head.data_len + CMD_HEAD_LENGTH;
-		goto exit;
-	} else if (cmd_head.wr == GTP_RW_NO_WRITE) {
-		ret = cmd_head.data_len + CMD_HEAD_LENGTH;
-		goto exit;
-	} else if (cmd_head.wr == GTP_RW_DISABLE_IRQ) { /* disable irq! */
+	} else if (5 == cmd_head.wr) {
+		/* memcpy(IC_TYPE, cmd_head.data, cmd_head.data_len); */
+	} else if (7 == cmd_head.wr) {	/*disable irq! */
 		gtp_irq_disable(i2c_get_clientdata(gt_client));
-
-		#if GTP_ESD_PROTECT
+#if GTP_ESD_PROTECT
 		gtp_esd_switch(gt_client, SWITCH_OFF);
-		#endif
-		ret = CMD_HEAD_LENGTH;
-		goto exit;
-	} else if (cmd_head.wr == GTP_RW_ENABLE_IRQ) { /* enable irq! */
+#endif
+	} else if (9 == cmd_head.wr) {	/*enable irq! */
 		gtp_irq_enable(i2c_get_clientdata(gt_client));
-
-		#if GTP_ESD_PROTECT
+#if GTP_ESD_PROTECT
 		gtp_esd_switch(gt_client, SWITCH_ON);
-		#endif
-		ret = CMD_HEAD_LENGTH;
-		goto exit;
-	} else if (cmd_head.wr == GTP_RW_CHECK_RAWDIFF_MODE) {
+#endif
+	} else if (17 == cmd_head.wr) {
 		struct goodix_ts_data *ts = i2c_get_clientdata(gt_client);
-		ret = copy_from_user(&cmd_head.data[GTP_ADDR_LENGTH],
-				&userbuf[CMD_HEAD_LENGTH], cmd_head.data_len);
+		ret =
+		    copy_from_user(&cmd_head.data[GTP_ADDR_LENGTH],
+				   &buff[CMD_HEAD_LENGTH], cmd_head.data_len);
 		if (ret) {
-			pr_debug("copy_from_user failed.");
-			goto exit;
+			GTP_DEBUG("copy_from_user failed.");
+			return -EPERM;
 		}
 		if (cmd_head.data[GTP_ADDR_LENGTH]) {
-			pr_debug("gtp enter rawdiff.");
+			GTP_INFO("gtp enter rawdiff.");
 			ts->gtp_rawdiff_mode = true;
 		} else {
 			ts->gtp_rawdiff_mode = false;
-			pr_debug("gtp leave rawdiff.");
+			GTP_INFO("gtp leave rawdiff.");
 		}
-		ret = CMD_HEAD_LENGTH;
-		goto exit;
-	} else if (cmd_head.wr == GTP_RW_ENTER_UPDATE_MODE) {
-		/* Enter update mode! */
-		if (gup_enter_update_mode(gt_client) ==  FAIL) {
-			ret = -EBUSY;
-			goto exit;
-		}
-	} else if (cmd_head.wr == GTP_RW_LEAVE_UPDATE_MODE) {
-		/* Leave update mode! */
-		gup_leave_update_mode(gt_client);
-	} else if (cmd_head.wr == GTP_RW_UPDATE_FW) {
-		/* Update firmware! */
+	}
+#ifdef UPDATE_FUNCTIONS
+	else if (11 == cmd_head.wr) {	/*Enter update mode! */
+		if (FAIL == gup_enter_update_mode(gt_client))
+			return -EPERM;
+	} else if (13 == cmd_head.wr)	/* Leave update mode! */
+		gup_leave_update_mode();
+	else if (15 == cmd_head.wr) {	/* Update firmware! */
 		show_len = 0;
 		total_len = 0;
-		if (cmd_head.data_len + 1 > data_length) {
-			dev_err(&gt_client->dev, "data len %d > data buff %d, rejected!\n",
-			cmd_head.data_len + 1, data_length);
-			ret = -EINVAL;
-			goto exit;
-		}
 		memset(cmd_head.data, 0, cmd_head.data_len + 1);
-		memcpy(cmd_head.data, &userbuf[CMD_HEAD_LENGTH],
-					cmd_head.data_len);
+		memcpy(cmd_head.data, &buff[CMD_HEAD_LENGTH],
+		       cmd_head.data_len);
 
-		if (gup_update_proc((void *)cmd_head.data) == FAIL) {
-			ret = -EBUSY;
-			goto exit;
-		}
+		if (FAIL == gup_update_proc((void *)cmd_head.data))
+			return -EPERM;
 	}
-	ret = CMD_HEAD_LENGTH;
+#endif
 
-exit:
-	mutex_unlock(&lock);
-	return ret;
+	return len;
 }
 
 /*******************************************************
 Function:
     Goodix tool read function.
 Input:
-  standard seq file read function param.
+  standard proc read function param.
 Output:
     Return read length.
 ********************************************************/
-static s32 goodix_tool_read(struct file *file, char __user *user_buf,
-					size_t count, loff_t *ppos)
+ssize_t goodix_tool_read(struct file *file, char __user *page, size_t size,
+			 loff_t *ppos)
 {
-	u16 data_len = 0;
-	s32 ret;
-	u8 buf[32];
+	s32 ret = 0;
 
-	mutex_lock(&lock);
-	if (cmd_head.wr & 0x1) {
-		dev_err(&gt_client->dev, "command head wrong\n");
-		ret = -EINVAL;
-		goto exit;
+	GTP_DEBUG_FUNC();
+
+	if (*ppos) {		/* ADB call again */
+		/*GTP_DEBUG("[HEAD]wr: %d", cmd_head.wr);
+		GTP_DEBUG("[PARAM]size: %d, *ppos: %d", size, (int)*ppos);
+		GTP_DEBUG("[TOOL_READ]ADB call again, return it.");
+		*/
+		return 0;
 	}
 
-	switch (cmd_head.wr) {
-	case GTP_RW_READ:
-		if (cmd_head.flag == GTP_NEED_FLAG) {
-			if (comfirm() == FAIL) {
-				dev_err(&gt_client->dev, "Comfirm fail!");
-				ret = -EINVAL;
-				goto exit;
+	if (cmd_head.wr % 2)
+		return -EPERM;
+	else if (!cmd_head.wr) {
+		u16 len = 0;
+		s16 data_len = 0;
+		u16 loc = 0;
+
+		if (1 == cmd_head.flag) {
+			if (FAIL == comfirm()) {
+				GTP_ERROR("[READ]Comfirm fail!");
+				return -EPERM;
 			}
-		} else if (cmd_head.flag == GTP_NEED_INTERRUPT) {
+		} else if (2 == cmd_head.flag) {
 			/* Need interrupt! */
 		}
 
 		memcpy(cmd_head.data, cmd_head.addr, cmd_head.addr_len);
 
-		pr_debug("[CMD HEAD DATA] ADDR:0x%02x%02x.", cmd_head.data[0],
-							cmd_head.data[1]);
-		pr_debug("[CMD HEAD ADDR] ADDR:0x%02x%02x.", cmd_head.addr[0],
-							cmd_head.addr[1]);
+		GTP_DEBUG("[CMD HEAD DATA] ADDR:0x%02x%02x.", cmd_head.data[0],
+			  cmd_head.data[1]);
+		GTP_DEBUG("[CMD HEAD ADDR] ADDR:0x%02x%02x.", cmd_head.addr[0],
+			  cmd_head.addr[1]);
 
 		if (cmd_head.delay)
 			msleep(cmd_head.delay);
 
 		data_len = cmd_head.data_len;
-		if (data_len <= 0 || (data_len > data_length)) {
-			dev_err(&gt_client->dev, "Invalid data length %d\n",
-				data_len);
-			ret = -EINVAL;
-			goto exit;
-		}
-		if (data_len > count)
-			data_len = count;
-
-		if (tool_i2c_read(cmd_head.data, data_len) <= 0) {
-			dev_err(&gt_client->dev, "Read data failed!\n");
-			ret = -EIO;
-			goto exit;
+		while (data_len > 0) {
+			if (data_len > DATA_LENGTH)
+				len = DATA_LENGTH;
+			else
+				len = data_len;
+			data_len -= len;
+
+			if (tool_i2c_read(cmd_head.data, len) <= 0) {
+				GTP_ERROR("[READ]Read data failed!");
+				return -EPERM;
+			}
+			ret =
+			    simple_read_from_buffer(&page[loc], size, ppos,
+						    &cmd_head.
+						    data[GTP_ADDR_LENGTH], len);
+			if (ret < 0)
+				return ret;
+			loc += len;
+
+			GTP_DEBUG_ARRAY(&cmd_head.data[GTP_ADDR_LENGTH], len);
+			GTP_DEBUG_ARRAY(page, len);
 		}
-		ret = simple_read_from_buffer(user_buf, count, ppos,
-			&cmd_head.data[GTP_ADDR_LENGTH], data_len);
-		break;
-	case GTP_RW_FILL_INFO:
-		ret = fill_update_info(user_buf, count, ppos);
-		break;
-	case GTP_RW_READ_VERSION:
-		/* Read driver version */
-		data_len = scnprintf(buf, sizeof(buf), "%s\n",
-			GTP_DRIVER_VERSION);
-		ret = simple_read_from_buffer(user_buf, count, ppos,
-			buf, data_len);
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
-
-exit:
-	mutex_unlock(&lock);
-	return ret;
-}
-
-static const struct file_operations goodix_proc_fops = {
-	.write = goodix_tool_write,
-	.read = goodix_tool_read,
-	.open = simple_open,
-	.owner = THIS_MODULE,
-};
-
-s32 init_wr_node(struct i2c_client *client)
-{
-	u8 i;
-
-	gt_client = client;
-	memset(&cmd_head, 0, sizeof(cmd_head));
-	cmd_head.data = NULL;
-
-	i = GTP_I2C_RETRY_5;
-	while ((!cmd_head.data) && i) {
-		cmd_head.data = devm_kzalloc(&client->dev,
-				i * DATA_LENGTH_UINT, GFP_KERNEL);
-		if (cmd_head.data)
-			break;
-		i--;
-	}
-	if (i) {
-		data_length = i * DATA_LENGTH_UINT;
-		dev_dbg(&client->dev, "Applied memory size:%d.", data_length);
-	} else {
-		dev_err(&client->dev, "Apply for memory failed.");
-		return FAIL;
-	}
-
-	cmd_head.addr_len = 2;
-	cmd_head.retry = GTP_I2C_RETRY_5;
-
-	register_i2c_func();
-
-	mutex_init(&lock);
-	tool_set_proc_name(procname);
-	goodix_proc_entry = proc_create(procname,
-			S_IWUSR | S_IWGRP | S_IRUSR | S_IRGRP,
-			goodix_proc_entry,
-			&goodix_proc_fops);
-	if (goodix_proc_entry == NULL) {
-		dev_err(&client->dev, "Couldn't create proc entry!");
-		return FAIL;
+		return cmd_head.data_len;
+	} else if (2 == cmd_head.wr) {
+		ret =
+		    simple_read_from_buffer(page, size, ppos, IC_TYPE,
+					    sizeof(IC_TYPE));
+		return ret;
+	} else if (4 == cmd_head.wr) {
+		u8 progress_buf[4];
+		progress_buf[0] = show_len >> 8;
+		progress_buf[1] = show_len & 0xff;
+		progress_buf[2] = total_len >> 8;
+		progress_buf[3] = total_len & 0xff;
+
+		ret =
+		    simple_read_from_buffer(page, size, ppos, progress_buf, 4);
+		return ret;
+	} else if (6 == cmd_head.wr) {
+		/* Read error code! */
+	} else if (8 == cmd_head.wr) {
+		ret =
+		    simple_read_from_buffer(page, size, ppos,
+					    GTP_DRIVER_VERSION,
+					    strlen(GTP_DRIVER_VERSION));
+		return ret;
 	}
-
-	return SUCCESS;
+	return -EPERM;
 }
diff --git a/drivers/input/touchscreen/gt9xx/gt9xx.c b/drivers/input/touchscreen/gt9xx/gt9xx.c
index 46dfeed..3419aa9 100644
--- a/drivers/input/touchscreen/gt9xx/gt9xx.c
+++ b/drivers/input/touchscreen/gt9xx/gt9xx.c
@@ -1,12 +1,8 @@
 /* drivers/input/touchscreen/gt9xx.c
  *
+ * 2010 - 2014 Goodix Technology.
  * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
  *
- * Linux Foundation chooses to take subject only to the GPLv2 license
- * terms, and distributes only under these terms.
- *
- * 2010 - 2013 Goodix Technology.
- *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
@@ -18,15 +14,15 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * General Public License for more details.
  *
- * Version: 1.8
+ * Version: 2.2
  * Authors: andrew@goodix.com, meta@goodix.com
- * Release Date: 2013/04/25
+ * Release Date: 2014/01/14
  * Revision record:
  *      V1.0:
  *          first Release. By Andrew, 2012/08/31
  *      V1.2:
  *          modify gtp_reset_guitar,slot report,tracking_id & 0x0F.
- *                  By Andrew, 2012/10/15
+ *	By Andrew, 2012/10/15
  *      V1.4:
  *          modify gt9xx_update.c. By Andrew, 2012/12/12
  *      V1.6:
@@ -39,26 +35,33 @@
  *      V1.8:
  *          1. pen/stylus identification
  *          2. read double check & fixed config support
- *          2. new esd & slide wakeup optimization
+ *          3. new esd & slide wakeup optimization
  *                  By Meta, 2013/06/08
+ *      V2.0:
+ *          1. compatible with GT9XXF
+ *          2. send config after resume
+ *                  By Meta, 2013/08/06
+ *      V2.2:
+ *          1. gt9xx_config for debug
+ *          2. gesture wakeup
+ *          3. pen separate input device, active-pen button support
+ *          4. coordinates & keys optimization
+ *                  By Meta, 2014/01/14
  */
 
+#include <linux/irq.h>
 #include <linux/regulator/consumer.h>
+#include <linux/of_gpio.h>
 #include "gt9xx.h"
 
-#include <linux/of_gpio.h>
-#include <linux/irq.h>
-#include <linux/module.h>
+#if GTP_ICS_SLOT_REPORT
 #include <linux/input/mt.h>
-#include <linux/debugfs.h>
+#endif
 
-#define GOODIX_DEV_NAME	"Goodix-CTP"
-#define CFG_MAX_TOUCH_POINTS	5
+static const char *goodix_ts_name = "goodix-ts";
+static struct workqueue_struct *goodix_wq;
+struct i2c_client *i2c_connect_client;
 #define GOODIX_COORDS_ARR_SIZE	4
-#define MAX_BUTTONS		4
-
-#define CFG_GROUP_LEN(p_cfg_grp)  (sizeof(p_cfg_grp) / sizeof(p_cfg_grp[0]))
-
 #define GOODIX_VTG_MIN_UV	2600000
 #define GOODIX_VTG_MAX_UV	3300000
 #define GOODIX_I2C_VTG_MIN_UV	1800000
@@ -67,20 +70,39 @@
 #define GOODIX_VDD_LOAD_MAX_UA	10000
 #define GOODIX_VIO_LOAD_MIN_UA	0
 #define GOODIX_VIO_LOAD_MAX_UA	10000
+#ifdef FEATURE_QRD8X26_UNISCOPE_MODIFY
+#define GPIO_VDD_2_8V		56
+#endif
+#define MAX_BUTTONS		4
+#define PROP_NAME_SIZE		24
 
-#define RESET_DELAY_T3_US	200	/* T3: > 100us */
-#define RESET_DELAY_T4		20	/* T4: > 5ms */
+u8 config[GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH] = {
+		GTP_REG_CONFIG_DATA >> 8, GTP_REG_CONFIG_DATA & 0xff};
 
-#define PHY_BUF_SIZE		32
-#define PROP_NAME_SIZE		24
+#if GTP_HAVE_TOUCH_KEY
+static const u16 touch_key_array[] = GTP_KEY_TAB;
+#define GTP_MAX_KEY_NUM  (sizeof(touch_key_array) / sizeof(touch_key_array[0]))
+#if GTP_DEBUG_ON
+static const int key_codes[] = {KEY_HOMEPAGE, KEY_BACK, KEY_MENU, KEY_SEARCH};
+static const char *const key_names[] = {
+	"Key_Home", "Key_Back", "Key_Menu", "Key_Search"};
+#endif
+#endif
 
-#define GTP_MAX_TOUCH		5
-#define GTP_ESD_CHECK_CIRCLE_MS	2000
+static s8 gtp_i2c_test(struct i2c_client *client);
+static void gtp_int_sync(struct goodix_ts_data *ts, s32 ms);
 
-static void gtp_int_sync(struct goodix_ts_data *ts, int ms);
-static int gtp_i2c_test(struct i2c_client *client);
-static int goodix_power_off(struct goodix_ts_data *ts);
-static int goodix_power_on(struct goodix_ts_data *ts);
+static ssize_t gt91xx_config_read_proc(struct file *, char __user *, size_t,
+				       loff_t *);
+static ssize_t gt91xx_config_write_proc(struct file *, const char __user *,
+					size_t, loff_t *);
+
+static struct proc_dir_entry *gt91xx_config_proc;
+static const struct file_operations config_proc_ops = {
+	.owner = THIS_MODULE,
+	.read = gt91xx_config_read_proc,
+	.write = gt91xx_config_write_proc,
+};
 
 #if defined(CONFIG_FB)
 static int fb_notifier_callback(struct notifier_block *self,
@@ -95,147 +117,180 @@ static void goodix_ts_late_resume(struct early_suspend *h);
 #if GTP_ESD_PROTECT
 static struct delayed_work gtp_esd_check_work;
 static struct workqueue_struct *gtp_esd_check_workqueue;
-static void gtp_esd_check_func(struct work_struct *work);
-static int gtp_init_ext_watchdog(struct i2c_client *client);
+static void gtp_esd_check_func(struct work_struct *);
+static s32 gtp_init_ext_watchdog(struct i2c_client *client);
+#endif
+
+/*********** For GT9XXF Start **********/
+#if GTP_COMPATIBLE_MODE
+static s32 gtp_esd_recovery(struct i2c_client *client);
+static s32 gtp_main_clk_proc(struct goodix_ts_data *ts);
+static s32 gtp_bak_ref_proc(struct goodix_ts_data *ts, u8 mode);
 #endif
+/********** For GT9XXF End **********/
 
-enum doze {
+#if GTP_GESTURE_WAKEUP
+enum {
 	DOZE_DISABLED = 0,
 	DOZE_ENABLED = 1,
 	DOZE_WAKEUP = 2,
-};
-static enum doze doze_status = DOZE_DISABLED;
+} DOZE_T;
+static DOZE_T doze_status = DOZE_DISABLED;
 static s8 gtp_enter_doze(struct goodix_ts_data *ts);
+#endif
 
-bool init_done;
-static u8 chip_gt9xxs;  /* true if ic is gt9xxs, like gt915s */
 u8 grp_cfg_version;
-struct i2c_client  *i2c_connect_client;
 
 #define GTP_DEBUGFS_DIR			"ts_debug"
 #define GTP_DEBUGFS_FILE_SUSPEND	"suspend"
 #define GTP_DEBUGFS_FILE_DATA		"data"
 #define GTP_DEBUGFS_FILE_ADDR		"addr"
+#define GTP_DEBUGFS_FILE_DUMP_INFO	"dump_info"
+
+#define GOODIX_INFO_MAX_LEN 512
+#define GOODIX_STORE_TS_INFO(buf, name, max_tch, product_id, fw_vkey_support) \
+				snprintf(buf, GOODIX_INFO_MAX_LEN, \
+				"controller\t= goodix\n" \
+				"name\t\t= %s\n" \
+				"max_touches\t= %d\n" \
+				"product\t= 0x%s\n" \
+				"fw_vkey_support\t= %s\n" \
+				, name, \
+				max_tch, product_id, \
+				fw_vkey_support)
 
 /*******************************************************
 Function:
-	Read data from the i2c slave device.
+    Read data from the i2c slave device.
 Input:
-	client:     i2c device.
-	buf[0~1]:   read start address.
-	buf[2~len-1]:   read data buffer.
-	len:    GTP_ADDR_LENGTH + read bytes count
+    client:     i2c device.
+    buf[0~1]:   read start address.
+    buf[2~len-1]:   read data buffer.
+    len:    GTP_ADDR_LENGTH + read bytes count
 Output:
-	numbers of i2c_msgs to transfer:
-		2: succeed, otherwise: failed
+    numbers of i2c_msgs to transfer:
+      2: succeed, otherwise: failed
 *********************************************************/
-int gtp_i2c_read(struct i2c_client *client, u8 *buf, int len)
+s32 gtp_i2c_read(struct i2c_client *client, u8 *buf, s32 len)
 {
-	struct goodix_ts_data *ts = i2c_get_clientdata(client);
-	int ret = -EIO;
-	u8 retries;
-	struct i2c_msg msgs[2] = {
-		{
-			.flags	= !I2C_M_RD,
-			.addr	= client->addr,
-			.len	= GTP_ADDR_LENGTH,
-			.buf	= &buf[0],
-		},
-		{
-			.flags	= I2C_M_RD,
-			.addr	= client->addr,
-			.len	= len - GTP_ADDR_LENGTH,
-			.buf	= &buf[GTP_ADDR_LENGTH],
-		},
-	};
+	struct i2c_msg msgs[2];
+	s32 ret = -1;
+	s32 retries = 0;
+
+	GTP_DEBUG_FUNC();
 
-	for (retries = 0; retries < GTP_I2C_RETRY_5; retries++) {
+	msgs[0].flags = !I2C_M_RD;
+	msgs[0].addr = client->addr;
+	msgs[0].len = GTP_ADDR_LENGTH;
+	msgs[0].buf = &buf[0];
+
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].addr = client->addr;
+	msgs[1].len = len - GTP_ADDR_LENGTH;
+	msgs[1].buf = &buf[GTP_ADDR_LENGTH];
+
+	while (retries < 5) {
 		ret = i2c_transfer(client->adapter, msgs, 2);
 		if (ret == 2)
 			break;
-		dev_err(&client->dev, "I2C retry: %d\n", retries + 1);
+		retries++;
 	}
-	if (retries == GTP_I2C_RETRY_5) {
-		if (ts->pdata->slide_wakeup)
-			/* reset chip would quit doze mode */
-			if (DOZE_ENABLED == doze_status)
-				return ret;
+	if ((retries >= 5)) {
+#if GTP_COMPATIBLE_MODE
+		struct goodix_ts_data *ts = i2c_get_clientdata(client);
+#endif
 
-		if (init_done)
-			gtp_reset_guitar(ts, 10);
+#if GTP_GESTURE_WAKEUP
+		/* reset chip would quit doze mode */
+		if (DOZE_ENABLED == doze_status)
+			return ret;
+#endif
+		GTP_ERROR
+		    ("I2C Read: 0x%04X, %d bytes failed, errcode: %d!",
+		     (((u16)(buf[0] << 8)) | buf[1]), len - 2, ret);
+#if GTP_COMPATIBLE_MODE
+		if (CHIP_TYPE_GT9F == ts->chip_type)
+			gtp_recovery_reset(client);
 		else
-			dev_warn(&client->dev,
-				"gtp_reset_guitar exit init_done=%d:\n",
-				init_done);
+#endif
+			gtp_reset_guitar(client, 10);
 	}
 	return ret;
 }
 
 /*******************************************************
 Function:
-	Write data to the i2c slave device.
+    Write data to the i2c slave device.
 Input:
-	client:     i2c device.
-	buf[0~1]:   write start address.
-	buf[2~len-1]:   data buffer
-	len:    GTP_ADDR_LENGTH + write bytes count
+    client:     i2c device.
+    buf[0~1]:   write start address.
+    buf[2~len-1]:   data buffer
+    len:    GTP_ADDR_LENGTH + write bytes count
 Output:
-	numbers of i2c_msgs to transfer:
-	1: succeed, otherwise: failed
+    numbers of i2c_msgs to transfer:
+    1: succeed, otherwise: failed
 *********************************************************/
-int gtp_i2c_write(struct i2c_client *client, u8 *buf, int len)
+s32 gtp_i2c_write(struct i2c_client *client, u8 *buf, s32 len)
 {
-	struct goodix_ts_data *ts = i2c_get_clientdata(client);
-	int ret = -EIO;
-	u8 retries;
-	struct i2c_msg msg = {
-		.flags = !I2C_M_RD,
-		.addr = client->addr,
-		.len = len,
-		.buf = buf,
-	};
+	struct i2c_msg msg;
+	s32 ret = -1;
+	s32 retries = 0;
+
+	GTP_DEBUG_FUNC();
 
-	for (retries = 0; retries < GTP_I2C_RETRY_5; retries++) {
+	msg.flags = !I2C_M_RD;
+	msg.addr = client->addr;
+	msg.len = len;
+	msg.buf = buf;
+
+	while (retries < 5) {
 		ret = i2c_transfer(client->adapter, &msg, 1);
 		if (ret == 1)
 			break;
-		dev_err(&client->dev, "I2C retry: %d\n", retries + 1);
+		retries++;
 	}
-	if ((retries == GTP_I2C_RETRY_5)) {
-		if (ts->pdata->slide_wakeup)
-			if (DOZE_ENABLED == doze_status)
-				return ret;
+	if ((retries >= 5)) {
+#if GTP_COMPATIBLE_MODE
+		struct goodix_ts_data *ts = i2c_get_clientdata(client);
+#endif
 
-		if (init_done)
-			gtp_reset_guitar(ts, 10);
+#if GTP_GESTURE_WAKEUP
+		if (DOZE_ENABLED == doze_status)
+			return ret;
+#endif
+		GTP_ERROR
+		    ("I2C Write: 0x%04X, %d bytes failed, errcode: %d!",
+		     (((u16)(buf[0] << 8)) | buf[1]), len - 2, ret);
+#if GTP_COMPATIBLE_MODE
+		if (CHIP_TYPE_GT9F == ts->chip_type)
+			gtp_recovery_reset(client);
 		else
-			dev_warn(&client->dev,
-				"gtp_reset_guitar exit init_done=%d:\n",
-				init_done);
+#endif
+			gtp_reset_guitar(client, 10);
 	}
 	return ret;
 }
 
 /*******************************************************
 Function:
-	i2c read twice, compare the results
+    i2c read twice, compare the results
 Input:
-	client:  i2c device
-	addr:    operate address
-	rxbuf:   read data to store, if compare successful
-	len:     bytes to read
+    client:  i2c device
+    addr:    operate address
+    rxbuf:   read data to store, if compare successful
+    len:     bytes to read
 Output:
-	FAIL:    read failed
-	SUCCESS: read successful
+    FAIL:    read failed
+    SUCCESS: read successful
 *********************************************************/
-int gtp_i2c_read_dbl_check(struct i2c_client *client,
-			u16 addr, u8 *rxbuf, int len)
+s32 gtp_i2c_read_dbl_check(struct i2c_client *client, u16 addr, u8 *rxbuf,
+			   int len)
 {
 	u8 buf[16] = {0};
 	u8 confirm_buf[16] = {0};
 	u8 retry = 0;
 
-	while (retry++ < GTP_I2C_RETRY_3) {
+	while (retry++ < 3) {
 		memset(buf, 0xAA, 16);
 		buf[0] = (u8)(addr >> 8);
 		buf[1] = (u8)(addr & 0xFF);
@@ -246,69 +301,69 @@ int gtp_i2c_read_dbl_check(struct i2c_client *client,
 		confirm_buf[1] = (u8)(addr & 0xFF);
 		gtp_i2c_read(client, confirm_buf, len + 2);
 
-		if (!memcmp(buf, confirm_buf, len + 2))
-			break;
-	}
-	if (retry < GTP_I2C_RETRY_3) {
-		memcpy(rxbuf, confirm_buf + 2, len);
-		return SUCCESS;
-	} else {
-		dev_err(&client->dev,
-			"i2c read 0x%04X, %d bytes, double check failed!",
-			addr, len);
-		return FAIL;
+		if (!memcmp(buf, confirm_buf, len + 2)) {
+			memcpy(rxbuf, confirm_buf + 2, len);
+			return SUCCESS;
+		}
 	}
+	GTP_ERROR("I2C read 0x%04X, %d bytes, double check failed!", addr, len);
+	return FAIL;
 }
 
 /*******************************************************
 Function:
-	Send config data.
+    Send config.
 Input:
-	client: i2c device.
+    client: i2c device.
 Output:
-	result of i2c write operation.
-	> 0: succeed, otherwise: failed
+    result of i2c write operation.
+    1: succeed, otherwise: failed
 *********************************************************/
-int gtp_send_cfg(struct goodix_ts_data *ts)
+s32 gtp_send_cfg(struct i2c_client *client)
 {
-	int ret = 0;
-	int retry;
+	s32 ret = 2;
 
-	if (ts->pdata->driver_send_cfg) {
-		if (ts->fixed_cfg) {
-			dev_dbg(&ts->client->dev,
-				"Ic fixed config, no config sent!");
-			ret = 2;
-		} else {
-			for (retry = 0; retry < GTP_I2C_RETRY_5; retry++) {
-				ret = gtp_i2c_write(ts->client,
-					ts->config_data,
-					GTP_CONFIG_MAX_LENGTH +
-						GTP_ADDR_LENGTH);
-				if (ret > 0)
-					break;
-			}
-		}
+#if GTP_DRIVER_SEND_CFG
+	s32 retry = 0;
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+	if (ts->fixed_cfg) {
+		GTP_INFO("Ic fixed config, no config sent!");
+		return 0;
+	} else if (ts->pnl_init_error) {
+		GTP_INFO("Error occured in init_panel, no config sent");
+		return 0;
 	}
 
+	GTP_INFO("Driver send config.");
+	for (retry = 0; retry < 5; retry++) {
+		ret =
+		    gtp_i2c_write(client, config,
+				  GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH);
+		if (ret > 0)
+			break;
+	}
+#endif
 	return ret;
 }
 
 /*******************************************************
 Function:
-	Disable irq function
+    Disable irq function
 Input:
-	ts: goodix i2c_client private data
+    ts: goodix i2c_client private data
 Output:
-	None.
+    None.
 *********************************************************/
 void gtp_irq_disable(struct goodix_ts_data *ts)
 {
 	unsigned long irqflags;
 
+	GTP_DEBUG_FUNC();
+
 	spin_lock_irqsave(&ts->irq_lock, irqflags);
-	if (!ts->irq_is_disabled) {
-		ts->irq_is_disabled = true;
+	if (!ts->irq_is_disable) {
+		ts->irq_is_disable = 1;
 		disable_irq_nosync(ts->client->irq);
 	}
 	spin_unlock_irqrestore(&ts->irq_lock, irqflags);
@@ -316,86 +371,195 @@ void gtp_irq_disable(struct goodix_ts_data *ts)
 
 /*******************************************************
 Function:
-	Enable irq function
+    Enable irq function
 Input:
-	ts: goodix i2c_client private data
+    ts: goodix i2c_client private data
 Output:
-	None.
+    None.
 *********************************************************/
 void gtp_irq_enable(struct goodix_ts_data *ts)
 {
 	unsigned long irqflags = 0;
 
+	GTP_DEBUG_FUNC();
+
 	spin_lock_irqsave(&ts->irq_lock, irqflags);
-	if (ts->irq_is_disabled) {
+	if (ts->irq_is_disable) {
 		enable_irq(ts->client->irq);
-		ts->irq_is_disabled = false;
+		ts->irq_is_disable = 0;
 	}
 	spin_unlock_irqrestore(&ts->irq_lock, irqflags);
 }
 
 /*******************************************************
 Function:
-	Report touch point event
+    Report touch point event
 Input:
-	ts: goodix i2c_client private data
-	id: trackId
-	x:  input x coordinate
-	y:  input y coordinate
-	w:  input pressure
+    ts: goodix i2c_client private data
+    id: trackId
+    x:  input x coordinate
+    y:  input y coordinate
+    w:  input pressure
 Output:
-	None.
+    None.
 *********************************************************/
-static void gtp_touch_down(struct goodix_ts_data *ts, int id, int x, int y,
-		int w)
+static void gtp_touch_down(struct goodix_ts_data *ts, s32 id, s32 x, s32 y,
+			   s32 w)
 {
-	if (ts->pdata->change_x2y)
-		swap(x, y);
+#if GTP_CHANGE_X2Y
+	GTP_SWAP(x, y);
+#endif
 
+#if GTP_ICS_SLOT_REPORT
 	input_mt_slot(ts->input_dev, id);
-	input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, true);
+	input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, id);
+	input_report_abs(ts->input_dev, ABS_MT_POSITION_X, x);
+	input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, y);
+	input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, w);
+	input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, w);
+#else
+	input_report_key(ts->input_dev, BTN_TOUCH, 1);
 	input_report_abs(ts->input_dev, ABS_MT_POSITION_X, x);
 	input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, y);
 	input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, w);
 	input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, w);
+	input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, id);
+	input_mt_sync(ts->input_dev);
+#endif
+
+	GTP_DEBUG("ID:%d, X:%d, Y:%d, W:%d", id, x, y, w);
 }
 
 /*******************************************************
 Function:
-	Report touch release event
+    Report touch release event
 Input:
-	ts: goodix i2c_client private data
+    ts: goodix i2c_client private data
 Output:
-	None.
+    None.
 *********************************************************/
-static void gtp_touch_up(struct goodix_ts_data *ts, int id)
+static void gtp_touch_up(struct goodix_ts_data *ts, s32 id)
 {
+#if GTP_ICS_SLOT_REPORT
 	input_mt_slot(ts->input_dev, id);
-	input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, false);
+	input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, -1);
+	GTP_DEBUG("Touch id[%2d] release!", id);
+#else
+	input_report_key(ts->input_dev, BTN_TOUCH, 0);
+#endif
+}
+
+#if GTP_WITH_PEN
+static void gtp_pen_init(struct goodix_ts_data *ts)
+{
+	s32 ret = 0;
+
+	GTP_INFO("Request input device for pen/stylus.");
+
+	ts->pen_dev = input_allocate_device();
+	if (ts->pen_dev == NULL) {
+		GTP_ERROR("Failed to allocate input device for pen/stylus.");
+		return;
+	}
+
+	ts->pen_dev->evbit[0] =
+	    BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+
+#if GTP_ICS_SLOT_REPORT
+	input_mt_init_slots(ts->pen_dev, 16, 0);
+#else
+	ts->pen_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+#endif
+
+	set_bit(BTN_TOOL_PEN, ts->pen_dev->keybit);
+	set_bit(INPUT_PROP_DIRECT, ts->pen_dev->propbit);
+
+#if GTP_PEN_HAVE_BUTTON
+	input_set_capability(ts->pen_dev, EV_KEY, BTN_STYLUS);
+	input_set_capability(ts->pen_dev, EV_KEY, BTN_STYLUS2);
+#endif
+
+	input_set_abs_params(ts->pen_dev, ABS_MT_POSITION_X, 0, ts->abs_x_max,
+			     0, 0);
+	input_set_abs_params(ts->pen_dev, ABS_MT_POSITION_Y, 0, ts->abs_y_max,
+			     0, 0);
+	input_set_abs_params(ts->pen_dev, ABS_MT_PRESSURE, 0, 255, 0, 0);
+	input_set_abs_params(ts->pen_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(ts->pen_dev, ABS_MT_TRACKING_ID, 0, 255, 0, 0);
+
+	ts->pen_dev->name = "goodix-pen";
+	ts->pen_dev->id.bustype = BUS_I2C;
+
+	ret = input_register_device(ts->pen_dev);
+	if (ret)
+		GTP_ERROR("Register %s input device failed", ts->pen_dev->name);
+}
+
+static void gtp_pen_down(s32 x, s32 y, s32 w, s32 id)
+{
+	struct goodix_ts_data *ts = i2c_get_clientdata(i2c_connect_client);
+
+#if GTP_CHANGE_X2Y
+	GTP_SWAP(x, y);
+#endif
+
+	input_report_key(ts->pen_dev, BTN_TOOL_PEN, 1);
+#if GTP_ICS_SLOT_REPORT
+	input_mt_slot(ts->pen_dev, id);
+	input_report_abs(ts->pen_dev, ABS_MT_TRACKING_ID, id);
+	input_report_abs(ts->pen_dev, ABS_MT_POSITION_X, x);
+	input_report_abs(ts->pen_dev, ABS_MT_POSITION_Y, y);
+	input_report_abs(ts->pen_dev, ABS_MT_PRESSURE, w);
+	input_report_abs(ts->pen_dev, ABS_MT_TOUCH_MAJOR, w);
+#else
+	input_report_key(ts->pen_dev, BTN_TOUCH, 1);
+	input_report_abs(ts->pen_dev, ABS_MT_POSITION_X, x);
+	input_report_abs(ts->pen_dev, ABS_MT_POSITION_Y, y);
+	input_report_abs(ts->pen_dev, ABS_MT_PRESSURE, w);
+	input_report_abs(ts->pen_dev, ABS_MT_TOUCH_MAJOR, w);
+	input_report_abs(ts->pen_dev, ABS_MT_TRACKING_ID, id);
+	input_mt_sync(ts->pen_dev);
+#endif
+	GTP_DEBUG("(%d)(%d, %d)[%d]", id, x, y, w);
 }
 
+static void gtp_pen_up(s32 id)
+{
+	struct goodix_ts_data *ts = i2c_get_clientdata(i2c_connect_client);
+
+	input_report_key(ts->pen_dev, BTN_TOOL_PEN, 0);
 
+#if GTP_ICS_SLOT_REPORT
+	input_mt_slot(ts->pen_dev, id);
+	input_report_abs(ts->pen_dev, ABS_MT_TRACKING_ID, -1);
+#else
+	input_report_key(ts->pen_dev, BTN_TOUCH, 0);
+#endif
+}
+#endif
 
 /*******************************************************
 Function:
-	Goodix touchscreen work function
+    Goodix touchscreen work function
 Input:
-	work: work struct of goodix_workqueue
+    work: work struct of goodix_workqueue
 Output:
-	None.
+    None.
 *********************************************************/
 static void goodix_ts_work_func(struct work_struct *work)
 {
-	u8 end_cmd[3] = { GTP_READ_COOR_ADDR >> 8,
-			GTP_READ_COOR_ADDR & 0xFF, 0};
+	u8 end_cmd[3] = {
+		GTP_READ_COOR_ADDR >> 8, GTP_READ_COOR_ADDR & 0xFF, 0};
 	u8 point_data[2 + 1 + 8 * GTP_MAX_TOUCH + 1] = {
-			GTP_READ_COOR_ADDR >> 8,
-			GTP_READ_COOR_ADDR & 0xFF};
+		GTP_READ_COOR_ADDR >> 8, GTP_READ_COOR_ADDR & 0xFF};
 	u8 touch_num = 0;
 	u8 finger = 0;
 	static u16 pre_touch;
 	static u8 pre_key;
+#if GTP_WITH_PEN
+	u8 pen_active = 0;
 	static u8 pre_pen;
+#endif
 	u8 key_value = 0;
 	u8 *coor_data = NULL;
 	s32 input_x = 0;
@@ -403,78 +567,176 @@ static void goodix_ts_work_func(struct work_struct *work)
 	s32 input_w = 0;
 	s32 id = 0;
 	s32 i = 0;
-	int ret = -1;
+	s32 ret = -1;
 	struct goodix_ts_data *ts = NULL;
+
+#if GTP_COMPATIBLE_MODE
+	u8 rqst_buf[3] = {0x80, 0x43};	/* for GT9XXF */
+#endif
+
+#if GTP_GESTURE_WAKEUP
 	u8 doze_buf[3] = {0x81, 0x4B};
+#endif
 
+	GTP_DEBUG_FUNC();
 	ts = container_of(work, struct goodix_ts_data, work);
-#ifdef CONFIG_GT9XX_TOUCHPANEL_UPDATE
 	if (ts->enter_update)
 		return;
-#endif
 
-	if (ts->pdata->slide_wakeup) {
-		if (DOZE_ENABLED == doze_status) {
-			ret = gtp_i2c_read(ts->client, doze_buf, 3);
-			if (ret > 0) {
-				if (doze_buf[2] == 0xAA) {
-					dev_dbg(&ts->client->dev,
-						"Slide(0xAA) To Light up the screen!");
-					doze_status = DOZE_WAKEUP;
-					input_report_key(
-						ts->input_dev, KEY_POWER, 1);
-					input_sync(ts->input_dev);
-					input_report_key(
-						ts->input_dev, KEY_POWER, 0);
-					input_sync(ts->input_dev);
-					/* clear 0x814B */
-					doze_buf[2] = 0x00;
-					gtp_i2c_write(ts->client, doze_buf, 3);
-				} else if (doze_buf[2] == 0xBB) {
-					dev_dbg(&ts->client->dev,
-						"Slide(0xBB) To Light up the screen!");
-					doze_status = DOZE_WAKEUP;
-					input_report_key(ts->input_dev,
-								KEY_POWER, 1);
-					input_sync(ts->input_dev);
-					input_report_key(ts->input_dev,
-								KEY_POWER, 0);
-					input_sync(ts->input_dev);
-					/* clear 0x814B*/
-					doze_buf[2] = 0x00;
-					gtp_i2c_write(ts->client, doze_buf, 3);
-				} else if (0xC0 == (doze_buf[2] & 0xC0)) {
-					dev_dbg(&ts->client->dev,
-						"double click to light up the screen!");
-					doze_status = DOZE_WAKEUP;
-					input_report_key(ts->input_dev,
-								KEY_POWER, 1);
-					input_sync(ts->input_dev);
-					input_report_key(ts->input_dev,
-								KEY_POWER, 0);
-					input_sync(ts->input_dev);
-					/* clear 0x814B */
-					doze_buf[2] = 0x00;
-					gtp_i2c_write(ts->client, doze_buf, 3);
-				} else {
-					gtp_enter_doze(ts);
-				}
+#if GTP_GESTURE_WAKEUP
+	if (DOZE_ENABLED == doze_status) {
+		ret = gtp_i2c_read(i2c_connect_client, doze_buf, 3);
+		GTP_DEBUG("0x814B = 0x%02X", doze_buf[2]);
+		if (ret > 0) {
+			if ((doze_buf[2] == 'a') || (doze_buf[2] == 'b')
+				|| (doze_buf[2] == 'c') || (doze_buf[2] == 'd')
+				|| (doze_buf[2] == 'e') || (doze_buf[2] == 'g')
+				|| (doze_buf[2] == 'h') || (doze_buf[2] == 'm')
+				|| (doze_buf[2] == 'o') || (doze_buf[2] == 'q')
+				|| (doze_buf[2] == 's') || (doze_buf[2] == 'v')
+				|| (doze_buf[2] == 'w') || (doze_buf[2] == 'y')
+				|| (doze_buf[2] == 'z') || (doze_buf[2] == 0x5E)
+			    ) {
+				if (doze_buf[2] != 0x5E)
+					GTP_INFO("Wakeup by gesture(%c), ",
+					     doze_buf[2]);
+				else
+					GTP_INFO("Wakeup by gesture(^), ");
+				GTP_INFO("light up the screen!");
+				doze_status = DOZE_WAKEUP;
+				input_report_key(ts->input_dev, KEY_POWER, 1);
+				input_sync(ts->input_dev);
+				input_report_key(ts->input_dev, KEY_POWER, 0);
+				input_sync(ts->input_dev);
+				/* clear 0x814B */
+				doze_buf[2] = 0x00;
+				gtp_i2c_write(i2c_connect_client, doze_buf, 3);
+			} else if ((doze_buf[2] == 0xAA)
+				   || (doze_buf[2] == 0xBB)
+				   || (doze_buf[2] == 0xAB)
+				   || (doze_buf[2] == 0xBA)) {
+				char *direction[4] = {
+					"Right", "Down", "Up", "Left"};
+				u8 type =
+				    ((doze_buf[2] & 0x0F) - 0x0A) +
+				    (((doze_buf[2] >> 4) & 0x0F) - 0x0A) * 2;
+
+				GTP_INFO("%s slide to light up the screen!",
+					 direction[type]);
+				doze_status = DOZE_WAKEUP;
+				input_report_key(ts->input_dev, KEY_POWER, 1);
+				input_sync(ts->input_dev);
+				input_report_key(ts->input_dev, KEY_POWER, 0);
+				input_sync(ts->input_dev);
+				/* clear 0x814B */
+				doze_buf[2] = 0x00;
+				gtp_i2c_write(i2c_connect_client, doze_buf, 3);
+			} else if (0xCC == doze_buf[2]) {
+				GTP_INFO
+				    ("Double click to light up the screen!");
+				doze_status = DOZE_WAKEUP;
+				input_report_key(ts->input_dev, KEY_POWER, 1);
+				input_sync(ts->input_dev);
+				input_report_key(ts->input_dev, KEY_POWER, 0);
+				input_sync(ts->input_dev);
+				/* clear 0x814B */
+				doze_buf[2] = 0x00;
+				gtp_i2c_write(i2c_connect_client, doze_buf, 3);
+			} else {
+				/* clear 0x814B */
+				doze_buf[2] = 0x00;
+				gtp_i2c_write(i2c_connect_client, doze_buf, 3);
+				gtp_enter_doze(ts);
 			}
-			if (ts->use_irq)
-				gtp_irq_enable(ts);
-
-			return;
 		}
+		if (ts->use_irq)
+			gtp_irq_enable(ts);
+		return;
 	}
+#endif
 
 	ret = gtp_i2c_read(ts->client, point_data, 12);
 	if (ret < 0) {
-		dev_err(&ts->client->dev,
-				"I2C transfer error. errno:%d\n ", ret);
-		goto exit_work_func;
+		GTP_ERROR("I2C transfer error. errno:%d\n ", ret);
+		if (ts->use_irq)
+			gtp_irq_enable(ts);
+		return;
 	}
 
 	finger = point_data[GTP_ADDR_LENGTH];
+
+#if GTP_COMPATIBLE_MODE
+	/* GT9XXF */
+	if ((finger == 0x00) && (CHIP_TYPE_GT9F == ts->chip_type)) {
+		ret = gtp_i2c_read(ts->client, rqst_buf, 3);
+		if (ret < 0) {
+			GTP_ERROR("Read request status error!");
+			goto exit_work_func;
+		}
+
+		switch (rqst_buf[2]) {
+		case GTP_RQST_CONFIG:
+			GTP_INFO("Request for config.");
+			ret = gtp_send_cfg(ts->client);
+			if (ret < 0)
+				GTP_ERROR("Request for config unresponded!");
+			else {
+				rqst_buf[2] = GTP_RQST_RESPONDED;
+				gtp_i2c_write(ts->client, rqst_buf, 3);
+				GTP_INFO("Request for config responded!");
+			}
+			break;
+
+		case GTP_RQST_BAK_REF:
+			GTP_INFO("Request for backup reference.");
+			ts->rqst_processing = 1;
+			ret = gtp_bak_ref_proc(ts, GTP_BAK_REF_SEND);
+			if (SUCCESS == ret) {
+				rqst_buf[2] = GTP_RQST_RESPONDED;
+				gtp_i2c_write(ts->client, rqst_buf, 3);
+				ts->rqst_processing = 0;
+				GTP_INFO
+				    ("Request for backup reference responded!");
+			} else
+				GTP_ERROR
+				    ("Requeet for backup reference unresponed");
+			break;
+
+		case GTP_RQST_RESET:
+			GTP_INFO("Request for reset.");
+			gtp_recovery_reset(ts->client);
+			break;
+
+		case GTP_RQST_MAIN_CLOCK:
+			GTP_INFO("Request for main clock.");
+			ts->rqst_processing = 1;
+			ret = gtp_main_clk_proc(ts);
+			if (FAIL == ret)
+				GTP_ERROR
+				    ("Request for main clock unresponded!");
+			else {
+				GTP_INFO("Request for main clock responded!");
+				rqst_buf[2] = GTP_RQST_RESPONDED;
+				gtp_i2c_write(ts->client, rqst_buf, 3);
+				ts->rqst_processing = 0;
+				ts->clk_chk_fs_times = 0;
+			}
+			break;
+
+		default:
+			GTP_INFO("Undefined request: 0x%02X", rqst_buf[2]);
+			rqst_buf[2] = GTP_RQST_RESPONDED;
+			gtp_i2c_write(ts->client, rqst_buf, 3);
+			break;
+		}
+	}
+#endif
+	if (finger == 0x00) {
+		if (ts->use_irq)
+			gtp_irq_enable(ts);
+		return;
+	}
+
 	if ((finger & 0x80) == 0)
 		goto exit_work_func;
 
@@ -483,150 +745,265 @@ static void goodix_ts_work_func(struct work_struct *work)
 		goto exit_work_func;
 
 	if (touch_num > 1) {
-		u8 buf[8 * GTP_MAX_TOUCH] = { (GTP_READ_COOR_ADDR + 10) >> 8,
-				(GTP_READ_COOR_ADDR + 10) & 0xff };
-
-		ret = gtp_i2c_read(ts->client, buf,
-				2 + 8 * (touch_num - 1));
+		u8 buf[8 * GTP_MAX_TOUCH] = {
+			(GTP_READ_COOR_ADDR + 10) >> 8,
+			(GTP_READ_COOR_ADDR + 10) & 0xff};
+		ret = gtp_i2c_read(ts->client, buf, 2 + 8 * (touch_num - 1));
 		memcpy(&point_data[12], &buf[2], 8 * (touch_num - 1));
 	}
-
-
+#if (GTP_HAVE_TOUCH_KEY || GTP_PEN_HAVE_BUTTON)
 	key_value = point_data[3 + 8 * touch_num];
 
 	if (key_value || pre_key) {
-		for (i = 0; i < ts->pdata->num_button; i++) {
-			input_report_key(ts->input_dev,
-				ts->pdata->button_map[i],
-				key_value & (0x01<<i));
+#if GTP_PEN_HAVE_BUTTON
+		if (key_value == 0x40) {
+			GTP_DEBUG("BTN_STYLUS & BTN_STYLUS2 Down.");
+			input_report_key(ts->pen_dev, BTN_STYLUS, 1);
+			input_report_key(ts->pen_dev, BTN_STYLUS2, 1);
+			pen_active = 1;
+		} else if (key_value == 0x10) {
+			GTP_DEBUG("BTN_STYLUS Down, BTN_STYLUS2 Up.");
+			input_report_key(ts->pen_dev, BTN_STYLUS, 1);
+			input_report_key(ts->pen_dev, BTN_STYLUS2, 0);
+			pen_active = 1;
+		} else if (key_value == 0x20) {
+			GTP_DEBUG("BTN_STYLUS Up, BTN_STYLUS2 Down.");
+			input_report_key(ts->pen_dev, BTN_STYLUS, 0);
+			input_report_key(ts->pen_dev, BTN_STYLUS2, 1);
+			pen_active = 1;
+		} else {
+			GTP_DEBUG("BTN_STYLUS & BTN_STYLUS2 Up.");
+			input_report_key(ts->pen_dev, BTN_STYLUS, 0);
+			input_report_key(ts->pen_dev, BTN_STYLUS2, 0);
+			if ((pre_key == 0x40) || (pre_key == 0x20) ||
+			    (pre_key == 0x10))
+				pen_active = 1;
 		}
-		touch_num = 0;
-		pre_touch = 0;
-	}
-
-	pre_key = key_value;
+		if (pen_active) {
+			touch_num = 0;	/* shield pen point */
+			/*pre_touch = 0; */
+		}
+#endif
 
-	if (ts->pdata->with_pen) {
-		if (pre_pen && (touch_num == 0)) {
-			dev_dbg(&ts->client->dev, "Pen touch UP(Slot)!");
-			input_report_key(ts->input_dev, BTN_TOOL_PEN, 0);
-			input_mt_slot(ts->input_dev, 5);
-			input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, -1);
-			pre_pen = 0;
+#if GTP_HAVE_TOUCH_KEY
+		if (!pre_touch) {
+			for (i = 0; i < GTP_MAX_KEY_NUM; i++) {
+#if GTP_DEBUG_ON
+				for (ret = 0; ret < 4; ++ret) {
+					if (key_codes[ret] ==
+					    touch_key_array[i]) {
+						GTP_DEBUG("Key: %s %s",
+							  key_names[ret],
+							  (key_value &
+							  (0x01 << i)) ?
+							  "Down" : "Up");
+						break;
+					}
+				}
+#endif
+				input_report_key(ts->input_dev,
+						 touch_key_array[i],
+						 key_value & (0x01 << i));
+			}
+			touch_num = 0;	/* shield fingers */
 		}
+#endif
 	}
+#endif
+	pre_key = key_value;
+
+	GTP_DEBUG("pre_touch:%02x, finger:%02x.", pre_touch, finger);
 
+#if GTP_ICS_SLOT_REPORT
+
+#if GTP_WITH_PEN
+	if (pre_pen && (touch_num == 0)) {
+		GTP_DEBUG("Pen touch UP(Slot)!");
+		gtp_pen_up(0);
+		pen_active = 1;
+		pre_pen = 0;
+	}
+#endif
 	if (pre_touch || touch_num) {
 		s32 pos = 0;
 		u16 touch_index = 0;
-
+		u8 report_num = 0;
 		coor_data = &point_data[3];
+
 		if (touch_num) {
 			id = coor_data[pos] & 0x0F;
-			if (ts->pdata->with_pen) {
-				id = coor_data[pos];
-				if (id == 128) {
-					dev_dbg(&ts->client->dev,
-							"Pen touch DOWN(Slot)!");
-					input_x  = coor_data[pos + 1]
-						| (coor_data[pos + 2] << 8);
-					input_y  = coor_data[pos + 3]
-						| (coor_data[pos + 4] << 8);
-					input_w  = coor_data[pos + 5]
-						| (coor_data[pos + 6] << 8);
-
-					input_report_key(ts->input_dev,
-						BTN_TOOL_PEN, 1);
-					input_mt_slot(ts->input_dev, 5);
-					input_report_abs(ts->input_dev,
-						ABS_MT_TRACKING_ID, 5);
-					input_report_abs(ts->input_dev,
-						ABS_MT_POSITION_X, input_x);
-					input_report_abs(ts->input_dev,
-						ABS_MT_POSITION_Y, input_y);
-					input_report_abs(ts->input_dev,
-						ABS_MT_TOUCH_MAJOR, input_w);
-					dev_dbg(&ts->client->dev,
-						"Pen/Stylus: (%d, %d)[%d]",
-						input_x, input_y, input_w);
-					pre_pen = 1;
-					pre_touch = 0;
-				}
+
+#if GTP_WITH_PEN
+			id = coor_data[pos];
+			if ((id & 0x80)) {
+				GTP_DEBUG("Pen touch DOWN(Slot)!");
+				input_x =
+				    coor_data[pos +
+					      1] | (coor_data[pos + 2] << 8);
+				input_y =
+				    coor_data[pos +
+					      3] | (coor_data[pos + 4] << 8);
+				input_w =
+				    coor_data[pos +
+					      5] | (coor_data[pos + 6] << 8);
+
+				gtp_pen_down(input_x, input_y, input_w, 0);
+				pre_pen = 1;
+				pre_touch = 0;
+				pen_active = 1;
 			}
+#endif
 
-			touch_index |= (0x01<<id);
+			touch_index |= (0x01 << id);
 		}
 
+		GTP_DEBUG("id = %d,touch_index = 0x%x, pre_touch = 0x%x\n", id,
+			  touch_index, pre_touch);
 		for (i = 0; i < GTP_MAX_TOUCH; i++) {
-			if (ts->pdata->with_pen)
-				if (pre_pen == 1)
-					break;
-
-			if (touch_index & (0x01<<i)) {
-				input_x = coor_data[pos + 1] |
-						coor_data[pos + 2] << 8;
-				input_y = coor_data[pos + 3] |
-						coor_data[pos + 4] << 8;
-				input_w = coor_data[pos + 5] |
-						coor_data[pos + 6] << 8;
+#if GTP_WITH_PEN
+			if (pre_pen == 1)
+				break;
+#endif
 
-				gtp_touch_down(ts, id,
-						input_x, input_y, input_w);
+			if ((touch_index & (0x01 << i))) {
+				input_x =
+				    coor_data[pos + 1] |
+					 (coor_data[pos + 2] << 8);
+				input_y =
+				    coor_data[pos + 3] |
+					(coor_data[pos + 4] << 8);
+				input_w =
+				    coor_data[pos + 5] |
+					(coor_data[pos + 6] << 8);
+
+				gtp_touch_down(ts, id, input_x,
+						input_y, input_w);
 				pre_touch |= 0x01 << i;
 
-				pos += 8;
-				id = coor_data[pos] & 0x0F;
-				touch_index |= (0x01<<id);
+				report_num++;
+				if (report_num < touch_num) {
+					pos += 8;
+					id = coor_data[pos] & 0x0F;
+					touch_index |= (0x01 << id);
+				}
 			} else {
 				gtp_touch_up(ts, i);
 				pre_touch &= ~(0x01 << i);
 			}
 		}
 	}
-	input_sync(ts->input_dev);
+#else
+
+	if (touch_num) {
+		for (i = 0; i < touch_num; i++) {
+			coor_data = &point_data[i * 8 + 3];
+
+			id = coor_data[0] & 0x0F;
+			input_x = coor_data[1] | (coor_data[2] << 8);
+			input_y = coor_data[3] | (coor_data[4] << 8);
+			input_w = coor_data[5] | (coor_data[6] << 8);
+
+#if GTP_WITH_PEN
+			id = coor_data[0];
+			if (id & 0x80) {
+				GTP_DEBUG("Pen touch DOWN!");
+				gtp_pen_down(input_x, input_y, input_w, 0);
+				pre_pen = 1;
+				pen_active = 1;
+				break;
+			} else
+#endif
+				gtp_touch_down(ts, id, input_x,
+						input_y, input_w);
+		}
+	} else if (pre_touch) {
+#if GTP_WITH_PEN
+		if (pre_pen == 1) {
+			GTP_DEBUG("Pen touch UP!");
+			gtp_pen_up(0);
+			pre_pen = 0;
+			pen_active = 1;
+		} else
+#endif
+		{
+			GTP_DEBUG("Touch Release!");
+			gtp_touch_up(ts, 0);
+		}
+	}
+
+	pre_touch = touch_num;
+#endif
+
+#if GTP_WITH_PEN
+	if (pen_active) {
+		pen_active = 0;
+		input_sync(ts->pen_dev);
+	} else
+#endif
+		input_sync(ts->input_dev);
 
 exit_work_func:
 	if (!ts->gtp_rawdiff_mode) {
 		ret = gtp_i2c_write(ts->client, end_cmd, 3);
 		if (ret < 0)
-			dev_warn(&ts->client->dev, "I2C write end_cmd error!\n");
-
+			GTP_INFO("I2C write end_cmd error!");
 	}
 	if (ts->use_irq)
 		gtp_irq_enable(ts);
+}
 
-	return;
+/*******************************************************
+Function:
+    Timer interrupt service routine for polling mode.
+Input:
+    timer: timer struct pointer
+Output:
+    Timer work mode.
+    HRTIMER_NORESTART: no restart mode
+*********************************************************/
+static enum hrtimer_restart goodix_ts_timer_handler(struct hrtimer *timer)
+{
+	struct goodix_ts_data *ts =
+	    container_of(timer, struct goodix_ts_data, timer);
+
+	GTP_DEBUG_FUNC();
+
+	queue_work(goodix_wq, &ts->work);
+	hrtimer_start(&ts->timer, ktime_set(0, (GTP_POLL_TIME + 6) * 1000000),
+		      HRTIMER_MODE_REL);
+	return HRTIMER_NORESTART;
 }
 
 /*******************************************************
 Function:
-	External interrupt service routine for interrupt mode.
+    External interrupt service routine for interrupt mode.
 Input:
-	irq:  interrupt number.
-	dev_id: private data pointer
+    irq:  interrupt number.
+    dev_id: private data pointer
 Output:
-	Handle Result.
-	IRQ_HANDLED: interrupt handled successfully
+    Handle Result.
+    IRQ_HANDLED: interrupt handled successfully
 *********************************************************/
 static irqreturn_t goodix_ts_irq_handler(int irq, void *dev_id)
 {
 	struct goodix_ts_data *ts = dev_id;
 
+	GTP_DEBUG_FUNC();
 	gtp_irq_disable(ts);
-
-	queue_work(ts->goodix_wq, &ts->work);
+	queue_work(goodix_wq, &ts->work);
 
 	return IRQ_HANDLED;
 }
+
 /*******************************************************
 Function:
-	Synchronization.
+    Synchronization.
 Input:
-	ms: synchronization time in millisecond.
+    ms: synchronization time in millisecond.
 Output:
-	None.
+    None.
 *******************************************************/
-void gtp_int_sync(struct goodix_ts_data *ts, int ms)
+static void gtp_int_sync(struct goodix_ts_data *ts, s32 ms)
 {
 	gpio_direction_output(ts->pdata->irq_gpio, 0);
 	msleep(ms);
@@ -635,66 +1012,71 @@ void gtp_int_sync(struct goodix_ts_data *ts, int ms)
 
 /*******************************************************
 Function:
-	Reset chip.
+    Reset chip.
 Input:
-	ms: reset time in millisecond, must >10ms
+    ms: reset time in millisecond
 Output:
-	None.
+    None.
 *******************************************************/
-void gtp_reset_guitar(struct goodix_ts_data *ts, int ms)
+void gtp_reset_guitar(struct i2c_client *client, s32 ms)
 {
-	/* This reset sequence will selcet I2C slave address */
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+	GTP_DEBUG_FUNC();
+	GTP_INFO("Guitar reset");
+	/* begin select I2C slave addr */
 	gpio_direction_output(ts->pdata->reset_gpio, 0);
+	/* T2: > 10ms */
 	msleep(ms);
+	/* HIGH: 0x28/0x29, LOW: 0xBA/0xBB */
+	gpio_direction_output(ts->pdata->irq_gpio, client->addr == 0x14);
 
-	if (ts->client->addr == GTP_I2C_ADDRESS_HIGH)
-		gpio_direction_output(ts->pdata->irq_gpio, 1);
-	else
-		gpio_direction_output(ts->pdata->irq_gpio, 0);
-
-	usleep(RESET_DELAY_T3_US);
+	/* T3: > 100us */
+	msleep(20);
 	gpio_direction_output(ts->pdata->reset_gpio, 1);
-	msleep(RESET_DELAY_T4);
 
+	/* T4: > 5ms */
+	msleep(20);
 	gpio_direction_input(ts->pdata->reset_gpio);
+	/* end select I2C slave addr */
 
-	gtp_int_sync(ts, 50);
+#if GTP_COMPATIBLE_MODE
+	if (CHIP_TYPE_GT9F == ts->chip_type)
+		return;
+#endif
 
+	gtp_int_sync(ts, 50);
 #if GTP_ESD_PROTECT
-	gtp_init_ext_watchdog(ts->client);
+	gtp_init_ext_watchdog(client);
 #endif
 }
 
-#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_FB)
+#if GTP_GESTURE_WAKEUP
 /*******************************************************
 Function:
-	Enter doze mode for sliding wakeup.
+    Enter doze mode for sliding wakeup.
 Input:
-	ts: goodix tp private data
+    ts: goodix tp private data
 Output:
-	1: succeed, otherwise failed
+    1: succeed, otherwise failed
 *******************************************************/
 static s8 gtp_enter_doze(struct goodix_ts_data *ts)
 {
-	int ret = -1;
+	s8 ret = -1;
 	s8 retry = 0;
 	u8 i2c_control_buf[3] = {
-		(u8)(GTP_REG_SLEEP >> 8),
-		(u8)GTP_REG_SLEEP, 8};
+		(u8)(GTP_REG_SLEEP >> 8), (u8)GTP_REG_SLEEP, 8};
 
-	if (ts->pdata->dbl_clk_wakeup)
-		i2c_control_buf[2] = 0x09;
-
-	gtp_irq_disable(ts);
+	GTP_DEBUG_FUNC();
 
-	while (retry++ < GTP_I2C_RETRY_3) {
+	GTP_DEBUG("Entering gesture mode.");
+	while (retry++ < 5) {
 		i2c_control_buf[0] = 0x80;
 		i2c_control_buf[1] = 0x46;
 		ret = gtp_i2c_write(ts->client, i2c_control_buf, 3);
 		if (ret < 0) {
-			dev_err(&ts->client->dev,
-				"failed to set doze flag into 0x8046, %d",
-				retry);
+			GTP_DEBUG("failed to set doze flag into 0x8046, %d",
+				  retry);
 			continue;
 		}
 		i2c_control_buf[0] = 0x80;
@@ -702,584 +1084,1152 @@ static s8 gtp_enter_doze(struct goodix_ts_data *ts)
 		ret = gtp_i2c_write(ts->client, i2c_control_buf, 3);
 		if (ret > 0) {
 			doze_status = DOZE_ENABLED;
-			dev_dbg(&ts->client->dev,
-				"GTP has been working in doze mode!");
-			gtp_irq_enable(ts);
+			GTP_INFO("Gesture mode enabled.");
 			return ret;
 		}
 		msleep(20);
 	}
-	dev_err(&ts->client->dev, "GTP send doze cmd failed.\n");
-	gtp_irq_enable(ts);
+	GTP_ERROR("GTP send gesture cmd failed.");
 	return ret;
 }
-/**
- * gtp_enter_sleep - Enter sleep mode
- * @ts: driver private data
- *
- * Returns zero on success, else an error.
- */
-static u8 gtp_enter_sleep(struct goodix_ts_data *ts)
-{
-	int ret = -1;
-	s8 retry = 0;
-	u8 i2c_control_buf[3] = {
-		(u8)(GTP_REG_SLEEP >> 8),
-		(u8)GTP_REG_SLEEP, 5};
+#else
+/*******************************************************
+Function:
+    Enter sleep mode.
+Input:
+    ts: private data.
+Output:
+    Executive outcomes.
+       1: succeed, otherwise failed.
+*******************************************************/
+static s8 gtp_enter_sleep(struct goodix_ts_data *ts)
+{
+	s8 ret = -1;
+	s8 retry = 0;
+	u8 i2c_control_buf[3] = {
+		(u8)(GTP_REG_SLEEP >> 8), (u8)GTP_REG_SLEEP, 5};
 
-	ret = gpio_direction_output(ts->pdata->irq_gpio, 0);
-	if (ret)
-		dev_err(&ts->client->dev,
-			"GTP sleep: Cannot reconfig gpio %d.\n",
-			ts->pdata->irq_gpio);
-	if (ts->pdata->enable_power_off) {
-		ret = gpio_direction_output(ts->pdata->reset_gpio, 0);
-		if (ret)
-			dev_err(&ts->client->dev,
-				"GTP sleep: Cannot reconfig gpio %d.\n",
-				ts->pdata->reset_gpio);
-		ret = goodix_power_off(ts);
-		if (ret) {
-			dev_err(&ts->client->dev, "GTP power off failed.\n");
-			return ret;
+#if GTP_COMPATIBLE_MODE
+	u8 status_buf[3] = {0x80, 0x44};
+#endif
+
+	GTP_DEBUG_FUNC();
+
+#if GTP_COMPATIBLE_MODE
+	if (CHIP_TYPE_GT9F == ts->chip_type) {
+		/* GT9XXF: host interact with ic */
+		ret = gtp_i2c_read(ts->client, status_buf, 3);
+		if (ret < 0)
+			GTP_ERROR("failed to get backup-reference status");
+
+		if (status_buf[2] & 0x80) {
+			ret = gtp_bak_ref_proc(ts, GTP_BAK_REF_STORE);
+			if (FAIL == ret)
+				GTP_ERROR("failed to store bak_ref");
 		}
-		return 0;
-	} else {
-		usleep(5000);
-		while (retry++ < GTP_I2C_RETRY_5) {
-			ret = gtp_i2c_write(ts->client, i2c_control_buf, 3);
-			if (ret == 1) {
-				dev_dbg(&ts->client->dev, "GTP enter sleep!");
-				return 0;
-			}
-			msleep(20);
+	}
+#endif
+
+	gpio_direction_output(ts->pdata->irq_gpio, 0);
+	msleep(20);
+
+	while (retry++ < 5) {
+		ret = gtp_i2c_write(ts->client, i2c_control_buf, 3);
+		if (ret > 0) {
+			GTP_INFO("GTP enter sleep!");
+			return ret;
 		}
-		dev_err(&ts->client->dev, "GTP send sleep cmd failed.\n");
-		return ret;
+		msleep(20);
 	}
+	GTP_ERROR("GTP send sleep cmd failed.");
+	return ret;
 }
+#endif
 
 /*******************************************************
 Function:
-	Wakeup from sleep.
+    Wakeup from sleep.
 Input:
-	ts: private data.
+    ts: private data.
 Output:
-	Executive outcomes.
-	>0: succeed, otherwise: failed.
+    Executive outcomes.
+    0: succeed, otherwise: failed.
 *******************************************************/
 static s8 gtp_wakeup_sleep(struct goodix_ts_data *ts)
 {
 	u8 retry = 0;
 	s8 ret = -1;
 
-	if (ts->pdata->enable_power_off) {
-		ret = gpio_direction_output(ts->pdata->irq_gpio, 0);
-		if (ret)
-			dev_err(&ts->client->dev,
-				"GTP wakeup: Cannot reconfig gpio %d.\n",
-				ts->pdata->irq_gpio);
-		ret = gpio_direction_output(ts->pdata->reset_gpio, 0);
-		if (ret)
-			dev_err(&ts->client->dev,
-				"GTP wakeup: Cannot reconfig gpio %d.\n",
-				ts->pdata->reset_gpio);
-		ret = goodix_power_on(ts);
-		if (ret) {
-			dev_err(&ts->client->dev, "GTP power on failed.\n");
-			return 0;
-		}
+	GTP_DEBUG_FUNC();
 
-		gtp_reset_guitar(ts, 20);
+#if GTP_COMPATIBLE_MODE
+	if (CHIP_TYPE_GT9F == ts->chip_type) {
+		u8 opr_buf[3] = {0x41, 0x80};
 
-		ret = gtp_send_cfg(ts);
-		if (ret <= 0) {
-			dev_err(&ts->client->dev,
-				"GTP wakeup sleep failed.\n");
-			return ret;
-		}
+		gpio_direction_output(ts->pdata->irq_gpio, 1);
+		msleep(20);
 
-		dev_dbg(&ts->client->dev,
-				"Wakeup sleep send config success.");
-	} else {
-err_retry:
-		if (ts->pdata->slide_wakeup) { /* wakeup not by slide */
-			if (DOZE_WAKEUP != doze_status)
-				gtp_reset_guitar(ts, 10);
-			else
-				/* wakeup by slide */
-				doze_status = DOZE_DISABLED;
-		} else {
-			if (chip_gt9xxs == 1) {
-				gtp_reset_guitar(ts, 10);
-			} else {
-				ret = gpio_direction_output(
-						ts->pdata->irq_gpio, 1);
-				usleep(5000);
+		for (retry = 0; retry < 10; ++retry) {
+			/* hold ss51 & dsp */
+			opr_buf[2] = 0x0C;
+			ret = gtp_i2c_write(ts->client, opr_buf, 3);
+			if (FAIL == ret) {
+				GTP_ERROR("failed to hold ss51 & dsp!");
+				continue;
 			}
+			opr_buf[2] = 0x00;
+			ret = gtp_i2c_read(ts->client, opr_buf, 3);
+			if (FAIL == ret) {
+				GTP_ERROR("failed to get ss51 & dsp status!");
+				continue;
+			}
+			if (0x0C != opr_buf[2]) {
+				GTP_DEBUG("ss51 & dsp not been hold, %d",
+					  retry + 1);
+				continue;
+			}
+			GTP_DEBUG("ss51 & dsp confirmed hold");
+
+			ret = gtp_fw_startup(ts->client);
+			if (FAIL == ret) {
+				GTP_ERROR
+				    ("startup GT9XXF failed, process recovery");
+				gtp_esd_recovery(ts->client);
+			}
+			break;
 		}
+		if (retry >= 10) {
+			GTP_ERROR("failed to wakeup, processing esd recovery");
+			gtp_esd_recovery(ts->client);
+		} else
+			GTP_INFO("GT9XXF gtp wakeup success");
+		return ret;
+	}
+#endif
+
+#if GTP_POWER_CTRL_SLEEP
+	while (retry++ < 5) {
+		gtp_reset_guitar(ts->client, ts->pdata->soft_rst_dly);
+		GTP_INFO("GTP wakeup sleep.");
+		return 1;
+	}
+#else
+	while (retry++ < 10) {
+#if GTP_GESTURE_WAKEUP
+		if (DOZE_WAKEUP != doze_status)
+			GTP_INFO("Powerkey wakeup.");
+		else
+			GTP_INFO("Gesture wakeup.");
+		doze_status = DOZE_DISABLED;
+		gtp_irq_disable(ts);
+		gtp_reset_guitar(ts->client, 10);
+		gtp_irq_enable(ts);
+
+#else
+		gpio_direction_output(ts->pdata->irq_gpio, 1);
+		msleep(20);
+#endif
+
 		ret = gtp_i2c_test(ts->client);
-		if (ret == 2) {
-			dev_dbg(&ts->client->dev, "GTP wakeup sleep.");
-			if (!ts->pdata->slide_wakeup) {
-				if (chip_gt9xxs == 0) {
-					gtp_int_sync(ts, 25);
-					msleep(20);
+		if (ret > 0) {
+			GTP_INFO("GTP wakeup sleep.");
+
+#if (!GTP_GESTURE_WAKEUP)
+			gtp_int_sync(ts, 25);
 #if GTP_ESD_PROTECT
-					gtp_init_ext_watchdog(ts->client);
+			gtp_init_ext_watchdog(ts->client);
+#endif
 #endif
-				}
-			}
 			return ret;
 		}
-		gtp_reset_guitar(ts, 20);
-		if (retry++ < GTP_I2C_RETRY_10)
-			goto err_retry;
-		dev_err(&ts->client->dev, "GTP wakeup sleep failed.\n");
+		gtp_reset_guitar(ts->client, ts->pdata->soft_rst_dly);
 	}
+#endif
+
+	GTP_ERROR("GTP wakeup sleep failed.");
 	return ret;
 }
-#endif /* !CONFIG_HAS_EARLYSUSPEND && !CONFIG_FB*/
+
+#if GTP_DRIVER_SEND_CFG
+static s32 gtp_get_info(struct goodix_ts_data *ts)
+{
+	u8 opr_buf[6] = {0};
+	s32 ret = 0;
+
+	ts->abs_x_max = GTP_MAX_WIDTH;
+	ts->abs_y_max = GTP_MAX_HEIGHT;
+	ts->int_trigger_type = GTP_INT_TRIGGER;
+
+	opr_buf[0] = (u8)((GTP_REG_CONFIG_DATA + 1) >> 8);
+	opr_buf[1] = (u8)((GTP_REG_CONFIG_DATA + 1) & 0xFF);
+
+	ret = gtp_i2c_read(ts->client, opr_buf, 6);
+	if (ret < 0)
+		return FAIL;
+
+	ts->abs_x_max = (opr_buf[3] << 8) + opr_buf[2];
+	ts->abs_y_max = (opr_buf[5] << 8) + opr_buf[4];
+
+	opr_buf[0] = (u8)((GTP_REG_CONFIG_DATA + 6) >> 8);
+	opr_buf[1] = (u8)((GTP_REG_CONFIG_DATA + 6) & 0xFF);
+
+	ret = gtp_i2c_read(ts->client, opr_buf, 3);
+	if (ret < 0)
+		return FAIL;
+
+	ts->int_trigger_type = opr_buf[2] & 0x03;
+	GTP_INFO("X_MAX = %d, Y_MAX = %d, TRIGGER = 0x%02x",
+		 ts->abs_x_max, ts->abs_y_max, ts->int_trigger_type);
+
+	return SUCCESS;
+}
+#endif
 
 /*******************************************************
 Function:
-	Initialize gtp.
+    Initialize gtp.
 Input:
-	ts: goodix private data
+    ts: goodix private data
 Output:
-	Executive outcomes.
-	> =0: succeed, otherwise: failed
+    Executive outcomes.
+    0: succeed, otherwise: failed
 *******************************************************/
-static int gtp_init_panel(struct goodix_ts_data *ts)
+static s32 gtp_init_panel(struct goodix_ts_data *ts)
 {
-	struct i2c_client *client = ts->client;
-	unsigned char *config_data = NULL;
-	int ret = -EIO;
-	int i;
+	s32 ret = -1;
+
+#if GTP_DRIVER_SEND_CFG
+	s32 i = 0;
 	u8 check_sum = 0;
-	u8 opr_buf[16];
+	u8 opr_buf[16] = {0};
 	u8 sensor_id = 0;
 
-	if (ts->pdata->driver_send_cfg) {
-		for (i = 0; i < GOODIX_MAX_CFG_GROUP; i++)
-			dev_dbg(&client->dev, "Config Groups(%d) Lengths: %d",
-				i, ts->pdata->config_data_len[i]);
+	u8 cfg_info_group1[] = CTP_CFG_GROUP1;
+	u8 cfg_info_group2[] = CTP_CFG_GROUP2;
+	u8 cfg_info_group3[] = CTP_CFG_GROUP3;
+	u8 cfg_info_group4[] = CTP_CFG_GROUP4;
+	u8 cfg_info_group5[] = CTP_CFG_GROUP5;
+	u8 cfg_info_group6[] = CTP_CFG_GROUP6;
+	u8 *send_cfg_buf[] = {
+		cfg_info_group1, cfg_info_group2, cfg_info_group3,
+		cfg_info_group4, cfg_info_group5, cfg_info_group6
+	};
+	u8 cfg_info_len[] = {CFG_GROUP_LEN(cfg_info_group1),
+		CFG_GROUP_LEN(cfg_info_group2),
+		CFG_GROUP_LEN(cfg_info_group3),
+		CFG_GROUP_LEN(cfg_info_group4),
+		CFG_GROUP_LEN(cfg_info_group5),
+		CFG_GROUP_LEN(cfg_info_group6)
+	};
+
+	GTP_DEBUG_FUNC();
+	GTP_DEBUG("Config Groups\' Lengths: %d, %d, %d, %d, %d, %d",
+		  cfg_info_len[0], cfg_info_len[1], cfg_info_len[2],
+		  cfg_info_len[3], cfg_info_len[4], cfg_info_len[5]);
 
+#if GTP_COMPATIBLE_MODE
+	if (CHIP_TYPE_GT9F == ts->chip_type)
+		ts->fw_error = 0;
+	else
+#endif
+	{
 		ret = gtp_i2c_read_dbl_check(ts->client, 0x41E4, opr_buf, 1);
 		if (SUCCESS == ret) {
 			if (opr_buf[0] != 0xBE) {
 				ts->fw_error = 1;
-				dev_err(&client->dev,
-					"Firmware error, no config sent!");
+				GTP_ERROR("Firmware error, no config sent!");
 				return -EINVAL;
 			}
 		}
+	}
 
-		for (i = 1; i < GOODIX_MAX_CFG_GROUP; i++) {
-			if (ts->pdata->config_data_len[i])
-				break;
-		}
-
-		if (i == GOODIX_MAX_CFG_GROUP) {
-			sensor_id = 0;
-		} else {
-			ret = gtp_i2c_read_dbl_check(ts->client,
+	if ((!cfg_info_len[1]) && (!cfg_info_len[2]) &&
+	    (!cfg_info_len[3]) && (!cfg_info_len[4]) && (!cfg_info_len[5]))
+		sensor_id = 0;
+	else {
+#if GTP_COMPATIBLE_MODE
+		msleep(50);
+#endif
+		ret = gtp_i2c_read_dbl_check(ts->client,
 					GTP_REG_SENSOR_ID, &sensor_id, 1);
-			if (SUCCESS == ret) {
-				if (sensor_id >= GOODIX_MAX_CFG_GROUP) {
-					dev_err(&client->dev,
-						"Invalid sensor_id(0x%02X), No Config Sent!",
-						sensor_id);
-					return -EINVAL;
-				}
-			} else {
-				dev_err(&client->dev,
-					"Failed to get sensor_id, No config sent!");
+		if (SUCCESS == ret) {
+			if (sensor_id >= 0x06) {
+				GTP_ERROR
+				    ("Invalid id(0x%02X), No Config Sent!",
+				     sensor_id);
+				ts->pnl_init_error = 1;
 				return -EINVAL;
 			}
-		}
-
-		dev_info(&client->dev, "Sensor ID selected: %d", sensor_id);
-
-		if (ts->pdata->config_data_len[sensor_id] <
-			GTP_CONFIG_MIN_LENGTH ||
-			!ts->pdata->config_data[sensor_id]) {
-			dev_err(&client->dev,
-					"Sensor_ID(%d) matches with NULL or invalid config group!\n",
-					sensor_id);
+		} else {
+			GTP_ERROR("Failed to get sensor_id, No config sent!");
+			ts->pnl_init_error = 1;
 			return -EINVAL;
 		}
+		GTP_INFO("Sensor_ID: %d", sensor_id);
+	}
+	ts->gtp_cfg_len = cfg_info_len[sensor_id];
+	GTP_INFO("CTP_CONFIG_GROUP%d used, config length: %d", sensor_id + 1,
+		 ts->gtp_cfg_len);
 
+	if (ts->gtp_cfg_len < GTP_CONFIG_MIN_LENGTH) {
+		GTP_ERROR
+		    ("Config Group%d is INVALID CONFIG GROUP(Len: %d)!",
+		     sensor_id + 1, ts->gtp_cfg_len);
+		ts->pnl_init_error = 1;
+		return -EINVAL;
+	}
+#if GTP_COMPATIBLE_MODE
+	if (CHIP_TYPE_GT9F == ts->chip_type)
+		ts->fixed_cfg = 0;
+	else
+#endif
+	{
 		ret = gtp_i2c_read_dbl_check(ts->client, GTP_REG_CONFIG_DATA,
-			&opr_buf[0], 1);
+						&opr_buf[0], 1);
 		if (ret == SUCCESS) {
+			GTP_DEBUG
+			    ("CFG_GROUP%d Config Version: %d, 0x%02X",
+			     sensor_id + 1, send_cfg_buf[sensor_id][0],
+			     send_cfg_buf[sensor_id][0]);
+			GTP_DEBUG
+			    ("IC Config Version: %d, 0x%02X",
+			     opr_buf[0], opr_buf[0]);
+
 			if (opr_buf[0] < 90) {
 				/* backup group config version */
-				grp_cfg_version =
-				ts->pdata->
-					config_data[sensor_id][GTP_ADDR_LENGTH];
-				ts->pdata->
-					config_data[sensor_id][GTP_ADDR_LENGTH]
-						= 0x00;
+				grp_cfg_version = send_cfg_buf[sensor_id][0];
+				send_cfg_buf[sensor_id][0] = 0x00;
 				ts->fixed_cfg = 0;
 			} else {
 				/* treated as fixed config, not send config */
-				dev_warn(&client->dev,
-					"Ic fixed config with config version(%d, 0x%02X)",
-					opr_buf[0], opr_buf[0]);
+				GTP_INFO
+				    ("Ic with config version (%d, 0x%02X)",
+				     opr_buf[0], opr_buf[0]);
 				ts->fixed_cfg = 1;
+				gtp_get_info(ts);
+				return 0;
 			}
 		} else {
-			dev_err(&client->dev,
-				"Failed to get ic config version!No config sent!");
+			GTP_ERROR
+			    ("Failed to get ic config version!No config sent!");
 			return -EINVAL;
 		}
+	}
 
-		config_data = ts->pdata->config_data[sensor_id];
-		ts->config_data = ts->pdata->config_data[sensor_id];
-		ts->gtp_cfg_len = ts->pdata->config_data_len[sensor_id];
+	memset(&config[GTP_ADDR_LENGTH], 0, GTP_CONFIG_MAX_LENGTH);
+	memcpy(&config[GTP_ADDR_LENGTH], send_cfg_buf[sensor_id],
+	       ts->gtp_cfg_len);
 
 #if GTP_CUSTOM_CFG
-		config_data[RESOLUTION_LOC] =
-		(unsigned char)(GTP_MAX_WIDTH && 0xFF);
-		config_data[RESOLUTION_LOC + 1] =
-		(unsigned char)(GTP_MAX_WIDTH >> 8);
-		config_data[RESOLUTION_LOC + 2] =
-		(unsigned char)(GTP_MAX_HEIGHT && 0xFF);
-		config_data[RESOLUTION_LOC + 3] =
-		(unsigned char)(GTP_MAX_HEIGHT >> 8);
-
-		if (GTP_INT_TRIGGER == 0)
-			config_data[TRIGGER_LOC] &= 0xfe;
-		else if (GTP_INT_TRIGGER == 1)
-			config_data[TRIGGER_LOC] |= 0x01;
-#endif  /* !GTP_CUSTOM_CFG */
+	config[RESOLUTION_LOC] = (u8)GTP_MAX_WIDTH;
+	config[RESOLUTION_LOC + 1] = (u8)(GTP_MAX_WIDTH >> 8);
+	config[RESOLUTION_LOC + 2] = (u8)GTP_MAX_HEIGHT;
+	config[RESOLUTION_LOC + 3] = (u8)(GTP_MAX_HEIGHT >> 8);
+
+	if (GTP_INT_TRIGGER == 0)	/* RISING */
+		config[TRIGGER_LOC] &= 0xfe;
+	else if (GTP_INT_TRIGGER == 1)	/* FALLING */
+		config[TRIGGER_LOC] |= 0x01;
+#endif /* GTP_CUSTOM_CFG */
+
+	check_sum = 0;
+	for (i = GTP_ADDR_LENGTH; i < ts->gtp_cfg_len; i++)
+		check_sum += config[i];
+	config[ts->gtp_cfg_len] = (~check_sum) + 1;
+
+#else /* driver not send config */
+
+	ts->gtp_cfg_len = GTP_CONFIG_MAX_LENGTH;
+	ret = gtp_i2c_read(ts->client, config,
+			ts->gtp_cfg_len + GTP_ADDR_LENGTH);
+	if (ret < 0) {
+		GTP_ERROR
+		    ("Read Config Fail, Use Default Resolution & INT Trigger!");
+		ts->abs_x_max = GTP_MAX_WIDTH;
+		ts->abs_y_max = GTP_MAX_HEIGHT;
+		ts->int_trigger_type = GTP_INT_TRIGGER;
+	}
+#endif /* GTP_DRIVER_SEND_CFG */
+
+	if ((ts->abs_x_max == 0) && (ts->abs_y_max == 0)) {
+		ts->abs_x_max =
+		    (config[RESOLUTION_LOC + 1] << 8) + config[RESOLUTION_LOC];
+		ts->abs_y_max = (config[RESOLUTION_LOC + 3] << 8)
+				+ config[RESOLUTION_LOC + 2];
+		ts->int_trigger_type = (config[TRIGGER_LOC]) & 0x03;
+	}
+#if GTP_COMPATIBLE_MODE
+	if (CHIP_TYPE_GT9F == ts->chip_type) {
+		u8 sensor_num = 0;
+		u8 driver_num = 0;
+		u8 have_key = 0;
+
+		have_key =
+		    (config[GTP_REG_HAVE_KEY - GTP_REG_CONFIG_DATA + 2] & 0x01);
+
+		if (1 == ts->is_950) {
+			driver_num = config[GTP_REG_MATRIX_DRVNUM
+					- GTP_REG_CONFIG_DATA + 2];
+			sensor_num = config[GTP_REG_MATRIX_SENNUM
+					- GTP_REG_CONFIG_DATA + 2];
+			if (have_key)
+				driver_num--;
+			ts->bak_ref_len =
+			    (driver_num * (sensor_num - 1) + 2) * 2 * 6;
+		} else {
+			driver_num = (config[CFG_LOC_DRVA_NUM] & 0x1F)
+					+ (config[CFG_LOC_DRVB_NUM] & 0x1F);
+			if (have_key)
+				driver_num--;
+			sensor_num = (config[CFG_LOC_SENS_NUM] & 0x0F)
+				+ ((config[CFG_LOC_SENS_NUM] >> 4) & 0x0F);
+			ts->bak_ref_len =
+			    (driver_num * (sensor_num - 2) + 2) * 2;
+		}
 
+		GTP_INFO
+		    ("%d * %d(key: %d), X_MAX: %d, Y_MAX: %d, TRIGGER: 0x%02x",
+		     driver_num, sensor_num, have_key, ts->abs_x_max,
+		     ts->abs_y_max, ts->int_trigger_type);
+		return 0;
+	} else
+#endif
+	{
+#if GTP_DRIVER_SEND_CFG
+		ret = gtp_send_cfg(ts->client);
+		if (ret < 0)
+			GTP_ERROR("Send config error.");
+		/* set config version to CTP_CFG_GROUP
+		  * for resume to send config
+		  */
+		config[GTP_ADDR_LENGTH] = grp_cfg_version;
 		check_sum = 0;
 		for (i = GTP_ADDR_LENGTH; i < ts->gtp_cfg_len; i++)
-			check_sum += config_data[i];
+			check_sum += config[i];
+		config[ts->gtp_cfg_len] = (~check_sum) + 1;
+#endif
+		GTP_INFO("X_MAX: %d, Y_MAX: %d, TRIGGER: 0x%02x", ts->abs_x_max,
+			 ts->abs_y_max, ts->int_trigger_type);
+	}
 
-		config_data[ts->gtp_cfg_len] = (~check_sum) + 1;
+	msleep(20);
+	return 0;
+}
 
-	} else { /* DRIVER NOT SEND CONFIG */
-		ts->gtp_cfg_len = GTP_CONFIG_MAX_LENGTH;
-		ret = gtp_i2c_read(ts->client, config_data,
-			ts->gtp_cfg_len + GTP_ADDR_LENGTH);
-		if (ret < 0) {
-			dev_err(&client->dev,
-				"Read Config Failed, Using DEFAULT Resolution & INT Trigger!\n");
-			ts->abs_x_max = GTP_MAX_WIDTH;
-			ts->abs_y_max = GTP_MAX_HEIGHT;
-			ts->int_trigger_type = GTP_INT_TRIGGER;
-		}
-	} /* !DRIVER NOT SEND CONFIG */
+static ssize_t gt91xx_config_read_proc(struct file *file, char __user *page,
+				       size_t size, loff_t *ppos)
+{
+	char *ptr = page;
+	char temp_data[GTP_CONFIG_MAX_LENGTH + 2] = {0x80, 0x47};
+	int i;
 
-	if ((ts->abs_x_max == 0) && (ts->abs_y_max == 0)) {
-		ts->abs_x_max = (config_data[RESOLUTION_LOC + 1] << 8)
-				+ config_data[RESOLUTION_LOC];
-		ts->abs_y_max = (config_data[RESOLUTION_LOC + 3] << 8)
-				+ config_data[RESOLUTION_LOC + 2];
-		ts->int_trigger_type = (config_data[TRIGGER_LOC]) & 0x03;
+	if (*ppos)
+		return 0;
+
+	ptr += snprintf(ptr, 36, "==== GT9XX config init value====\n");
+	for (i = 0; i < GTP_CONFIG_MAX_LENGTH; i++) {
+		ptr += snprintf(ptr, 4, "0x%02X ", config[i + 2]);
+		if (i % 8 == 7)
+			ptr += snprintf(ptr, 4, "\n");
+	}
+
+	ptr += snprintf(ptr, 4, "\n");
+	ptr += snprintf(ptr, 36, "==== GT9XX config real value====\n");
+	gtp_i2c_read(i2c_connect_client, temp_data, GTP_CONFIG_MAX_LENGTH + 2);
+	for (i = 0; i < GTP_CONFIG_MAX_LENGTH; i++) {
+		ptr += snprintf(ptr, 4, "0x%02X ", temp_data[i + 2]);
+		if (i % 8 == 7)
+			ptr += snprintf(ptr, 4, "\n");
+	}
+	*ppos += ptr - page;
+	return (ssize_t)(ptr - page);
+}
+
+static ssize_t gt91xx_config_write_proc(struct file *filp,
+					const char __user *buffer,
+					size_t count, loff_t *off)
+{
+	s32 ret = 0;
+
+	GTP_DEBUG("write count %d\n", count);
+
+	if (count > GTP_CONFIG_MAX_LENGTH) {
+		GTP_ERROR("size not match [%d:%d]\n", GTP_CONFIG_MAX_LENGTH,
+			  count);
+		return -EFAULT;
+	}
+
+	if (copy_from_user(&config[2], buffer, count)) {
+		GTP_ERROR("copy from user fail\n");
+		return -EFAULT;
 	}
-	ret = gtp_send_cfg(ts);
+
+	ret = gtp_send_cfg(i2c_connect_client);
 	if (ret < 0)
-		dev_err(&client->dev, "%s: Send config error.\n", __func__);
+		GTP_ERROR("send config failed.");
 
-	msleep(20);
-	return ret;
+	return count;
 }
 
 /*******************************************************
 Function:
-	Read firmware version
+    Read chip version.
 Input:
-	client:  i2c device
-	version: buffer to keep ic firmware version
+    client:  i2c device
+    version: buffer to keep ic firmware version
 Output:
-	read operation return.
-	0: succeed, otherwise: failed
+    read operation return.
+    2: succeed, otherwise: failed
 *******************************************************/
-static int gtp_read_fw_version(struct i2c_client *client, u16 *version)
+s32 gtp_read_version(struct i2c_client *client, u16 *version)
 {
-	int ret = 0;
-	u8 buf[GTP_FW_VERSION_BUFFER_MAXSIZE] = {
-		GTP_REG_FW_VERSION >> 8, GTP_REG_FW_VERSION & 0xff };
+	s32 ret = -1;
+	u8 buf[8] = {GTP_REG_VERSION >> 8, GTP_REG_VERSION & 0xff};
+
+	GTP_DEBUG_FUNC();
 
 	ret = gtp_i2c_read(client, buf, sizeof(buf));
 	if (ret < 0) {
-		dev_err(&client->dev, "GTP read version failed.\n");
-		return -EIO;
+		GTP_ERROR("GTP read version failed");
+		return ret;
 	}
 
 	if (version)
-		*version = (buf[3] << 8) | buf[2];
+		*version = (buf[7] << 8) | buf[6];
+
+	if (buf[5] == 0x00)
+		GTP_INFO("IC Version: %c%c%c_%02x%02x", buf[2], buf[3],
+			buf[4], buf[7], buf[6]);
+	else
+		GTP_INFO("IC Version: %c%c%c%c_%02x%02x", buf[2], buf[3],
+			buf[4], buf[5], buf[7], buf[6]);
 
 	return ret;
 }
+
 /*******************************************************
 Function:
-	Read and check chip id.
+    I2c test Function.
 Input:
-	client:  i2c device
+    client:i2c client.
 Output:
-	read operation return.
-	0: succeed, otherwise: failed
+    Executive outcomes.
+    2: succeed, otherwise failed.
 *******************************************************/
-static int gtp_check_product_id(struct i2c_client *client)
+static s8 gtp_i2c_test(struct i2c_client *client)
 {
-	int ret = 0;
-	char product_id[GTP_PRODUCT_ID_MAXSIZE];
-	struct goodix_ts_data *ts = i2c_get_clientdata(client);
-	/* 04 bytes are used for the Product-id in the register space.*/
-	u8 buf[GTP_PRODUCT_ID_BUFFER_MAXSIZE] =	{
-		GTP_REG_PRODUCT_ID >> 8, GTP_REG_PRODUCT_ID & 0xff };
+	u8 test[3] = {GTP_REG_CONFIG_DATA >> 8, GTP_REG_CONFIG_DATA & 0xff};
+	u8 retry = 0;
+	s8 ret = -1;
 
-	ret = gtp_i2c_read(client, buf, sizeof(buf));
-	if (ret < 0) {
-		dev_err(&client->dev, "GTP read product_id failed.\n");
-		return -EIO;
+	GTP_DEBUG_FUNC();
+
+	while (retry++ < 5) {
+		ret = gtp_i2c_read(client, test, 3);
+		if (ret > 0)
+			return ret;
+		GTP_ERROR("GTP i2c test failed time %d.", retry);
+		msleep(20);
 	}
+	return ret;
+}
+
+/*******************************************************
+Function:
+    Request gpio(INT & RST) ports.
+Input:
+    ts: private data.
+Output:
+    Executive outcomes.
+    >= 0: succeed, < 0: failed
+*******************************************************/
+static s8 gtp_request_io_port(struct goodix_ts_data *ts)
+{
+	s32 ret = 0;
+
+	GTP_DEBUG_FUNC();
 
-	if (buf[5] == 0x00) {
-		/* copy (GTP_PRODUCT_ID_MAXSIZE - 1) from buffer. Ex: 915 */
-		strlcpy(product_id, &buf[2], GTP_PRODUCT_ID_MAXSIZE - 1);
+#ifndef FEATURE_QRD8X26_UNISCOPE_MODIFY
+	ret = gpio_request(ts->pdata->irq_gpio, "GTP_INT_IRQ");
+	if (ret < 0) {
+		GTP_ERROR("Failed to request GPIO:%d, ERRNO:%d",
+			  (s32)ts->pdata->irq_gpio, ret);
+		ret = -ENODEV;
 	} else {
-		if (buf[5] == 'S' || buf[5] == 's')
-			chip_gt9xxs = 1;
-		/* copy GTP_PRODUCT_ID_MAXSIZE from buffer. Ex: 915s */
-		strlcpy(product_id, &buf[2], GTP_PRODUCT_ID_MAXSIZE);
+		ret = gpio_direction_input(ts->pdata->irq_gpio);
+		if (ret < 0)
+			gpio_free(ts->pdata->irq_gpio);
+		ts->client->irq = gpio_to_irq(ts->pdata->irq_gpio);
 	}
 
-	dev_info(&client->dev, "Goodix Product ID = %s\n", product_id);
+	ret = gpio_request(ts->pdata->reset_gpio, "GTP_RST_PORT");
+	if (ret < 0) {
+		GTP_ERROR("Failed to request GPIO:%d, ERRNO:%d",
+			  (s32)ts->pdata->reset_gpio, ret);
+		ret = -ENODEV;
+	}
+#endif
+	ret = gpio_direction_input(ts->pdata->reset_gpio);
+	if (ret < 0)
+		gpio_free(ts->pdata->reset_gpio);
 
-	ret = strcmp(product_id, ts->pdata->product_id);
-	if (ret != 0)
-		return -EINVAL;
+	gtp_reset_guitar(ts->client, 20);
 
 	return ret;
 }
 
 /*******************************************************
 Function:
-	I2c test Function.
+    Request interrupt.
 Input:
-	client:i2c client.
+    ts: private data.
 Output:
-	Executive outcomes.
-	2: succeed, otherwise failed.
+    Executive outcomes.
+    0: succeed, -1: failed.
 *******************************************************/
-static int gtp_i2c_test(struct i2c_client *client)
+static s8 gtp_request_irq(struct goodix_ts_data *ts)
 {
-	u8 buf[3] = { GTP_REG_CONFIG_DATA >> 8, GTP_REG_CONFIG_DATA & 0xff };
-	int retry = GTP_I2C_RETRY_5;
-	int ret = -EIO;
+	s32 ret = -1;
+	const u8 irq_table[] = GTP_IRQ_TAB;
 
-	while (retry--) {
-		ret = gtp_i2c_read(client, buf, 3);
-		if (ret > 0)
-			return ret;
-		dev_err(&client->dev, "GTP i2c test failed time %d.\n", retry);
-		msleep(20);
+	GTP_DEBUG_FUNC();
+	GTP_DEBUG("INT trigger type:%x", ts->int_trigger_type);
+	GTP_DEBUG("ts->client->irq:%d", ts->client->irq);
+
+	ret = request_irq(ts->client->irq, goodix_ts_irq_handler,
+			  irq_table[ts->int_trigger_type],
+			  ts->client->name, ts);
+	if (ret) {
+		GTP_ERROR("Request IRQ failed!ERRNO:%d.", ret);
+		gpio_direction_input(ts->pdata->irq_gpio);
+		gpio_free(ts->pdata->irq_gpio);
+
+		hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		ts->timer.function = goodix_ts_timer_handler;
+		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+		return ret;
+	} else {
+		gtp_irq_disable(ts);
+		ts->use_irq = 1;
+		return 0;
 	}
-	return ret;
 }
 
 /*******************************************************
 Function:
-	Request gpio(INT & RST) ports.
+    Request input device Function.
 Input:
-	ts: private data.
+    ts:private data.
 Output:
-	Executive outcomes.
-	= 0: succeed, != 0: failed
+    Executive outcomes.
+    0: succeed, otherwise: failed.
 *******************************************************/
-static int gtp_request_io_port(struct goodix_ts_data *ts)
+static s8 gtp_request_input_dev(struct goodix_ts_data *ts)
 {
-	struct i2c_client *client = ts->client;
-	struct goodix_ts_platform_data *pdata = ts->pdata;
-	int ret;
+	s8 ret = -1;
+	s8 phys[32];
+#if GTP_HAVE_TOUCH_KEY
+	u8 index = 0;
+#endif
 
-	if (gpio_is_valid(pdata->irq_gpio)) {
-		ret = gpio_request(pdata->irq_gpio, "goodix_ts_irq_gpio");
-		if (ret) {
-			dev_err(&client->dev, "Unable to request irq gpio [%d]\n",
-				pdata->irq_gpio);
-			goto err_pwr_off;
+	GTP_DEBUG_FUNC();
+
+	ts->input_dev = input_allocate_device();
+	if (ts->input_dev == NULL) {
+		GTP_ERROR("Failed to allocate input device.");
+		return -ENOMEM;
+	}
+
+	ts->input_dev->evbit[0] =
+	    BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+#if GTP_ICS_SLOT_REPORT
+	input_mt_init_slots(ts->input_dev, 16, 0);
+#else
+	ts->input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+#endif
+	__set_bit(INPUT_PROP_DIRECT, ts->input_dev->propbit);
+
+#if GTP_HAVE_TOUCH_KEY
+	for (index = 0; index < GTP_MAX_KEY_NUM; index++)
+		input_set_capability(ts->input_dev, EV_KEY,
+				     touch_key_array[index]);
+#endif
+
+#if GTP_GESTURE_WAKEUP
+	input_set_capability(ts->input_dev, EV_KEY, KEY_POWER);
+#endif
+
+#if GTP_CHANGE_X2Y
+	GTP_SWAP(ts->abs_x_max, ts->abs_y_max);
+#endif
+
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, ts->abs_x_max,
+			     0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, ts->abs_y_max,
+			     0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_TRACKING_ID, 0, 255, 0, 0);
+
+	snprintf(phys, 32, "input/ts");
+	ts->input_dev->name = goodix_ts_name;
+	ts->input_dev->phys = phys;
+	ts->input_dev->id.bustype = BUS_I2C;
+	ts->input_dev->id.vendor = 0xDEAD;
+	ts->input_dev->id.product = 0xBEEF;
+	ts->input_dev->id.version = 10427;
+
+	ret = input_register_device(ts->input_dev);
+	if (ret) {
+		GTP_ERROR("Register %s input device failed",
+			  ts->input_dev->name);
+		return -ENODEV;
+	}
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	ts->early_suspend.suspend = goodix_ts_early_suspend;
+	ts->early_suspend.resume = goodix_ts_late_resume;
+	register_early_suspend(&ts->early_suspend);
+#endif
+
+#if GTP_WITH_PEN
+	gtp_pen_init(ts);
+#endif
+
+	return 0;
+}
+
+/************** For GT9XXF Start *************/
+#if GTP_COMPATIBLE_MODE
+s32 gtp_fw_startup(struct i2c_client *client)
+{
+	u8 opr_buf[4];
+	s32 ret = 0;
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+	/* init sw WDT */
+	opr_buf[0] = 0xAA;
+	ret = i2c_write_bytes(client, 0x8041, opr_buf, 1);
+	if (ret < 0)
+		return FAIL;
+
+	/* release SS51 & DSP */
+	opr_buf[0] = 0x00;
+	ret = i2c_write_bytes(client, 0x4180, opr_buf, 1);
+	if (ret < 0)
+		return FAIL;
+
+	/* int sync */
+	gtp_int_sync(ts, 25);
+
+	/* check fw run status */
+	ret = i2c_read_bytes(client, 0x8041, opr_buf, 1);
+	if (ret < 0)
+		return FAIL;
+
+	if (0xAA == opr_buf[0]) {
+		GTP_ERROR("IC works abnormally,startup failed.");
+		return FAIL;
+	}
+
+	GTP_INFO("IC works normally, Startup success.");
+	opr_buf[0] = 0xAA;
+	i2c_write_bytes(client, 0x8041, opr_buf, 1);
+	return SUCCESS;
+}
+
+static s32 gtp_esd_recovery(struct i2c_client *client)
+{
+	s32 retry = 0;
+	s32 ret = 0;
+	struct goodix_ts_data *ts;
+
+	ts = i2c_get_clientdata(client);
+
+	gtp_irq_disable(ts);
+
+	GTP_INFO("GT9XXF esd recovery mode");
+	for (retry = 0; retry < 5; retry++) {
+		ret = gup_fw_download_proc(NULL, GTP_FL_ESD_RECOVERY);
+		if (FAIL == ret) {
+			GTP_ERROR("esd recovery failed %d", retry + 1);
+			continue;
 		}
-		ret = gpio_direction_input(pdata->irq_gpio);
-		if (ret) {
-			dev_err(&client->dev, "Unable to set direction for irq gpio [%d]\n",
-				pdata->irq_gpio);
-			goto err_free_irq_gpio;
+		ret = gtp_fw_startup(ts->client);
+		if (FAIL == ret) {
+			GTP_ERROR("GT9XXF start up failed %d", retry + 1);
+			continue;
 		}
-	} else {
-		dev_err(&client->dev, "Invalid irq gpio [%d]!\n",
-			pdata->irq_gpio);
-		ret = -EINVAL;
-		goto err_pwr_off;
+		break;
 	}
+	gtp_irq_enable(ts);
 
-	if (gpio_is_valid(pdata->reset_gpio)) {
-		ret = gpio_request(pdata->reset_gpio, "goodix_ts_reset_gpio");
-		if (ret) {
-			dev_err(&client->dev, "Unable to request reset gpio [%d]\n",
-				pdata->reset_gpio);
-			goto err_free_irq_gpio;
-		}
+	if (retry >= 5) {
+		GTP_ERROR("failed to esd recovery");
+		return FAIL;
+	}
 
-		ret = gpio_direction_output(pdata->reset_gpio, 0);
-		if (ret) {
-			dev_err(&client->dev, "Unable to set direction for reset gpio [%d]\n",
-				pdata->reset_gpio);
-			goto err_free_reset_gpio;
+	GTP_INFO("Esd recovery successful");
+	return SUCCESS;
+}
+
+void gtp_recovery_reset(struct i2c_client *client)
+{
+#if GTP_ESD_PROTECT
+	gtp_esd_switch(client, SWITCH_OFF);
+#endif
+	GTP_DEBUG_FUNC();
+
+	gtp_esd_recovery(client);
+
+#if GTP_ESD_PROTECT
+	gtp_esd_switch(client, SWITCH_ON);
+#endif
+}
+
+static s32 gtp_bak_ref_proc(struct goodix_ts_data *ts, u8 mode)
+{
+	s32 ret = 0;
+	s32 i = 0;
+	s32 j = 0;
+	u16 ref_sum = 0;
+	u16 learn_cnt = 0;
+	u16 chksum = 0;
+	s32 ref_seg_len = 0;
+	s32 ref_grps = 0;
+	struct file *ref_filp = NULL;
+	u8 *p_bak_ref;
+	struct filename name;
+
+	ret = gup_check_fs_mounted("/data");
+	if (FAIL == ret) {
+		ts->ref_chk_fs_times++;
+		GTP_DEBUG("Ref check /data times/MAX_TIMES: %d / %d",
+			  ts->ref_chk_fs_times, GTP_CHK_FS_MNT_MAX);
+		if (ts->ref_chk_fs_times < GTP_CHK_FS_MNT_MAX) {
+			msleep(50);
+			GTP_INFO("/data not mounted.");
+			return FAIL;
 		}
+		GTP_INFO("check /data mount timeout...");
+	} else
+		GTP_INFO("/data mounted!!!(%d/%d)", ts->ref_chk_fs_times,
+			 GTP_CHK_FS_MNT_MAX);
+
+	p_bak_ref = kzalloc(ts->bak_ref_len, GFP_KERNEL);
+	if (NULL == p_bak_ref) {
+		GTP_ERROR("Allocate memory for p_bak_ref failed!");
+		return FAIL;
+	}
+
+	if (ts->is_950) {
+		ref_seg_len = ts->bak_ref_len / 6;
+		ref_grps = 6;
 	} else {
-		dev_err(&client->dev, "Invalid irq gpio [%d]!\n",
-			pdata->reset_gpio);
-		ret = -EINVAL;
-		goto err_free_irq_gpio;
-	}
-	/* IRQ GPIO is an input signal, but we are setting it to output
-	  * direction and pulling it down, to comply with power up timing
-	  * requirements, mentioned in power up timing section of device
-	  * datasheet.
-	  */
-	ret = gpio_direction_output(pdata->irq_gpio, 0);
-	if (ret)
-		dev_warn(&client->dev,
-			"pull down interrupt gpio failed\n");
-	ret = gpio_direction_output(pdata->reset_gpio, 0);
-	if (ret)
-		dev_warn(&client->dev,
-			"pull down reset gpio failed\n");
+		ref_seg_len = ts->bak_ref_len;
+		ref_grps = 1;
+	}
 
-	return ret;
+	name.name = GTP_BAK_REF_PATH;
+	ref_filp = file_open_name(&name, O_RDWR | O_CREAT, 0666);
+	if (IS_ERR(ref_filp)) {
+		GTP_ERROR("Failed to open/create %s.", GTP_BAK_REF_PATH);
+		if (GTP_BAK_REF_SEND == mode)
+			goto bak_ref_default;
+		else
+			goto bak_ref_exit;
+	}
 
-err_free_reset_gpio:
-	if (gpio_is_valid(pdata->reset_gpio))
-		gpio_free(pdata->reset_gpio);
-err_free_irq_gpio:
-	if (gpio_is_valid(pdata->irq_gpio))
-		gpio_free(pdata->irq_gpio);
-err_pwr_off:
+	switch (mode) {
+	case GTP_BAK_REF_SEND:
+		GTP_INFO("Send backup-reference");
+		ref_filp->f_op->llseek(ref_filp, 0, SEEK_SET);
+		ret = ref_filp->f_op->read(ref_filp,
+			(char *)p_bak_ref, ts->bak_ref_len, &ref_filp->f_pos);
+		if (ret < 0) {
+			GTP_ERROR("failed to read bak_ref info from file");
+			goto bak_ref_default;
+		}
+		for (j = 0; j < ref_grps; ++j) {
+			ref_sum = 0;
+			for (i = 0; i < (ref_seg_len); i += 2)
+				ref_sum +=
+				    (p_bak_ref[i + j * ref_seg_len] << 8) +
+				    p_bak_ref[i + 1 + j * ref_seg_len];
+			learn_cnt =
+			    (p_bak_ref[j * ref_seg_len + ref_seg_len - 4] << 8)
+			    + (p_bak_ref[j * ref_seg_len + ref_seg_len - 3]);
+			chksum =
+			    (p_bak_ref[j * ref_seg_len + ref_seg_len - 2] << 8)
+			    + (p_bak_ref[j * ref_seg_len + ref_seg_len - 1]);
+			GTP_DEBUG("learn count = %d", learn_cnt);
+			GTP_DEBUG("chksum = %d", chksum);
+			GTP_DEBUG("ref_sum = 0x%04X", ref_sum & 0xFFFF);
+
+			if (1 != ref_sum) {
+				GTP_INFO
+				    ("wrong chksum for bak_ref, reset to 0x00");
+				memset(&p_bak_ref[j * ref_seg_len], 0,
+				       ref_seg_len);
+				p_bak_ref[ref_seg_len + j * ref_seg_len - 1] =
+				    0x01;
+			} else {
+				if (j == (ref_grps - 1))
+					GTP_INFO
+					    ("backup-reference data in %s used",
+					     GTP_BAK_REF_PATH);
+			}
+		}
+		ret = i2c_write_bytes(ts->client, GTP_REG_BAK_REF, p_bak_ref,
+					ts->bak_ref_len);
+		if (FAIL == ret) {
+			GTP_ERROR("send bak_ref failed: iic comm error");
+			goto bak_ref_exit;
+		}
+		break;
+
+	case GTP_BAK_REF_STORE:
+		GTP_INFO("Store backup-reference");
+		ret = i2c_read_bytes(ts->client, GTP_REG_BAK_REF, p_bak_ref,
+					ts->bak_ref_len);
+		if (ret < 0) {
+			GTP_ERROR("read bak_ref info failed, send default");
+			goto bak_ref_default;
+		}
+		ref_filp->f_op->llseek(ref_filp, 0, SEEK_SET);
+		ref_filp->f_op->write(ref_filp, (char *)p_bak_ref,
+				      ts->bak_ref_len, &ref_filp->f_pos);
+		break;
+
+	default:
+		GTP_ERROR("invalid backup-reference request");
+		break;
+	}
+	ret = SUCCESS;
+	goto bak_ref_exit;
+
+bak_ref_default:
+	for (j = 0; j < ref_grps; ++j) {
+		memset(&p_bak_ref[j * ref_seg_len], 0, ref_seg_len);
+		p_bak_ref[j * ref_seg_len + ref_seg_len - 1] = 0x01;
+	}
+	ret = i2c_write_bytes(ts->client, GTP_REG_BAK_REF, p_bak_ref,
+				ts->bak_ref_len);
+	if (!IS_ERR(ref_filp)) {
+		GTP_INFO("write backup-reference data into %s",
+			 GTP_BAK_REF_PATH);
+		ref_filp->f_op->llseek(ref_filp, 0, SEEK_SET);
+		ref_filp->f_op->write(ref_filp, (char *)p_bak_ref,
+				      ts->bak_ref_len, &ref_filp->f_pos);
+	}
+	if (ret == FAIL)
+		GTP_ERROR("failed to load the default backup reference");
+
+bak_ref_exit:
+	kfree(p_bak_ref);
+	if (ref_filp && !IS_ERR(ref_filp))
+		filp_close(ref_filp, NULL);
 	return ret;
 }
 
-/*******************************************************
-Function:
-	Request interrupt.
-Input:
-	ts: private data.
-Output:
-	Executive outcomes.
-	0: succeed, -1: failed.
-*******************************************************/
-static int gtp_request_irq(struct goodix_ts_data *ts)
+static s32 gtp_verify_main_clk(u8 *p_main_clk)
 {
-	int ret = 0;
-	const u8 irq_table[] = GTP_IRQ_TAB;
+	u8 chksum = 0;
+	u8 main_clock = p_main_clk[0];
+	s32 i = 0;
 
-	ret = request_threaded_irq(ts->client->irq, NULL,
-			goodix_ts_irq_handler,
-			irq_table[ts->int_trigger_type],
-			ts->client->name, ts);
-	if (ret) {
-		ts->use_irq = false;
-		return ret;
-	} else {
-		gtp_irq_disable(ts);
-		ts->use_irq = true;
-		return ret;
+	if (main_clock < 50 || main_clock > 120)
+		return FAIL;
+
+	for (i = 0; i < 5; ++i) {
+		if (main_clock != p_main_clk[i])
+			return FAIL;
+		chksum += p_main_clk[i];
+	}
+	chksum += p_main_clk[5];
+	if ((chksum) == 0)
+		return SUCCESS;
+	return FAIL;
+}
+
+static s32 gtp_main_clk_proc(struct goodix_ts_data *ts)
+{
+	s32 ret = 0;
+	s32 i = 0;
+	s32 clk_chksum = 0;
+	struct file *clk_filp = NULL;
+	u8 p_main_clk[6] = {0};
+	struct filename name;
+
+	ret = gup_check_fs_mounted("/data");
+	if (FAIL == ret) {
+		ts->clk_chk_fs_times++;
+		GTP_DEBUG("Clock check /data times/MAX_TIMES: %d / %d",
+			  ts->clk_chk_fs_times, GTP_CHK_FS_MNT_MAX);
+		if (ts->clk_chk_fs_times < GTP_CHK_FS_MNT_MAX) {
+			msleep(50);
+			GTP_INFO("/data not mounted.");
+			return FAIL;
+		}
+		GTP_INFO("Check /data mount timeout!");
+	} else
+		GTP_INFO("/data mounted!!!(%d/%d)", ts->clk_chk_fs_times,
+			 GTP_CHK_FS_MNT_MAX);
+
+	name.name = GTP_MAIN_CLK_PATH;
+	clk_filp = file_open_name(&name, O_RDWR | O_CREAT, 0666);
+	if (IS_ERR(clk_filp))
+		GTP_ERROR("%s is unavailable, calculate main clock",
+			  GTP_MAIN_CLK_PATH);
+	else {
+		clk_filp->f_op->llseek(clk_filp, 0, SEEK_SET);
+		clk_filp->f_op->read(clk_filp, (char *)p_main_clk, 6,
+				     &clk_filp->f_pos);
+
+		ret = gtp_verify_main_clk(p_main_clk);
+		if (FAIL == ret) {
+			/* recalculate main clock
+			  * & rewrite main clock data to file
+			  */
+			GTP_ERROR
+			    ("main clock data in %s is wrong,",
+			     GTP_MAIN_CLK_PATH);
+		} else {
+			GTP_INFO
+			    ("main clock data in %s used, main clock freq: %d",
+			     GTP_MAIN_CLK_PATH, p_main_clk[0]);
+			filp_close(clk_filp, NULL);
+			goto update_main_clk;
+		}
+	}
+
+#if GTP_ESD_PROTECT
+	gtp_esd_switch(ts->client, SWITCH_OFF);
+#endif
+	ret = gup_clk_calibration();
+	gtp_esd_recovery(ts->client);
+
+#if GTP_ESD_PROTECT
+	gtp_esd_switch(ts->client, SWITCH_ON);
+#endif
+
+	GTP_INFO("calibrate main clock: %d", ret);
+	if (ret < 50 || ret > 120) {
+		GTP_ERROR("wrong main clock: %d", ret);
+		goto exit_main_clk;
+	}
+
+	for (i = 0; i < 5; ++i) {
+		p_main_clk[i] = ret;
+		clk_chksum += p_main_clk[i];
+	}
+	p_main_clk[5] = 0 - clk_chksum;
+
+	if (!IS_ERR(clk_filp)) {
+		GTP_DEBUG("write main clock data into %s", GTP_MAIN_CLK_PATH);
+		clk_filp->f_op->llseek(clk_filp, 0, SEEK_SET);
+		clk_filp->f_op->write(clk_filp, (char *)p_main_clk, 6,
+				      &clk_filp->f_pos);
+		filp_close(clk_filp, NULL);
+	}
+
+update_main_clk:
+	ret = i2c_write_bytes(ts->client, GTP_REG_MAIN_CLK, p_main_clk, 6);
+	if (FAIL == ret) {
+		GTP_ERROR("update main clock failed!");
+		return FAIL;
 	}
+	return SUCCESS;
+
+exit_main_clk:
+	if (!IS_ERR(clk_filp))
+		filp_close(clk_filp, NULL);
+	return FAIL;
 }
 
-/*******************************************************
-Function:
-	Request input device Function.
-Input:
-	ts:private data.
-Output:
-	Executive outcomes.
-	0: succeed, otherwise: failed.
-*******************************************************/
-static int gtp_request_input_dev(struct goodix_ts_data *ts)
+static s32 gtp_gt9xxf_init(struct i2c_client *client)
 {
-	int ret;
-	char phys[PHY_BUF_SIZE];
-	int index = 0;
+	s32 ret = 0;
 
-	ts->input_dev = input_allocate_device();
-	if (ts->input_dev == NULL) {
-		dev_err(&ts->client->dev,
-				"Failed to allocate input device.\n");
-		return -ENOMEM;
-	}
+	ret = gup_fw_download_proc(NULL, GTP_FL_FW_BURN);
+	if (FAIL == ret)
+		return FAIL;
 
-	ts->input_dev->evbit[0] =
-		BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) ;
-	set_bit(BTN_TOOL_FINGER, ts->input_dev->keybit);
-	__set_bit(INPUT_PROP_DIRECT, ts->input_dev->propbit);
-	/* in case of "out of memory" */
-	input_mt_init_slots(ts->input_dev, 10, 0);
+	ret = gtp_fw_startup(client);
+	if (FAIL == ret)
+		return FAIL;
 
-	if (ts->pdata->have_touch_key) {
-		for (index = 0; index < ts->pdata->num_button; index++) {
-			input_set_capability(ts->input_dev,
-				EV_KEY, ts->pdata->button_map[index]);
-		}
-	}
+	return SUCCESS;
+}
+
+static void gtp_get_chip_type(struct goodix_ts_data *ts)
+{
+	u8 opr_buf[10] = {0x00};
+	s32 ret = 0;
 
-	if (ts->pdata->slide_wakeup)
-		input_set_capability(ts->input_dev, EV_KEY, KEY_POWER);
+	msleep(20);
 
-	if (ts->pdata->with_pen) {  /* pen support */
-		__set_bit(BTN_TOOL_PEN, ts->input_dev->keybit);
-		__set_bit(INPUT_PROP_DIRECT, ts->input_dev->propbit);
-		__set_bit(INPUT_PROP_POINTER, ts->input_dev->propbit);
+	ret =
+	    gtp_i2c_read_dbl_check(ts->client, GTP_REG_CHIP_TYPE, opr_buf, 10);
+	if (FAIL == ret) {
+		GTP_ERROR("Failed to get chip-type");
+		ts->chip_type = CHIP_TYPE_GT9;
+		return;
 	}
 
-	if (ts->pdata->change_x2y)
-		swap(ts->abs_x_max, ts->abs_y_max);
+	if (!memcmp(opr_buf, "GOODIX_GT9", 10))
+		ts->chip_type = CHIP_TYPE_GT9;
+	else	/* GT9XXF */
+		ts->chip_type = CHIP_TYPE_GT9F;
+	GTP_INFO("Chip Type: %s",
+		 (ts->chip_type ==
+		  CHIP_TYPE_GT9) ? "GOODIX_GT9" : "GOODIX_GT9F");
+}
+#endif
 
-	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X,
-				0, ts->abs_x_max, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y,
-				0, ts->abs_y_max, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR,
-				0, 255, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR,
-				0, 255, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_TRACKING_ID,
-				0, 255, 0, 0);
+static int goodix_ts_get_dt_coords(struct device *dev, char *name,
+				   struct goodix_ts_platform_data *pdata)
+{
+	struct property *prop;
+	struct device_node *np = dev->of_node;
+	int rc;
+	u32 coords[GOODIX_COORDS_ARR_SIZE];
 
-	snprintf(phys, PHY_BUF_SIZE, "input/ts");
-	ts->input_dev->name = GOODIX_DEV_NAME;
-	ts->input_dev->phys = phys;
-	ts->input_dev->id.bustype = BUS_I2C;
-	ts->input_dev->id.vendor = 0xDEAD;
-	ts->input_dev->id.product = 0xBEEF;
-	ts->input_dev->id.version = 10427;
+	prop = of_find_property(np, name, NULL);
+	if (!prop)
+		return -EINVAL;
+	if (!prop->value)
+		return -ENODATA;
 
-	ret = input_register_device(ts->input_dev);
-	if (ret) {
-		dev_err(&ts->client->dev,
-				"Register %s input device failed.\n",
-				ts->input_dev->name);
-		goto exit_free_inputdev;
+	rc = of_property_read_u32_array(np, name, coords,
+					GOODIX_COORDS_ARR_SIZE);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read %s\n", name);
+		return rc;
 	}
 
-	return 0;
+	if (!strcmp(name, "goodix,panel-coords")) {
+		pdata->panel_minx = coords[0];
+		pdata->panel_miny = coords[1];
+		pdata->panel_maxx = coords[2];
+		pdata->panel_maxy = coords[3];
+	} else if (!strcmp(name, "goodix,display-coords")) {
+		pdata->x_min = coords[0];
+		pdata->y_min = coords[1];
+		pdata->x_max = coords[2];
+		pdata->y_max = coords[3];
+	} else {
+		dev_err(dev, "unsupported property %s\n", name);
+		return -EINVAL;
+	}
 
-exit_free_inputdev:
-	input_free_device(ts->input_dev);
-	ts->input_dev = NULL;
-	return ret;
+	return 0;
 }
 
 static int reg_set_optimum_mode_check(struct regulator *reg, int load_uA)
 {
 	return (regulator_count_voltages(reg) > 0) ?
-		regulator_set_optimum_mode(reg, load_uA) : 0;
+	    regulator_set_optimum_mode(reg, load_uA) : 0;
 }
 
 /**
@@ -1291,39 +2241,38 @@ static int reg_set_optimum_mode_check(struct regulator *reg, int load_uA)
 static int goodix_power_on(struct goodix_ts_data *ts)
 {
 	int ret;
+#ifdef FEATURE_QRD8X26_UNISCOPE_MODIFY
+	int err = 0;
+#endif
 
 	if (ts->power_on) {
-		dev_info(&ts->client->dev,
-				"Device already power on\n");
+		dev_info(&ts->client->dev, "Device already power on\n");
 		return 0;
 	}
-
-	if (!IS_ERR(ts->avdd)) {
-		ret = reg_set_optimum_mode_check(ts->avdd,
-			GOODIX_VDD_LOAD_MAX_UA);
-		if (ret < 0) {
-			dev_err(&ts->client->dev,
-				"Regulator avdd set_opt failed rc=%d\n", ret);
-			goto err_set_opt_avdd;
-		}
-		ret = regulator_enable(ts->avdd);
-		if (ret) {
+#ifdef FEATURE_QRD8X26_UNISCOPE_MODIFY
+	/* VDD 2.8V Power on */
+	if (gpio_is_valid(GPIO_VDD_2_8V)) {
+		err = gpio_direction_output(GPIO_VDD_2_8V, 1);
+		if (err) {
 			dev_err(&ts->client->dev,
-				"Regulator avdd enable failed ret=%d\n", ret);
-			goto err_enable_avdd;
+				"set_direction for ft5x06 2.8V gpio failed\n");
+			goto free_vdd_gpio;
 		}
 	}
 
+	msleep(20);
+#endif
+
 	if (!IS_ERR(ts->vdd)) {
 		ret = regulator_set_voltage(ts->vdd, GOODIX_VTG_MIN_UV,
-					   GOODIX_VTG_MAX_UV);
+					    GOODIX_VTG_MAX_UV);
 		if (ret) {
 			dev_err(&ts->client->dev,
 				"Regulator set_vtg failed vdd ret=%d\n", ret);
 			goto err_set_vtg_vdd;
 		}
 		ret = reg_set_optimum_mode_check(ts->vdd,
-			GOODIX_VDD_LOAD_MAX_UA);
+						 GOODIX_VDD_LOAD_MAX_UA);
 		if (ret < 0) {
 			dev_err(&ts->client->dev,
 				"Regulator vdd set_opt failed rc=%d\n", ret);
@@ -1339,7 +2288,7 @@ static int goodix_power_on(struct goodix_ts_data *ts)
 
 	if (!IS_ERR(ts->vcc_i2c)) {
 		ret = regulator_set_voltage(ts->vcc_i2c, GOODIX_I2C_VTG_MIN_UV,
-					   GOODIX_I2C_VTG_MAX_UV);
+					    GOODIX_I2C_VTG_MAX_UV);
 		if (ret) {
 			dev_err(&ts->client->dev,
 				"Regulator set_vtg failed vcc_i2c ret=%d\n",
@@ -1347,7 +2296,7 @@ static int goodix_power_on(struct goodix_ts_data *ts)
 			goto err_set_vtg_vcc_i2c;
 		}
 		ret = reg_set_optimum_mode_check(ts->vcc_i2c,
-			GOODIX_VIO_LOAD_MAX_UA);
+						 GOODIX_VIO_LOAD_MAX_UA);
 		if (ret < 0) {
 			dev_err(&ts->client->dev,
 				"Regulator vcc_i2c set_opt failed rc=%d\n",
@@ -1361,7 +2310,7 @@ static int goodix_power_on(struct goodix_ts_data *ts)
 				ret);
 			regulator_disable(ts->vdd);
 			goto err_enable_vcc_i2c;
-			}
+		}
 	}
 
 	ts->power_on = true;
@@ -1379,11 +2328,12 @@ err_set_opt_vdd:
 	if (!IS_ERR(ts->vdd))
 		regulator_set_voltage(ts->vdd, 0, GOODIX_VTG_MAX_UV);
 err_set_vtg_vdd:
-	if (!IS_ERR(ts->avdd))
-		regulator_disable(ts->avdd);
-err_enable_avdd:
-err_set_opt_avdd:
 	ts->power_on = false;
+#ifdef FEATURE_QRD8X26_UNISCOPE_MODIFY
+free_vdd_gpio:
+	if (gpio_is_valid(GPIO_VDD_2_8V))
+		gpio_free(GPIO_VDD_2_8V);
+#endif
 	return ret;
 }
 
@@ -1396,16 +2346,25 @@ err_set_opt_avdd:
 static int goodix_power_off(struct goodix_ts_data *ts)
 {
 	int ret;
+#ifdef FEATURE_QRD8X26_UNISCOPE_MODIFY
+	int err = 0;
+#endif
 
 	if (!ts->power_on) {
-		dev_info(&ts->client->dev,
-				"Device already power off\n");
+		dev_info(&ts->client->dev, "Device already power off\n");
 		return 0;
 	}
+#ifdef FEATURE_QRD8X26_UNISCOPE_MODIFY
+	err = gpio_direction_output(GPIO_VDD_2_8V, 0);
+	if (err) {
+		dev_err(&ts->client->dev,
+			"set_direction for ft5x06 2.8V gpio failed\n");
+	}
+#endif
 
 	if (!IS_ERR(ts->vcc_i2c)) {
 		ret = regulator_set_voltage(ts->vcc_i2c, 0,
-			GOODIX_I2C_VTG_MAX_UV);
+					    GOODIX_I2C_VTG_MAX_UV);
 		if (ret < 0)
 			dev_err(&ts->client->dev,
 				"Regulator vcc_i2c set_vtg failed ret=%d\n",
@@ -1428,13 +2387,6 @@ static int goodix_power_off(struct goodix_ts_data *ts)
 				"Regulator vdd disable failed ret=%d\n", ret);
 	}
 
-	if (!IS_ERR(ts->avdd)) {
-		ret = regulator_disable(ts->avdd);
-		if (ret)
-			dev_err(&ts->client->dev,
-				"Regulator avdd disable failed ret=%d\n", ret);
-	}
-
 	ts->power_on = false;
 	return 0;
 }
@@ -1448,28 +2400,68 @@ static int goodix_power_off(struct goodix_ts_data *ts)
 static int goodix_power_init(struct goodix_ts_data *ts)
 {
 	int ret;
-
-	ts->avdd = regulator_get(&ts->client->dev, "avdd");
-	if (IS_ERR(ts->avdd)) {
-		ret = PTR_ERR(ts->avdd);
-		dev_info(&ts->client->dev,
-			"Regulator get failed avdd ret=%d\n", ret);
-	}
+#ifdef FEATURE_QRD8X26_UNISCOPE_MODIFY
+	int err = 0;
+#endif
 
 	ts->vdd = regulator_get(&ts->client->dev, "vdd");
 	if (IS_ERR(ts->vdd)) {
 		ret = PTR_ERR(ts->vdd);
 		dev_info(&ts->client->dev,
-			"Regulator get failed vdd ret=%d\n", ret);
+			 "Regulator get failed vdd ret=%d\n", ret);
 	}
 
 	ts->vcc_i2c = regulator_get(&ts->client->dev, "vcc-i2c");
 	if (IS_ERR(ts->vcc_i2c)) {
 		ret = PTR_ERR(ts->vcc_i2c);
 		dev_info(&ts->client->dev,
-			"Regulator get failed vcc_i2c ret=%d\n", ret);
+			 "Regulator get failed vcc_i2c ret=%d\n", ret);
+	}
+#ifdef FEATURE_QRD8X26_UNISCOPE_MODIFY
+	if (regulator_count_voltages(ts->vcc_i2c) > 0) {
+		err = regulator_set_voltage(ts->vcc_i2c, GOODIX_I2C_VTG_MIN_UV,
+					    GOODIX_I2C_VTG_MIN_UV);
+		if (err) {
+			dev_err(&ts->client->desv,
+				"Regulator set_vtg failed vcc_i2c rc=%d\n",
+				err);
+			goto err_set_vtg_vcc_i2c;
+		}
+	}
+
+	err = gpio_request(GPIO_VDD_2_8V, "ft5x06 2.8V");
+	if (err)
+		dev_err(&ts->client->dev, "ft5x06 2.8V request failed");
+
+	/* request GTP GPIO --Timing 2014-2-14 */
+	ret = gpio_request(ts->pdata->irq_gpio, "GTP_INT_IRQ");
+	if (ret < 0) {
+		GTP_ERROR("Failed to request GPIO:%d, ERRNO:%d",
+			  (s32)ts->pdata->irq_gpio, ret);
+		ret = -ENODEV;
+	} else {
+		ret = gpio_direction_input(ts->pdata->irq_gpio);
+		if (ret < 0)
+			gpio_free(ts->pdata->irq_gpio);
+		ts->client->irq = gpio_to_irq(ts->pdata->irq_gpio);
 	}
 
+	ret = gpio_request(ts->pdata->reset_gpio, "GTP_RST_PORT");
+	if (ret < 0) {
+		GTP_ERROR("Failed to request GPIO:%d, ERRNO:%d",
+			  (s32)ts->pdata->reset_gpio, ret);
+		ret = -ENODEV;
+	}
+	/* RST and INT output low for poweron timing  --Timing 2014-2-14 */
+	err = gpio_direction_output(ts->pdata->irq_gpio, 0);
+	err = gpio_direction_output(ts->pdata->reset_gpio, 0);
+	err = gpio_direction_output(GPIO_VDD_2_8V, 0);
+	msleep(200);
+
+err_set_vtg_vcc_i2c:
+	if (!IS_ERR(ts->vdd))
+		regulator_disable(ts->vdd);
+#endif
 	return 0;
 }
 
@@ -1483,11 +2475,10 @@ static int goodix_power_deinit(struct goodix_ts_data *ts)
 {
 	regulator_put(ts->vdd);
 	regulator_put(ts->vcc_i2c);
-	regulator_put(ts->avdd);
-
 	return 0;
 }
 
+/************* For GT9XXF End ************/
 static ssize_t gtp_fw_name_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
@@ -1495,15 +2486,14 @@ static ssize_t gtp_fw_name_show(struct device *dev,
 
 	if (!strlen(ts->fw_name))
 		return snprintf(buf, GTP_FW_NAME_MAXSIZE - 1,
-			"No fw name has been given.");
-	else
-		return snprintf(buf, GTP_FW_NAME_MAXSIZE - 1,
-			"%s\n", ts->fw_name);
+				"No fw name has been given.");
+	return snprintf(buf, GTP_FW_NAME_MAXSIZE - 1,
+				"%s\n", ts->fw_name);
 }
 
 static ssize_t gtp_fw_name_store(struct device *dev,
-				struct device_attribute *attr,
-				const char *buf, size_t size)
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
 {
 	struct goodix_ts_data *ts = dev_get_drvdata(dev);
 
@@ -1513,22 +2503,22 @@ static ssize_t gtp_fw_name_store(struct device *dev,
 	}
 
 	strlcpy(ts->fw_name, buf, size);
-	if (ts->fw_name[size-1] == '\n')
-		ts->fw_name[size-1] = '\0';
+	if (ts->fw_name[size - 1] == '\n')
+		ts->fw_name[size - 1] = '\0';
 
 	return size;
 }
 
 static ssize_t gtp_fw_upgrade_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
+				   struct device_attribute *attr, char *buf)
 {
 	struct goodix_ts_data *ts = dev_get_drvdata(dev);
 	return snprintf(buf, 2, "%d\n", ts->fw_loading);
 }
 
 static ssize_t gtp_fw_upgrade_store(struct device *dev,
-				struct device_attribute *attr,
-				const char *buf, size_t size)
+				    struct device_attribute *attr,
+				    const char *buf, size_t size)
 {
 	struct goodix_ts_data *ts = dev_get_drvdata(dev);
 	unsigned int val;
@@ -1554,7 +2544,7 @@ static ssize_t gtp_fw_upgrade_store(struct device *dev,
 			ret = gup_update_proc(NULL);
 			if (ret == FAIL)
 				dev_err(&ts->client->dev,
-						"Fail to update GTP firmware.\n");
+					"Fail to update GTP firmware.\n");
 		}
 		ts->fw_loading = false;
 		enable_irq(ts->client->irq);
@@ -1565,8 +2555,8 @@ static ssize_t gtp_fw_upgrade_store(struct device *dev,
 }
 
 static ssize_t gtp_force_fw_upgrade_store(struct device *dev,
-				struct device_attribute *attr,
-				const char *buf, size_t size)
+					  struct device_attribute *attr,
+					  const char *buf, size_t size)
 {
 	struct goodix_ts_data *ts = dev_get_drvdata(dev);
 	unsigned int val;
@@ -1593,7 +2583,7 @@ static ssize_t gtp_force_fw_upgrade_store(struct device *dev,
 			ret = gup_update_proc(NULL);
 			if (ret == FAIL)
 				dev_err(&ts->client->dev,
-				"Fail to force update GTP firmware.\n");
+					"Fail to force update GTP firmware.\n");
 		}
 		ts->force_update = false;
 		ts->fw_loading = false;
@@ -1604,20 +2594,127 @@ static ssize_t gtp_force_fw_upgrade_store(struct device *dev,
 	return size;
 }
 
+static ssize_t goodix_enable_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct goodix_ts_data *ts = dev_get_drvdata(dev);
+	if (ts->gtp_is_suspend) {
+		dev_info(&ts->client->dev, "Already in suspend state\n");
+		return snprintf(buf, 4, "%s\n", "0");
+	}
+	return snprintf(buf, 4, "%s\n", ts->enable ? "1" : "0");
+}
+
+static ssize_t goodix_enable_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	struct goodix_ts_data *ts = dev_get_drvdata(dev);
+	unsigned long val;
+	int rc, ret, i;
+
+	if (size > 2)
+		return -EINVAL;
+
+	if (ts->gtp_is_suspend) {
+		dev_info(&ts->client->dev, "Already in suspend state\n");
+		goto no_operation;
+	}
+
+	rc = kstrtoul(buf, 10, &val);
+	if (rc != 0)
+		return rc;
+
+	if (val) {
+		ret = gtp_wakeup_sleep(ts);
+
+#if GTP_GESTURE_WAKEUP
+		doze_status = DOZE_DISABLED;
+#endif
+
+		if (ret <= 0)
+			dev_err(&ts->client->dev, "GTP resume failed.\n");
+
+		if (ts->use_irq)
+			gtp_irq_enable(ts);
+		else
+			hrtimer_start(&ts->timer, ktime_set(1, 0),
+				      HRTIMER_MODE_REL);
+
+#if GTP_ESD_PROTECT
+		ts->gtp_is_suspend = 0;
+		gtp_esd_switch(ts->client, SWITCH_ON);
+#endif
+		ts->enable = true;
+	} else {
+#if GTP_ESD_PROTECT
+		ts->gtp_is_suspend = 1;
+		gtp_esd_switch(ts->client, SWITCH_OFF);
+#endif
+
+#if GTP_GESTURE_WAKEUP
+		ret = gtp_enter_doze(ts);
+#else
+		if (ts->use_irq)
+			gtp_irq_disable(ts);
+		else
+			hrtimer_cancel(&ts->timer);
+
+		for (i = 0; i < GTP_MAX_TOUCH; i++)
+			gtp_touch_up(ts, i);
+
+		input_sync(ts->input_dev);
+
+		ret = gtp_enter_sleep(ts);
+#endif
+		if (ret <= 0)
+			dev_err(&ts->client->dev,
+				"GTP early suspend failed.\n");
+		/* to avoid waking up while not sleeping,
+		 * delay 48 + 10ms to ensure reliability
+		 */
+		msleep(58);
+		ts->enable = false;
+	}
+
+no_operation:
+	return size;
+}
+
+static ssize_t goodix_mt_protocol_type_show(struct device *dev,
+					    struct device_attribute *attr,
+					    char *buf)
+{
+	return snprintf(buf, 16, "%s\n", "MT Protocal B");
+}
+
+static ssize_t goodix_ts_info_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct goodix_ts_data *data = dev_get_drvdata(dev);
+	return snprintf(buf, GOODIX_INFO_MAX_LEN, "%s\n", data->ts_info);
+}
+
 static DEVICE_ATTR(fw_name, (S_IRUGO | S_IWUSR | S_IWGRP),
-			gtp_fw_name_show,
-			gtp_fw_name_store);
-static DEVICE_ATTR(fw_upgrade, (S_IRUGO | S_IWUSR | S_IWGRP),
-			gtp_fw_upgrade_show,
-			gtp_fw_upgrade_store);
-static DEVICE_ATTR(force_fw_upgrade, (S_IRUGO | S_IWUSR | S_IWGRP),
-			gtp_fw_upgrade_show,
-			gtp_force_fw_upgrade_store);
+		   gtp_fw_name_show, gtp_fw_name_store);
+static DEVICE_ATTR(update_fw, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   gtp_fw_upgrade_show, gtp_fw_upgrade_store);
+static DEVICE_ATTR(force_update_fw, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   gtp_fw_upgrade_show, gtp_force_fw_upgrade_store);
+static DEVICE_ATTR(enable, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   goodix_enable_show, goodix_enable_store);
+static DEVICE_ATTR(mt_protocol_type, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   goodix_mt_protocol_type_show, NULL);
+static DEVICE_ATTR(ts_info, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   goodix_ts_info_show, NULL);
 
 static struct attribute *gtp_attrs[] = {
 	&dev_attr_fw_name.attr,
-	&dev_attr_fw_upgrade.attr,
-	&dev_attr_force_fw_upgrade.attr,
+	&dev_attr_update_fw.attr,
+	&dev_attr_force_update_fw.attr,
+	&dev_attr_enable.attr,
+	&dev_attr_mt_protocol_type.attr,
+	&dev_attr_ts_info.attr,
 	NULL
 };
 
@@ -1673,7 +2770,7 @@ static int gtp_debug_data_get(void *_data, u64 *val)
 }
 
 DEFINE_SIMPLE_ATTRIBUTE(debug_data_fops, gtp_debug_data_get,
-				gtp_debug_data_set, "%llx\n");
+			gtp_debug_data_set, "%llx\n");
 
 static int gtp_debug_addr_set(void *_data, u64 val)
 {
@@ -1681,7 +2778,7 @@ static int gtp_debug_addr_set(void *_data, u64 val)
 
 	if (gtp_debug_addr_is_valid(val)) {
 		mutex_lock(&ts->input_dev->mutex);
-			ts->addr = val;
+		ts->addr = val;
 		mutex_unlock(&ts->input_dev->mutex);
 	}
 
@@ -1701,7 +2798,7 @@ static int gtp_debug_addr_get(void *_data, u64 *val)
 }
 
 DEFINE_SIMPLE_ATTRIBUTE(debug_addr_fops, gtp_debug_addr_get,
-				gtp_debug_addr_set, "%llx\n");
+			gtp_debug_addr_set, "%llx\n");
 
 static int gtp_debug_suspend_set(void *_data, u64 val)
 {
@@ -1731,81 +2828,69 @@ static int gtp_debug_suspend_get(void *_data, u64 *val)
 DEFINE_SIMPLE_ATTRIBUTE(debug_suspend_fops, gtp_debug_suspend_get,
 			gtp_debug_suspend_set, "%lld\n");
 
+static int goodix_debug_dump_info(struct seq_file *m, void *v)
+{
+	struct goodix_ts_data *data = m->private;
+
+	seq_printf(m, "%s\n", data->ts_info);
+
+	return 0;
+}
+
+static int debugfs_dump_info_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, goodix_debug_dump_info, inode->i_private);
+}
+
+static const struct file_operations debug_dump_info_fops = {
+	.owner = THIS_MODULE,
+	.open = debugfs_dump_info_open,
+	.read = seq_read,
+	.release = single_release,
+};
+
 static int gtp_debugfs_init(struct goodix_ts_data *data)
 {
 	data->debug_base = debugfs_create_dir(GTP_DEBUGFS_DIR, NULL);
-
 	if (IS_ERR_OR_NULL(data->debug_base)) {
 		dev_err(&data->client->dev, "Failed to create debugfs dir.\n");
-			return -EINVAL;
+		return -EINVAL;
 	}
 
 	if ((IS_ERR_OR_NULL(debugfs_create_file(GTP_DEBUGFS_FILE_SUSPEND,
-					S_IWUSR | S_IWGRP | S_IRUSR | S_IRGRP,
-					data->debug_base,
-					data,
-					&debug_suspend_fops)))) {
+						S_IWUSR | S_IWGRP | S_IRUSR |
+						S_IRGRP, data->debug_base, data,
+						&debug_suspend_fops)))) {
 		dev_err(&data->client->dev, "Failed to create suspend file.\n");
 		debugfs_remove_recursive(data->debug_base);
 		return -EINVAL;
 	}
 
 	if ((IS_ERR_OR_NULL(debugfs_create_file(GTP_DEBUGFS_FILE_DATA,
-					S_IWUSR | S_IWGRP | S_IRUSR | S_IRGRP,
-					data->debug_base,
-					data,
-					&debug_data_fops)))) {
+						S_IWUSR | S_IWGRP | S_IRUSR |
+						S_IRGRP, data->debug_base, data,
+						&debug_data_fops)))) {
 		dev_err(&data->client->dev, "Failed to create data file.\n");
 		debugfs_remove_recursive(data->debug_base);
 		return -EINVAL;
 	}
 
 	if ((IS_ERR_OR_NULL(debugfs_create_file(GTP_DEBUGFS_FILE_ADDR,
-					S_IWUSR | S_IWGRP | S_IRUSR | S_IRGRP,
-					data->debug_base,
-					data,
-					&debug_addr_fops)))) {
+						S_IWUSR | S_IWGRP | S_IRUSR |
+						S_IRGRP, data->debug_base, data,
+						&debug_addr_fops)))) {
 		dev_err(&data->client->dev, "Failed to create addr file.\n");
 		debugfs_remove_recursive(data->debug_base);
 		return -EINVAL;
 	}
 
-	return 0;
-}
-
-static int goodix_ts_get_dt_coords(struct device *dev, char *name,
-				struct goodix_ts_platform_data *pdata)
-{
-	struct property *prop;
-	struct device_node *np = dev->of_node;
-	int rc;
-	u32 coords[GOODIX_COORDS_ARR_SIZE];
-
-	prop = of_find_property(np, name, NULL);
-	if (!prop)
-		return -EINVAL;
-	if (!prop->value)
-		return -ENODATA;
-
-	rc = of_property_read_u32_array(np, name, coords,
-		GOODIX_COORDS_ARR_SIZE);
-	if (rc && (rc != -EINVAL)) {
-		dev_err(dev, "Unable to read %s\n", name);
-		return rc;
-	}
-
-	if (!strcmp(name, "goodix,panel-coords")) {
-		pdata->panel_minx = coords[0];
-		pdata->panel_miny = coords[1];
-		pdata->panel_maxx = coords[2];
-		pdata->panel_maxy = coords[3];
-	} else if (!strcmp(name, "goodix,display-coords")) {
-		pdata->x_min = coords[0];
-		pdata->y_min = coords[1];
-		pdata->x_max = coords[2];
-		pdata->y_max = coords[3];
-	} else {
-		dev_err(dev, "unsupported property %s\n", name);
+	if ((IS_ERR_OR_NULL(debugfs_create_file(GTP_DEBUGFS_FILE_DUMP_INFO,
+						S_IWUSR | S_IWGRP | S_IRUSR |
+						S_IRGRP, data->debug_base, data,
+						&debug_dump_info_fops)))) {
+		dev_err(&data->client->dev,
+			"Failed to create dump info file.\n");
+		debugfs_remove_recursive(data->debug_base);
 		return -EINVAL;
 	}
 
@@ -1813,7 +2898,7 @@ static int goodix_ts_get_dt_coords(struct device *dev, char *name,
 }
 
 static int goodix_parse_dt(struct device *dev,
-			struct goodix_ts_platform_data *pdata)
+			   struct goodix_ts_platform_data *pdata)
 {
 	int rc;
 	struct device_node *np = dev->of_node;
@@ -1823,6 +2908,7 @@ static int goodix_parse_dt(struct device *dev,
 	char prop_name[PROP_NAME_SIZE];
 	int i, read_cfg_num;
 
+	pdata->name = "goodix";
 	rc = goodix_ts_get_dt_coords(dev, "goodix,panel-coords", pdata);
 	if (rc && (rc != -EINVAL))
 		return rc;
@@ -1831,53 +2917,49 @@ static int goodix_parse_dt(struct device *dev,
 	if (rc)
 		return rc;
 
-	pdata->i2c_pull_up = of_property_read_bool(np,
-						"goodix,i2c-pull-up");
+	pdata->i2c_pull_up = of_property_read_bool(np, "goodix,i2c-pull-up");
 
-	pdata->force_update = of_property_read_bool(np,
-						"goodix,force-update");
+	pdata->no_force_update = of_property_read_bool(np,
+						"goodix,no-force-update");
 
 	pdata->enable_power_off = of_property_read_bool(np,
 						"goodix,enable-power-off");
-
-	pdata->have_touch_key = of_property_read_bool(np,
-						"goodix,have-touch-key");
-
-	pdata->driver_send_cfg = of_property_read_bool(np,
-						"goodix,driver-send-cfg");
-
-	pdata->change_x2y = of_property_read_bool(np,
-						"goodix,change-x2y");
-
-	pdata->with_pen = of_property_read_bool(np,
-						"goodix,with-pen");
-
-	pdata->slide_wakeup = of_property_read_bool(np,
-						"goodix,slide-wakeup");
-
-	pdata->dbl_clk_wakeup = of_property_read_bool(np,
-						"goodix,dbl_clk_wakeup");
-
+	pdata->fw_vkey_support = of_property_read_bool(np,
+						"goodix,fw-vkey-support");
 	/* reset, irq gpio info */
 	pdata->reset_gpio = of_get_named_gpio_flags(np, "reset-gpios",
-				0, &pdata->reset_gpio_flags);
+						    0,
+						    &pdata->reset_gpio_flags);
 	if (pdata->reset_gpio < 0)
 		return pdata->reset_gpio;
 
 	pdata->irq_gpio = of_get_named_gpio_flags(np, "interrupt-gpios",
-				0, &pdata->irq_gpio_flags);
+						  0, &pdata->irq_gpio_flags);
 	if (pdata->irq_gpio < 0)
 		return pdata->irq_gpio;
 
 	rc = of_property_read_string(np, "goodix,product-id",
-						&pdata->product_id);
+				     &pdata->product_id);
 	if (rc && (rc != -EINVAL)) {
 		dev_err(dev, "Failed to parse product_id.");
 		return -EINVAL;
 	}
 
-	rc = of_property_read_string(np, "goodix,fw_name",
-						&pdata->fw_name);
+	rc = of_property_read_u32(np, "goodix,num_max_touches",
+				  &pdata->num_max_touches);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Failed to parse num_max_touches.");
+		return -EINVAL;
+	}
+
+	rc = of_property_read_u32(np, "goodix,soft_rst_dly",
+				  &pdata->soft_rst_dly);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Failed to parse soft reset delay.");
+		return -EINVAL;
+	}
+
+	rc = of_property_read_string(np, "goodix,fw_name", &pdata->fw_name);
 	if (rc && (rc != -EINVAL)) {
 		dev_err(dev, "Failed to parse firmware name.\n");
 		return -EINVAL;
@@ -1890,30 +2972,29 @@ static int goodix_parse_dt(struct device *dev,
 			return -EINVAL;
 
 		rc = of_property_read_u32_array(np,
-			"goodix,button-map", button_map,
-			num_buttons);
+						"goodix,button-map",
+						button_map,
+						num_buttons);
 		if (rc) {
 			dev_err(dev, "Unable to read key codes\n");
 			return rc;
 		}
-		pdata->num_button = num_buttons;
-		memcpy(pdata->button_map, button_map,
-			pdata->num_button * sizeof(u32));
 	}
 
 	read_cfg_num = 0;
 	for (i = 0; i < GOODIX_MAX_CFG_GROUP; i++) {
 		snprintf(prop_name, sizeof(prop_name), "goodix,cfg-data%d", i);
 		prop = of_find_property(np, prop_name,
-			&pdata->config_data_len[i]);
+					&pdata->config_data_len[i]);
 		if (!prop || !prop->value) {
 			pdata->config_data_len[i] = 0;
 			pdata->config_data[i] = NULL;
 			continue;
 		}
 		pdata->config_data[i] = devm_kzalloc(dev,
-				GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH,
-				GFP_KERNEL);
+						     GTP_CONFIG_MAX_LENGTH +
+						     GTP_ADDR_LENGTH,
+						     GFP_KERNEL);
 		if (!pdata->config_data[i]) {
 			dev_err(dev,
 				"Not enough memory for panel config data %d\n",
@@ -1923,37 +3004,45 @@ static int goodix_parse_dt(struct device *dev,
 		pdata->config_data[i][0] = GTP_REG_CONFIG_DATA >> 8;
 		pdata->config_data[i][1] = GTP_REG_CONFIG_DATA & 0xff;
 		memcpy(&pdata->config_data[i][GTP_ADDR_LENGTH],
-				prop->value, pdata->config_data_len[i]);
+		       prop->value, pdata->config_data_len[i]);
 		read_cfg_num++;
 	}
-	dev_dbg(dev, "%d config data read from device tree.\n", read_cfg_num);
+	dev_info(dev, "%d config data read from device tree.\n", read_cfg_num);
 
 	return 0;
 }
 
 /*******************************************************
 Function:
-	I2c probe.
+    I2c probe.
 Input:
-	client: i2c device struct.
-	id: device id.
+    client: i2c device struct.
+    id: device id.
 Output:
-	Executive outcomes.
-	0: succeed.
+    Executive outcomes.
+    0: succeed.
 *******************************************************/
-
 static int goodix_ts_probe(struct i2c_client *client,
 			   const struct i2c_device_id *id)
 {
+	s32 ret = -1;
 	struct goodix_ts_platform_data *pdata;
 	struct goodix_ts_data *ts;
 	u16 version_info;
-	int ret;
 
+	GTP_DEBUG_FUNC();
+
+	/* do NOT remove these logs */
+	GTP_INFO("GTP Driver Version: %s", GTP_DRIVER_VERSION);
+	GTP_INFO("GTP Driver Built@%s, %s", __TIME__, __DATE__);
+	GTP_INFO("GTP I2C Address: 0x%02x", client->addr);
+
+	i2c_connect_client = client;
 	dev_dbg(&client->dev, "GTP I2C Address: 0x%02x\n", client->addr);
 	if (client->dev.of_node) {
 		pdata = devm_kzalloc(&client->dev,
-			sizeof(struct goodix_ts_platform_data), GFP_KERNEL);
+				     sizeof(struct goodix_ts_platform_data),
+				     GFP_KERNEL);
 		if (!pdata) {
 			dev_err(&client->dev,
 				"GTP Failed to allocate memory for pdata\n");
@@ -1963,103 +3052,110 @@ static int goodix_ts_probe(struct i2c_client *client,
 		ret = goodix_parse_dt(&client->dev, pdata);
 		if (ret)
 			return ret;
-	} else {
+	} else
 		pdata = client->dev.platform_data;
-	}
 
 	if (!pdata) {
 		dev_err(&client->dev, "GTP invalid pdata\n");
 		return -EINVAL;
 	}
 
-	i2c_connect_client = client;
-
 	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
-		dev_err(&client->dev, "GTP I2C not supported\n");
+		GTP_ERROR("I2C check functionality failed.");
 		return -ENODEV;
 	}
 
-	ts = devm_kzalloc(&client->dev, sizeof(*ts), GFP_KERNEL);
-	if (!ts) {
-		dev_err(&client->dev, "GTP not enough memory for ts\n");
+	ts = kzalloc(sizeof(*ts), GFP_KERNEL);
+	if (ts == NULL) {
+		GTP_ERROR("Alloc GFP_KERNEL memory failed.");
 		return -ENOMEM;
 	}
 
 	memset(ts, 0, sizeof(*ts));
+	INIT_WORK(&ts->work, goodix_ts_work_func);
 	ts->client = client;
 	ts->pdata = pdata;
-	/* For 2.6.39 & later use spin_lock_init(&ts->irq_lock)
-	 * For 2.6.39 & before, use ts->irq_lock = SPIN_LOCK_UNLOCKED
-	 */
 	spin_lock_init(&ts->irq_lock);
+	mutex_init(&ts->lock);
+#if GTP_ESD_PROTECT
+	ts->clk_tick_cnt = 2 * HZ;
+	GTP_DEBUG("Clock ticks for an esd cycle: %d", ts->clk_tick_cnt);
+	spin_lock_init(&ts->esd_lock);
+#endif
 	i2c_set_clientdata(client, ts);
+
 	ts->gtp_rawdiff_mode = 0;
-	ts->power_on = false;
 
-	ret = gtp_request_io_port(ts);
-	if (ret) {
-		dev_err(&client->dev, "GTP request IO port failed.\n");
+	ts->ts_info =
+	    devm_kzalloc(&client->dev, GOODIX_INFO_MAX_LEN, GFP_KERNEL);
+	if (!ts->ts_info) {
+		dev_err(&client->dev, "Not enough memory\n");
 		goto exit_free_client_data;
 	}
 
+	GOODIX_STORE_TS_INFO(ts->ts_info, ts->pdata->name,
+			     ts->pdata->num_max_touches, ts->pdata->product_id,
+			     ts->pdata->fw_vkey_support ? "yes" : "no");
+
 	ret = goodix_power_init(ts);
 	if (ret) {
 		dev_err(&client->dev, "GTP power init failed\n");
-		goto exit_free_io_port;
+		goto exit_free_ts_info;
 	}
-
 	ret = goodix_power_on(ts);
 	if (ret) {
 		dev_err(&client->dev, "GTP power on failed\n");
 		goto exit_deinit_power;
 	}
+	ret = gtp_request_io_port(ts);
+	if (ret < 0) {
+		GTP_ERROR("GTP request IO port failed.");
+		kfree(ts);
+		goto exit_power_off;
+	}
 
-	gtp_reset_guitar(ts, 20);
+	gtp_reset_guitar(ts->client, ts->pdata->soft_rst_dly);
 
 	ret = gtp_i2c_test(client);
-	if (ret != 2) {
-		dev_err(&client->dev, "I2C communication ERROR!\n");
+	if (ret < 0) {
+		GTP_ERROR("I2C communication ERROR!");
 		goto exit_power_off;
 	}
 
-	if (pdata->force_update)
-		ts->force_update = true;
+#if GTP_COMPATIBLE_MODE
+	gtp_get_chip_type(ts);
+	if (CHIP_TYPE_GT9F == ts->chip_type) {
+		ret = gtp_gt9xxf_init(ts->client);
+		if (FAIL == ret) {
+			GTP_INFO("Failed to init GT9XXF.");
+			goto exit_power_off;
+		}
+	}
+#endif
 
+	if (!pdata->no_force_update)
+		ts->force_update = true;
 	if (pdata->fw_name)
 		strlcpy(ts->fw_name, pdata->fw_name,
-						strlen(pdata->fw_name) + 1);
+			strlen(pdata->fw_name) + 1);
+
+	ret = gtp_read_version(client, &version_info);
+	if (ret < 0)
+		GTP_ERROR("Read version failed.");
 
-	if (config_enabled(CONFIG_GT9XX_TOUCHPANEL_UPDATE)) {
-		ret = gup_init_update_proc(ts);
-		if (ret < 0) {
-			dev_err(&client->dev,
-					"GTP Create firmware update thread error.\n");
-			goto exit_power_off;
-		}
-	}
 	ret = gtp_init_panel(ts);
 	if (ret < 0) {
-		dev_err(&client->dev, "GTP init panel failed.\n");
+		GTP_ERROR("GTP init panel failed.");
 		ts->abs_x_max = GTP_MAX_WIDTH;
 		ts->abs_y_max = GTP_MAX_HEIGHT;
 		ts->int_trigger_type = GTP_INT_TRIGGER;
 	}
-
-	ret = gtp_request_input_dev(ts);
-	if (ret) {
-		dev_err(&client->dev, "GTP request input dev failed.\n");
-		goto exit_free_inputdev;
-	}
-	input_set_drvdata(ts->input_dev, ts);
-
-	mutex_init(&ts->lock);
 #if defined(CONFIG_FB)
 	ts->fb_notif.notifier_call = fb_notifier_callback;
 	ret = fb_register_client(&ts->fb_notif);
 	if (ret)
 		dev_err(&ts->client->dev,
-			"Unable to register fb_notifier: %d\n",
-			ret);
+			"Unable to register fb_notifier: %d\n", ret);
 #elif defined(CONFIG_HAS_EARLYSUSPEND)
 	ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
 	ts->early_suspend.suspend = goodix_ts_early_suspend;
@@ -2067,30 +3163,44 @@ static int goodix_ts_probe(struct i2c_client *client,
 	register_early_suspend(&ts->early_suspend);
 #endif
 
-	ts->goodix_wq = create_singlethread_workqueue("goodix_wq");
-	INIT_WORK(&ts->work, goodix_ts_work_func);
-
-	ret = gtp_request_irq(ts);
-	if (ret)
-		dev_info(&client->dev, "GTP request irq failed %d.\n", ret);
+	/* Create proc file system */
+	gt91xx_config_proc =
+	    proc_create(GT91XX_CONFIG_PROC_FILE, 0666, NULL, &config_proc_ops);
+	if (gt91xx_config_proc == NULL)
+		GTP_ERROR("create_proc_entry %s failed\n",
+			  GT91XX_CONFIG_PROC_FILE);
 	else
-		dev_info(&client->dev, "GTP works in interrupt mode.\n");
+		GTP_INFO("create proc entry %s success",
+			 GT91XX_CONFIG_PROC_FILE);
 
-	ret = gtp_read_fw_version(client, &version_info);
-	if (ret != 2)
-		dev_err(&client->dev, "GTP firmware version read failed.\n");
+#if GTP_AUTO_UPDATE
+	ret = gup_init_update_proc(ts);
+	if (ret < 0)
+		GTP_ERROR("Create update thread error.");
+#endif
 
-	ret = gtp_check_product_id(client);
-	if (ret != 0) {
-		dev_err(&client->dev, "GTP Product id doesn't match.\n");
-		goto exit_free_irq;
+	ret = gtp_request_input_dev(ts);
+	if (ret < 0) {
+		GTP_ERROR("GTP request input dev failed");
+		goto exit_free_inputdev;
 	}
+
+	ret = gtp_request_irq(ts);
+	if (ret < 0)
+		GTP_INFO("GTP works in polling mode.");
+	else
+		GTP_INFO("GTP works in interrupt mode.");
+
 	if (ts->use_irq)
 		gtp_irq_enable(ts);
 
+	ts->enable = true;
+
 #ifdef CONFIG_GT9XX_TOUCHPANEL_DEBUG
+#if GTP_CREATE_WR_NODE
 	init_wr_node(client);
 #endif
+#endif
 
 #if GTP_ESD_PROTECT
 	gtp_esd_switch(client, SWITCH_ON);
@@ -2104,14 +3214,23 @@ static int goodix_ts_probe(struct i2c_client *client,
 	ret = gtp_debugfs_init(ts);
 	if (ret != 0) {
 		dev_err(&client->dev, "Failed to create debugfs entries, %d\n",
-						ret);
+			ret);
 		goto exit_remove_sysfs;
 	}
 
-	init_done = true;
 	return 0;
+
+exit_remove_sysfs:
+	sysfs_remove_group(&ts->input_dev->dev.kobj, &gtp_attr_grp);
 exit_free_irq:
-	mutex_destroy(&ts->lock);
+	input_unregister_device(ts->input_dev);
+	if (ts->input_dev) {
+		input_free_device(ts->input_dev);
+		ts->input_dev = NULL;
+	}
+	if (ts->use_irq)
+		free_irq(client->irq, ts);
+exit_free_inputdev:
 #if defined(CONFIG_FB)
 	if (fb_unregister_client(&ts->fb_notif))
 		dev_err(&client->dev,
@@ -2119,96 +3238,157 @@ exit_free_irq:
 #elif defined(CONFIG_HAS_EARLYSUSPEND)
 	unregister_early_suspend(&ts->early_suspend);
 #endif
-	if (ts->use_irq)
-		free_irq(client->irq, ts);
-	cancel_work_sync(&ts->work);
-	flush_workqueue(ts->goodix_wq);
-	destroy_workqueue(ts->goodix_wq);
-
-	input_unregister_device(ts->input_dev);
-	if (ts->input_dev) {
-		input_free_device(ts->input_dev);
-		ts->input_dev = NULL;
-	}
-exit_remove_sysfs:
-	sysfs_remove_group(&ts->input_dev->dev.kobj, &gtp_attr_grp);
-exit_free_inputdev:
-	kfree(ts->config_data);
 exit_power_off:
 	goodix_power_off(ts);
 exit_deinit_power:
 	goodix_power_deinit(ts);
-exit_free_io_port:
-	if (gpio_is_valid(pdata->reset_gpio))
-		gpio_free(pdata->reset_gpio);
-	if (gpio_is_valid(pdata->irq_gpio))
-		gpio_free(pdata->irq_gpio);
+exit_free_ts_info:
+	devm_kfree(&client->dev, ts->ts_info);
 exit_free_client_data:
+	mutex_destroy(&ts->lock);
+	cancel_work_sync(&ts->work);
 	i2c_set_clientdata(client, NULL);
+	kfree(ts);
 	return ret;
 }
 
 /*******************************************************
 Function:
-	Goodix touchscreen driver release function.
+    Goodix touchscreen driver release function.
 Input:
-	client: i2c device struct.
+    client: i2c device struct.
 Output:
-	Executive outcomes. 0---succeed.
+    Executive outcomes. 0---succeed.
 *******************************************************/
 static int goodix_ts_remove(struct i2c_client *client)
 {
 	struct goodix_ts_data *ts = i2c_get_clientdata(client);
 
-	sysfs_remove_group(&ts->input_dev->dev.kobj, &gtp_attr_grp);
+	GTP_DEBUG_FUNC();
 
-#if defined(CONFIG_FB)
-	if (fb_unregister_client(&ts->fb_notif))
-		dev_err(&client->dev,
-			"Error occurred while unregistering fb_notifier.\n");
-#elif defined(CONFIG_HAS_EARLYSUSPEND)
+#ifdef CONFIG_HAS_EARLYSUSPEND
 	unregister_early_suspend(&ts->early_suspend);
 #endif
-	mutex_destroy(&ts->lock);
 
 #ifdef CONFIG_GT9XX_TOUCHPANEL_DEBUG
+#if GTP_CREATE_WR_NODE
 	uninit_wr_node();
 #endif
+#endif
 
 #if GTP_ESD_PROTECT
-	cancel_work_sync(gtp_esd_check_workqueue);
-	flush_workqueue(gtp_esd_check_workqueue);
 	destroy_workqueue(gtp_esd_check_workqueue);
 #endif
 
 	if (ts) {
-		if (ts->use_irq)
+		if (ts->use_irq) {
+			gpio_direction_input(ts->pdata->irq_gpio);
+			gpio_free(ts->pdata->irq_gpio);
 			free_irq(client->irq, ts);
-
-		cancel_work_sync(&ts->work);
-		flush_workqueue(ts->goodix_wq);
-		destroy_workqueue(ts->goodix_wq);
-
-		input_unregister_device(ts->input_dev);
-		if (ts->input_dev) {
-			input_free_device(ts->input_dev);
-			ts->input_dev = NULL;
-		}
-
+		} else
+			hrtimer_cancel(&ts->timer);
 		if (gpio_is_valid(ts->pdata->reset_gpio))
 			gpio_free(ts->pdata->reset_gpio);
 		if (gpio_is_valid(ts->pdata->irq_gpio))
 			gpio_free(ts->pdata->irq_gpio);
-
-		goodix_power_off(ts);
-		goodix_power_deinit(ts);
-		i2c_set_clientdata(client, NULL);
 	}
+
+	GTP_INFO("GTP driver removing...");
+	i2c_set_clientdata(client, NULL);
+	input_unregister_device(ts->input_dev);
 	debugfs_remove_recursive(ts->debug_base);
+	kfree(ts);
 
 	return 0;
 }
 
+#ifdef CONFIG_HAS_EARLYSUSPEND
+/*******************************************************
+Function:
+    Early suspend function.
+Input:
+    h: early_suspend struct.
+Output:
+    None.
+*******************************************************/
+static void goodix_ts_early_suspend(struct i2c_client *client,
+				    pm_message_t mesg)
+{
+	struct goodix_ts_data *ts;
+	s8 ret = -1;
+	ts = container_of(client, struct goodix_ts_data, i2c_client);
+
+	GTP_DEBUG_FUNC();
+
+	GTP_INFO("System suspend.");
+
+	ts->gtp_is_suspend = 1;
+#if GTP_ESD_PROTECT
+	gtp_esd_switch(ts->client, SWITCH_OFF);
+#endif
+
+#if GTP_GESTURE_WAKEUP
+	ret = gtp_enter_doze(ts);
+#else
+	if (ts->use_irq)
+		gtp_irq_disable(ts);
+	else
+		hrtimer_cancel(&ts->timer);
+	ret = gtp_enter_sleep(ts);
+#endif
+	if (ret < 0)
+		GTP_ERROR("GTP early suspend failed.");
+	/* to avoid waking up while not sleeping
+	  * delay 48 + 10ms to ensure reliability
+	  */
+	msleep(58);
+}
+
+/*******************************************************
+Function:
+    Late resume function.
+Input:
+    h: early_suspend struct.
+Output:
+    None.
+*******************************************************/
+static void goodix_ts_late_resume(struct i2c_client *client)
+{
+	struct goodix_ts_data *ts;
+	s8 ret = -1;
+	ts = container_of(client, struct goodix_ts_data, i2c_client);
+
+	GTP_DEBUG_FUNC();
+
+	GTP_INFO("System resume.");
+
+	ret = gtp_wakeup_sleep(ts);
+
+#if GTP_GESTURE_WAKEUP
+	doze_status = DOZE_DISABLED;
+#endif
+
+	if (ret < 0)
+		GTP_ERROR("GTP later resume failed.");
+#if (GTP_COMPATIBLE_MODE)
+	if (CHIP_TYPE_GT9F == ts->chip_type) {
+		/* do nothing */
+	} else
+#endif
+		gtp_send_cfg(ts->client);
+
+	if (ts->use_irq)
+		gtp_irq_enable(ts);
+	else
+		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+
+	ts->gtp_is_suspend = 0;
+#if GTP_ESD_PROTECT
+	gtp_esd_switch(ts->client, SWITCH_ON);
+#endif
+}
+#endif
+
 #if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_FB)
 /*******************************************************
 Function:
@@ -2220,8 +3400,10 @@ Output:
 *******************************************************/
 static int goodix_ts_suspend(struct device *dev)
 {
+	int ret = -1;
 	struct goodix_ts_data *ts = dev_get_drvdata(dev);
-	int ret = 0, i;
+
+	GTP_DEBUG_FUNC();
 
 	if (ts->gtp_is_suspend) {
 		dev_dbg(&ts->client->dev, "Already in suspend state.\n");
@@ -2230,38 +3412,36 @@ static int goodix_ts_suspend(struct device *dev)
 
 	mutex_lock(&ts->lock);
 
+	GTP_INFO("System suspend.");
+
 	if (ts->fw_loading) {
 		dev_info(&ts->client->dev,
-			"Fw upgrade in progress, can't go to suspend.");
+			 "Fw upgrade in progress, can't go to suspend.");
 		mutex_unlock(&ts->lock);
 		return 0;
 	}
-
 #if GTP_ESD_PROTECT
 	gtp_esd_switch(ts->client, SWITCH_OFF);
 #endif
 
-	if (ts->pdata->slide_wakeup) {
-		ret = gtp_enter_doze(ts);
-	} else {
-		if (ts->use_irq)
-			gtp_irq_disable(ts);
-
-		for (i = 0; i < GTP_MAX_TOUCH; i++)
-			gtp_touch_up(ts, i);
-
-		input_sync(ts->input_dev);
-
-		ret = gtp_enter_sleep(ts);
-		if (ret < 0)
-			dev_err(&ts->client->dev, "GTP early suspend failed.\n");
-	}
-	/* to avoid waking up while not sleeping,
-	 * delay 48 + 10ms to ensure reliability
-	 */
+#if GTP_GESTURE_WAKEUP
+	ret = gtp_enter_doze(ts);
+#else
+	if (ts->use_irq)
+		gtp_irq_disable(ts);
+	else
+		hrtimer_cancel(&ts->timer);
+	ret = gtp_enter_sleep(ts);
+#endif
+	if (ret < 0)
+		GTP_ERROR("GTP early suspend failed.");
+	/* to avoid waking up while not sleeping
+	  * delay 48 + 10ms to ensure reliability
+	  */
 	msleep(58);
-	mutex_unlock(&ts->lock);
+
 	ts->gtp_is_suspend = 1;
+	mutex_unlock(&ts->lock);
 
 	return ret;
 }
@@ -2276,8 +3456,10 @@ Output:
 *******************************************************/
 static int goodix_ts_resume(struct device *dev)
 {
+	int ret = -1;
 	struct goodix_ts_data *ts = dev_get_drvdata(dev);
-	int ret = 0;
+
+	GTP_DEBUG_FUNC();
 
 	if (!ts->gtp_is_suspend) {
 		dev_dbg(&ts->client->dev, "Already in awake state.\n");
@@ -2285,37 +3467,47 @@ static int goodix_ts_resume(struct device *dev)
 	}
 
 	mutex_lock(&ts->lock);
+
+	GTP_INFO("System resume.");
 	ret = gtp_wakeup_sleep(ts);
 
-	if (ts->pdata->slide_wakeup)
-		doze_status = DOZE_DISABLED;
+#if GTP_GESTURE_WAKEUP
+	doze_status = DOZE_DISABLED;
+#endif
 
-	if (ret <= 0)
-		dev_err(&ts->client->dev, "GTP resume failed.\n");
+	if (ret < 0)
+		GTP_ERROR("GTP later resume failed.");
+#if (GTP_COMPATIBLE_MODE)
+	if (CHIP_TYPE_GT9F == ts->chip_type) {
+		/* do nothing */
+	} else
+#endif
+		gtp_send_cfg(ts->client);
 
 	if (ts->use_irq)
 		gtp_irq_enable(ts);
+	else
+		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
 
+	ts->gtp_is_suspend = 0;
 #if GTP_ESD_PROTECT
 	gtp_esd_switch(ts->client, SWITCH_ON);
 #endif
 	mutex_unlock(&ts->lock);
-	ts->gtp_is_suspend = 0;
-
 	return ret;
 }
 
 #if defined(CONFIG_FB)
 static int fb_notifier_callback(struct notifier_block *self,
-				 unsigned long event, void *data)
+				unsigned long event, void *data)
 {
 	struct fb_event *evdata = data;
 	int *blank;
 	struct goodix_ts_data *ts =
-		container_of(self, struct goodix_ts_data, fb_notif);
+	    container_of(self, struct goodix_ts_data, fb_notif);
 
 	if (evdata && evdata->data && event == FB_EVENT_BLANK &&
-			ts && ts->client) {
+	    ts && ts->client) {
 		blank = evdata->data;
 		if (*blank == FB_BLANK_UNBLANK)
 			goodix_ts_resume(&ts->client->dev);
@@ -2356,139 +3548,221 @@ static void goodix_ts_late_resume(struct early_suspend *h)
 	struct goodix_ts_data *ts;
 
 	ts = container_of(h, struct goodix_ts_data, early_suspend);
-	goodix_ts_late_resume(ts);
+	goodix_ts_resume(&ts->client->dev);
 	return;
 }
 #endif
-#endif /* !CONFIG_HAS_EARLYSUSPEND && !CONFIG_FB*/
+#endif /* !CONFIG_HAS_EARLYSUSPEND && !CONFIG_FB */
 
 #if GTP_ESD_PROTECT
+static s32 gtp_i2c_read_no_rst(struct i2c_client *client, u8 *buf, s32 len)
+{
+	struct i2c_msg msgs[2];
+	s32 ret = -1;
+	s32 retries = 0;
+
+	GTP_DEBUG_FUNC();
+
+	msgs[0].flags = !I2C_M_RD;
+	msgs[0].addr = client->addr;
+	msgs[0].len = GTP_ADDR_LENGTH;
+	msgs[0].buf = &buf[0];
+
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].addr = client->addr;
+	msgs[1].len = len - GTP_ADDR_LENGTH;
+	msgs[1].buf = &buf[GTP_ADDR_LENGTH];
+
+	while (retries < 5) {
+		ret = i2c_transfer(client->adapter, msgs, 2);
+		if (ret == 2)
+			break;
+		retries++;
+	}
+	if ((retries >= 5))
+		GTP_ERROR("I2C Read: 0x%04X, %d bytes failed, errcode: %d!",
+			  (((u16)(buf[0] << 8)) | buf[1]), len - 2, ret);
+	return ret;
+}
+
+static s32 gtp_i2c_write_no_rst(struct i2c_client *client, u8 *buf, s32 len)
+{
+	struct i2c_msg msg;
+	s32 ret = -1;
+	s32 retries = 0;
+
+	GTP_DEBUG_FUNC();
+
+	msg.flags = !I2C_M_RD;
+	msg.addr = client->addr;
+	msg.len = len;
+	msg.buf = buf;
+
+	while (retries < 5) {
+		ret = i2c_transfer(client->adapter, &msg, 1);
+		if (ret == 1)
+			break;
+		retries++;
+	}
+	if ((retries >= 5))
+		GTP_ERROR("I2C Write: 0x%04X, %d bytes failed, errcode: %d!",
+			  (((u16)(buf[0] << 8)) | buf[1]), len - 2, ret);
+	return ret;
+}
+
 /*******************************************************
 Function:
-	switch on & off esd delayed work
+    switch on & off esd delayed work
 Input:
-	client:  i2c device
-	on:	SWITCH_ON / SWITCH_OFF
+    client:  i2c device
+    on:      SWITCH_ON / SWITCH_OFF
 Output:
-	void
+    void
 *********************************************************/
-void gtp_esd_switch(struct i2c_client *client, int on)
+void gtp_esd_switch(struct i2c_client *client, s32 on)
 {
 	struct goodix_ts_data *ts;
 
 	ts = i2c_get_clientdata(client);
+	spin_lock(&ts->esd_lock);
+
 	if (SWITCH_ON == on) {
-		/* switch on esd  */
 		if (!ts->esd_running) {
 			ts->esd_running = 1;
-			dev_dbg(&client->dev, "Esd started\n");
+			spin_unlock(&ts->esd_lock);
+			GTP_INFO("Esd started");
 			queue_delayed_work(gtp_esd_check_workqueue,
-				&gtp_esd_check_work, GTP_ESD_CHECK_CIRCLE);
-		}
+					   &gtp_esd_check_work,
+					   ts->clk_tick_cnt);
+		} else
+			spin_unlock(&ts->esd_lock);
 	} else {
-		/* switch off esd */
 		if (ts->esd_running) {
 			ts->esd_running = 0;
-			dev_dbg(&client->dev, "Esd cancelled\n");
+			spin_unlock(&ts->esd_lock);
+			GTP_INFO("Esd cancelled");
 			cancel_delayed_work_sync(&gtp_esd_check_work);
-		}
+		} else
+			spin_unlock(&ts->esd_lock);
 	}
 }
 
 /*******************************************************
 Function:
-	Initialize external watchdog for esd protect
+    Initialize external watchdog for esd protect
 Input:
-	client:  i2c device.
+    client:  i2c device.
 Output:
-	result of i2c write operation.
-		1: succeed, otherwise: failed
+    result of i2c write operation.
+    1: succeed, otherwise: failed
 *********************************************************/
-static int gtp_init_ext_watchdog(struct i2c_client *client)
+static s32 gtp_init_ext_watchdog(struct i2c_client *client)
 {
-	/* in case of recursively reset by calling gtp_i2c_write*/
-	struct i2c_msg msg;
-	u8 opr_buffer[4] = {0x80, 0x40, 0xAA, 0xAA};
-	int ret;
-	int retries = 0;
-
-	msg.flags = !I2C_M_RD;
-	msg.addr  = client->addr;
-	msg.len   = 4;
-	msg.buf   = opr_buffer;
-
-	while (retries < GTP_I2C_RETRY_5) {
-		ret = i2c_transfer(client->adapter, &msg, 1);
-		if (ret == 1)
-			return 1;
-		retries++;
-	}
-	if (retries == GTP_I2C_RETRY_5)
-		dev_err(&client->dev, "init external watchdog failed!");
-	return 0;
+	u8 opr_buffer[3] = {0x80, 0x41, 0xAA};
+	GTP_DEBUG("[Esd]Init external watchdog");
+	return gtp_i2c_write_no_rst(client, opr_buffer, 3);
 }
 
 /*******************************************************
 Function:
-	Esd protect function.
-	Added external watchdog by meta, 2013/03/07
+    Esd protect function.
+    External watchdog added by meta, 2013/03/07
 Input:
-	work: delayed work
+    work: delayed work
 Output:
-	None.
+    None.
 *******************************************************/
 static void gtp_esd_check_func(struct work_struct *work)
 {
-	s32 retry;
+	s32 i;
 	s32 ret = -1;
 	struct goodix_ts_data *ts = NULL;
-	u8 test[4] = {0x80, 0x40};
+	u8 esd_buf[5] = {0x80, 0x40};
+
+	GTP_DEBUG_FUNC();
 
 	ts = i2c_get_clientdata(i2c_connect_client);
 
 	if (ts->gtp_is_suspend) {
-		dev_dbg(&ts->client->dev, "Esd terminated!\n");
-		ts->esd_running = 0;
+		GTP_INFO("Esd suspended!");
 		return;
 	}
-#ifdef CONFIG_GT9XX_TOUCHPANEL_UPDATE
-	if (ts->enter_update)
-		return;
-#endif
 
-	for (retry = 0; retry < GTP_I2C_RETRY_3; retry++) {
-		ret = gtp_i2c_read(ts->client, test, 4);
+	for (i = 0; i < 3; i++) {
+		ret = gtp_i2c_read_no_rst(ts->client, esd_buf, 4);
 
+		GTP_DEBUG("[Esd]0x8040 = 0x%02X, 0x8041 = 0x%02X", esd_buf[2],
+			  esd_buf[3]);
 		if ((ret < 0)) {
-			/* IC works abnormally..*/
+			/* IIC communication problem */
 			continue;
 		} else {
-			if ((test[2] == 0xAA) || (test[3] != 0xAA)) {
-				/* IC works abnormally..*/
-				retry = GTP_I2C_RETRY_3;
-				break;
+			if ((esd_buf[2] == 0xAA) || (esd_buf[3] != 0xAA)) {
+				/* IC works abnormally.. */
+				u8 chk_buf[4] = {0x80, 0x40};
+
+				gtp_i2c_read_no_rst(ts->client, chk_buf, 4);
+
+				GTP_DEBUG
+				    ("[Check]0x8040 = 0x%02X, 0x8041 = 0x%02X",
+				     chk_buf[2], chk_buf[3]);
+
+				if ((chk_buf[2] == 0xAA)
+				    || (chk_buf[3] != 0xAA)) {
+					i = 3;
+					break;
+				} else
+					continue;
 			} else {
-				/* IC works normally, Write 0x8040 0xAA*/
-				test[2] = 0xAA;
-				gtp_i2c_write(ts->client, test, 3);
+				/* IC works normally,
+				  * Write 0x8040 0xAA,
+				  * feed the dog
+				  */
+				esd_buf[2] = 0xAA;
+				gtp_i2c_write_no_rst(ts->client, esd_buf, 3);
 				break;
 			}
 		}
 	}
-	if (retry == GTP_I2C_RETRY_3) {
-		dev_err(&ts->client->dev,
-			"IC Working ABNORMALLY, Resetting Guitar...\n");
-		gtp_reset_guitar(ts, 50);
+	if (i >= 3) {
+#if GTP_COMPATIBLE_MODE
+		if (CHIP_TYPE_GT9F == ts->chip_type) {
+			if (ts->rqst_processing)
+				GTP_INFO("Request processing, no esd recovery");
+			else {
+				GTP_ERROR("IC working abnormally!");
+				esd_buf[0] = 0x42;
+				esd_buf[1] = 0x26;
+				esd_buf[2] = 0x01;
+				esd_buf[3] = 0x01;
+				esd_buf[4] = 0x01;
+				gtp_i2c_write_no_rst(ts->client, esd_buf, 5);
+				msleep(50);
+				gtp_esd_recovery(ts->client);
+			}
+		} else
+#endif
+		{
+			GTP_ERROR
+			    ("IC working abnormally! Process reset guitar.");
+			esd_buf[0] = 0x42;
+			esd_buf[1] = 0x26;
+			esd_buf[2] = 0x01;
+			esd_buf[3] = 0x01;
+			esd_buf[4] = 0x01;
+			gtp_i2c_write_no_rst(ts->client, esd_buf, 5);
+			msleep(50);
+			gtp_reset_guitar(ts->client, 50);
+			msleep(50);
+			gtp_send_cfg(ts->client);
+		}
 	}
 
 	if (!ts->gtp_is_suspend)
-		queue_delayed_work(gtp_esd_check_workqueue,
-			&gtp_esd_check_work, GTP_ESD_CHECK_CIRCLE);
-	else {
-		dev_dbg(&ts->client->dev, "Esd terminated!\n");
-		ts->esd_running = 0;
-	}
-
+		queue_delayed_work(gtp_esd_check_workqueue, &gtp_esd_check_work,
+				   ts->clk_tick_cnt);
+	else
+		GTP_INFO("Esd suspended!");
 	return;
 }
 #endif
@@ -2504,26 +3778,26 @@ static const struct dev_pm_ops goodix_ts_dev_pm_ops = {
 #endif
 
 static const struct i2c_device_id goodix_ts_id[] = {
-	{ GTP_I2C_NAME, 0 },
-	{ }
+	{GTP_I2C_NAME, 0},
+	{}
 };
 
 static struct of_device_id goodix_match_table[] = {
-	{ .compatible = "goodix,gt9xx", },
-	{ },
+	{.compatible = "goodix,gt9xx",},
+	{},
 };
 
 static struct i2c_driver goodix_ts_driver = {
-	.probe      = goodix_ts_probe,
-	.remove     = goodix_ts_remove,
+	.probe = goodix_ts_probe,
+	.remove = goodix_ts_remove,
 #ifdef CONFIG_HAS_EARLYSUSPEND
-	.suspend    = goodix_ts_early_suspend,
-	.resume     = goodix_ts_late_resume,
+	.suspend = goodix_ts_early_suspend,
+	.resume = goodix_ts_late_resume,
 #endif
-	.id_table   = goodix_ts_id,
+	.id_table = goodix_ts_id,
 	.driver = {
-		.name     = GTP_I2C_NAME,
-		.owner    = THIS_MODULE,
+		.name = GTP_I2C_NAME,
+		.owner = THIS_MODULE,
 		.of_match_table = goodix_match_table,
 #if CONFIG_PM
 		.pm = &goodix_ts_dev_pm_ops,
@@ -2541,27 +3815,35 @@ Output:
 ********************************************************/
 static int __init goodix_ts_init(void)
 {
-	int ret;
-
+	GTP_DEBUG_FUNC();
+	GTP_INFO("GTP driver installing...");
+	goodix_wq = create_singlethread_workqueue("goodix_wq");
+	if (!goodix_wq) {
+		GTP_ERROR("Creat workqueue failed.");
+		return -ENOMEM;
+	}
 #if GTP_ESD_PROTECT
 	INIT_DELAYED_WORK(&gtp_esd_check_work, gtp_esd_check_func);
 	gtp_esd_check_workqueue = create_workqueue("gtp_esd_check");
 #endif
-	ret = i2c_add_driver(&goodix_ts_driver);
-	return ret;
+	return i2c_add_driver(&goodix_ts_driver);
 }
 
 /*******************************************************
 Function:
-	Driver uninstall function.
+    Driver uninstall function.
 Input:
-	None.
+    None.
 Output:
-	Executive Outcomes. 0---succeed.
+    Executive Outcomes. 0---succeed.
 ********************************************************/
 static void __exit goodix_ts_exit(void)
 {
+	GTP_DEBUG_FUNC();
+	GTP_INFO("GTP driver exited.");
 	i2c_del_driver(&goodix_ts_driver);
+	if (goodix_wq)
+		destroy_workqueue(goodix_wq);
 }
 
 module_init(goodix_ts_init);
diff --git a/drivers/input/touchscreen/gt9xx/gt9xx.h b/drivers/input/touchscreen/gt9xx/gt9xx.h
index 3cedf26..b7590ac 100644
--- a/drivers/input/touchscreen/gt9xx/gt9xx.h
+++ b/drivers/input/touchscreen/gt9xx/gt9xx.h
@@ -1,12 +1,8 @@
 /* drivers/input/touchscreen/gt9xx.h
  *
+ * 2010 - 2014 Goodix Technology.
  * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
  *
- * Linux Foundation chooses to take subject only to the GPLv2 license
- * terms, and distributes only under these terms.
- *
- * 2010 - 2013 Goodix Technology.
- *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
@@ -24,10 +20,22 @@
 #define _GOODIX_GT9XX_H_
 
 #include <linux/kernel.h>
+#include <linux/hrtimer.h>
 #include <linux/i2c.h>
+#include <linux/irq.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/module.h>
 #include <linux/delay.h>
-#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/proc_fs.h>
+#include <linux/debugfs.h>
+#include <linux/string.h>
 #include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <mach/gpio.h>
 
 #if defined(CONFIG_FB)
 #include <linux/notifier.h>
@@ -36,18 +44,59 @@
 #include <linux/earlysuspend.h>
 #define GOODIX_SUSPEND_LEVEL 1
 #endif
+/***************************PART1:ON/OFF define*******************************/
+#define UPDATE_FUNCTIONS
+
+#define GTP_CUSTOM_CFG        0
+#define GTP_CHANGE_X2Y        0
+#define GTP_DRIVER_SEND_CFG   1
+#define GTP_HAVE_TOUCH_KEY    1
+#define GTP_POWER_CTRL_SLEEP  0
+#define GTP_ICS_SLOT_REPORT   1
+
+#define GTP_AUTO_UPDATE       0	/* auto update fw by .bin file as default */
+#define GTP_HEADER_FW_UPDATE  0	/* auto update fw by gtp_default_FW
+				  * in gt9xx_firmware.h, function together
+				  * with GTP_AUTO_UPDATE
+				  */
+#define GTP_AUTO_UPDATE_CFG   0	/* auto update config by .cfg file,
+				  *function together with GTP_AUTO_UPDATE
+				  */
+
+#define GTP_COMPATIBLE_MODE   0	/* compatible with GT9XXF */
 
-#define MAX_BUTTONS 4
+#define GTP_CREATE_WR_NODE    1
+#define GTP_ESD_PROTECT       0	/* esd protection with a cycle of 2 seconds */
+
+#define GTP_WITH_PEN          0
+#define GTP_PEN_HAVE_BUTTON   0	/* active pen has buttons, function
+				  * together with GTP_WITH_PEN
+				  */
+
+#define GTP_GESTURE_WAKEUP    0	/* gesture wakeup */
+
+#define GTP_DEBUG_ON          0
+#define GTP_DEBUG_ARRAY_ON    0
+#define GTP_DEBUG_FUNC_ON     0
+
+#if GTP_COMPATIBLE_MODE
+enum chip_type_t {
+	CHIP_TYPE_GT9 = 0,
+	CHIP_TYPE_GT9F = 1,
+};
+#endif
 #define GOODIX_MAX_CFG_GROUP	6
 #define GTP_FW_NAME_MAXSIZE	50
-
 struct goodix_ts_platform_data {
 	int irq_gpio;
 	u32 irq_gpio_flags;
 	int reset_gpio;
 	u32 reset_gpio_flags;
+	u32 num_max_touches;
+	u32 soft_rst_dly;
 	const char *product_id;
 	const char *fw_name;
+	char *name;
 	u32 x_max;
 	u32 y_max;
 	u32 x_min;
@@ -56,54 +105,62 @@ struct goodix_ts_platform_data {
 	u32 panel_miny;
 	u32 panel_maxx;
 	u32 panel_maxy;
-	bool force_update;
+	bool no_force_update;
 	bool i2c_pull_up;
 	bool enable_power_off;
+	bool fw_vkey_support;
 	size_t config_data_len[GOODIX_MAX_CFG_GROUP];
 	u8 *config_data[GOODIX_MAX_CFG_GROUP];
-	u32 button_map[MAX_BUTTONS];
-	u8 num_button;
-	bool have_touch_key;
-	bool driver_send_cfg;
-	bool change_x2y;
-	bool with_pen;
-	bool slide_wakeup;
-	bool dbl_clk_wakeup;
 };
 struct goodix_ts_data {
 	spinlock_t irq_lock;
 	struct i2c_client *client;
-	struct input_dev  *input_dev;
+	struct input_dev *input_dev;
 	struct goodix_ts_platform_data *pdata;
 	struct hrtimer timer;
-	struct workqueue_struct *goodix_wq;
-	struct work_struct	work;
-	char fw_name[GTP_FW_NAME_MAXSIZE];
-	struct delayed_work goodix_update_work;
-	s32 irq_is_disabled;
+	struct work_struct work;
+	u8 enable;
+	u16 addr;
+	s32 irq_is_disable;
 	s32 use_irq;
 	u16 abs_x_max;
 	u16 abs_y_max;
-	u16 addr;
-	u8  max_touch_num;
-	u8  int_trigger_type;
-	u8  green_wake_mode;
-	u8  chip_type;
-	u8 *config_data;
-	u8  enter_update;
-	u8  gtp_is_suspend;
-	u8  gtp_rawdiff_mode;
-	u8  gtp_cfg_len;
-	u8  fixed_cfg;
-	u8  esd_running;
-	u8  fw_error;
-	bool power_on;
-	struct mutex lock;
+	u8 max_touch_num;
+	u8 int_trigger_type;
+	u8 green_wake_mode;
+	u8 enter_update;
+	u8 gtp_is_suspend;
+	u8 gtp_rawdiff_mode;
+	u8 gtp_cfg_len;
+	u8 fixed_cfg;
+	u8 fw_error;
+	u8 pnl_init_error;
 	bool fw_loading;
+	char fw_name[GTP_FW_NAME_MAXSIZE];
+	char *ts_info;
 	bool force_update;
-	struct regulator *avdd;
 	struct regulator *vdd;
 	struct regulator *vcc_i2c;
+	bool power_on;
+#if GTP_WITH_PEN
+	struct input_dev *pen_dev;
+#endif
+
+#if GTP_ESD_PROTECT
+	spinlock_t esd_lock;
+	u8 esd_running;
+	s32 clk_tick_cnt;
+#endif
+
+#if GTP_COMPATIBLE_MODE
+	u16 bak_ref_len;
+	s32 ref_chk_fs_times;
+	s32 clk_chk_fs_times;
+	enum chip_type_t chip_type;
+	u8 rqst_processing;
+	u8 is_950;
+#endif
+	struct mutex lock;
 #if defined(CONFIG_FB)
 	struct notifier_block fb_notif;
 #elif defined(CONFIG_HAS_EARLYSUSPEND)
@@ -115,111 +172,227 @@ struct goodix_ts_data {
 extern u16 show_len;
 extern u16 total_len;
 
-/***************************PART1:ON/OFF define*******************************/
-#define GTP_CUSTOM_CFG			0
-#define GTP_ESD_PROTECT			0
+/******************* PART2:TODO define *************************/
+/* STEP_1(REQUIRED): Define Configuration Information Group(s)
+    Sensor_ID Map:
+   sensor_opt1 sensor_opt2 Sensor_ID
+    GND         GND         0
+    VDDIO       GND         1
+    NC          GND         2
+    GND         NC/300K     3
+    VDDIO       NC/300K     4
+    NC          NC/300K     5
+*/
+/* TODO: define your own default or for Sensor_ID == 0 config here. */
+/* The predefined one is just a sample config,
+  * which is not suitable for your tp in most cases.
+  */
+#define CTP_CFG_GROUP1 {\
+	0x41, 0xD0, 0x02, 0x00, 0x05, 0x05, 0x34, 0xC1, 0x01, 0x08,\
+	0x28, 0x0F, 0x50, 0x2D, 0x03, 0x05, 0x01, 0x01, 0x00, 0x00,\
+	0x00, 0x00, 0x00, 0x17, 0x19, 0x1B, 0x14, 0x88, 0x27, 0x0A,\
+	0x33, 0x35, 0xD0, 0x05, 0x00, 0x00, 0x00, 0x99, 0x03, 0x11,\
+	0x14, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,\
+	0x00, 0x23, 0x4B, 0x94, 0xC5, 0x02, 0x00, 0x00, 0x00, 0x04,\
+	0xAB, 0x25, 0x00, 0x92, 0x2C, 0x00, 0x80, 0x33, 0x00, 0x70,\
+	0x3B, 0x00, 0x61, 0x45, 0x00, 0x61, 0x10, 0x28, 0x48, 0x00,\
+	0xF0, 0x4A, 0x3A, 0xFF, 0xFF, 0x27, 0x00, 0x00, 0x00, 0x00,\
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
+	0x3C, 0x1E, 0x08, 0x0A, 0x0C, 0x0E, 0x10, 0x12, 0x14, 0x16,\
+	0x18, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
+	0x00, 0x00, 0x20, 0x28, 0x1F, 0x24, 0x1E, 0x22, 0x1D, 0x06,\
+	0x08, 0x05, 0x0A, 0x04, 0x0C, 0x02, 0x00, 0x00, 0x00, 0x00,\
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x14, 0x5A, 0x00, 0x00,\
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x50, 0x00, 0x00, 0x00,\
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEE, 0x01\
+}
+
+/* TODO: define your config for Sensor_ID == 1 here, if needed */
+#define CTP_CFG_GROUP2 {\
+}
+
+/* TODO: define your config for Sensor_ID == 2 here, if needed */
+#define CTP_CFG_GROUP3 {\
+}
+
+/* TODO: define your config for Sensor_ID == 3 here, if needed */
+#define CTP_CFG_GROUP4 {\
+}
 
-#define GTP_IRQ_TAB            {\
-				IRQ_TYPE_EDGE_RISING,\
-				IRQ_TYPE_EDGE_FALLING,\
-				IRQ_TYPE_LEVEL_LOW,\
-				IRQ_TYPE_LEVEL_HIGH\
-				}
+/* TODO: define your config for Sensor_ID == 4 here, if needed */
+#define CTP_CFG_GROUP5 {\
+}
 
+/* TODO: define your config for Sensor_ID == 5 here, if needed */
+#define CTP_CFG_GROUP6 {\
+}
 
-#define GTP_IRQ_TAB_RISING	0
-#define GTP_IRQ_TAB_FALLING	1
+/* STEP_2(REQUIRED): Customize your I/O ports & I/O operations */
+#define GTP_IRQ_TAB	{\
+	IRQ_TYPE_EDGE_RISING, \
+	IRQ_TYPE_EDGE_FALLING, \
+	IRQ_TYPE_LEVEL_LOW, \
+	IRQ_TYPE_LEVEL_HIGH }
+
+/* STEP_3(optional): Specify your special config info if needed */
 #if GTP_CUSTOM_CFG
-#define GTP_MAX_HEIGHT		800
-#define GTP_MAX_WIDTH		480
-#define GTP_INT_TRIGGER		GTP_IRQ_TAB_RISING
+#define GTP_MAX_HEIGHT   800
+#define GTP_MAX_WIDTH    480
+#define GTP_INT_TRIGGER  0	/* 0: Rising 1: Falling */
 #else
-#define GTP_MAX_HEIGHT		4096
-#define GTP_MAX_WIDTH		4096
-#define GTP_INT_TRIGGER		GTP_IRQ_TAB_FALLING
+#define GTP_MAX_HEIGHT   4096
+#define GTP_MAX_WIDTH    4096
+#define GTP_INT_TRIGGER  1
 #endif
+#define GTP_MAX_TOUCH    5
 
-#define GTP_PRODUCT_ID_MAXSIZE	5
-#define GTP_PRODUCT_ID_BUFFER_MAXSIZE	6
-#define GTP_FW_VERSION_BUFFER_MAXSIZE	4
-#define GTP_MAX_TOUCH		5
-#define GTP_ESD_CHECK_CIRCLE	2000      /* jiffy: ms */
+/* STEP_4(optional): If keys are available and
+  * reported as keys, config your key info here
+  */
+#if GTP_HAVE_TOUCH_KEY
+#define GTP_KEY_TAB  {KEY_MENU, KEY_HOMEPAGE, KEY_BACK}
+#endif
 
 /***************************PART3:OTHER define*********************************/
-#define GTP_DRIVER_VERSION	"V1.8.1<2013/09/01>"
-#define GTP_I2C_NAME		"Goodix-TS"
-#define GTP_POLL_TIME		10     /* jiffy: ms*/
-#define GTP_ADDR_LENGTH		2
-#define GTP_CONFIG_MIN_LENGTH	186
-#define GTP_CONFIG_MAX_LENGTH	240
-#define FAIL			0
-#define SUCCESS			1
-#define SWITCH_OFF		0
-#define SWITCH_ON		1
+#define GTP_DRIVER_VERSION          "V2.2<2014/01/14>"
+#define GTP_I2C_NAME                "Goodix-TS"
+#define GT91XX_CONFIG_PROC_FILE     "gt9xx_config"
+#define GTP_POLL_TIME         10
+#define GTP_ADDR_LENGTH       2
+#define GTP_CONFIG_MIN_LENGTH 186
+#define GTP_CONFIG_MAX_LENGTH 240
+#define FAIL                  0
+#define SUCCESS               1
+#define SWITCH_OFF            0
+#define SWITCH_ON             1
+
+/******************** For GT9XXF Start **********************/
+#define GTP_REG_BAK_REF                 0x99D0
+#define GTP_REG_MAIN_CLK                0x8020
+#define GTP_REG_CHIP_TYPE               0x8000
+#define GTP_REG_HAVE_KEY                0x804E
+#define GTP_REG_MATRIX_DRVNUM           0x8069
+#define GTP_REG_MATRIX_SENNUM           0x806A
 
+#define GTP_FL_FW_BURN              0x00
+#define GTP_FL_ESD_RECOVERY         0x01
+#define GTP_FL_READ_REPAIR          0x02
+
+#define GTP_BAK_REF_SEND                0
+#define GTP_BAK_REF_STORE               1
+#define CFG_LOC_DRVA_NUM                29
+#define CFG_LOC_DRVB_NUM                30
+#define CFG_LOC_SENS_NUM                31
+
+#define GTP_CHK_FW_MAX                  40
+#define GTP_CHK_FS_MNT_MAX              300
+#define GTP_BAK_REF_PATH                "/data/gtp_ref.bin"
+#define GTP_MAIN_CLK_PATH               "/data/gtp_clk.bin"
+#define GTP_RQST_CONFIG                 0x01
+#define GTP_RQST_BAK_REF                0x02
+#define GTP_RQST_RESET                  0x03
+#define GTP_RQST_MAIN_CLOCK             0x04
+#define GTP_RQST_RESPONDED              0x00
+#define GTP_RQST_IDLE                   0xFF
+
+/******************** For GT9XXF End **********************/
 /* Registers define */
 #define GTP_READ_COOR_ADDR	0x814E
 #define GTP_REG_SLEEP		0x8040
 #define GTP_REG_SENSOR_ID	0x814A
 #define GTP_REG_CONFIG_DATA	0x8047
-#define GTP_REG_FW_VERSION	0x8144
-#define GTP_REG_PRODUCT_ID	0x8140
-
-#define GTP_I2C_RETRY_3		3
-#define GTP_I2C_RETRY_5		5
-#define GTP_I2C_RETRY_10	10
+#define GTP_REG_VERSION		0x8140
+#define GTP_VALID_ADDR_START	0x8040
+#define GTP_VALID_ADDR_END	0x8177
 
 #define RESOLUTION_LOC		3
 #define TRIGGER_LOC		8
 
-/* HIGH: 0x28/0x29, LOW: 0xBA/0xBB */
-#define GTP_I2C_ADDRESS_HIGH	0x14
-#define GTP_I2C_ADDRESS_LOW	0x5D
-#define GTP_VALID_ADDR_START	0x8040
-#define GTP_VALID_ADDR_END	0x8177
-
-#define CFG_GROUP_LEN(p_cfg_grp) (sizeof(p_cfg_grp) / sizeof(p_cfg_grp[0]))
-
-/* GTP CM_HEAD RW flags */
-#define GTP_RW_READ			0
-#define GTP_RW_WRITE			1
-#define GTP_RW_READ_IC_TYPE		2
-#define GTP_RW_WRITE_IC_TYPE		3
-#define GTP_RW_FILL_INFO		4
-#define GTP_RW_NO_WRITE			5
-#define GTP_RW_READ_ERROR		6
-#define GTP_RW_DISABLE_IRQ		7
-#define GTP_RW_READ_VERSION		8
-#define GTP_RW_ENABLE_IRQ		9
-#define GTP_RW_ENTER_UPDATE_MODE	11
-#define GTP_RW_LEAVE_UPDATE_MODE	13
-#define GTP_RW_UPDATE_FW		15
-#define GTP_RW_CHECK_RAWDIFF_MODE	17
-
-/* GTP need flag or interrupt */
-#define GTP_NO_NEED			0
-#define GTP_NEED_FLAG			1
-#define GTP_NEED_INTERRUPT		2
+#define CFG_GROUP_LEN(p_cfg_grp)  (sizeof(p_cfg_grp) / sizeof(p_cfg_grp[0]))
+/* Log define */
+#define GTP_INFO(fmt, arg...) pr_info("<<-GTP-INFO->> "fmt"\n", ##arg)
+#define GTP_ERROR(fmt, arg...) pr_err("<<-GTP-ERROR->> "fmt"\n", ##arg)
+#define GTP_DEBUG(fmt, arg...) \
+	do {\
+		if (GTP_DEBUG_ON)\
+			pr_debug("<<-GTP-DEBUG->> [%d]"fmt"\n",\
+					__LINE__, ##arg);\
+	} while (0)
+#define GTP_DEBUG_ARRAY(array, num) \
+	do {\
+		s32 i;\
+		u8 *a = array;\
+		if (GTP_DEBUG_ARRAY_ON) {\
+			pr_debug("<<-GTP-DEBUG-ARRAY->>\n");\
+			for (i = 0; i < (num); i++) {\
+				pr_debug("%02x   ", (a)[i]);\
+				if ((i + 1) % 10 == 0) \
+					pr_debug("\n");\
+			} \
+			pr_debug("\n");\
+		} \
+	} while (0)
+#define GTP_DEBUG_FUNC() \
+	do {\
+		if (GTP_DEBUG_FUNC_ON)\
+			pr_debug("<<-GTP-FUNC->> Func:%s@Line:%d\n",\
+					__func__, __LINE__);\
+	} while (0)
+#define GTP_SWAP(x, y) \
+	do {\
+		typeof(x) z = x;\
+		x = y;\
+		y = z;\
+	} while (0)
 
 /*****************************End of Part III********************************/
+extern struct i2c_client *i2c_connect_client;
+extern u8 config[GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH];
+void gtp_reset_guitar(struct i2c_client *client, s32 ms);
+s32 gtp_send_cfg(struct i2c_client *client);
+s32 gtp_read_version(struct i2c_client *, u16 *);
+s32 gtp_i2c_read_dbl_check(struct i2c_client *, u16, u8 *, int);
 
-void gtp_esd_switch(struct i2c_client *client, int on);
+#ifdef UPDATE_FUNCTIONS
+s32 gup_enter_update_mode(struct i2c_client *client);
+void gup_leave_update_mode(void);
+s32 gup_update_proc(void *dir);
+#endif
+
+void gtp_irq_disable(struct goodix_ts_data *);
+void gtp_irq_enable(struct goodix_ts_data *);
 
-int gtp_i2c_read_dbl_check(struct i2c_client *client, u16 addr,
-					u8 *rxbuf, int len);
-int gtp_send_cfg(struct goodix_ts_data *ts);
-void gtp_reset_guitar(struct goodix_ts_data *ts, int ms);
-void gtp_irq_disable(struct goodix_ts_data *ts);
-void gtp_irq_enable(struct goodix_ts_data *ts);
+#if GTP_ESD_PROTECT
+void gtp_esd_switch(struct i2c_client *, s32);
+#endif
 
 #ifdef CONFIG_GT9XX_TOUCHPANEL_DEBUG
-s32 init_wr_node(struct i2c_client *client);
+#if GTP_CREATE_WR_NODE
+s32 init_wr_node(struct i2c_client *);
 void uninit_wr_node(void);
 #endif
+#endif
+
+#if GTP_AUTO_UPDATE
+extern u8 gup_init_update_proc(struct goodix_ts_data *);
+#endif
+
+#if GTP_COMPATIBLE_MODE
+s32 i2c_read_bytes(struct i2c_client *client, u16 addr, u8 *buf,
+			  s32 len);
+s32 i2c_write_bytes(struct i2c_client *client, u16 addr, u8 *buf,
+			   s32 len);
+s32 gup_clk_calibration(void);
+s32 gup_fw_download_proc(void *dir, u8 dwn_mode);
+u8 gup_check_fs_mounted(char *path_name);
+void gtp_recovery_reset(struct i2c_client *client);
+s32 gtp_fw_startup(struct i2c_client *client);
+#endif
 
-u8 gup_init_update_proc(struct goodix_ts_data *ts);
-s32 gup_enter_update_mode(struct i2c_client *client);
-void gup_leave_update_mode(struct i2c_client *client);
-s32 gup_update_proc(void *dir);
-extern struct i2c_client  *i2c_connect_client;
 #endif /* _GOODIX_GT9XX_H_ */
diff --git a/drivers/input/touchscreen/gt9xx/gt9xx_firmware.h b/drivers/input/touchscreen/gt9xx/gt9xx_firmware.h
new file mode 100644
index 0000000..59f38c8
--- /dev/null
+++ b/drivers/input/touchscreen/gt9xx/gt9xx_firmware.h
@@ -0,0 +1,4638 @@
+/* Copyright Statement:
+ * This firmware are protected under relevant copyright laws,
+ * this information contained
+ * herein is confidential and proprietary to Goodix.
+ *
+ * GOODIX (C) 2014. All rights reserved.
+ * Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * WARNING:The GTP_COMPATIBLE_MODE part of this file
+ * was generated by the specialized tools,
+ * please do not modify it manually!
+ *
+ */
+
+#ifndef _GT9XX_FIRMWARE_H_
+#define _GT9XX_FIRMWARE_H_
+
+#if GTP_HEADER_FW_UPDATE
+unsigned char gtp_default_FW[] = {
+	/* TODO:Puts your update firmware data here! */
+};
+#endif
+
+#if GTP_COMPATIBLE_MODE
+unsigned char gtp_default_FW_fl[] = {
+	0x00, 0x90, 0x06, 0x00, 0x39, 0x35, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
+	    0x10, 0x40, 0x80, 0x00,
+	0x55, 0x40, 0xa4, 0x28, 0xb3, 0x26, 0x69, 0xf0, 0x0c, 0xc1, 0x38, 0xa8,
+	    0xd5, 0xa0, 0x88, 0xb0,
+	0x01, 0x41, 0xf0, 0x90, 0x72, 0x37, 0x32, 0xe0, 0x1d, 0xc9, 0x26, 0xca,
+	    0x49, 0x8c, 0x01, 0x8d,
+	0x05, 0x02, 0xa5, 0x49, 0xf3, 0xdd, 0x12, 0x6b, 0x4d, 0x21, 0x39, 0x24,
+	    0xeb, 0x96, 0x09, 0x0d,
+	0x87, 0x03, 0x49, 0x39, 0x72, 0x6f, 0x09, 0x7b, 0x4d, 0x4b, 0xc0, 0x30,
+	    0x04, 0x0f, 0x60, 0x1c,
+	0xa3, 0x68, 0x68, 0xc9, 0x90, 0x20, 0x7a, 0xb0, 0xe1, 0x5f, 0x89, 0x55,
+	    0xf7, 0x9b, 0x16, 0x3c,
+	0x0b, 0xae, 0x28, 0xd5, 0x20, 0xe1, 0x10, 0x98, 0xd7, 0x07, 0x81, 0xe0,
+	    0xf4, 0x7e, 0x85, 0x61,
+	0x23, 0xc6, 0x5d, 0x27, 0x36, 0x8b, 0x07, 0x87, 0x40, 0x42, 0x88, 0x55,
+	    0x77, 0x97, 0xd4, 0xb1,
+	0x01, 0x03, 0x13, 0x54, 0xa0, 0x06, 0x5e, 0x17, 0xc5, 0xbc, 0xcd, 0x13,
+	    0xe0, 0x73, 0x47, 0xac,
+	0x2c, 0x48, 0x35, 0x8e, 0x1b, 0xcc, 0x10, 0xda, 0x0f, 0x4c, 0x56, 0x72,
+	    0x56, 0x76, 0x9a, 0x3c,
+	0x2f, 0x49, 0xc2, 0x0a, 0xba, 0x2f, 0x20, 0x3a, 0x55, 0x69, 0xc7, 0x5e,
+	    0xa6, 0x2b, 0x58, 0x5c,
+	0x0f, 0x08, 0xd9, 0x1d, 0x3b, 0x2c, 0x17, 0x7d, 0x2f, 0xb4, 0xee, 0xd6,
+	    0x5a, 0x6e, 0x5a, 0x19,
+	0xaf, 0x48, 0x03, 0xb1, 0x78, 0x24, 0x9b, 0x29, 0xd9, 0x49, 0x44, 0x1e,
+	    0x5b, 0x0c, 0x49, 0x2a,
+	0x39, 0xea, 0x7a, 0xb3, 0x3b, 0x4c, 0x66, 0x80, 0xd8, 0xb1, 0x40, 0x85,
+	    0x10, 0x03, 0xca, 0x18,
+	0x07, 0x86, 0x8e, 0x45, 0x28, 0x8c, 0x03, 0x0c, 0x4d, 0xfd, 0x83, 0xe8,
+	    0xfe, 0x99, 0xbb, 0x2f,
+	0x05, 0x88, 0x9a, 0x5b, 0xde, 0x2f, 0xab, 0xeb, 0x4a, 0xe5, 0x8a, 0xfc,
+	    0x7f, 0x91, 0xcb, 0xbf,
+	0x09, 0x0b, 0x73, 0xa3, 0xa8, 0xae, 0xe3, 0xfd, 0xb4, 0x6a, 0xa3, 0x4f,
+	    0x24, 0x74, 0x04, 0x80,
+	0x78, 0xf8, 0x7c, 0x74, 0x38, 0x3f, 0x2c, 0xc0, 0xd0, 0x58, 0xb4, 0xec,
+	    0xd1, 0x76, 0xde, 0xb0,
+	0x26, 0xe9, 0x64, 0xae, 0xb3, 0x19, 0xe5, 0xc2, 0xef, 0x34, 0xbc, 0xfd,
+	    0xd0, 0x77, 0x4f, 0x28,
+	0x82, 0x11, 0x2d, 0xbb, 0x37, 0x47, 0x64, 0xd3, 0x6e, 0x37, 0xb1, 0xf1,
+	    0x53, 0x74, 0x02, 0x1d,
+	0x24, 0xe6, 0x0b, 0x65, 0xf5, 0x3c, 0x64, 0xc3, 0x6f, 0x36, 0xb9, 0xe0,
+	    0x52, 0x75, 0x42, 0x00,
+	0x42, 0x9f, 0x6b, 0xba, 0xef, 0x30, 0x34, 0xe2, 0x6d, 0x4f, 0x2f, 0x66,
+	    0x90, 0x86, 0x76, 0x60,
+	0xc1, 0xba, 0x33, 0x3c, 0x6b, 0xc8, 0x87, 0x47, 0x1c, 0x6d, 0x01, 0x68,
+	    0x92, 0xca, 0x51, 0xfd,
+	0x49, 0x52, 0xc7, 0x2d, 0x9a, 0x7b, 0xf0, 0x65, 0xb6, 0x83, 0xad, 0xc2,
+	    0x0f, 0x79, 0xe9, 0x21,
+	0x5c, 0x18, 0x35, 0x3d, 0xdb, 0x7a, 0x06, 0xf3, 0x98, 0xf9, 0x1d, 0x09,
+	    0x58, 0x71, 0xc6, 0x75,
+	0x32, 0xb3, 0xe6, 0xcd, 0x7c, 0x37, 0x3f, 0xfb, 0xec, 0x44, 0xb6, 0xe0,
+	    0xd9, 0x7e, 0x79, 0x69,
+	0x1e, 0x1c, 0x09, 0x7e, 0xbb, 0x11, 0x66, 0x9f, 0xf8, 0xf5, 0xbe, 0xf1,
+	    0xd8, 0x7f, 0x37, 0xd7,
+	0xc3, 0x21, 0xe7, 0xcc, 0xf0, 0xb1, 0xbe, 0xfa, 0x64, 0x06, 0xb3, 0xe5,
+	    0x5b, 0x7c, 0x51, 0x69,
+	0x92, 0xb0, 0x8d, 0x7f, 0xbf, 0xb3, 0xbf, 0xf3, 0x7c, 0xf7, 0xbb, 0xf4,
+	    0x5a, 0xa0, 0xf9, 0xf9,
+	0x8b, 0x9d, 0x39, 0x24, 0x5a, 0x71, 0x8b, 0xa0, 0x6c, 0x67, 0xf6, 0x85,
+	    0xdb, 0xd3, 0x4f, 0x3e,
+	0x48, 0x17, 0xc8, 0x83, 0xce, 0xc1, 0x4b, 0x00, 0xeb, 0xe6, 0x42, 0x78,
+	    0x3c, 0x23, 0xe2, 0x23,
+	0x4b, 0x51, 0x3c, 0x0a, 0x64, 0x36, 0x0a, 0x15, 0x04, 0xa5, 0x4f, 0xca,
+	    0x5b, 0xd1, 0xd8, 0x33,
+	0x4a, 0x50, 0xef, 0xdd, 0x67, 0xf4, 0xa9, 0x14, 0xcb, 0x1d, 0x77, 0xd0,
+	    0xfd, 0x4c, 0x20, 0x02,
+	0x04, 0xc0, 0x14, 0x16, 0xb7, 0xe2, 0x20, 0x62, 0xc4, 0xc6, 0xb4, 0x59,
+	    0xf7, 0x3b, 0x28, 0x12,
+	0x05, 0xc1, 0xc8, 0x14, 0x4b, 0x0c, 0x3c, 0xb5, 0x64, 0x56, 0x88, 0xcf,
+	    0xaa, 0xa3, 0xfa, 0x0c,
+	0x84, 0x82, 0x7c, 0x3e, 0x48, 0xc9, 0xed, 0x1b, 0x25, 0x19, 0xc3, 0xda,
+	    0xd9, 0x99, 0x29, 0x8f,
+	0x85, 0x83, 0x75, 0xf5, 0x93, 0x18, 0x8d, 0xcc, 0x86, 0x30, 0x62, 0xd4,
+	    0x34, 0x4c, 0xef, 0x20,
+	0x45, 0x74, 0x58, 0x7a, 0xb1, 0x29, 0x29, 0x64, 0xbb, 0x8b, 0xd1, 0x15,
+	    0xf5, 0xab, 0x30, 0x56,
+	0x47, 0xca, 0xc8, 0x2a, 0xb6, 0xc7, 0x6e, 0x10, 0x2f, 0xc8, 0xdd, 0xf2,
+	    0x0f, 0x89, 0x38, 0x96,
+	0x21, 0xcb, 0xb8, 0x76, 0x31, 0xa0, 0xc5, 0x01, 0x85, 0x36, 0xf0, 0x18,
+	    0x71, 0xdd, 0x09, 0x51,
+	0x8c, 0x8a, 0x2d, 0x87, 0xc9, 0x08, 0x20, 0x06, 0xc1, 0x77, 0x02, 0x08,
+	    0xb7, 0xeb, 0x22, 0x0a,
+	0x0c, 0xc8, 0xe7, 0x8a, 0x63, 0x18, 0x62, 0x59, 0x54, 0x42, 0x7f, 0xc6,
+	    0xc2, 0xa7, 0x2a, 0x1a,
+	0x0d, 0xc9, 0x46, 0xef, 0xaf, 0x39, 0x8e, 0x5a, 0x45, 0x19, 0xba, 0xd8,
+	    0x6e, 0x78, 0x23, 0x96,
+	0x8c, 0x8a, 0x7c, 0xa2, 0x9a, 0x51, 0xf4, 0xd5, 0x2d, 0xac, 0xea, 0x34,
+	    0x3b, 0xf1, 0xa5, 0xcd,
+	0x8d, 0x8b, 0x43, 0x35, 0x1f, 0xa3, 0x94, 0xeb, 0x4c, 0x6a, 0xe1, 0x3a,
+	    0x7a, 0xed, 0x9d, 0xb3,
+	0x4e, 0xce, 0x38, 0x2c, 0x5d, 0xcc, 0x4f, 0xee, 0x31, 0xe9, 0x8d, 0x10,
+	    0x3c, 0x08, 0xd5, 0xbc,
+	0xee, 0x72, 0xb3, 0x54, 0xfa, 0x72, 0x1a, 0x78, 0x0c, 0xd6, 0x82, 0x59,
+	    0xa6, 0xe2, 0xbc, 0x68,
+	0xbd, 0x0a, 0xe1, 0xa7, 0x06, 0x61, 0x2a, 0x6c, 0x33, 0x81, 0x88, 0xed,
+	    0x70, 0x9e, 0x90, 0x24,
+	0x02, 0x09, 0x07, 0xc0, 0x9e, 0x0f, 0xdc, 0xff, 0x9b, 0x1a, 0x6c, 0x80,
+	    0x2a, 0x7c, 0x01, 0x82,
+	0x4f, 0xb4, 0xa0, 0xe6, 0x24, 0xbb, 0x90, 0xec, 0xbb, 0xed, 0x90, 0x5b,
+	    0x25, 0x8b, 0xac, 0x92,
+	0x94, 0x1c, 0x6c, 0x72, 0x67, 0xf0, 0x63, 0xfa, 0x1a, 0xf1, 0x67, 0x55,
+	    0x73, 0x6a, 0xda, 0x87,
+	0xa4, 0xf7, 0x27, 0x7c, 0x4b, 0x6d, 0xde, 0xd4, 0x64, 0x05, 0x95, 0xd5,
+	    0x0f, 0xb0, 0xc9, 0xb4,
+	0x16, 0x1e, 0x05, 0x3f, 0x54, 0xb5, 0xfd, 0xcf, 0x3a, 0x5e, 0x92, 0x35,
+	    0x75, 0xf8, 0xe3, 0x32,
+	0x66, 0x45, 0xbd, 0xf7, 0x93, 0x4b, 0x29, 0x0b, 0xe4, 0xd0, 0x24, 0x94,
+	    0x89, 0xb6, 0x4c, 0x0b,
+	0x86, 0x1f, 0x6a, 0x3e, 0x57, 0xf8, 0x25, 0xc2, 0xc0, 0xb0, 0xda, 0x93,
+	    0xd4, 0x70, 0x9e, 0xc1,
+	0x61, 0x90, 0x5e, 0x80, 0x68, 0xbe, 0xed, 0x81, 0xa5, 0x24, 0x29, 0xa8,
+	    0x1f, 0xbf, 0xea, 0x2c,
+	0xdc, 0xf7, 0x93, 0xee, 0x37, 0xf7, 0x45, 0x23, 0xb9, 0xcc, 0xdb, 0x15,
+	    0x96, 0x58, 0xc2, 0xad,
+	0x2d, 0xf8, 0x08, 0xdc, 0x9f, 0xdd, 0x56, 0xa8, 0x65, 0xd7, 0x8e, 0x2b,
+	    0xfa, 0x79, 0x2f, 0x45,
+	0xce, 0x9d, 0x06, 0xbb, 0xba, 0x3b, 0xc1, 0x58, 0x8c, 0xbc, 0x5e, 0x9e,
+	    0x9c, 0x56, 0xdd, 0x89,
+	0xa4, 0xd5, 0xdf, 0x67, 0x2a, 0xf5, 0x57, 0xa9, 0xe1, 0x51, 0x8f, 0xe8,
+	    0xf2, 0x98, 0x3a, 0xe9,
+	0x23, 0xfe, 0x47, 0x93, 0xaf, 0xf4, 0x47, 0x9c, 0x4e, 0xdd, 0x26, 0x4c,
+	    0xc0, 0xfd, 0xa6, 0x37,
+	0x86, 0x87, 0x41, 0xf7, 0xd7, 0x0d, 0x60, 0x0c, 0xc2, 0xd1, 0xe8, 0x6c,
+	    0xfe, 0xc5, 0x0e, 0x68,
+	0x2a, 0x92, 0xf9, 0xcd, 0x58, 0xb2, 0x84, 0x98, 0xae, 0x57, 0xcc, 0x01,
+	    0x4c, 0x5b, 0xb5, 0xb4,
+	0x09, 0xd3, 0xf1, 0x3b, 0xfc, 0x11, 0x3d, 0xf6, 0xdd, 0xca, 0xcf, 0xfc,
+	    0xd3, 0xf1, 0x36, 0x0e,
+	0x0a, 0x1f, 0xcd, 0x37, 0x37, 0x70, 0xf8, 0x13, 0xc7, 0x90, 0xc1, 0x1d,
+	    0x58, 0xef, 0xbf, 0xe6,
+	0x12, 0x4d, 0xd9, 0xcc, 0xb5, 0xff, 0xbc, 0x01, 0xbe, 0x9b, 0x6f, 0x81,
+	    0xd6, 0x50, 0x1e, 0x72,
+	0xfa, 0x5c, 0xf3, 0xef, 0xe0, 0x2d, 0x9e, 0xd8, 0x36, 0x46, 0xc0, 0x31,
+	    0x32, 0x9e, 0xf8, 0x09,
+	0x25, 0x7d, 0x80, 0x63, 0x6f, 0xaf, 0x61, 0xdc, 0xa4, 0x00, 0x2e, 0xf5,
+	    0xaf, 0x6d, 0xdd, 0xeb,
+	0x78, 0x82, 0xb1, 0x91, 0xcd, 0xab, 0xc6, 0xc5, 0xc7, 0xa3, 0xe1, 0xb7,
+	    0x37, 0x5b, 0xd5, 0x67,
+	0xa3, 0xab, 0x74, 0x26, 0xed, 0xa8, 0x50, 0xe4, 0x55, 0xff, 0x0b, 0x87,
+	    0x76, 0xc9, 0x70, 0xb8,
+	0x8f, 0xca, 0x30, 0x32, 0x9e, 0xa3, 0xe8, 0xfd, 0xa2, 0x26, 0xe2, 0xc5,
+	    0x20, 0xca, 0x52, 0xc3,
+	0x02, 0x5d, 0x8b, 0x58, 0xa1, 0xa4, 0x08, 0x78, 0x67, 0xf9, 0x8e, 0x5d,
+	    0x39, 0x22, 0xfd, 0x33,
+	0xb0, 0xa3, 0xcf, 0x95, 0x9f, 0xac, 0x53, 0x73, 0x3c, 0x5c, 0x7d, 0x17,
+	    0xf7, 0x3a, 0x13, 0xf6,
+	0xf9, 0x8b, 0xdb, 0xad, 0xbd, 0xf7, 0x4b, 0xaa, 0xc8, 0xc0, 0xaa, 0x3c,
+	    0xda, 0xaf, 0x72, 0x3f,
+	0xdc, 0x06, 0xb2, 0xf6, 0x1f, 0xab, 0x20, 0xba, 0xaf, 0xdd, 0x5b, 0xda,
+	    0x6a, 0xe9, 0xb1, 0x8b,
+	0x6a, 0xc9, 0x82, 0x6b, 0x67, 0x24, 0x2b, 0x79, 0xd8, 0x45, 0x9a, 0xcf,
+	    0x39, 0x71, 0x34, 0x29,
+	0x08, 0xd4, 0x72, 0x63, 0x18, 0x26, 0x63, 0xbb, 0x49, 0x71, 0x63, 0xd5,
+	    0x0b, 0x24, 0xb8, 0xa0,
+	0x86, 0xc1, 0xc4, 0xaa, 0x98, 0x28, 0x95, 0x0e, 0x8b, 0x2f, 0xc4, 0x0e,
+	    0x3a, 0x59, 0xad, 0x18,
+	0x49, 0xa0, 0xdc, 0x3e, 0x73, 0x20, 0xa5, 0x0b, 0x64, 0xec, 0x28, 0x8f,
+	    0xd7, 0x2c, 0xbc, 0x3a,
+	0xb6, 0x62, 0x18, 0x2f, 0xd9, 0xde, 0x87, 0xb9, 0x4b, 0xb6, 0xad, 0x6b,
+	    0x3b, 0xed, 0x58, 0xc6,
+	0x8a, 0xff, 0x92, 0x64, 0x3c, 0x4a, 0x63, 0x24, 0x34, 0x0a, 0xcd, 0x1f,
+	    0xbb, 0x4a, 0x1a, 0x66,
+	0x32, 0x5d, 0x40, 0x6b, 0x22, 0x7d, 0x34, 0xed, 0xc1, 0x8f, 0x9c, 0x13,
+	    0x13, 0x50, 0xee, 0x14,
+	0x79, 0x7d, 0xa3, 0xfb, 0xe8, 0xaa, 0x63, 0xce, 0x71, 0x1e, 0xa6, 0x56,
+	    0xf4, 0x24, 0x53, 0xf1,
+	0x07, 0x29, 0x7e, 0x8d, 0x15, 0xcd, 0x75, 0xa3, 0xf5, 0x5f, 0xed, 0x27,
+	    0xf1, 0x05, 0xf6, 0xee,
+	0xc1, 0x02, 0x8d, 0x11, 0xbf, 0xbc, 0x22, 0xb9, 0x46, 0x55, 0xfd, 0x15,
+	    0xfd, 0x7c, 0x24, 0xc2,
+	0x4f, 0x19, 0x50, 0x34, 0xcd, 0x7b, 0x74, 0xf0, 0x89, 0xde, 0xec, 0xd4,
+	    0xcb, 0xdb, 0x73, 0x23,
+	0x17, 0x14, 0x60, 0x3c, 0xbf, 0xf3, 0x9c, 0x0c, 0xdb, 0xd8, 0xa2, 0xf3,
+	    0x57, 0xda, 0x3a, 0xbf,
+	0x49, 0x27, 0xa5, 0x73, 0xef, 0x3b, 0x62, 0x15, 0x1e, 0x9d, 0x75, 0x97,
+	    0x90, 0xb1, 0x1c, 0xc8,
+	0xa5, 0xec, 0x90, 0xf0, 0x1c, 0xba, 0x04, 0xdd, 0x44, 0x15, 0x7d, 0x87,
+	    0x91, 0x90, 0xf9, 0xf6,
+	0x4a, 0xdd, 0xe6, 0x2b, 0x18, 0xe5, 0x36, 0x5d, 0xc9, 0xa7, 0x7e, 0xbd,
+	    0x07, 0x58, 0x76, 0xeb,
+	0x40, 0xb1, 0xa1, 0xf3, 0xe0, 0xa2, 0x1f, 0xc7, 0xce, 0x3c, 0xbe, 0x45,
+	    0xd8, 0x1a, 0xb3, 0x6b,
+	0x04, 0xe7, 0xff, 0xaa, 0x45, 0x35, 0x4e, 0x78, 0x09, 0x15, 0x57, 0xd1,
+	    0x2e, 0x7c, 0x15, 0xf9,
+	0xf3, 0x75, 0x8f, 0x19, 0xb7, 0x76, 0x27, 0x46, 0x4c, 0xe4, 0x7f, 0xa1,
+	    0xdb, 0xab, 0xe6, 0x4a,
+	0xaa, 0xb5, 0x39, 0x48, 0x45, 0x9d, 0x8d, 0x5d, 0x48, 0x8c, 0xa8, 0xeb,
+	    0x5e, 0xdd, 0x76, 0x2b,
+	0x5b, 0xe6, 0x97, 0xf8, 0x7b, 0x72, 0x66, 0xaa, 0x65, 0x3f, 0x7e, 0x8e,
+	    0x19, 0xba, 0x7f, 0x3a,
+	0x96, 0x7b, 0xfd, 0x25, 0xae, 0x71, 0x8e, 0x6b, 0x6a, 0xc5, 0xef, 0xdd,
+	    0x60, 0xd1, 0x55, 0x25,
+	0xab, 0x5d, 0xaf, 0xdf, 0x98, 0x32, 0x15, 0xfc, 0xd8, 0x6d, 0xa1, 0xfa,
+	    0xdf, 0xd2, 0x1b, 0xb2,
+	0xc8, 0x86, 0x1f, 0x44, 0xb5, 0xbb, 0x08, 0xa0, 0xae, 0x6c, 0xd0, 0x24,
+	    0x13, 0xed, 0x83, 0xf0,
+	0x03, 0x51, 0x10, 0xf9, 0x13, 0x71, 0x3a, 0xf2, 0x49, 0x4a, 0xe1, 0xaa,
+	    0xf2, 0xac, 0xd5, 0x83,
+	0x27, 0xe7, 0x36, 0x61, 0x63, 0xb2, 0x49, 0x41, 0x49, 0x44, 0xfb, 0x3a,
+	    0xb4, 0x42, 0x80, 0xe3,
+	0x04, 0x72, 0x2a, 0xd5, 0x34, 0x5c, 0x3b, 0xd1, 0x47, 0xc7, 0x46, 0xdf,
+	    0xdd, 0xac, 0x39, 0x51,
+	0xe3, 0x7b, 0xd8, 0xae, 0x44, 0xeb, 0x77, 0x10, 0x68, 0x1b, 0x8e, 0x60,
+	    0xb7, 0x67, 0x20, 0x43,
+	0xee, 0x14, 0xae, 0xb4, 0xb6, 0xc9, 0xf7, 0x81, 0x04, 0xbe, 0x45, 0x8d,
+	    0x79, 0x43, 0x5f, 0x6e,
+	0x09, 0x70, 0x55, 0x25, 0x14, 0x61, 0x5b, 0xc6, 0x85, 0xcb, 0x03, 0x94,
+	    0x5a, 0xa7, 0x8e, 0x13,
+	0xcf, 0xc5, 0x8b, 0x5b, 0x94, 0xc7, 0x7d, 0x4c, 0xa0, 0x85, 0xc1, 0x8d,
+	    0x2a, 0x56, 0x5c, 0x0c,
+	0x6f, 0xac, 0xca, 0x6c, 0xeb, 0xea, 0x3f, 0x48, 0xbb, 0xce, 0x88, 0xc6,
+	    0x52, 0xa7, 0xde, 0x0e,
+	0xae, 0xec, 0x11, 0xf8, 0x0d, 0x54, 0x81, 0xd2, 0x31, 0x86, 0x88, 0xc1,
+	    0xa9, 0xe6, 0xf0, 0x34,
+	0x08, 0x8c, 0xe5, 0x1c, 0xaf, 0xf0, 0x13, 0x63, 0x6d, 0x75, 0x0c, 0xde,
+	    0x7f, 0x19, 0x94, 0xf9,
+	0x28, 0x2a, 0x53, 0x6c, 0xb8, 0xc7, 0x04, 0x33, 0x6a, 0xcd, 0x7b, 0xc7,
+	    0xa6, 0xed, 0xbd, 0x4c,
+	0x8e, 0x6c, 0xb8, 0xb1, 0xbd, 0xee, 0xa9, 0xb9, 0x7d, 0xd8, 0x8d, 0x1c,
+	    0x2c, 0x73, 0xea, 0x9c,
+	0x3d, 0x8b, 0x76, 0xda, 0x60, 0x1e, 0xc2, 0x5a, 0x45, 0x0d, 0x42, 0x80,
+	    0xa2, 0x81, 0xa3, 0xab,
+	0x8e, 0x84, 0x3d, 0x08, 0x98, 0x3c, 0xc9, 0x84, 0xfd, 0xef, 0x63, 0x90,
+	    0xed, 0x4b, 0x4b, 0x33,
+	0x2e, 0x50, 0x2b, 0x3e, 0xf4, 0xb4, 0x05, 0xab, 0x2e, 0x70, 0x18, 0x5b,
+	    0x22, 0x4e, 0x1a, 0xf3,
+	0xe6, 0x0d, 0xfd, 0x4a, 0xc1, 0xff, 0xf4, 0x5f, 0xcc, 0xcb, 0x7d, 0x24,
+	    0xf4, 0x01, 0x64, 0x16,
+	0x16, 0x53, 0xcc, 0x24, 0x5f, 0xbe, 0x83, 0x54, 0x56, 0x1b, 0x9c, 0x8a,
+	    0xd4, 0x08, 0x1b, 0xf3,
+	0x66, 0x12, 0xa4, 0xf8, 0x13, 0x3f, 0xe1, 0xd1, 0x43, 0xc2, 0x8d, 0x55,
+	    0x0b, 0xf4, 0x95, 0x6c,
+	0x4c, 0xda, 0xcd, 0x95, 0xb0, 0xbc, 0xfd, 0xae, 0xd3, 0xc8, 0xe5, 0xae,
+	    0x54, 0x91, 0x3b, 0xc2,
+	0x06, 0xb6, 0x1b, 0x43, 0x38, 0xd6, 0x8c, 0x60, 0xe6, 0x4f, 0xab, 0xdf,
+	    0x9d, 0xb0, 0x35, 0xdf,
+	0xce, 0xa4, 0xf9, 0x90, 0x33, 0xfb, 0xef, 0x14, 0xc2, 0x7e, 0x58, 0x94,
+	    0x53, 0xee, 0xe1, 0xd0,
+	0x9a, 0x07, 0xaf, 0x5a, 0xb8, 0xf0, 0x4d, 0x33, 0x98, 0xcd, 0xcb, 0x1f,
+	    0x84, 0x59, 0x95, 0xdb,
+	0x4e, 0xc6, 0x5a, 0x53, 0xc8, 0x8f, 0x05, 0xf6, 0x07, 0x7c, 0x9e, 0x91,
+	    0x08, 0xec, 0xc1, 0x4a,
+	0x34, 0x83, 0x0e, 0xb1, 0xb9, 0x2a, 0x64, 0x2e, 0x30, 0x8b, 0x56, 0x22,
+	    0x5e, 0xaa, 0xb2, 0x05,
+	0x2c, 0x79, 0x8e, 0x2d, 0x9c, 0xbf, 0x63, 0x73, 0xc2, 0xc4, 0x7a, 0x38,
+	    0x39, 0xff, 0x61, 0xed,
+	0x53, 0x37, 0x67, 0xfb, 0x2a, 0xbc, 0x09, 0xce, 0x5f, 0x57, 0x35, 0xcd,
+	    0x71, 0x98, 0xf0, 0x9e,
+	0xab, 0xd2, 0x5d, 0xd6, 0x1e, 0xb6, 0x29, 0xd9, 0xf7, 0xb4, 0x9f, 0x1b,
+	    0x5c, 0x54, 0x9e, 0x22,
+	0x60, 0x31, 0xbf, 0xd3, 0xcb, 0xf3, 0x0e, 0xfb, 0xae, 0xda, 0x02, 0x88,
+	    0x02, 0xb3, 0x50, 0xe2,
+	0x88, 0xdf, 0xd0, 0xaf, 0x57, 0xb0, 0x5e, 0x03, 0xce, 0x57, 0xde, 0x14,
+	    0xca, 0x74, 0xf2, 0x2d,
+	0x9d, 0x8c, 0xe6, 0xb0, 0x19, 0xff, 0x85, 0x2e, 0x4d, 0xd8, 0x67, 0x74,
+	    0x0f, 0x77, 0xf6, 0x7d,
+	0xa9, 0x96, 0x12, 0xad, 0x44, 0xfd, 0xf8, 0x13, 0xd3, 0x90, 0xdf, 0x75,
+	    0xdb, 0xff, 0xa7, 0xa1,
+	0xe1, 0xaf, 0xbe, 0xb4, 0x9f, 0x56, 0x6e, 0x90, 0xab, 0x03, 0xd2, 0xdb,
+	    0xb9, 0xe3, 0x76, 0xbc,
+	0xea, 0x72, 0x9e, 0x76, 0x71, 0xa8, 0x84, 0xf0, 0x62, 0xec, 0xc2, 0xef,
+	    0x39, 0xe2, 0x53, 0x12,
+	0xad, 0xc1, 0x89, 0xc0, 0x79, 0xe1, 0x2f, 0x85, 0x4d, 0xe4, 0x3d, 0xba,
+	    0xd3, 0x11, 0x77, 0xa9,
+	0x6a, 0xb0, 0xf0, 0x73, 0x66, 0x33, 0xc9, 0x21, 0x3e, 0xbe, 0xe0, 0x53,
+	    0x6e, 0x21, 0x02, 0x07,
+	0x0c, 0xab, 0x00, 0x38, 0x05, 0x3f, 0x01, 0x5f, 0x78, 0x06, 0x3a, 0xe0,
+	    0x02, 0x3a, 0x1a, 0xba,
+	0xa6, 0xa4, 0x91, 0x0a, 0x15, 0xb5, 0xa1, 0xb2, 0xe2, 0x3a, 0xf0, 0x16,
+	    0xae, 0x69, 0x17, 0xb1,
+	0x59, 0xa7, 0x28, 0xc1, 0xd4, 0x6d, 0xd6, 0xb0, 0xc4, 0xc4, 0x11, 0x79,
+	    0xa2, 0xbb, 0x71, 0x61,
+	0xbe, 0x38, 0xa1, 0xd1, 0xd1, 0x78, 0x31, 0x13, 0x74, 0x49, 0xe1, 0x4b,
+	    0xa5, 0x92, 0x5b, 0x56,
+	0x0e, 0xca, 0x3a, 0xf3, 0x6b, 0x28, 0xbe, 0xbb, 0x65, 0x42, 0x95, 0x97,
+	    0xaf, 0xe3, 0x0a, 0xf0,
+	0x8e, 0x4b, 0x32, 0x6f, 0x7f, 0x88, 0x61, 0x30, 0xec, 0xf6, 0x22, 0xb8,
+	    0x0d, 0xe1, 0xb4, 0x09,
+	0x88, 0x0a, 0xdc, 0x08, 0x9e, 0x48, 0x59, 0xad, 0x94, 0xfa, 0x78, 0x1c,
+	    0xba, 0x75, 0xc9, 0x26,
+	0x89, 0x0b, 0xb3, 0x2d, 0xfc, 0x34, 0x25, 0x9d, 0xcf, 0xbb, 0xd3, 0x0c,
+	    0x64, 0x29, 0xae, 0x2f,
+	0xc8, 0x0d, 0xf9, 0x0e, 0xbb, 0x91, 0x6a, 0x83, 0xc9, 0x41, 0x05, 0xe8,
+	    0x0e, 0x1c, 0x28, 0x5f,
+	0x0a, 0xcd, 0xf2, 0x23, 0x9a, 0x20, 0x03, 0x26, 0x4d, 0x8f, 0xe2, 0x82,
+	    0x5d, 0xb4, 0x06, 0x2e,
+	0xeb, 0x0a, 0xeb, 0x2f, 0x6f, 0x22, 0x2a, 0xed, 0x9e, 0xdf, 0xbb, 0x0f,
+	    0x25, 0x60, 0x15, 0xe5,
+	0x8b, 0xa4, 0x78, 0xf1, 0x67, 0x5c, 0x83, 0x91, 0x4c, 0x0d, 0x12, 0x63,
+	    0xe9, 0x9b, 0x50, 0xc7,
+	0xe2, 0x50, 0x83, 0xfc, 0x33, 0x92, 0xac, 0x53, 0x4e, 0xfd, 0x95, 0xdb,
+	    0xd7, 0xdd, 0xd3, 0xfc,
+	0x52, 0x44, 0x9e, 0xe4, 0x37, 0x81, 0x85, 0x5a, 0x88, 0x42, 0x00, 0x56,
+	    0x91, 0x8e, 0x4d, 0x14,
+	0xd7, 0xce, 0xbb, 0x31, 0xd8, 0x3f, 0xc5, 0x90, 0x41, 0xd3, 0xc1, 0xd5,
+	    0xf8, 0xd6, 0x52, 0xbb,
+	0x9e, 0x01, 0xa1, 0xd2, 0xb7, 0x83, 0xe5, 0xb9, 0x08, 0x60, 0xa3, 0x04,
+	    0x4e, 0x28, 0x90, 0x44,
+	0x7e, 0xa4, 0xfc, 0xbb, 0xb3, 0x39, 0x6c, 0x9b, 0xe3, 0x59, 0x79, 0x9b,
+	    0xef, 0x28, 0x32, 0x79,
+	0xca, 0x76, 0xf4, 0x2b, 0xb0, 0x38, 0x74, 0x92, 0x9f, 0xd6, 0xba, 0x96,
+	    0xc8, 0x6a, 0x3b, 0x69,
+	0xb2, 0x5b, 0x05, 0xdc, 0xd5, 0x38, 0xee, 0xa3, 0x43, 0xab, 0x6e, 0xab,
+	    0x47, 0x15, 0x33, 0x33,
+	0x43, 0xc2, 0x36, 0x17, 0x12, 0x88, 0x67, 0x0b, 0x18, 0x88, 0x87, 0xed,
+	    0x9b, 0x54, 0xc6, 0x61,
+	0x13, 0xc3, 0x1f, 0x4c, 0x7c, 0x95, 0xee, 0x58, 0xbf, 0xf9, 0x96, 0x91,
+	    0x87, 0x25, 0x3b, 0x61,
+	0x19, 0x1d, 0xdc, 0x6c, 0xe2, 0x98, 0x44, 0x66, 0x15, 0x46, 0x65, 0x9b,
+	    0xd8, 0x86, 0xf1, 0x74,
+	0x1b, 0x81, 0x55, 0xbd, 0x43, 0x95, 0xc7, 0x43, 0x4d, 0x85, 0x57, 0xb5,
+	    0x9d, 0x77, 0x48, 0x1d,
+	0xfd, 0xc1, 0x5d, 0x77, 0x1c, 0x94, 0xa4, 0x5f, 0x8a, 0x85, 0x5f, 0xa0,
+	    0xb3, 0xe7, 0x3e, 0xf9,
+	0x14, 0xb3, 0xae, 0xae, 0xc9, 0x7e, 0x0f, 0xb6, 0x6c, 0xcc, 0xa8, 0xea,
+	    0x9b, 0xff, 0x30, 0x74,
+	0xc2, 0x7e, 0x0e, 0x48, 0x1c, 0xb0, 0x36, 0x9a, 0xd4, 0x53, 0x21, 0x8e,
+	    0x88, 0xc2, 0x92, 0xb7,
+	0xc0, 0x4d, 0x5c, 0x01, 0x89, 0xf0, 0xbe, 0x6d, 0xa8, 0x01, 0xf3, 0x1e,
+	    0x76, 0x73, 0x59, 0x60,
+	0x40, 0xac, 0xb1, 0x79, 0x52, 0x7c, 0x67, 0x17, 0x68, 0x52, 0x24, 0x79,
+	    0xb9, 0x20, 0x20, 0x02,
+	0x6f, 0x53, 0x18, 0xfc, 0x04, 0xed, 0xb3, 0xcc, 0x54, 0x8d, 0xb7, 0x9d,
+	    0xa3, 0x6b, 0x76, 0xb6,
+	0x55, 0x23, 0xb3, 0x56, 0x55, 0xd5, 0xf8, 0x2a, 0xfa, 0xc9, 0x00, 0x07,
+	    0xf4, 0x60, 0xa5, 0xf2,
+	0xfa, 0x83, 0xde, 0xc0, 0x92, 0x12, 0xcc, 0xe4, 0x1e, 0x5f, 0xda, 0x16,
+	    0xb6, 0xfd, 0xf9, 0xe3,
+	0x52, 0x22, 0xfb, 0x15, 0xa1, 0xe1, 0x6c, 0x29, 0xf7, 0x77, 0x24, 0xdd,
+	    0x70, 0x12, 0xb7, 0x08,
+	0xe7, 0x2b, 0x20, 0x5b, 0x5d, 0xbf, 0x73, 0xac, 0xb2, 0xd7, 0xa5, 0x21,
+	    0x65, 0xdd, 0x0e, 0xe2,
+	0x06, 0xc5, 0x28, 0xc6, 0xa0, 0xab, 0x6e, 0xdb, 0x41, 0x15, 0xa9, 0x06,
+	    0xd7, 0x4a, 0xb1, 0x30,
+	0xa0, 0xea, 0x09, 0xc3, 0xc6, 0xf8, 0xb1, 0x7e, 0x8d, 0xbb, 0x49, 0xf4,
+	    0xec, 0x4b, 0x65, 0xe5,
+	0xe4, 0x59, 0xd1, 0xb8, 0x14, 0xaa, 0xea, 0x9b, 0x40, 0x85, 0x81, 0xff,
+	    0x72, 0x6e, 0xf2, 0xe0,
+	0xe5, 0xcb, 0x21, 0x77, 0xf5, 0x6b, 0x67, 0x55, 0x24, 0xc5, 0x4d, 0xa6,
+	    0xf9, 0x3b, 0xb6, 0x09,
+	0x27, 0x86, 0xd3, 0x78, 0xee, 0xb9, 0xc2, 0x32, 0xf0, 0x86, 0x07, 0x0f,
+	    0xfc, 0x68, 0xdb, 0xeb,
+	0x6f, 0x27, 0xb5, 0x6d, 0xfc, 0xb3, 0x21, 0x47, 0x7f, 0x97, 0x48, 0xab,
+	    0x80, 0x48, 0x19, 0xe8,
+	0xe3, 0x26, 0x13, 0xe4, 0x10, 0xe9, 0x61, 0xe5, 0xb1, 0xd4, 0x22, 0xd5,
+	    0x28, 0xa4, 0x74, 0xee,
+	0xbd, 0xc1, 0x1b, 0x8c, 0xbf, 0x93, 0xb0, 0x8e, 0x06, 0x8f, 0xd2, 0xfd,
+	    0xfd, 0xe6, 0x6d, 0x68,
+	0x73, 0xcf, 0x96, 0x1c, 0xbe, 0x10, 0xba, 0x62, 0xcc, 0x8f, 0xfb, 0x0d,
+	    0x65, 0xa2, 0x9c, 0x38,
+	0xe4, 0xcc, 0x8b, 0x2d, 0x98, 0x1e, 0x7f, 0x5a, 0xfd, 0x80, 0x75, 0x1c,
+	    0xec, 0xa1, 0x68, 0x45,
+	0x2e, 0x20, 0xc3, 0x3d, 0x6a, 0xa3, 0x39, 0x95, 0x3e, 0xc3, 0x48, 0xd7,
+	    0x23, 0xdc, 0x13, 0x84,
+	0x22, 0x00, 0xf2, 0xf5, 0x52, 0x31, 0x22, 0x06, 0xd7, 0x7d, 0x0f, 0xfc,
+	    0xad, 0x0d, 0x12, 0xf7,
+	0xc5, 0x10, 0x40, 0x09, 0x36, 0xf1, 0x8e, 0x4b, 0x21, 0x93, 0x43, 0xc4,
+	    0x5b, 0xb3, 0xeb, 0x72,
+	0x07, 0xd2, 0xda, 0x78, 0x5d, 0x31, 0xe1, 0x45, 0xb8, 0xd6, 0x9a, 0xd4,
+	    0x9a, 0x83, 0x3c, 0x60,
+	0x21, 0x3e, 0x0a, 0x27, 0x5c, 0x50, 0x3a, 0xee, 0x0c, 0x90, 0xbe, 0xdf,
+	    0x54, 0x2c, 0x5e, 0x73,
+	0x54, 0x3b, 0x48, 0x55, 0x1b, 0xbc, 0x09, 0x20, 0xc7, 0x96, 0xce, 0x0b,
+	    0xf6, 0xab, 0x6f, 0x1c,
+	0x96, 0x99, 0xba, 0x52, 0x6f, 0x30, 0x43, 0xb0, 0xc6, 0x08, 0x35, 0xe8,
+	    0x45, 0x01, 0x36, 0x2b,
+	0x73, 0xd4, 0x65, 0xc4, 0xf1, 0x1b, 0x72, 0x00, 0x67, 0xdb, 0x88, 0x0d,
+	    0xf0, 0x2f, 0x55, 0xb8,
+	0x26, 0x9a, 0xfb, 0x73, 0xb1, 0x27, 0x55, 0x91, 0x1a, 0xdb, 0xa8, 0x07,
+	    0x44, 0x56, 0x5e, 0x3a,
+	0x94, 0x2d, 0xf8, 0x6c, 0x38, 0x3d, 0xf6, 0xb6, 0x2d, 0xd2, 0x02, 0xcc,
+	    0xf1, 0x4e, 0xf1, 0x70,
+	0x12, 0x09, 0xd6, 0x2e, 0xd9, 0xfb, 0xee, 0xbb, 0xad, 0x74, 0x05, 0xce,
+	    0xfd, 0xef, 0x87, 0x71,
+	0xdb, 0x7d, 0xb5, 0xa7, 0x47, 0x17, 0xb7, 0xba, 0x8e, 0x7a, 0x8c, 0xdf,
+	    0x7c, 0xe5, 0xef, 0x72,
+	0x96, 0x16, 0xac, 0x4a, 0x54, 0xd2, 0xed, 0x8b, 0x1a, 0xa4, 0xf7, 0xaa,
+	    0x14, 0x92, 0xdf, 0x88,
+	0x8f, 0xe1, 0x45, 0xac, 0xc1, 0x31, 0x4e, 0x6e, 0x36, 0x17, 0x26, 0x1d,
+	    0xfa, 0x71, 0xc3, 0xa5,
+	0xb2, 0x10, 0x07, 0x5a, 0x6f, 0xe3, 0x46, 0x04, 0xec, 0xd0, 0xc6, 0x1e,
+	    0x29, 0xbf, 0x4f, 0xa9,
+	0x52, 0xfd, 0x9c, 0x34, 0x49, 0xa5, 0x1f, 0x89, 0x11, 0xd0, 0xa5, 0x58,
+	    0x15, 0x9a, 0x96, 0x30,
+	0x1c, 0x4a, 0x2f, 0x4f, 0x08, 0xa4, 0x00, 0x39, 0x4e, 0x40, 0xf8, 0xa6,
+	    0x72, 0x72, 0xe7, 0xff,
+	0xe1, 0xd6, 0xa0, 0x8e, 0x34, 0x6d, 0x22, 0x10, 0x38, 0xef, 0x28, 0x6a,
+	    0xa5, 0x3c, 0xef, 0x6e,
+	0x60, 0x05, 0x19, 0xe4, 0x10, 0xf0, 0x66, 0x37, 0xa8, 0x05, 0xcb, 0x0f,
+	    0x2b, 0xb4, 0xfa, 0x46,
+	0x69, 0x31, 0x7e, 0x3b, 0xa4, 0x82, 0xb1, 0x53, 0xa2, 0x25, 0x3c, 0x5a,
+	    0x4d, 0xf7, 0x70, 0x62,
+	0xb3, 0x8a, 0xf7, 0x13, 0x70, 0xa0, 0x0f, 0x0c, 0x2a, 0x07, 0xca, 0x0a,
+	    0xab, 0x21, 0x93, 0x7f,
+	0x7c, 0x89, 0x93, 0x60, 0xe9, 0x89, 0xe2, 0x93, 0xce, 0x05, 0x68, 0x9b,
+	    0x42, 0x29, 0xb1, 0x2a,
+	0x27, 0x79, 0xf2, 0xc6, 0x13, 0xba, 0x85, 0x61, 0xa2, 0xfa, 0xff, 0xd1,
+	    0xee, 0x06, 0x3a, 0xba,
+	0x84, 0x84, 0x5d, 0x02, 0x48, 0x99, 0x8a, 0x3f, 0xbd, 0x3e, 0xb1, 0xd7,
+	    0xe8, 0x27, 0xf6, 0x1e,
+	0x16, 0xda, 0x59, 0x2a, 0xfb, 0x2a, 0xc9, 0x02, 0xb7, 0xec, 0x39, 0xdd,
+	    0x2e, 0xce, 0x22, 0x82,
+	0x0b, 0xa8, 0xa6, 0xff, 0x94, 0x69, 0x28, 0x99, 0xc4, 0xe7, 0x56, 0x4a,
+	    0xd5, 0x15, 0x5f, 0xf4,
+	0xab, 0x32, 0x75, 0x3b, 0xb8, 0x32, 0x4d, 0xd0, 0x27, 0x04, 0x37, 0x43,
+	    0xc4, 0x36, 0x39, 0xfa,
+	0xba, 0xa5, 0xe3, 0xbf, 0xe2, 0x27, 0xb7, 0x0d, 0x4a, 0xcd, 0x74, 0xd2,
+	    0x6d, 0xbc, 0x99, 0x6a,
+	0xe7, 0x49, 0x5d, 0x42, 0x3e, 0x3b, 0xe4, 0x31, 0x6c, 0xb7, 0x4f, 0xae,
+	    0x78, 0x54, 0xeb, 0x3a,
+	0xb1, 0x13, 0xd0, 0x20, 0xa9, 0x61, 0x2a, 0x70, 0xaa, 0xcd, 0x06, 0x0c,
+	    0x2b, 0xc1, 0xd9, 0xc7,
+	0xfe, 0x84, 0x4e, 0x58, 0x59, 0x15, 0x08, 0xdf, 0x6f, 0x03, 0x78, 0x97,
+	    0x55, 0x0f, 0xd3, 0xb6,
+	0x05, 0xa3, 0x53, 0xb5, 0x9a, 0x95, 0x06, 0x9a, 0x4e, 0xc3, 0x8c, 0x50,
+	    0xdc, 0x8e, 0x6b, 0xb3,
+	0x62, 0xbe, 0x10, 0x63, 0xe4, 0xf6, 0xca, 0x0b, 0x49, 0x28, 0x1f, 0xad,
+	    0x85, 0xc0, 0x84, 0x11,
+	0xac, 0xb2, 0xd3, 0xe6, 0xc7, 0x55, 0xac, 0x5b, 0xc1, 0x0f, 0x0d, 0x4f,
+	    0x68, 0x1d, 0x64, 0x96,
+	0xa2, 0x75, 0xf7, 0xb3, 0x90, 0x8e, 0x24, 0x43, 0x03, 0x34, 0x20, 0x11,
+	    0x55, 0x1d, 0xa5, 0xe3,
+	0x6a, 0x01, 0xbd, 0xa2, 0x4f, 0x3f, 0xa1, 0xc3, 0x5f, 0x37, 0x83, 0xc7,
+	    0x0f, 0x40, 0x75, 0xb6,
+	0x5c, 0x1c, 0x1d, 0x6c, 0xf1, 0x28, 0x25, 0x42, 0x8b, 0x12, 0xa7, 0x26,
+	    0x89, 0x8c, 0x1b, 0xe3,
+	0xdf, 0x55, 0x96, 0xc4, 0x95, 0x75, 0x66, 0xc4, 0xe0, 0x50, 0x9c, 0xed,
+	    0x52, 0x67, 0x31, 0x97,
+	0x8e, 0xe3, 0x77, 0x9a, 0xae, 0xc8, 0xa3, 0xd4, 0xde, 0xf4, 0x59, 0x34,
+	    0x13, 0x48, 0x53, 0xa3,
+	0xc2, 0x6f, 0xe8, 0xbe, 0x2b, 0x6a, 0x5a, 0x83, 0xa1, 0x36, 0x44, 0x9a,
+	    0x7d, 0xf0, 0xf6, 0xa1,
+	0x23, 0x08, 0x60, 0xf1, 0x31, 0x50, 0x65, 0x0e, 0x56, 0x34, 0x31, 0x66,
+	    0x99, 0x7f, 0x00, 0x3d,
+	0x60, 0x5b, 0x21, 0xfa, 0xcf, 0x28, 0xa5, 0x10, 0x94, 0xeb, 0xac, 0x3f,
+	    0x08, 0xa7, 0xd5, 0xc6,
+	0x56, 0x40, 0x0e, 0x0c, 0x20, 0x3f, 0x61, 0x42, 0xcc, 0x26, 0x25, 0xcc,
+	    0xf9, 0x66, 0x1b, 0x55,
+	0x8c, 0x85, 0x3d, 0x72, 0xcb, 0x3a, 0xac, 0x0c, 0x22, 0x57, 0x3b, 0xde,
+	    0xc4, 0x8c, 0xd2, 0x11,
+	0xaf, 0x20, 0xaf, 0x02, 0x18, 0x84, 0x1e, 0xdf, 0x52, 0x4b, 0xa1, 0x91,
+	    0x98, 0x7f, 0x03, 0xaf,
+	0x4b, 0x18, 0x47, 0x3c, 0x32, 0x33, 0xad, 0xcc, 0x83, 0x6d, 0x45, 0x68,
+	    0x36, 0x69, 0x76, 0x36,
+	0x87, 0x10, 0xf6, 0x27, 0xc8, 0x7c, 0x20, 0xfe, 0x8a, 0xde, 0xb8, 0x9e,
+	    0x90, 0x19, 0x26, 0xed,
+	0x41, 0x7a, 0x57, 0xb3, 0x94, 0x98, 0x41, 0x8b, 0x8a, 0xd1, 0x6a, 0x1e,
+	    0x7e, 0x1d, 0xb2, 0xfd,
+	0xc0, 0x10, 0x96, 0xc2, 0x5e, 0xe0, 0xab, 0xdd, 0x02, 0x6e, 0xe0, 0xcc,
+	    0x7f, 0xc0, 0xa3, 0x6c,
+	0xed, 0x93, 0x1f, 0xe0, 0xb8, 0xad, 0x48, 0x05, 0xb9, 0xcf, 0xc9, 0x02,
+	    0xbd, 0xe3, 0x6a, 0x49,
+	0x27, 0xf0, 0xa4, 0x49, 0xb2, 0xb1, 0x39, 0x54, 0xe9, 0x3d, 0xaa, 0x0f,
+	    0xbe, 0xa5, 0x07, 0xaa,
+	0x27, 0xc0, 0x5e, 0x20, 0x35, 0xb9, 0x68, 0x62, 0x61, 0x3d, 0xef, 0xc5,
+	    0x84, 0x67, 0xbd, 0x60,
+	0xeb, 0xc1, 0x16, 0xf1, 0xb1, 0xa5, 0x41, 0x14, 0x38, 0xcc, 0x83, 0x87,
+	    0x7b, 0x4c, 0x7a, 0x40,
+	0x94, 0xc5, 0xd7, 0x23, 0x65, 0xa4, 0x72, 0x80, 0xea, 0xcb, 0xa2, 0x21,
+	    0xef, 0x42, 0xdc, 0x30,
+	0xfc, 0xc4, 0x4c, 0x34, 0xe0, 0xc0, 0x87, 0x01, 0x7b, 0xa9, 0x3c, 0xa6,
+	    0x29, 0x4a, 0x1f, 0x44,
+	0x27, 0x19, 0x3c, 0x6b, 0xb2, 0x09, 0xe1, 0x24, 0x0c, 0x77, 0xa3, 0x94,
+	    0xb4, 0x84, 0xd4, 0x6e,
+	0x78, 0xda, 0xd1, 0xa8, 0x76, 0x38, 0x9e, 0x57, 0x66, 0x6c, 0xaf, 0xf3,
+	    0x9b, 0xf2, 0xa1, 0xfb,
+	0x8d, 0xec, 0xd4, 0x09, 0xbd, 0x77, 0xa2, 0xa8, 0xae, 0x7b, 0x16, 0x5d,
+	    0xd8, 0xa9, 0x12, 0x89,
+	0x37, 0x76, 0x55, 0xe6, 0x1d, 0xe9, 0x3b, 0x5c, 0xb2, 0xd2, 0xdd, 0x40,
+	    0x9f, 0xe9, 0x0b, 0x0d,
+	0x01, 0xef, 0x17, 0x6d, 0xe7, 0xfa, 0x6a, 0x9e, 0x69, 0x15, 0x1f, 0x4d,
+	    0x27, 0x17, 0x2d, 0x1d,
+	0x46, 0xcf, 0x6f, 0xed, 0x1f, 0x2c, 0x37, 0x5d, 0x3e, 0xdb, 0x2b, 0x0e,
+	    0x7c, 0x6a, 0xb1, 0xb4,
+	0xb7, 0x3f, 0x9d, 0x6a, 0xff, 0xaa, 0x0a, 0x6e, 0xae, 0x33, 0x32, 0x7b,
+	    0x81, 0xd3, 0xfa, 0xa6,
+	0x8f, 0x76, 0x92, 0x7a, 0xba, 0x2c, 0xc5, 0x8c, 0x6b, 0x60, 0xf6, 0xde,
+	    0x6d, 0x2d, 0x1c, 0x21,
+	0xfc, 0x11, 0x95, 0x48, 0x3d, 0xcb, 0x4d, 0x89, 0x29, 0xde, 0x5f, 0xfc,
+	    0xbc, 0xe4, 0xe5, 0xa2,
+	0x22, 0xcd, 0x14, 0xb9, 0x8d, 0xe2, 0xe7, 0x8a, 0x6c, 0x8f, 0x44, 0x38,
+	    0x1d, 0xaf, 0x79, 0xa6,
+	0x4c, 0x01, 0x1b, 0x1d, 0xc1, 0x36, 0x8c, 0x4c, 0x74, 0x9d, 0xd5, 0x82,
+	    0xd5, 0x7a, 0xd7, 0xed,
+	0x4d, 0x9c, 0x78, 0x51, 0xc2, 0x0c, 0xad, 0x83, 0xc4, 0x2e, 0x84, 0x50,
+	    0xd4, 0x7b, 0xda, 0xf9,
+	0xce, 0x9d, 0xa5, 0xa3, 0x4b, 0x3f, 0x98, 0x49, 0xc0, 0x7f, 0x32, 0x96,
+	    0x55, 0x53, 0xd2, 0xed,
+	0x8b, 0x4c, 0x4a, 0xe9, 0xd4, 0xb7, 0x03, 0x9a, 0xcb, 0x0c, 0xc5, 0x48,
+	    0x50, 0x4c, 0x66, 0xb1,
+	0x0b, 0x11, 0xe5, 0xb0, 0x12, 0x31, 0x62, 0x80, 0x06, 0x0b, 0xcf, 0x57,
+	    0xfa, 0x6b, 0x52, 0x30,
+	0x45, 0xc0, 0xd2, 0x34, 0x55, 0x60, 0x88, 0xd6, 0x58, 0xf5, 0xc1, 0x31,
+	    0xa1, 0xfd, 0x77, 0xe9,
+	0x4d, 0xd2, 0xf7, 0xbb, 0x5d, 0xf2, 0x0b, 0xe5, 0x07, 0x55, 0x35, 0xf2,
+	    0x29, 0x29, 0xfd, 0xa8,
+	0xcf, 0x9a, 0x7d, 0x3f, 0xb2, 0xfa, 0x23, 0x11, 0xe3, 0x52, 0x3d, 0xf5,
+	    0xb3, 0xca, 0x7c, 0xa2,
+	0x50, 0x37, 0xdf, 0xf4, 0x5d, 0xbc, 0x6d, 0xaa, 0x17, 0xb8, 0x26, 0x44,
+	    0xf1, 0x05, 0x50, 0x9d,
+	0x09, 0x34, 0x75, 0x9e, 0xcd, 0xea, 0x83, 0x25, 0x98, 0x50, 0x47, 0xc5,
+	    0xe7, 0xc6, 0x87, 0x7b,
+	0x48, 0x49, 0xc6, 0xab, 0x40, 0x39, 0xf7, 0x3b, 0xf5, 0xb6, 0x52, 0x40,
+	    0x09, 0xac, 0xbc, 0x6a,
+	0x0e, 0x0b, 0x98, 0x32, 0xbb, 0xd9, 0x1f, 0x51, 0x58, 0x52, 0x84, 0x35,
+	    0x4e, 0x2e, 0x99, 0xb0,
+	0x00, 0x43, 0x80, 0x6f, 0x2c, 0xf1, 0x08, 0xec, 0xa6, 0xd3, 0x1a, 0x7d,
+	    0x14, 0xf4, 0x5c, 0xea,
+	0x1f, 0x32, 0x1a, 0x3d, 0x5c, 0x9d, 0x18, 0x98, 0x9c, 0x20, 0xde, 0xef,
+	    0xc2, 0x0c, 0xf7, 0x3a,
+	0x0d, 0xde, 0x81, 0x6f, 0x9a, 0xb8, 0xd3, 0xcf, 0x17, 0xbd, 0x76, 0x80,
+	    0x82, 0x01, 0xcf, 0xa8,
+	0x0c, 0x1c, 0x97, 0xfb, 0x8c, 0x5c, 0x68, 0x04, 0x06, 0xd0, 0x00, 0x9c,
+	    0x2b, 0xbe, 0xad, 0x7f,
+	0x9d, 0x06, 0x41, 0xfb, 0x16, 0xb2, 0x22, 0x11, 0x2a, 0x02, 0x44, 0xda,
+	    0xb1, 0xff, 0xd3, 0x10,
+	0x01, 0x01, 0xb1, 0x56, 0xb0, 0x8c, 0xce, 0x17, 0xe0, 0xee, 0x58, 0xac,
+	    0x3b, 0x23, 0xf7, 0xff,
+	0x86, 0xc0, 0x56, 0x81, 0x86, 0xe8, 0xd0, 0x33, 0x61, 0xed, 0xee, 0xa1,
+	    0x92, 0x3d, 0x09, 0x93,
+	0x33, 0x43, 0xdb, 0x05, 0x1c, 0x41, 0x48, 0x0e, 0xa7, 0x98, 0x58, 0x48,
+	    0xd7, 0xf1, 0x94, 0x42,
+	0x06, 0x1f, 0x8a, 0xa6, 0xed, 0x22, 0xe7, 0x1c, 0xb6, 0xfd, 0x2f, 0x17,
+	    0x2f, 0xc7, 0x49, 0x36,
+	0xe8, 0x16, 0x4f, 0x69, 0xf8, 0xe6, 0x47, 0x6f, 0x36, 0x43, 0x47, 0x0b,
+	    0x5d, 0xca, 0x0f, 0x27,
+	0x69, 0xe5, 0xe1, 0x25, 0x33, 0xac, 0x91, 0xb0, 0xb9, 0x92, 0x8d, 0x22,
+	    0xdc, 0xc9, 0xe5, 0x22,
+	0xf6, 0xa1, 0xa9, 0xe2, 0x60, 0x2a, 0x28, 0xf9, 0x62, 0x98, 0x81, 0xf7,
+	    0x7d, 0x66, 0xc2, 0x9c,
+	0x7f, 0x08, 0x7d, 0x88, 0x0e, 0x3f, 0x12, 0xef, 0x96, 0xc3, 0x9f, 0xa8,
+	    0x4e, 0xd0, 0x7b, 0x0c,
+	0x0f, 0xcb, 0x75, 0x9e, 0xab, 0x69, 0x7b, 0xf8, 0x4d, 0x68, 0x5b, 0x41,
+	    0x5f, 0xcb, 0x03, 0x09,
+	0x88, 0x0c, 0xeb, 0x6f, 0x9e, 0x78, 0x33, 0xc3, 0xa1, 0xa9, 0xf3, 0x87,
+	    0xcc, 0x28, 0xd0, 0x19,
+	0x89, 0x0b, 0x4b, 0x89, 0xfc, 0x8b, 0xdc, 0x4a, 0xfb, 0xbd, 0xbd, 0x4f,
+	    0xa5, 0x94, 0x13, 0x3b,
+	0x73, 0xaa, 0x3b, 0x6b, 0xbb, 0x53, 0xe6, 0x0a, 0xb5, 0x0e, 0xea, 0x96,
+	    0xf6, 0x61, 0x03, 0x3e,
+	0xf8, 0x1d, 0xb4, 0x1d, 0xb7, 0x20, 0x05, 0x0a, 0xb8, 0xf2, 0x86, 0xf8,
+	    0x20, 0xa6, 0x95, 0x09,
+	0x8c, 0x15, 0xa3, 0xfa, 0x2d, 0x23, 0x96, 0x70, 0xcc, 0xe4, 0xac, 0x52,
+	    0xfd, 0xbb, 0xf3, 0xa2,
+	0x41, 0x1c, 0xb5, 0x19, 0xa8, 0x75, 0x3b, 0xd3, 0x8d, 0x0d, 0x60, 0x3f,
+	    0x7a, 0x92, 0xc4, 0x0c,
+	0x05, 0x0b, 0xfb, 0x00, 0x72, 0x6f, 0xd4, 0x2c, 0x27, 0x4d, 0x60, 0x84,
+	    0xd1, 0xa3, 0x6c, 0x92,
+	0x26, 0x1c, 0x4e, 0xe0, 0xb3, 0xd6, 0xee, 0x72, 0xc0, 0x13, 0xe2, 0x50,
+	    0x8c, 0xd7, 0xce, 0x05,
+	0xe6, 0x48, 0xe5, 0x2f, 0xb4, 0x70, 0x3d, 0xc3, 0xe6, 0x00, 0x3a, 0xe2,
+	    0x3a, 0x21, 0x47, 0x8c,
+	0x4a, 0xd0, 0x76, 0x11, 0xa7, 0xf9, 0xdc, 0x4e, 0xe7, 0x01, 0xc8, 0x46,
+	    0xda, 0x31, 0x7b, 0x5f,
+	0xdd, 0x89, 0x70, 0xa6, 0xd9, 0x1c, 0x90, 0x86, 0x9f, 0x4f, 0xab, 0xdb,
+	    0x51, 0xa1, 0xe7, 0x10,
+	0x33, 0x5b, 0x91, 0x18, 0x9e, 0x59, 0xf7, 0x75, 0xf0, 0x6a, 0x4c, 0x5b,
+	    0x7b, 0xb5, 0xa6, 0x86,
+	0xa4, 0x64, 0x71, 0xa7, 0x59, 0x7e, 0xd5, 0xbf, 0x6f, 0x34, 0x4a, 0x61,
+	    0x89, 0xbd, 0xcb, 0xd3,
+	0xe3, 0x5b, 0x09, 0x26, 0xbe, 0x07, 0x3d, 0x46, 0x54, 0x15, 0xf8, 0xf3,
+	    0x67, 0x13, 0x66, 0x8a,
+	0x8e, 0x15, 0xe6, 0x26, 0x7c, 0x7a, 0x19, 0x2a, 0xda, 0x1a, 0xd5, 0x68,
+	    0x7e, 0x2a, 0xbd, 0x7a,
+	0x49, 0x19, 0xa8, 0xee, 0x45, 0x96, 0x4c, 0xff, 0xa3, 0x50, 0xa4, 0x51,
+	    0xf9, 0x26, 0x59, 0x6b,
+	0xac, 0x9f, 0x46, 0xf0, 0xbe, 0x98, 0xd7, 0x25, 0x3e, 0xf7, 0x08, 0x29,
+	    0xb2, 0xde, 0x71, 0x35,
+	0x5c, 0x98, 0x14, 0xe3, 0xdb, 0x1b, 0x17, 0xf8, 0x00, 0xd8, 0xe2, 0x57,
+	    0x74, 0x39, 0x80, 0x8e,
+	0x66, 0x27, 0x7a, 0x49, 0xd1, 0xb4, 0x15, 0x30, 0xe8, 0x58, 0xee, 0xc8,
+	    0x79, 0x3c, 0xf2, 0x30,
+	0x6f, 0xc1, 0xb1, 0x26, 0xc7, 0x36, 0x5e, 0x7c, 0x39, 0xfc, 0x5e, 0x9b,
+	    0x5f, 0x49, 0x0e, 0xae,
+	0x5d, 0x2e, 0xe1, 0x79, 0xf3, 0xb3, 0x27, 0x8b, 0x11, 0xc5, 0x69, 0xc9,
+	    0x44, 0xa1, 0xe3, 0x5c,
+	0x7e, 0x7d, 0x7c, 0xa0, 0xbd, 0x95, 0xe0, 0x11, 0xef, 0x83, 0x7f, 0xf3,
+	    0x77, 0xf2, 0x20, 0x80,
+	0xb6, 0xd0, 0xf6, 0x07, 0x33, 0x00, 0x4e, 0x8a, 0xad, 0x23, 0x0b, 0x96,
+	    0x5c, 0x3f, 0x28, 0x12,
+	0x05, 0x87, 0xd9, 0x02, 0x13, 0xf3, 0x49, 0x2e, 0x43, 0x93, 0xeb, 0xcc,
+	    0xd7, 0xf6, 0xe1, 0x97,
+	0xf3, 0x82, 0xf3, 0x06, 0xf1, 0xa4, 0xd2, 0xd0, 0xaa, 0xc4, 0x8b, 0x9e,
+	    0x2f, 0x6f, 0x58, 0x0f,
+	0x83, 0x41, 0x36, 0x93, 0xc7, 0x9b, 0xf3, 0x59, 0x44, 0xce, 0x7b, 0xb3,
+	    0xc3, 0xe9, 0x9f, 0x38,
+	0xcc, 0x67, 0x58, 0xb5, 0x1b, 0xb4, 0xb2, 0x16, 0x7d, 0x9e, 0xd8, 0x04,
+	    0x50, 0x86, 0xee, 0xf2,
+	0x4b, 0x64, 0x3a, 0x07, 0x97, 0x74, 0x21, 0x66, 0x92, 0xa9, 0x90, 0x14,
+	    0xa4, 0x8b, 0xa1, 0xce,
+	0x5f, 0x8e, 0x59, 0xb4, 0xd7, 0x02, 0xcd, 0x9d, 0xde, 0xab, 0x84, 0xa5,
+	    0x77, 0x59, 0x81, 0xc6,
+	0x07, 0xe6, 0xa3, 0x4a, 0x68, 0xa1, 0xbd, 0x2d, 0xc9, 0xd9, 0x46, 0xec,
+	    0x22, 0x71, 0xf9, 0x0a,
+	0x0c, 0x88, 0x62, 0x96, 0x62, 0xea, 0x0c, 0x9a, 0xc1, 0xaa, 0xd2, 0x84,
+	    0x08, 0xaa, 0xea, 0x8e,
+	0x7a, 0x89, 0xba, 0x7c, 0xea, 0xcc, 0x52, 0x58, 0x4b, 0x9b, 0x9c, 0xbc,
+	    0xf3, 0xc8, 0x23, 0x89,
+	0x3e, 0xc8, 0x62, 0xdb, 0x1e, 0xcd, 0xcc, 0xaf, 0xda, 0x9d, 0x72, 0x52,
+	    0xda, 0x48, 0x2b, 0x1b,
+	0x8d, 0xf6, 0x93, 0xe0, 0x7c, 0x34, 0xc4, 0xbf, 0x9f, 0x68, 0x83, 0x02,
+	    0x22, 0xed, 0xca, 0xdf,
+	0x35, 0x0f, 0xc2, 0x2e, 0xbf, 0x26, 0x0f, 0x85, 0xdb, 0x11, 0xfa, 0x7a,
+	    0x96, 0xc7, 0x2f, 0x3d,
+	0x21, 0xcf, 0x8a, 0xe9, 0xa8, 0xa0, 0x42, 0x81, 0x3c, 0xcd, 0x6a, 0xfc,
+	    0xf1, 0xec, 0xdf, 0x7a,
+	0x2f, 0x71, 0x9b, 0x72, 0x75, 0x6d, 0xda, 0xe9, 0x4e, 0x34, 0x6c, 0x7c,
+	    0xf9, 0xe5, 0xae, 0x00,
+	0x8e, 0xed, 0x12, 0x78, 0x3e, 0xd0, 0xd4, 0x14, 0x12, 0x8d, 0xc3, 0x85,
+	    0x73, 0xe2, 0x20, 0x71,
+	0x1e, 0x1d, 0xda, 0xff, 0xb6, 0x57, 0xd8, 0x31, 0x4d, 0xda, 0x76, 0x33,
+	    0x77, 0x50, 0x80, 0x01,
+	0x00, 0x99, 0x18, 0x12, 0x23, 0x48, 0xfc, 0x3e, 0x22, 0xd7, 0x39, 0x32,
+	    0x27, 0xbb, 0x5b, 0x33,
+	0x4d, 0x11, 0x5e, 0x03, 0xa2, 0x78, 0xe4, 0x21, 0x0a, 0x0d, 0xeb, 0xdf,
+	    0x74, 0xf6, 0xad, 0xb2,
+	0xc9, 0x37, 0x6d, 0x06, 0x7d, 0x67, 0xcb, 0x4d, 0xe3, 0x81, 0x7d, 0x3b,
+	    0x88, 0xb1, 0x0d, 0x29,
+	0xd9, 0x92, 0xbb, 0xd8, 0x4b, 0x40, 0xd8, 0x67, 0xb3, 0xb6, 0x10, 0xc2,
+	    0x8b, 0x40, 0x37, 0xd2,
+	0x21, 0xf7, 0x40, 0xa9, 0xfd, 0xe6, 0x8a, 0x08, 0x92, 0xda, 0x53, 0xec,
+	    0xd4, 0x70, 0x45, 0x1f,
+	0x07, 0x29, 0xbd, 0x43, 0xb8, 0x81, 0x1c, 0x08, 0x19, 0xd0, 0x8d, 0xd5,
+	    0x46, 0xf9, 0xd5, 0xac,
+	0x94, 0xd7, 0x56, 0x44, 0x8d, 0xbd, 0xc9, 0x8c, 0x44, 0x95, 0xec, 0xa9,
+	    0x2f, 0xf8, 0xed, 0x3b,
+	0xc5, 0x3b, 0x39, 0x91, 0x1f, 0xbe, 0xd5, 0x28, 0xde, 0x18, 0xf0, 0xbd,
+	    0xa0, 0x61, 0xae, 0xbb,
+	0x01, 0x34, 0x64, 0xed, 0x0b, 0x18, 0x16, 0xd8, 0x6b, 0x8b, 0xa4, 0xbf,
+	    0x5e, 0x93, 0xcb, 0x18,
+	0xf3, 0x92, 0xd6, 0x93, 0xba, 0xe8, 0xf7, 0x27, 0xab, 0xc7, 0xd7, 0x05,
+	    0x94, 0xf7, 0x7d, 0x88,
+	0x80, 0x94, 0x97, 0x60, 0x54, 0x88, 0xcd, 0x79, 0x4c, 0x99, 0xef, 0x2a,
+	    0xbd, 0xe0, 0xcd, 0x8d,
+	0x20, 0x40, 0x68, 0x4c, 0x8c, 0xae, 0x35, 0x66, 0xe1, 0x71, 0xc4, 0xd2,
+	    0x89, 0xbd, 0x98, 0x30,
+	0x29, 0x0f, 0x4d, 0xa7, 0xd4, 0x64, 0x1d, 0x78, 0xef, 0xfa, 0xfe, 0xd7,
+	    0x82, 0x49, 0xa3, 0x01,
+	0x15, 0x98, 0xdf, 0x31, 0x12, 0xb3, 0x2f, 0x70, 0x07, 0x27, 0x84, 0xef,
+	    0xe2, 0x29, 0x24, 0x5f,
+	0xb1, 0x2f, 0xd1, 0x3f, 0xd7, 0xf4, 0x47, 0xbb, 0x97, 0x53, 0x87, 0xed,
+	    0x00, 0x4a, 0x78, 0x24,
+	0xe1, 0x9c, 0xf8, 0x36, 0x60, 0xbf, 0x68, 0xca, 0xec, 0x4d, 0xbb, 0xcf,
+	    0xe0, 0x24, 0xb7, 0x2d,
+	0xfe, 0xdc, 0x9b, 0xee, 0x85, 0x2e, 0x61, 0x43, 0xc5, 0xe3, 0xed, 0x34,
+	    0x4a, 0x36, 0x78, 0xf0,
+	0x23, 0x12, 0xbc, 0x1b, 0x33, 0xa7, 0x00, 0xc3, 0x09, 0x4d, 0x01, 0x8f,
+	    0xd0, 0x4e, 0xdd, 0xef,
+	0x70, 0x60, 0xb6, 0x27, 0xe1, 0xbc, 0xb9, 0xd1, 0xc5, 0xe1, 0x99, 0x0c,
+	    0x20, 0x17, 0x7f, 0xcf,
+	0xf9, 0x99, 0xb9, 0x22, 0xf9, 0x75, 0x76, 0x67, 0xe1, 0x4a, 0xb2, 0x64,
+	    0xbb, 0xb5, 0x31, 0x4d,
+	0xc8, 0x0a, 0xb6, 0xf4, 0xeb, 0x54, 0x9a, 0xe3, 0x45, 0x87, 0x34, 0x0b,
+	    0x91, 0x65, 0xa0, 0xbb,
+	0x33, 0x30, 0x01, 0xe1, 0x9e, 0x2b, 0xf5, 0xa3, 0x46, 0x04, 0xb3, 0x64,
+	    0xd3, 0x74, 0xa0, 0x23,
+	0x5a, 0x78, 0x7e, 0x7c, 0x95, 0x5c, 0x3f, 0xf5, 0x85, 0xe1, 0x62, 0xe7,
+	    0xd7, 0x6f, 0x79, 0x76,
+	0xd2, 0x95, 0x3b, 0x12, 0xbb, 0xad, 0xb6, 0x4a, 0x7a, 0x47, 0xea, 0x3e,
+	    0x85, 0xb4, 0xb1, 0x83,
+	0xfe, 0xf9, 0xf2, 0x2e, 0x61, 0xb5, 0x24, 0x3e, 0x71, 0xe6, 0x37, 0xd7,
+	    0x6a, 0x7b, 0x62, 0x49,
+	0xc0, 0x95, 0xac, 0x27, 0x3b, 0x5e, 0x83, 0x86, 0xc0, 0x48, 0xbc, 0xd7,
+	    0x31, 0x65, 0x65, 0xfb,
+	0x30, 0x86, 0xda, 0x2c, 0x3a, 0x94, 0xbb, 0x4a, 0x45, 0x18, 0x24, 0x00,
+	    0x26, 0xb6, 0x78, 0x12,
+	0xbd, 0x81, 0x6d, 0x52, 0x6a, 0xd8, 0x92, 0xfc, 0x80, 0xc1, 0x55, 0x1f,
+	    0x78, 0x6d, 0xad, 0xab,
+	0xa8, 0x50, 0x13, 0x0b, 0xcf, 0xfc, 0x74, 0x7f, 0x82, 0x42, 0xfa, 0x7e,
+	    0x4b, 0x05, 0x6a, 0xa2,
+	0xae, 0x73, 0xd4, 0x72, 0xa6, 0x6c, 0x8f, 0x1b, 0x44, 0x2b, 0x6d, 0x7c,
+	    0xd7, 0x6d, 0xa8, 0x1d,
+	0x28, 0x32, 0x6c, 0x60, 0x16, 0x82, 0x75, 0x7e, 0x5a, 0xe3, 0x8b, 0x75,
+	    0x5b, 0x0f, 0x94, 0xc7,
+	0xb2, 0xaf, 0x93, 0xda, 0x5a, 0x3f, 0x2a, 0xa7, 0x54, 0xff, 0x2f, 0x01,
+	    0x87, 0xcd, 0x9c, 0xd6,
+	0xea, 0x8c, 0x1c, 0x65, 0x92, 0x21, 0x64, 0x97, 0xd8, 0x37, 0xe7, 0xff,
+	    0x5f, 0x4d, 0x82, 0x52,
+	0x03, 0x4f, 0xfa, 0xf7, 0xc2, 0xad, 0xb1, 0xca, 0x6e, 0xfd, 0x41, 0x5e,
+	    0x01, 0x11, 0x5d, 0xe6,
+	0xb9, 0x54, 0xd3, 0x93, 0xb1, 0xce, 0x8d, 0x5b, 0x5f, 0x73, 0xdd, 0x62,
+	    0xb9, 0x05, 0x90, 0x3f,
+	0xd7, 0x77, 0x9a, 0xf9, 0x32, 0x76, 0x55, 0x10, 0x6e, 0x32, 0xef, 0x7a,
+	    0x85, 0xdf, 0x77, 0x75,
+	0xd0, 0x0b, 0xc4, 0xd0, 0xb3, 0x57, 0x6e, 0xc1, 0xe7, 0xfa, 0x1c, 0x55,
+	    0x2c, 0xea, 0xbe, 0xba,
+	0x8c, 0xa9, 0x15, 0xe6, 0x70, 0x66, 0xad, 0x11, 0xa2, 0x3d, 0xad, 0xe1,
+	    0x1b, 0x47, 0x31, 0xf5,
+	0x46, 0x88, 0xf3, 0x75, 0x93, 0x3a, 0xfd, 0x82, 0x40, 0xf4, 0x69, 0x97,
+	    0x08, 0xda, 0x68, 0xfa,
+	0xa5, 0xae, 0x11, 0x73, 0xcd, 0x5b, 0x52, 0xdb, 0xec, 0x69, 0xab, 0x22,
+	    0x79, 0x98, 0xb5, 0x38,
+	0xc4, 0xbb, 0xa5, 0x39, 0xe8, 0x95, 0xcf, 0x4b, 0xe5, 0x44, 0x7f, 0x57,
+	    0x25, 0x67, 0x78, 0xfb,
+	0x7a, 0x85, 0x7c, 0xd6, 0x96, 0x86, 0x69, 0xaf, 0x01, 0x3e, 0xac, 0x22,
+	    0x0b, 0x47, 0xff, 0x4a,
+	0x48, 0x77, 0x2f, 0x38, 0x70, 0x7f, 0x67, 0xca, 0x4a, 0x3e, 0xa7, 0xcf,
+	    0x60, 0x24, 0x47, 0xbe,
+	0xd1, 0x0c, 0x00, 0x8b, 0xd3, 0xed, 0xf2, 0x1b, 0xe6, 0x1d, 0x43, 0xdd,
+	    0xdb, 0xfd, 0xb1, 0xfc,
+	0xda, 0xd2, 0x0e, 0x78, 0x9f, 0xbb, 0x05, 0x67, 0x14, 0xff, 0x8c, 0x4b,
+	    0x90, 0x19, 0xfd, 0x37,
+	0xba, 0xd3, 0xa5, 0xcc, 0xb9, 0x3c, 0x8a, 0xf8, 0x91, 0x33, 0xe8, 0x1e,
+	    0x7e, 0xf3, 0x4e, 0xa2,
+	0x4c, 0x0f, 0xc9, 0x9d, 0xa3, 0x8a, 0x84, 0xdb, 0xed, 0x64, 0xe7, 0x13,
+	    0x57, 0x72, 0x8b, 0xf9,
+	0x20, 0x3d, 0x9d, 0x19, 0xb7, 0x25, 0x4e, 0x25, 0xe5, 0x6f, 0x64, 0xd8,
+	    0xad, 0x83, 0x0a, 0x32,
+	0x82, 0x13, 0xd3, 0x79, 0xc1, 0xae, 0x70, 0x3b, 0xfc, 0x60, 0x05, 0x93,
+	    0xea, 0xe3, 0x58, 0xf0,
+	0x27, 0x5f, 0xb2, 0x5c, 0xfe, 0xad, 0x49, 0x04, 0x65, 0x83, 0xce, 0x5d,
+	    0xfa, 0x7d, 0xd2, 0x28,
+	0x26, 0x28, 0x9b, 0xe9, 0x2d, 0xac, 0x99, 0xd9, 0x01, 0xcc, 0x57, 0x32,
+	    0x4f, 0xeb, 0x07, 0x06,
+	0xa5, 0x99, 0xf3, 0xd4, 0x12, 0xac, 0xd0, 0x28, 0xe5, 0xa1, 0x3c, 0xc6,
+	    0x29, 0x4f, 0x51, 0x32,
+	0x5b, 0x18, 0x90, 0xa9, 0x36, 0x47, 0x56, 0x75, 0xd6, 0x69, 0x38, 0xd7,
+	    0x22, 0x3a, 0x02, 0x12,
+	0x25, 0xc7, 0x6d, 0x34, 0xa2, 0x2c, 0x5f, 0x64, 0x0f, 0xc9, 0x89, 0x63,
+	    0x3f, 0xd7, 0xc5, 0xd6,
+	0x74, 0x3a, 0xb0, 0xe6, 0x32, 0x26, 0xd9, 0x39, 0xe3, 0xc9, 0x4d, 0x15,
+	    0x28, 0x4a, 0x5a, 0x02,
+	0xf1, 0x79, 0x1f, 0x11, 0xbf, 0x2d, 0x33, 0x5c, 0x68, 0xbf, 0xb0, 0x41,
+	    0xc6, 0x97, 0x22, 0x0f,
+	0x9f, 0x83, 0x85, 0xb7, 0xea, 0x24, 0x9a, 0xd0, 0xe8, 0x66, 0xc7, 0xd0,
+	    0x79, 0xf2, 0xdc, 0x70,
+	0xa2, 0x35, 0x0c, 0x5c, 0x3f, 0x7b, 0xc8, 0x27, 0x75, 0x6b, 0x34, 0xe5,
+	    0x35, 0x67, 0xa9, 0xc8,
+	0x2e, 0xc4, 0xf8, 0xe5, 0x28, 0x2e, 0x43, 0x33, 0x68, 0x8a, 0xfa, 0x40,
+	    0xa1, 0x14, 0xa6, 0xb1,
+	0xfb, 0xee, 0xda, 0xb0, 0xe3, 0xc0, 0xd6, 0xa8, 0xca, 0x41, 0x67, 0x5f,
+	    0xff, 0x6d, 0x03, 0xb9,
+	0x2b, 0x90, 0x79, 0xcc, 0x17, 0xa7, 0x7e, 0xfd, 0xe8, 0xdd, 0xa8, 0xc9,
+	    0x59, 0xce, 0x98, 0x34,
+	0x80, 0x71, 0x00, 0x0f, 0xce, 0x03, 0x97, 0x8d, 0xde, 0x45, 0x4f, 0x9c,
+	    0x5a, 0x63, 0x73, 0x46,
+	0x72, 0xe3, 0x69, 0xae, 0xeb, 0x8f, 0x21, 0x7f, 0x41, 0x80, 0xcb, 0x38,
+	    0x01, 0x10, 0xc3, 0x7d,
+	0xc5, 0x46, 0x41, 0xfd, 0xa2, 0x2d, 0x4c, 0x86, 0x67, 0xe0, 0x8e, 0xfc,
+	    0xcb, 0xb1, 0x80, 0xe0,
+	0xff, 0x2e, 0xa4, 0x8e, 0xde, 0xf5, 0xc6, 0xba, 0x81, 0xde, 0x2b, 0x49,
+	    0x80, 0x92, 0xde, 0x07,
+	0xaa, 0x1d, 0xc0, 0xf4, 0x30, 0xa4, 0x08, 0x92, 0x60, 0xce, 0xeb, 0x45,
+	    0xf6, 0x0f, 0x17, 0x09,
+	0x56, 0x97, 0x16, 0x18, 0x42, 0x0e, 0xad, 0x1c, 0x12, 0xe3, 0x46, 0xcc,
+	    0xdb, 0x4c, 0xdf, 0x34,
+	0x36, 0x69, 0x71, 0xf9, 0x0e, 0xf6, 0x29, 0x90, 0x8d, 0xe5, 0x58, 0x7d,
+	    0x8d, 0xa9, 0xd8, 0xa9,
+	0x84, 0xf0, 0xdb, 0xfb, 0xcb, 0x84, 0xb1, 0xb2, 0x63, 0xf8, 0x78, 0x31,
+	    0x8a, 0x73, 0x9f, 0xe7,
+	0x57, 0x99, 0xba, 0x88, 0x1f, 0xc9, 0x4b, 0xca, 0x6b, 0x70, 0x96, 0x1d,
+	    0xf0, 0x8f, 0xd6, 0x31,
+	0x0b, 0x6a, 0x2d, 0x3f, 0x8b, 0x1a, 0x82, 0x03, 0x40, 0x76, 0xfd, 0x89,
+	    0x35, 0x77, 0xa2, 0x0e,
+	0x22, 0x17, 0x47, 0x75, 0xcd, 0x8e, 0x0b, 0x9b, 0xe8, 0xc4, 0x9d, 0x0b,
+	    0xad, 0xe4, 0x14, 0x05,
+	0xd2, 0x14, 0x44, 0xec, 0xe8, 0xc6, 0xc6, 0x9e, 0xdc, 0x2d, 0x38, 0x31,
+	    0x8c, 0xaf, 0x77, 0x58,
+	0xe0, 0xf6, 0xdc, 0x92, 0x77, 0xb5, 0xcf, 0xd8, 0x4f, 0xca, 0x63, 0xe5,
+	    0xfe, 0x14, 0xcc, 0x65,
+	0x89, 0x37, 0x95, 0xc4, 0x0a, 0x36, 0x47, 0x89, 0x3c, 0xaf, 0x86, 0x34,
+	    0xfc, 0xab, 0x1e, 0xee,
+	0xdf, 0xd3, 0xb6, 0x6e, 0x93, 0xfc, 0x63, 0x6e, 0x44, 0x87, 0xfe, 0xeb,
+	    0x73, 0xff, 0xd5, 0x3c,
+	0x3f, 0x60, 0xda, 0x4c, 0x37, 0xb5, 0x26, 0xfe, 0xc6, 0xa2, 0xc0, 0x5e,
+	    0xdc, 0x5d, 0x66, 0xb0,
+	0x09, 0x8e, 0xdb, 0x20, 0xb8, 0xfd, 0x4f, 0x18, 0xd2, 0x51, 0xf3, 0x6b,
+	    0xd8, 0x9e, 0x97, 0xff,
+	0x1f, 0xdb, 0x7b, 0x18, 0x56, 0x4e, 0x25, 0x3b, 0x87, 0xae, 0xea, 0xbc,
+	    0x1e, 0xbe, 0x3a, 0xf3,
+	0x38, 0x8b, 0x15, 0x77, 0x28, 0x62, 0x05, 0xa4, 0x7b, 0x60, 0xac, 0x46,
+	    0xa3, 0x05, 0xb0, 0xe3,
+	0x3d, 0x8b, 0xdc, 0x6e, 0xfa, 0x45, 0x8f, 0xb4, 0x6b, 0x1a, 0x58, 0xb8,
+	    0x54, 0x67, 0x49, 0x30,
+	0xb8, 0x1d, 0x51, 0xa4, 0x6f, 0x60, 0xb6, 0x0d, 0xa3, 0x0d, 0xa9, 0xde,
+	    0xe3, 0x8b, 0x8e, 0x71,
+	0xb0, 0xa1, 0x32, 0xf7, 0x3d, 0xde, 0x43, 0xce, 0x62, 0xc8, 0xa9, 0x21,
+	    0xd7, 0xa1, 0x1c, 0x3c,
+	0x31, 0xb0, 0x7d, 0x79, 0xed, 0x79, 0x28, 0x52, 0x2a, 0x75, 0xeb, 0x14,
+	    0xd2, 0x72, 0x30, 0x54,
+	0xea, 0x54, 0xb7, 0x3e, 0x61, 0xba, 0x26, 0x76, 0xa2, 0xc6, 0x4f, 0x3b,
+	    0xae, 0x19, 0xc3, 0x43,
+	0xee, 0xad, 0x12, 0xbb, 0x2b, 0x95, 0x47, 0x03, 0xa2, 0x57, 0x41, 0x5b,
+	    0xa6, 0x93, 0x89, 0xf0,
+	0xf6, 0xf8, 0x59, 0xd7, 0x7d, 0x38, 0xeb, 0x82, 0x4f, 0x06, 0x70, 0x0b,
+	    0x46, 0x3a, 0x97, 0x7b,
+	0x34, 0x82, 0xfa, 0x37, 0x20, 0xdd, 0x6a, 0x19, 0x74, 0xe7, 0xbb, 0x52,
+	    0xfb, 0x0d, 0x75, 0x27,
+	0x31, 0x4b, 0xaa, 0x15, 0x1f, 0x0a, 0x43, 0x89, 0xec, 0xc8, 0x1a, 0x4f,
+	    0x6d, 0x2b, 0x84, 0x69,
+	0x8b, 0x87, 0x12, 0x89, 0xab, 0xe0, 0x86, 0xf9, 0x6b, 0xb5, 0x2c, 0xcf,
+	    0xb3, 0x65, 0x57, 0x65,
+	0x60, 0x7a, 0xb0, 0xee, 0x15, 0xa6, 0x63, 0x44, 0xea, 0xdb, 0xcf, 0x41,
+	    0x2e, 0x0e, 0xf6, 0x2a,
+	0x88, 0xeb, 0xfa, 0xa2, 0xb6, 0x21, 0x44, 0x0a, 0x22, 0x41, 0x06, 0xff,
+	    0xfb, 0x53, 0x80, 0xa7,
+	0xa7, 0x00, 0x42, 0xb4, 0x08, 0x60, 0x60, 0xc8, 0xa9, 0xe2, 0xa5, 0x82,
+	    0x5d, 0xef, 0xac, 0x16,
+	0x8c, 0x2d, 0x3e, 0x43, 0x93, 0x81, 0x41, 0x48, 0x21, 0x0a, 0xaa, 0x49,
+	    0x3b, 0xf1, 0x2b, 0xee,
+	0x22, 0xf3, 0xb5, 0x18, 0x8b, 0x62, 0xff, 0x5d, 0x3f, 0xac, 0x22, 0x0f,
+	    0x64, 0x34, 0xd2, 0x04,
+	0x06, 0xb8, 0x3f, 0x16, 0x30, 0x3a, 0x6b, 0x9d, 0x9f, 0xcd, 0x20, 0xc6,
+	    0x8f, 0x32, 0x36, 0x20,
+	0xc3, 0x53, 0x77, 0xb3, 0x90, 0x37, 0x0a, 0xd2, 0x01, 0xc5, 0x28, 0xd6,
+	    0x8a, 0x33, 0x17, 0xc4,
+	0x4b, 0x56, 0xc9, 0x01, 0x9a, 0x68, 0xc6, 0x5f, 0x09, 0x63, 0xc1, 0xa3,
+	    0x51, 0xed, 0xdd, 0xf0,
+	0x48, 0x22, 0x7b, 0xf6, 0xb7, 0x70, 0x60, 0x76, 0x4c, 0xa5, 0xc2, 0x41,
+	    0x7e, 0x8e, 0xc0, 0xe4,
+	0x87, 0x6b, 0xde, 0xc6, 0x81, 0x69, 0xec, 0x9e, 0x4c, 0xf2, 0xec, 0x23,
+	    0xa8, 0x35, 0x34, 0xd4,
+	0xca, 0x44, 0x75, 0xe5, 0x92, 0xb4, 0x88, 0x63, 0xc2, 0x8a, 0x3b, 0x87,
+	    0xff, 0xa3, 0x85, 0x31,
+	0xcb, 0xbd, 0xdf, 0xc7, 0x20, 0x77, 0x6d, 0x1a, 0x11, 0x17, 0x39, 0x1b,
+	    0x1b, 0x32, 0xdd, 0x53,
+	0x11, 0x47, 0x86, 0x3f, 0x52, 0x78, 0xe2, 0xc0, 0x42, 0xa8, 0x4d, 0x32,
+	    0x04, 0xda, 0x10, 0xea,
+	0x48, 0x30, 0x97, 0x08, 0x43, 0xf3, 0x53, 0xcf, 0xbe, 0x50, 0xf4, 0xfe,
+	    0x8d, 0xfe, 0xb2, 0x6b,
+	0xad, 0x94, 0x22, 0xe3, 0xe3, 0xe4, 0x12, 0x3c, 0x43, 0x1d, 0xca, 0xba,
+	    0xd8, 0xa6, 0xc7, 0x2d,
+	0xe1, 0x9b, 0xde, 0x8a, 0x1d, 0x85, 0x19, 0xd2, 0xb9, 0x53, 0x97, 0xed,
+	    0xda, 0x38, 0x5d, 0x2b,
+	0xaf, 0x58, 0xed, 0x9d, 0xba, 0xf8, 0x27, 0x47, 0x45, 0x56, 0x2b, 0xdf,
+	    0x74, 0xfd, 0x86, 0x5c,
+	0x4f, 0x1a, 0xc7, 0x2a, 0x1e, 0xe3, 0xed, 0x4d, 0x9d, 0xd7, 0x4d, 0x73,
+	    0x93, 0xc5, 0xfa, 0xba,
+	0x90, 0x78, 0x0e, 0x59, 0x9e, 0xe0, 0x04, 0xd6, 0x1d, 0xf2, 0x4f, 0xef,
+	    0x56, 0x72, 0x36, 0x4d,
+	0x0b, 0x01, 0xfa, 0x36, 0xc9, 0x3e, 0x66, 0xd4, 0x01, 0x1a, 0x34, 0xc9,
+	    0x77, 0xd8, 0x77, 0x37,
+	0x07, 0x12, 0xe5, 0x37, 0xf8, 0x30, 0xfb, 0x9b, 0xcf, 0xfe, 0xed, 0xcc,
+	    0xc3, 0xde, 0x6a, 0x1f,
+	0x65, 0xa0, 0xd8, 0x21, 0xb7, 0x0d, 0xf0, 0x83, 0xb5, 0x6f, 0x88, 0xd9,
+	    0x52, 0xa3, 0x3e, 0x3b,
+	0xee, 0xc5, 0x28, 0x57, 0x61, 0x0a, 0x3a, 0xd0, 0x6d, 0xa0, 0x18, 0x44,
+	    0x37, 0x66, 0x79, 0xbe,
+	0xe7, 0x9e, 0x34, 0xd7, 0x37, 0xab, 0x95, 0x51, 0x67, 0xa7, 0x3c, 0x17,
+	    0x9d, 0x4d, 0x13, 0xa3,
+	0x6b, 0x2c, 0xd1, 0x13, 0x7c, 0xf2, 0x60, 0x2c, 0x20, 0x1c, 0x79, 0x96,
+	    0x75, 0x5c, 0x18, 0x65,
+	0xfb, 0x8b, 0x9e, 0x16, 0x94, 0xa0, 0xcb, 0xc7, 0x8c, 0xc9, 0xf4, 0x8d,
+	    0xe5, 0xa4, 0xa8, 0xf3,
+	0x30, 0x28, 0xd2, 0xad, 0xe4, 0xe4, 0x29, 0x8d, 0xf2, 0x16, 0x78, 0x44,
+	    0x37, 0xf0, 0x3b, 0xa5,
+	0xee, 0xd7, 0xfd, 0x25, 0x7d, 0x0e, 0x0e, 0x99, 0x7b, 0x67, 0x6a, 0xab,
+	    0xbd, 0xe9, 0x7c, 0xb1,
+	0xe4, 0x8d, 0x50, 0xa8, 0xb9, 0x01, 0x82, 0x18, 0xbd, 0x78, 0x87, 0x71,
+	    0x3e, 0xe8, 0x86, 0x68,
+	0x81, 0x01, 0x62, 0xaf, 0x69, 0xea, 0x33, 0x5c, 0xb3, 0x53, 0x72, 0xd7,
+	    0x3b, 0x86, 0x39, 0x68,
+	0xf2, 0x24, 0x70, 0xf6, 0x99, 0xe4, 0xfe, 0xc8, 0x4b, 0xea, 0xd8, 0x3f,
+	    0x5e, 0x78, 0x03, 0x99,
+	0x5c, 0x80, 0x73, 0x2b, 0x9a, 0x11, 0x33, 0xd2, 0x88, 0x88, 0x0c, 0xbd,
+	    0xdc, 0x37, 0x3e, 0x2a,
+	0x2c, 0x0a, 0xd4, 0x58, 0x60, 0x1d, 0x00, 0xbf, 0xe7, 0xce, 0x7b, 0x9e,
+	    0xca, 0x34, 0x74, 0x63,
+	0xbd, 0x21, 0xda, 0xb0, 0x7d, 0xbd, 0x4b, 0xd2, 0xbd, 0x8c, 0xa0, 0x40,
+	    0xb5, 0x88, 0x54, 0x73,
+	0x82, 0x0b, 0xdf, 0xe2, 0xf4, 0xc9, 0xa1, 0x7a, 0xbf, 0x2e, 0x6d, 0x8d,
+	    0xdb, 0x60, 0xf6, 0xad,
+	0xc6, 0xbf, 0x74, 0xbc, 0x1a, 0x25, 0xb1, 0x1f, 0x32, 0x6d, 0x63, 0x94,
+	    0xbd, 0x10, 0x6d, 0x9b,
+	0x8b, 0xaf, 0x7b, 0x18, 0x76, 0x7c, 0x4c, 0xd3, 0xc9, 0xad, 0xa9, 0xd8,
+	    0x34, 0x8b, 0x38, 0x9f,
+	0xda, 0x92, 0xfa, 0x64, 0x30, 0x1d, 0xcb, 0x65, 0xae, 0xa9, 0xec, 0xd8,
+	    0x15, 0xf4, 0x39, 0x16,
+	0x03, 0xe2, 0x6c, 0x32, 0x11, 0xaa, 0x68, 0x5a, 0x7a, 0x9c, 0x7c, 0x17,
+	    0xf1, 0xfc, 0xcf, 0xc2,
+	0xa0, 0x3f, 0x34, 0x03, 0x9e, 0x6b, 0x8e, 0x30, 0xd1, 0xda, 0xd7, 0xa4,
+	    0xf7, 0x00, 0x77, 0x41,
+	0xcd, 0xa2, 0x37, 0x13, 0xa3, 0xfb, 0x5b, 0xde, 0x1e, 0xc1, 0x46, 0x90,
+	    0x54, 0x0c, 0x99, 0xe6,
+	0x4e, 0x99, 0xcd, 0xae, 0xc1, 0x49, 0x4c, 0xd3, 0xc7, 0x55, 0xcc, 0xc2,
+	    0x45, 0x00, 0x12, 0xd4,
+	0xc6, 0x16, 0x7c, 0xe8, 0x3e, 0x40, 0x2e, 0x40, 0x8c, 0xb1, 0x03, 0x0e,
+	    0x77, 0x4e, 0x73, 0xa1,
+	0xc6, 0xb7, 0xcf, 0x17, 0xea, 0xae, 0xe5, 0x10, 0x62, 0x5b, 0x4f, 0x19,
+	    0xe6, 0x3b, 0x1f, 0x20,
+	0x2b, 0x9a, 0x65, 0x2f, 0xb7, 0xf7, 0x45, 0xd7, 0xe1, 0x55, 0x79, 0xd3,
+	    0x94, 0xe6, 0xe6, 0x2e,
+	0x60, 0x15, 0xc6, 0x11, 0xcf, 0xfa, 0x8e, 0x39, 0x59, 0x47, 0x76, 0x5b,
+	    0x2c, 0xba, 0xbb, 0x4a,
+	0x8e, 0x92, 0xfa, 0x4a, 0xca, 0xdc, 0x5d, 0x7a, 0x33, 0x52, 0x0a, 0xc1,
+	    0xde, 0x42, 0x5f, 0xca,
+	0xd8, 0x37, 0x65, 0xc5, 0x49, 0xf8, 0x9b, 0xd4, 0x36, 0x07, 0xe3, 0xa9,
+	    0x09, 0xf5, 0xaf, 0xda,
+	0xd9, 0x6e, 0x97, 0x60, 0x3f, 0x5c, 0x7f, 0x8a, 0xd1, 0x74, 0xbb, 0x80,
+	    0xc5, 0xb9, 0x1d, 0xed,
+	0x8f, 0x23, 0x22, 0xa8, 0xd5, 0xd8, 0x7b, 0x2d, 0x87, 0x54, 0xe0, 0x46,
+	    0x95, 0xb8, 0x56, 0x25,
+	0x0b, 0x30, 0x02, 0x4d, 0x09, 0x10, 0x07, 0x89, 0x62, 0x54, 0x5a, 0xda,
+	    0x96, 0xee, 0xd3, 0xa9,
+	0x59, 0xfb, 0xdf, 0x35, 0x12, 0xb3, 0x90, 0x95, 0x8f, 0xda, 0xcd, 0x5f,
+	    0x46, 0x51, 0xfe, 0xcb,
+	0x67, 0xf6, 0xba, 0xaf, 0x3f, 0xa0, 0x5f, 0x71, 0xcb, 0xc0, 0xcd, 0xcf,
+	    0x4b, 0x50, 0xa0, 0x73,
+	0xa3, 0x83, 0x7f, 0x43, 0x23, 0x84, 0xd0, 0xf8, 0x8a, 0xe4, 0xf2, 0x39,
+	    0x51, 0x00, 0x3a, 0x20,
+	0xe5, 0xae, 0x73, 0xfc, 0x95, 0xec, 0xbe, 0xc0, 0x1d, 0x4e, 0x88, 0x52,
+	    0xae, 0x7a, 0xb0, 0x25,
+	0x69, 0x11, 0x3b, 0x9a, 0x6f, 0xa0, 0x69, 0x90, 0x42, 0xe5, 0xcb, 0x38,
+	    0x77, 0x79, 0xa9, 0x62,
+	0x22, 0x80, 0x25, 0x8b, 0x90, 0xa3, 0x27, 0x80, 0xe0, 0xa3, 0xdf, 0x53,
+	    0x26, 0x97, 0x12, 0xf7,
+	0xe9, 0x60, 0x16, 0x44, 0x14, 0x3f, 0xa4, 0x64, 0xe1, 0x21, 0x78, 0xe0,
+	    0x61, 0x64, 0x8a, 0xfd,
+	0x80, 0x08, 0x32, 0xd6, 0xf1, 0x16, 0xe2, 0x00, 0x4b, 0x4c, 0x18, 0x68,
+	    0xbb, 0x6f, 0x79, 0xaa,
+	0x31, 0x44, 0xc1, 0x05, 0x96, 0x0b, 0x29, 0x45, 0xf1, 0xf2, 0x99, 0x1c,
+	    0xb1, 0x84, 0x34, 0x93,
+	0x22, 0x18, 0x09, 0x4c, 0x9a, 0x65, 0xd9, 0x12, 0xfd, 0x41, 0x99, 0x4a,
+	    0xab, 0xbc, 0xb3, 0x2c,
+	0xbd, 0xa9, 0x3d, 0x3c, 0xef, 0xe7, 0x6a, 0xaa, 0xae, 0x3c, 0xea, 0x3e,
+	    0xb3, 0xcb, 0xb2, 0x3c,
+	0x32, 0x53, 0xea, 0xbc, 0x01, 0x26, 0xe8, 0x37, 0xe8, 0x27, 0xa4, 0xde,
+	    0x78, 0x29, 0x3b, 0x39,
+	0xdb, 0x15, 0xda, 0x0b, 0x7d, 0xd5, 0x2b, 0x39, 0x6b, 0x4c, 0x28, 0x32,
+	    0x7b, 0xee, 0xb7, 0x5e,
+	0x87, 0x94, 0xd2, 0x34, 0x3c, 0xda, 0x79, 0x35, 0xc8, 0x7b, 0x9d, 0x8c,
+	    0x30, 0xc8, 0xff, 0x15,
+	0xf5, 0x51, 0xcb, 0xae, 0xc6, 0x5d, 0xa6, 0x6d, 0xeb, 0xcc, 0xd2, 0x57,
+	    0x66, 0xf7, 0x35, 0x32,
+	0x5a, 0x92, 0xb5, 0xd8, 0x60, 0x24, 0xae, 0x7c, 0xea, 0xcd, 0xfa, 0x96,
+	    0xc9, 0x67, 0xc8, 0xb7,
+	0x33, 0xb6, 0xa3, 0xea, 0xd0, 0x23, 0x2b, 0x89, 0x8e, 0x48, 0xd3, 0x16,
+	    0x04, 0xe5, 0x23, 0x5f,
+	0x08, 0x6b, 0x6c, 0x65, 0x72, 0xbe, 0x23, 0xfb, 0x65, 0x0f, 0xda, 0xff,
+	    0x39, 0x5f, 0x75, 0x94,
+	0x26, 0xd2, 0xbc, 0x6c, 0x22, 0x7f, 0x44, 0x21, 0x48, 0x56, 0x94, 0xa4,
+	    0x43, 0xd2, 0x9c, 0xe2,
+	0x9e, 0x4a, 0xd5, 0x93, 0xf7, 0xce, 0x45, 0xb6, 0xa7, 0x6a, 0x63, 0xc7,
+	    0x17, 0x1f, 0x9f, 0x03,
+	0x12, 0x52, 0x29, 0x6c, 0x34, 0xdf, 0x45, 0xbc, 0x41, 0x3e, 0x2d, 0xe2,
+	    0x3a, 0xd1, 0x8d, 0x7a,
+	0x12, 0x53, 0xed, 0x35, 0xa1, 0x3e, 0x08, 0x56, 0xd2, 0x62, 0x7a, 0xf5,
+	    0xf5, 0x87, 0x7f, 0xe7,
+	0x81, 0x71, 0x02, 0xe3, 0x34, 0x84, 0x94, 0x08, 0x62, 0x5c, 0x61, 0x06,
+	    0xf2, 0x85, 0x4d, 0xb2,
+	0xa1, 0x80, 0x6b, 0xf9, 0xb1, 0x52, 0x9b, 0x74, 0x3b, 0x86, 0xea, 0xb4,
+	    0x79, 0xd8, 0x7a, 0x23,
+	0x20, 0x15, 0xc9, 0x41, 0xa3, 0x39, 0xd5, 0x82, 0x05, 0x18, 0x8f, 0xe8,
+	    0xf4, 0xa6, 0x17, 0x33,
+	0xa5, 0x8d, 0x4e, 0xb7, 0x48, 0x75, 0x9d, 0xb9, 0x40, 0x8c, 0xca, 0xc5,
+	    0xa3, 0x35, 0x44, 0x66,
+	0xc9, 0x63, 0x7d, 0xf3, 0xec, 0x37, 0xae, 0x57, 0x4a, 0xb5, 0x44, 0xde,
+	    0x93, 0xfb, 0x6e, 0x2f,
+	0xde, 0x58, 0x7c, 0x11, 0x3f, 0xa3, 0x26, 0x50, 0xed, 0x96, 0xc8, 0x7c,
+	    0x2c, 0x3b, 0x47, 0x67,
+	0x13, 0x05, 0xa5, 0x7e, 0x96, 0x3c, 0x12, 0x5b, 0xa8, 0x15, 0xa9, 0x1d,
+	    0x75, 0xdc, 0xf0, 0xe7,
+	0x0a, 0x7e, 0xe9, 0x1f, 0x5f, 0x09, 0xf7, 0xa9, 0xda, 0x6a, 0xd4, 0x55,
+	    0x78, 0x1f, 0xd5, 0xaa,
+	0xd5, 0x1a, 0x99, 0xac, 0xe6, 0xad, 0x56, 0x6a, 0xc4, 0xec, 0xd1, 0x98,
+	    0x79, 0x6c, 0xf1, 0xe4,
+	0xa9, 0x88, 0xd6, 0xd8, 0x92, 0x52, 0x26, 0x7a, 0xc5, 0xdf, 0x2b, 0x1e,
+	    0xfb, 0x9f, 0xb5, 0x40,
+	0x0b, 0xc1, 0xa7, 0x6a, 0x11, 0x33, 0xec, 0x0b, 0x46, 0xa3, 0xb7, 0x5f,
+	    0xe2, 0xf5, 0x11, 0x3b,
+	0x8f, 0xb4, 0xdf, 0x40, 0xbf, 0x12, 0xe4, 0x1b, 0x47, 0xa2, 0x73, 0x0d,
+	    0xf1, 0x3d, 0x25, 0x65,
+	0x0a, 0x3f, 0x5f, 0x84, 0x36, 0x50, 0x6a, 0x2e, 0xe7, 0xc6, 0x23, 0xb6,
+	    0x9c, 0x43, 0x83, 0x7c,
+	0xd0, 0xc1, 0xf1, 0x10, 0xf0, 0x7e, 0x40, 0xb0, 0x67, 0xd1, 0x40, 0x44,
+	    0xbe, 0x22, 0xb1, 0x5c,
+	0x39, 0x7e, 0xd9, 0xa7, 0xd4, 0x72, 0x47, 0x34, 0xa7, 0x32, 0xc9, 0x35,
+	    0xe7, 0xe3, 0xed, 0x75,
+	0xed, 0x8e, 0xc9, 0xb7, 0x8d, 0x5e, 0x63, 0x32, 0x66, 0xc5, 0xc7, 0x92,
+	    0xe6, 0xe2, 0xa0, 0xd6,
+	0x63, 0x24, 0x0c, 0xd5, 0x6e, 0xac, 0xb0, 0x7b, 0x60, 0xc2, 0xaa, 0x48,
+	    0xf5, 0xe0, 0xdd, 0x43,
+	0x29, 0xa0, 0xb2, 0x52, 0xb4, 0xe7, 0x7f, 0xc1, 0x44, 0x65, 0x9e, 0x4f,
+	    0xe8, 0x48, 0xb3, 0x52,
+	0xe4, 0x82, 0x63, 0xc5, 0x38, 0x89, 0x51, 0x50, 0x49, 0x84, 0x7a, 0x20,
+	    0xb5, 0x46, 0xda, 0xbb,
+	0x0b, 0x4a, 0x6e, 0xab, 0x91, 0x37, 0x20, 0xfd, 0x62, 0xce, 0x6c, 0x30,
+	    0x49, 0xef, 0x30, 0xd3,
+	0xb7, 0xe5, 0xda, 0x8c, 0x3e, 0x58, 0x62, 0x36, 0xef, 0xce, 0x0a, 0xd1,
+	    0xb5, 0x8b, 0xea, 0x8e,
+	0x68, 0x8f, 0xaf, 0x7c, 0x2e, 0x4b, 0x9a, 0xcc, 0xc8, 0x49, 0x7a, 0xe6,
+	    0x6e, 0xab, 0xb3, 0x89,
+	0x3e, 0x5a, 0x18, 0xed, 0x1e, 0xa9, 0x63, 0x22, 0x6d, 0xd1, 0x1f, 0xb0,
+	    0xdf, 0x41, 0x5a, 0x17,
+	0xa9, 0x8d, 0x53, 0x9d, 0xbf, 0x5b, 0x01, 0xd3, 0xfd, 0x84, 0x79, 0xc3,
+	    0xdd, 0xeb, 0x02, 0x70,
+	0x2d, 0x83, 0x05, 0xcc, 0xb0, 0x2e, 0xf6, 0xee, 0x12, 0x27, 0x36, 0x11,
+	    0x3e, 0x2c, 0x12, 0xb2,
+	0x13, 0xc0, 0x7f, 0xbc, 0x3b, 0xab, 0x79, 0xd9, 0x24, 0x0e, 0xfd, 0x17,
+	    0x5c, 0xfd, 0x3a, 0x58,
+	0x6b, 0xeb, 0xd9, 0xad, 0x32, 0x03, 0x63, 0xf6, 0xe4, 0x8c, 0x0c, 0x1d,
+	    0xa8, 0xac, 0x10, 0x53,
+	0x2a, 0x30, 0x99, 0xf6, 0x99, 0x1f, 0x79, 0x8a, 0xa1, 0xcf, 0x9b, 0xcd,
+	    0xc7, 0x64, 0x9b, 0x60,
+	0x00, 0x4b, 0x9a, 0x64, 0x97, 0xf2, 0x8c, 0x4a, 0x54, 0x9f, 0x9c, 0xa0,
+	    0xd5, 0xef, 0x0c, 0x6b,
+	0xcb, 0xea, 0x6a, 0xe9, 0x96, 0x3c, 0x44, 0x5a, 0x7b, 0x9e, 0x84, 0x58,
+	    0xd9, 0xfc, 0xd3, 0x7e,
+	0x4b, 0x09, 0x7f, 0xb9, 0x36, 0x75, 0x0f, 0x21, 0x0e, 0x5e, 0x01, 0xc5,
+	    0x4f, 0x97, 0x3d, 0x17,
+	0x9e, 0xa8, 0xcd, 0x21, 0xf6, 0xbc, 0xfd, 0x4f, 0x8b, 0xc8, 0x40, 0xdd,
+	    0x74, 0xfe, 0x71, 0xc3,
+	0x4d, 0xc5, 0x18, 0xb5, 0x46, 0xda, 0x0c, 0x66, 0x3a, 0x0f, 0x77, 0xd0,
+	    0x77, 0x04, 0x54, 0x21,
+	0x5f, 0x94, 0xd0, 0x31, 0xb5, 0xb1, 0x25, 0x47, 0xc2, 0x0a, 0x3c, 0xef,
+	    0x12, 0xff, 0x65, 0x41,
+	0x26, 0x73, 0x83, 0xfe, 0xb7, 0xf6, 0xb5, 0xfb, 0x38, 0x97, 0xcb, 0xde,
+	    0x96, 0xb4, 0xff, 0x5b,
+	0x94, 0x23, 0x5f, 0xb5, 0xdc, 0xb8, 0x7c, 0x95, 0x18, 0xcc, 0x7f, 0x75,
+	    0x15, 0xc7, 0x1c, 0x62,
+	0x18, 0xd7, 0xc6, 0x8c, 0xb8, 0xb5, 0x92, 0xdc, 0x93, 0xc3, 0x8b, 0xec,
+	    0xdd, 0x75, 0x77, 0x9d,
+	0xeb, 0x36, 0xf6, 0x9a, 0x7d, 0xf6, 0x76, 0xbf, 0x90, 0x59, 0xc5, 0x4e,
+	    0x92, 0x58, 0x8b, 0x62,
+	0x64, 0x77, 0xfe, 0xaf, 0x1b, 0xf7, 0x97, 0xdd, 0x63, 0x2c, 0x68, 0xae,
+	    0x0b, 0x45, 0xfb, 0x19,
+	0x4b, 0xef, 0xf6, 0xbf, 0x18, 0xd5, 0xc5, 0x53, 0xdd, 0x96, 0x6d, 0x4c,
+	    0x79, 0x76, 0xdc, 0xba,
+	0x26, 0x95, 0x32, 0xfc, 0xf6, 0xb3, 0x7a, 0x8c, 0x9d, 0xcc, 0xac, 0x40,
+	    0xdd, 0xbe, 0xfc, 0x5e,
+	0x7f, 0x5b, 0x9c, 0x77, 0x39, 0x0d, 0x2b, 0x7e, 0x3f, 0x91, 0xbe, 0xef,
+	    0xfa, 0xff, 0xe7, 0xa8,
+	0x49, 0xd0, 0x35, 0x3c, 0xd0, 0xb8, 0xcf, 0x10, 0x6c, 0x59, 0x38, 0x20,
+	    0xda, 0xfd, 0xc7, 0x46,
+	0x4e, 0x99, 0xe3, 0xf8, 0xb9, 0x2f, 0x21, 0x4f, 0xe7, 0x74, 0x3f, 0xde,
+	    0x4c, 0xbe, 0x5e, 0x29,
+	0x48, 0xa2, 0x38, 0xea, 0x00, 0x6d, 0x9a, 0x0c, 0xab, 0x24, 0x9e, 0xd7,
+	    0xf1, 0xe0, 0x50, 0x14,
+	0x29, 0xfd, 0x58, 0x2b, 0x2d, 0xf4, 0x20, 0xc3, 0x6b, 0x03, 0x12, 0x9d,
+	    0x57, 0xa9, 0x14, 0x85,
+	0xc5, 0x07, 0x7c, 0x3e, 0xbe, 0xb7, 0x29, 0xd2, 0xe2, 0x27, 0xe9, 0x56,
+	    0xe8, 0x20, 0x37, 0x38,
+	0x87, 0xcb, 0x18, 0x91, 0xaa, 0x72, 0x93, 0x32, 0x2a, 0x27, 0x74, 0x46,
+	    0xe9, 0x21, 0x9d, 0x78,
+	0x79, 0x26, 0x44, 0xb5, 0x26, 0xdb, 0x6a, 0x12, 0x71, 0x36, 0x47, 0x5a,
+	    0x26, 0x7f, 0xdd, 0xd2,
+	0xe5, 0x77, 0x59, 0x94, 0x5f, 0x3e, 0x38, 0xc3, 0x82, 0x4a, 0x73, 0xf1,
+	    0xc0, 0x5a, 0x81, 0x7c,
+	0x8c, 0xf2, 0xff, 0x7c, 0x1d, 0x80, 0xa9, 0x63, 0x8a, 0xcb, 0x55, 0x3b,
+	    0x5f, 0x04, 0x71, 0xae,
+	0xbc, 0x96, 0x8d, 0x33, 0x51, 0x23, 0x00, 0x4d, 0x66, 0xb8, 0x26, 0x85,
+	    0xb4, 0xc6, 0xdc, 0xf7,
+	0xe1, 0x39, 0x21, 0x20, 0xc4, 0x59, 0x2a, 0xc7, 0x7f, 0x48, 0x18, 0x00,
+	    0xb3, 0x0c, 0x74, 0x1e,
+	0xe8, 0x8a, 0x0e, 0x19, 0x3b, 0xcb, 0xad, 0x05, 0xbd, 0x98, 0xa4, 0x05,
+	    0xfa, 0x2b, 0x15, 0x6b,
+	0xe8, 0x2c, 0xbe, 0x6d, 0xdc, 0x2b, 0x24, 0x8c, 0x38, 0x09, 0xad, 0x15,
+	    0x7b, 0x0f, 0xfd, 0x22,
+	0x0d, 0x94, 0x92, 0xbd, 0xd7, 0xd3, 0xdb, 0xc9, 0xa0, 0x9f, 0x11, 0x50,
+	    0xdf, 0xa3, 0x78, 0xb3,
+	0x0c, 0xfd, 0xca, 0xe5, 0x29, 0x0e, 0x0b, 0xe5, 0xef, 0xcc, 0xc7, 0xe8,
+	    0x09, 0x64, 0xed, 0x65,
+	0xe2, 0xfc, 0xc8, 0xba, 0xfa, 0x36, 0xda, 0x19, 0x91, 0xc0, 0xe4, 0x55,
+	    0xb9, 0xab, 0x87, 0xb8,
+	0xfe, 0x0e, 0x7b, 0xad, 0xd6, 0x63, 0xab, 0xae, 0x14, 0x44, 0x6c, 0x8f,
+	    0x92, 0x5f, 0x31, 0x08,
+	0xff, 0x06, 0x4b, 0xbb, 0xa8, 0x0d, 0xa3, 0xfd, 0xfe, 0x66, 0x37, 0xff,
+	    0x31, 0xe3, 0x7a, 0x86,
+	0xc1, 0x93, 0x7f, 0x43, 0xc9, 0xc6, 0x16, 0xd3, 0x54, 0xf9, 0x2b, 0x42,
+	    0x76, 0xb8, 0xcc, 0xc4,
+	0xaa, 0x64, 0xd6, 0x54, 0x59, 0x00, 0x0b, 0xc1, 0x0b, 0x5a, 0x8a, 0x9d,
+	    0xc2, 0x8c, 0xf3, 0xba,
+	0x24, 0x8d, 0xbe, 0x1b, 0xb3, 0x00, 0xc5, 0x41, 0xb8, 0xff, 0xa5, 0x5a,
+	    0x93, 0xc4, 0xad, 0x7f,
+	0xa7, 0xdb, 0xf4, 0xf3, 0xf2, 0xc3, 0x1f, 0xc2, 0x91, 0xfa, 0x65, 0xb7,
+	    0xd5, 0x68, 0xa3, 0x00,
+	0x26, 0xe0, 0xd4, 0xb7, 0x3e, 0x76, 0xd4, 0xa0, 0x76, 0xf9, 0xd1, 0x0c,
+	    0xa0, 0x39, 0x88, 0x00,
+	0x5d, 0x79, 0x9b, 0xd6, 0x7d, 0x2e, 0x5e, 0x82, 0x50, 0x77, 0x4b, 0x12,
+	    0xf1, 0xb2, 0x56, 0xb2,
+	0xda, 0x74, 0x51, 0x1f, 0xb4, 0xcd, 0xc4, 0x73, 0x15, 0x5c, 0x2a, 0x0d,
+	    0xf6, 0x3b, 0x2b, 0xe9,
+	0xa2, 0xf4, 0xda, 0xb3, 0x3e, 0x55, 0xa5, 0x73, 0x05, 0x45, 0x11, 0x97,
+	    0x0c, 0x6c, 0xa3, 0x7b,
+	0x5a, 0xbc, 0x9c, 0x8d, 0x19, 0x4a, 0x44, 0x48, 0x60, 0x6a, 0xf7, 0xca,
+	    0x87, 0x3a, 0x3a, 0x1c,
+	0x6c, 0x60, 0x4e, 0xcd, 0xd2, 0x34, 0x67, 0xde, 0x6f, 0x91, 0x21, 0x5e,
+	    0xdc, 0x86, 0xa7, 0x30,
+	0xae, 0x00, 0xdd, 0xc7, 0xd0, 0x0b, 0x4d, 0x32, 0x80, 0x6b, 0x1d, 0xae,
+	    0x13, 0x1e, 0x71, 0x9e,
+	0x08, 0xb4, 0x23, 0x0f, 0xe9, 0x31, 0xf8, 0x47, 0x64, 0xad, 0x5f, 0xe9,
+	    0x65, 0xd4, 0x1f, 0xcf,
+	0xcf, 0xe3, 0x39, 0x8b, 0xd3, 0x6d, 0x68, 0xc5, 0xc9, 0xf7, 0x56, 0x8a,
+	    0xf7, 0x8a, 0x5b, 0xab,
+	0x17, 0x71, 0x22, 0x43, 0x3a, 0xfd, 0x4b, 0x7a, 0x8d, 0x2f, 0x1e, 0x1d,
+	    0x9a, 0x3c, 0x87, 0x11,
+	0x3a, 0xb1, 0x20, 0x32, 0x53, 0x8f, 0x2f, 0xf4, 0x2a, 0xf1, 0xdf, 0xfc,
+	    0x1b, 0x31, 0x29, 0xf0,
+	0xa8, 0x8e, 0x96, 0x5c, 0x1e, 0xbe, 0x67, 0x88, 0xd3, 0x56, 0x00, 0xf9,
+	    0xfd, 0x84, 0xe0, 0x56,
+	0xc9, 0xf5, 0x60, 0x52, 0xe0, 0x3f, 0xa1, 0x3d, 0x78, 0x82, 0x5d, 0xa2,
+	    0x11, 0xca, 0x0c, 0xe1,
+	0x77, 0x25, 0xfc, 0x28, 0x37, 0xe3, 0x00, 0xdd, 0xbd, 0x62, 0x86, 0x0f,
+	    0xf6, 0x6a, 0x81, 0xed,
+	0x82, 0x4a, 0x1e, 0x82, 0x6f, 0x57, 0xbb, 0x2c, 0x2f, 0xa6, 0x8f, 0x1f,
+	    0x77, 0x87, 0x89, 0xaa,
+	0x83, 0x99, 0xf6, 0xe3, 0x44, 0x7e, 0x0a, 0x83, 0x39, 0xe0, 0xde, 0x06,
+	    0xed, 0xfc, 0xe4, 0x51,
+	0x7a, 0xf5, 0x58, 0x56, 0xb1, 0x2e, 0xd3, 0x5e, 0x9a, 0x35, 0xc8, 0x86,
+	    0x4c, 0xff, 0x36, 0xb0,
+	0x5b, 0x00, 0x6a, 0x30, 0x98, 0x23, 0xeb, 0x81, 0x7b, 0x48, 0x38, 0x82,
+	    0xa3, 0x11, 0x01, 0xf5,
+	0x98, 0x8b, 0x66, 0x37, 0xd6, 0xaf, 0x57, 0x5e, 0xb6, 0x6b, 0xb5, 0x01,
+	    0xf5, 0x64, 0x96, 0xd1,
+	0x61, 0xb5, 0xc9, 0x17, 0xb9, 0x2a, 0x07, 0x5f, 0xf4, 0xe5, 0xec, 0xf5,
+	    0x31, 0x05, 0x16, 0x79,
+	0x34, 0xca, 0x89, 0x55, 0xe1, 0x14, 0x81, 0x8a, 0x4a, 0x43, 0x0a, 0x69,
+	    0x52, 0xaa, 0x92, 0xe5,
+	0xe4, 0xb8, 0x15, 0x9b, 0x7d, 0xa9, 0x2d, 0xd3, 0x45, 0x64, 0x2d, 0x2e,
+	    0xa2, 0x62, 0xa9, 0x49,
+	0x7b, 0x9a, 0x63, 0x5b, 0x68, 0x75, 0x2d, 0x35, 0xbc, 0x3e, 0x39, 0xb0,
+	    0x51, 0x88, 0x3d, 0x79,
+	0xed, 0xfd, 0x54, 0x61, 0xff, 0x74, 0xae, 0x4a, 0xe3, 0xc0, 0x36, 0x0e,
+	    0xe5, 0xf4, 0x5a, 0x77,
+	0xf1, 0xce, 0xbb, 0xcf, 0xb9, 0x01, 0xca, 0x0a, 0x56, 0xca, 0xca, 0x1f,
+	    0x66, 0xe5, 0x7d, 0xb2,
+	0x4d, 0xc0, 0x15, 0xda, 0x44, 0x41, 0x1c, 0x57, 0xa4, 0x9c, 0xc0, 0x96,
+	    0x5b, 0xa2, 0x39, 0xef,
+	0x7b, 0x21, 0x76, 0xa7, 0x12, 0x6f, 0x81, 0xe3, 0x6f, 0xa2, 0x75, 0x1c,
+	    0xe6, 0xe1, 0x94, 0x28,
+	0xff, 0xe3, 0x8b, 0x5d, 0xe4, 0xa2, 0x45, 0x57, 0x40, 0x49, 0xa2, 0x61,
+	    0x3a, 0xe6, 0xf4, 0xa5,
+	0x85, 0x3f, 0x27, 0x95, 0x40, 0xe1, 0x7c, 0x06, 0x91, 0xbc, 0x10, 0xd9,
+	    0xd7, 0xb2, 0x14, 0x61,
+	0x47, 0xf4, 0xfc, 0xae, 0xfd, 0x92, 0x65, 0x7e, 0xc0, 0x8e, 0x86, 0x54,
+	    0x73, 0x39, 0xf1, 0x07,
+	0xe1, 0xb8, 0x83, 0xba, 0x88, 0x16, 0x57, 0x23, 0xe7, 0x43, 0x3f, 0xf0,
+	    0x1f, 0x96, 0x15, 0x60,
+	0xcf, 0x3e, 0xba, 0x95, 0xe5, 0x17, 0x3c, 0xd5, 0x5a, 0x66, 0xd1, 0x44,
+	    0x79, 0x7e, 0x04, 0x71,
+	0xe7, 0x99, 0xa4, 0x20, 0xb4, 0x73, 0x36, 0x60, 0x80, 0x36, 0x5e, 0x1b,
+	    0x72, 0xb6, 0x64, 0xf6,
+	0xce, 0xe4, 0xff, 0x11, 0xe9, 0xbd, 0x7f, 0x1a, 0x6d, 0x5e, 0x82, 0xdf,
+	    0x9e, 0xc4, 0x67, 0x21,
+	0x64, 0xb6, 0xa3, 0xa5, 0x49, 0x1b, 0x4d, 0x92, 0xde, 0xdf, 0x2a, 0xc8,
+	    0xd2, 0x7b, 0xfa, 0x2c,
+	0xa1, 0x2d, 0xbd, 0xa5, 0x5c, 0x86, 0x79, 0x15, 0x0e, 0xe6, 0xeb, 0x95,
+	    0x97, 0x63, 0x33, 0x0e,
+	0x69, 0xab, 0x76, 0xa2, 0xf4, 0xdb, 0x60, 0x90, 0x0e, 0x2d, 0xce, 0xdd,
+	    0x44, 0xf1, 0xbd, 0xbd,
+	0x8c, 0x36, 0x88, 0x2f, 0x45, 0x32, 0x63, 0x96, 0xb9, 0x48, 0xe0, 0x86,
+	    0x82, 0xff, 0x59, 0x8c,
+	0x0d, 0x35, 0x32, 0x9c, 0xde, 0x2b, 0x20, 0x95, 0x9c, 0x98, 0x37, 0xae,
+	    0xf0, 0xbb, 0xb8, 0xe8,
+	0x95, 0xd9, 0x86, 0xae, 0x85, 0xf9, 0x98, 0x82, 0xde, 0xc1, 0x4d, 0x2a,
+	    0x5c, 0x04, 0xc8, 0x48,
+	0xae, 0x27, 0xbc, 0x3a, 0x56, 0x8d, 0x0e, 0x98, 0x5d, 0x9c, 0x8b, 0x29,
+	    0xd3, 0x7a, 0xae, 0xff,
+	0xfc, 0xdf, 0xb0, 0x3c, 0x73, 0x38, 0x68, 0xc2, 0x84, 0x8c, 0xfe, 0xbe,
+	    0x20, 0x76, 0x5f, 0xeb,
+	0x47, 0xfe, 0x27, 0x17, 0xbf, 0xb3, 0x8f, 0x03, 0x96, 0x93, 0xf7, 0x66,
+	    0x53, 0x78, 0xb0, 0x62,
+	0xa9, 0xb4, 0xc9, 0x3d, 0xcb, 0x10, 0xd3, 0x68, 0x9f, 0xd5, 0x43, 0x7b,
+	    0xd5, 0xe4, 0x38, 0xe0,
+	0x4f, 0x8b, 0xac, 0xf4, 0x13, 0x11, 0xca, 0x42, 0xfb, 0xcf, 0xe9, 0x5b,
+	    0xf7, 0xeb, 0xb0, 0xe3,
+	0x3d, 0x8a, 0xbc, 0x26, 0x17, 0x02, 0x42, 0xf0, 0x79, 0x5e, 0xa1, 0x76,
+	    0xf0, 0x2c, 0x49, 0x30,
+	0xb8, 0x1d, 0xf8, 0x76, 0xac, 0x6d, 0x49, 0x25, 0x68, 0x12, 0xd9, 0x14,
+	    0xe4, 0x7d, 0x63, 0x20,
+	0xb9, 0x41, 0x53, 0x77, 0x72, 0x2a, 0xa1, 0xc2, 0xfd, 0x58, 0x66, 0xdd,
+	    0xbb, 0x2e, 0x90, 0xb3,
+	0x2c, 0x8f, 0x3f, 0x35, 0x2a, 0x2d, 0x2e, 0xd0, 0xa9, 0xe7, 0xcb, 0x8c,
+	    0xb3, 0x7f, 0xb7, 0xd2,
+	0xe1, 0xc6, 0x0c, 0xaa, 0xf8, 0x06, 0x08, 0x37, 0x81, 0x41, 0x07, 0xac,
+	    0x6c, 0x35, 0xc1, 0xc5,
+	0x9c, 0xc8, 0x88, 0x36, 0xa6, 0x4a, 0x0f, 0x4c, 0xca, 0xeb, 0x72, 0x93,
+	    0xa5, 0xba, 0x71, 0xab,
+	0x2f, 0x0a, 0xf7, 0x30, 0x1e, 0x45, 0x51, 0x78, 0xa0, 0x43, 0xa6, 0xf1,
+	    0xa4, 0x48, 0xd2, 0x1d,
+	0xa9, 0xf7, 0x02, 0x2f, 0xf8, 0x6a, 0xf4, 0x4e, 0xb7, 0x75, 0x69, 0x53,
+	    0x0d, 0x97, 0xb5, 0xb8,
+	0xa4, 0x19, 0xa9, 0x8a, 0xec, 0x3b, 0x24, 0x15, 0x0a, 0x46, 0x62, 0x3e,
+	    0x41, 0xc9, 0x3d, 0x24,
+	0xab, 0x4b, 0x53, 0x9e, 0x17, 0x31, 0xbf, 0xb6, 0xc9, 0x12, 0xfb, 0x4f,
+	    0x6b, 0x97, 0x6b, 0xab,
+	0x8c, 0x06, 0x69, 0xdd, 0x9d, 0x0e, 0x43, 0x69, 0x22, 0x1a, 0x0a, 0x4e,
+	    0xed, 0x07, 0x3d, 0x75,
+	0xe1, 0x48, 0xdc, 0x65, 0x3b, 0xcc, 0x44, 0xc8, 0xa1, 0x4f, 0xb2, 0xc6,
+	    0x6a, 0x61, 0x72, 0xa6,
+	0xa7, 0x00, 0xdf, 0xbc, 0x5b, 0x8d, 0x9f, 0x6b, 0xb7, 0x4e, 0x5e, 0x1e,
+	    0x19, 0x62, 0x79, 0xf1,
+	0x61, 0x6a, 0x7c, 0x0a, 0x94, 0x87, 0x0d, 0x44, 0x35, 0x0c, 0x3f, 0xff,
+	    0xda, 0x66, 0xb4, 0xa9,
+	0x87, 0x4d, 0x9f, 0x4c, 0xb1, 0x82, 0x9b, 0xf4, 0x0d, 0x9b, 0xec, 0x18,
+	    0x3a, 0x90, 0x3e, 0x73,
+	0x1c, 0xef, 0x28, 0xfb, 0xea, 0xed, 0x40, 0x4c, 0xc1, 0xd0, 0x38, 0x37,
+	    0x5d, 0x78, 0xd9, 0x60,
+	0x22, 0xb0, 0xac, 0x74, 0x90, 0x53, 0x8d, 0x34, 0x42, 0x2a, 0xe2, 0x98,
+	    0x98, 0x20, 0x3b, 0xa8,
+	0xa6, 0x51, 0xe6, 0xc5, 0xac, 0x34, 0x6d, 0x9a, 0xd8, 0xa7, 0x15, 0xc6,
+	    0x9d, 0xff, 0x18, 0x7b,
+	0x48, 0x62, 0x49, 0x45, 0xcf, 0x30, 0xdd, 0x10, 0x0d, 0x6e, 0x31, 0x26,
+	    0xd4, 0x7b, 0x90, 0xf1,
+	0x83, 0xeb, 0xba, 0xc3, 0x93, 0xcb, 0x87, 0x1e, 0xef, 0x31, 0x77, 0x92,
+	    0xa4, 0x72, 0xe0, 0xa3,
+	0x49, 0xe3, 0x73, 0x8f, 0xe2, 0xe8, 0xfc, 0x23, 0xe7, 0x15, 0x68, 0x16,
+	    0x86, 0x7c, 0x7b, 0x65,
+	0x8c, 0xc9, 0x05, 0x48, 0x74, 0x8a, 0x6d, 0x7e, 0x19, 0xf6, 0xa4, 0xd1,
+	    0x51, 0xfb, 0xf6, 0xa1,
+	0x23, 0x08, 0xe6, 0x92, 0x30, 0x3a, 0x1b, 0xf6, 0xa9, 0x13, 0x5f, 0x77,
+	    0x41, 0xb6, 0xfe, 0x78,
+	0xeb, 0xb9, 0xbe, 0x48, 0xd9, 0x97, 0xd6, 0x0c, 0x56, 0x43, 0x16, 0xcf,
+	    0x55, 0x3a, 0xb1, 0x7a,
+	0x61, 0x28, 0x05, 0x7c, 0x38, 0x7b, 0xc4, 0x48, 0x96, 0x56, 0x2a, 0xde,
+	    0x86, 0xd4, 0x12, 0x0d,
+	0x8e, 0xfa, 0x16, 0x09, 0x9e, 0xcb, 0x30, 0xbd, 0xee, 0x79, 0x56, 0x40,
+	    0x59, 0xa5, 0x31, 0xb0,
+	0xc8, 0xbb, 0xdb, 0xaa, 0xda, 0x56, 0x2b, 0x8b, 0xa1, 0x0a, 0x0e, 0x39,
+	    0xef, 0xa0, 0x78, 0x78,
+	0x4b, 0x18, 0x21, 0x33, 0xb9, 0x31, 0x6e, 0x76, 0xe9, 0x18, 0xee, 0x0c,
+	    0x2c, 0xd1, 0xdc, 0x9f,
+	0xc2, 0xbe, 0x6a, 0x3e, 0x97, 0xc0, 0x61, 0x1a, 0x6d, 0x0f, 0x69, 0x99,
+	    0x7d, 0xec, 0x26, 0x09,
+	0xae, 0x1a, 0x24, 0x0f, 0x3e, 0x30, 0x3f, 0xee, 0x49, 0x3b, 0x4b, 0xdc,
+	    0x5b, 0xc1, 0x29, 0x7c,
+	0x42, 0x5c, 0xb7, 0xcc, 0x8f, 0x9f, 0x82, 0xbb, 0x67, 0x53, 0x92, 0x7f,
+	    0x49, 0xbe, 0xa8, 0x2f,
+	0x84, 0x20, 0x92, 0xf7, 0xb7, 0xe0, 0x69, 0xb5, 0xe1, 0x3f, 0xd2, 0x37,
+	    0x55, 0xc7, 0xd7, 0x90,
+	0xa3, 0x5e, 0x33, 0xe8, 0xb9, 0xac, 0x30, 0x36, 0xed, 0x44, 0x28, 0xb4,
+	    0xd5, 0x26, 0x7f, 0x2e,
+	0x8c, 0x0f, 0x9f, 0x2e, 0x92, 0x81, 0x0f, 0x0f, 0x49, 0x34, 0xb7, 0x0e,
+	    0x5c, 0x4b, 0x11, 0xd4,
+	0x47, 0xa3, 0x56, 0xd0, 0x57, 0xa1, 0xf9, 0x97, 0xb9, 0x1b, 0x81, 0xc8,
+	    0xa2, 0xe3, 0xa5, 0x94,
+	0xb9, 0x39, 0x71, 0x7a, 0x10, 0xf6, 0x63, 0x7d, 0x3e, 0x69, 0x30, 0x5e,
+	    0x4d, 0xff, 0x3b, 0xa1,
+	0x8b, 0x88, 0x48, 0x34, 0xe0, 0xc0, 0x50, 0x75, 0xc6, 0x81, 0x69, 0x94,
+	    0xbe, 0x8c, 0xf4, 0xb0,
+	0x02, 0x0b, 0x3a, 0x05, 0x1a, 0xaa, 0xe0, 0xe7, 0xd0, 0x1d, 0x52, 0x11,
+	    0x54, 0xf1, 0x12, 0x74,
+	0x26, 0x76, 0xd1, 0xa8, 0x62, 0xab, 0xce, 0x5e, 0x3a, 0xa4, 0xef, 0x15,
+	    0x28, 0x4a, 0x2a, 0x9f,
+	0x6f, 0xe8, 0x19, 0x9c, 0x1c, 0xa0, 0x6a, 0x12, 0x2f, 0xa5, 0xe9, 0xd1,
+	    0x27, 0x17, 0x0a, 0x07,
+	0xe4, 0xf8, 0xb8, 0xfc, 0xe6, 0xbb, 0x02, 0xaa, 0xee, 0x42, 0x6a, 0x21,
+	    0x73, 0x64, 0x35, 0x26,
+	0x67, 0xfb, 0x63, 0xe7, 0x87, 0xe7, 0x26, 0xaf, 0xe6, 0x91, 0x73, 0xaa,
+	    0x79, 0x3e, 0x61, 0xf9,
+	0xac, 0xbb, 0x13, 0xaf, 0x62, 0x34, 0x87, 0x0a, 0xf9, 0x89, 0xc5, 0x16,
+	    0x34, 0xda, 0x9d, 0x30,
+	0x78, 0x53, 0xda, 0x31, 0x9f, 0xa1, 0x14, 0x08, 0xb9, 0x59, 0x6e, 0x9f,
+	    0xfd, 0x8c, 0xaa, 0xca,
+	0x16, 0x59, 0x2d, 0x6f, 0x35, 0x02, 0xbe, 0x1c, 0xa6, 0x6e, 0xb7, 0xfc,
+	    0xed, 0xbc, 0x38, 0x4b,
+	0xf5, 0x2e, 0x23, 0xc2, 0x56, 0x25, 0x60, 0x50, 0xb6, 0x8c, 0xc1, 0x94,
+	    0xd8, 0x7f, 0x39, 0x44,
+	0xe5, 0x22, 0x4b, 0x2d, 0xfd, 0x8b, 0xec, 0x84, 0x26, 0x4c, 0xc3, 0x81,
+	    0x52, 0xf4, 0x7c, 0x88,
+	0xc5, 0x3f, 0xb2, 0xaa, 0x32, 0x93, 0x10, 0x80, 0x8d, 0xa1, 0x8c, 0x5c,
+	    0xd8, 0xfd, 0x4a, 0x5f,
+	0x24, 0xd1, 0x9b, 0xba, 0xc9, 0x80, 0xf0, 0x9f, 0xc6, 0x2d, 0x6f, 0x45,
+	    0x01, 0x5c, 0x30, 0xf0,
+	0x9c, 0xfe, 0x7c, 0x77, 0xbc, 0xbd, 0x7f, 0xbe, 0xc5, 0xb2, 0x22, 0x54,
+	    0x88, 0x6f, 0x19, 0xb9,
+	0x4c, 0xa2, 0x6d, 0x7f, 0xf2, 0x38, 0x00, 0xec, 0xe3, 0x88, 0x2c, 0xf0,
+	    0xfb, 0x72, 0x7e, 0xc0,
+	0x95, 0x39, 0x75, 0xe5, 0xa3, 0x14, 0xd4, 0xa5, 0xca, 0xd9, 0xcc, 0x19,
+	    0xf4, 0xe3, 0x24, 0xda,
+	0xef, 0xd6, 0xb1, 0xc9, 0xda, 0x6a, 0x12, 0xf4, 0x63, 0x77, 0x50, 0x1e,
+	    0xa3, 0x38, 0x37, 0xb3,
+	0x26, 0x80, 0xf0, 0xe4, 0x40, 0xf7, 0x92, 0x1c, 0xae, 0x92, 0x64, 0x85,
+	    0x8a, 0x09, 0x3f, 0xc0,
+	0x89, 0x34, 0xe8, 0xa0, 0x84, 0xf7, 0xd9, 0x62, 0x63, 0xda, 0x1a, 0x75,
+	    0x45, 0x16, 0x30, 0xe8,
+	0x4c, 0x22, 0xe6, 0xbf, 0x04, 0x17, 0x0b, 0xf1, 0xd5, 0x64, 0xf3, 0x5d,
+	    0xf8, 0x75, 0x6b, 0xfd,
+	0x0e, 0xd9, 0xd0, 0x99, 0x9c, 0x46, 0xb5, 0x3e, 0x4b, 0x7f, 0x86, 0x4d,
+	    0x5f, 0xfa, 0x5a, 0xec,
+	0x8f, 0xda, 0x07, 0xfd, 0xde, 0xbf, 0x80, 0x82, 0xea, 0xa1, 0xe5, 0xac,
+	    0x17, 0x9e, 0x1b, 0xa9,
+	0xab, 0xb8, 0xf5, 0x04, 0xd5, 0xea, 0xc0, 0xd0, 0xeb, 0xf8, 0x7e, 0xae,
+	    0x1c, 0x54, 0x46, 0x4e,
+	0xa1, 0x31, 0x4a, 0x6b, 0xeb, 0xdf, 0x95, 0x28, 0xea, 0xd2, 0x8e, 0x06,
+	    0xaa, 0x31, 0x3c, 0xaa,
+	0xaf, 0x1b, 0xb7, 0x74, 0xca, 0xf2, 0x06, 0x89, 0x57, 0xd4, 0xa6, 0xef,
+	    0xfd, 0xea, 0x31, 0x59,
+	0xae, 0x33, 0x4c, 0x05, 0x05, 0x41, 0xd3, 0x09, 0x42, 0x23, 0x97, 0x45,
+	    0x96, 0xf1, 0x4f, 0x9b,
+	0xe7, 0x12, 0xee, 0xa0, 0x18, 0xfd, 0x67, 0x88, 0xc2, 0x5d, 0xea, 0xef,
+	    0x5c, 0xbe, 0x10, 0x04,
+	0x04, 0x21, 0x7b, 0x7b, 0x23, 0x60, 0x2d, 0x80, 0x14, 0x62, 0x36, 0xa0,
+	    0x6d, 0x5d, 0x10, 0x14,
+	0x29, 0xc5, 0x4c, 0xde, 0xaa, 0xde, 0xde, 0x56, 0xc3, 0x42, 0xbc, 0x68,
+	    0xf0, 0x68, 0xa3, 0xe9,
+	0xb4, 0x4f, 0x2a, 0x42, 0x9e, 0xfe, 0xd1, 0x21, 0x86, 0x59, 0x39, 0x21,
+	    0xf4, 0x64, 0x59, 0x99,
+	0x94, 0x05, 0xe9, 0x55, 0x73, 0xfe, 0x1c, 0xd3, 0xf2, 0x51, 0x19, 0x74,
+	    0x34, 0x60, 0x3e, 0x69,
+	0x31, 0xe2, 0xf8, 0x94, 0xe5, 0x2b, 0x18, 0xf1, 0x44, 0x94, 0x65, 0x06,
+	    0x13, 0xe4, 0xe4, 0xcf,
+	0x02, 0x45, 0xa8, 0x10, 0x9b, 0x28, 0xef, 0x4d, 0xb7, 0x94, 0xa0, 0x16,
+	    0x10, 0x1a, 0xf9, 0xbe,
+	0x6b, 0x37, 0xf9, 0x95, 0x69, 0x29, 0xba, 0xe5, 0x96, 0xc7, 0xa9, 0x07,
+	    0x93, 0x6e, 0x45, 0xe7,
+	0xe0, 0x7f, 0x83, 0xae, 0x30, 0x21, 0x99, 0x88, 0xa4, 0x41, 0xa1, 0xf7,
+	    0xd6, 0x83, 0xad, 0xea,
+	0xa9, 0x8f, 0xfa, 0x2b, 0xe5, 0x27, 0xaa, 0xaa, 0x6a, 0xb8, 0xd7, 0x31,
+	    0xda, 0x6c, 0x0e, 0x5f,
+	0x08, 0x49, 0x8e, 0xfe, 0xf8, 0x96, 0x9a, 0x4a, 0x7a, 0x0b, 0x32, 0xb5,
+	    0xdb, 0x0e, 0x87, 0x0c,
+	0x07, 0x0e, 0xe3, 0x4d, 0x76, 0xa1, 0x6b, 0xef, 0xc8, 0x06, 0x1f, 0xdd,
+	    0xdc, 0x65, 0x1f, 0x0f,
+	0xa9, 0xbb, 0x74, 0x99, 0xec, 0xd5, 0xe3, 0xbb, 0xcc, 0x81, 0x1a, 0xad,
+	    0x7a, 0x43, 0x54, 0x61,
+	0xb9, 0x41, 0x92, 0x63, 0xbb, 0xa6, 0x72, 0xa0, 0x4c, 0xfc, 0x88, 0x6d,
+	    0xf9, 0x6a, 0x70, 0xa3,
+	0xf7, 0x3c, 0xd2, 0xac, 0x1a, 0x22, 0xdd, 0x24, 0x4d, 0x9d, 0xba, 0xdc,
+	    0x61, 0x62, 0x1b, 0x4d,
+	0x83, 0x49, 0x34, 0xaf, 0x18, 0x66, 0x21, 0x29, 0xd4, 0x0c, 0x83, 0x7c,
+	    0x3b, 0x61, 0x8b, 0xe1,
+	0x07, 0xdb, 0x7f, 0xad, 0x97, 0x20, 0xb3, 0x8a, 0x47, 0xe2, 0xbb, 0xdd,
+	    0x81, 0x60, 0xf0, 0x06,
+	0x52, 0x5c, 0x3e, 0x64, 0x39, 0x2b, 0x1c, 0x25, 0xc1, 0xd8, 0x0b, 0xc4,
+	    0x3c, 0x8d, 0x72, 0x40,
+	0xca, 0xbb, 0xcd, 0x16, 0x9f, 0x41, 0x1e, 0x52, 0xc0, 0xd9, 0xbc, 0xac,
+	    0xd5, 0x50, 0x52, 0xf3,
+	0x4b, 0x78, 0x23, 0xf3, 0x52, 0x12, 0x95, 0x43, 0x41, 0xda, 0xed, 0x05,
+	    0x98, 0x50, 0x73, 0x45,
+	0x5a, 0xe8, 0xb5, 0x6f, 0x1d, 0x3e, 0x0d, 0x53, 0x40, 0xdb, 0xcd, 0x84,
+	    0xf9, 0x14, 0x43, 0xd8,
+	0xcb, 0x25, 0x70, 0xa6, 0x71, 0xc3, 0x74, 0x13, 0x5a, 0xa9, 0xac, 0x66,
+	    0x77, 0xb4, 0x72, 0xe9,
+	0x80, 0xb8, 0xb4, 0x56, 0x32, 0x77, 0x1c, 0x72, 0xeb, 0x2d, 0xbc, 0xb0,
+	    0x67, 0x78, 0x3d, 0x45,
+	0xfa, 0xb6, 0xbd, 0xa7, 0xf1, 0xc8, 0x4d, 0xe4, 0xef, 0x67, 0xed, 0x35,
+	    0x09, 0x79, 0x5e, 0x55,
+	0xfb, 0x97, 0xf5, 0x05, 0x44, 0x38, 0x65, 0x91, 0xef, 0xfc, 0x97, 0x0e,
+	    0x50, 0x71, 0x82, 0x0c,
+	0x46, 0x24, 0xf9, 0x64, 0xa8, 0x75, 0x1e, 0x4a, 0xea, 0x10, 0xde, 0xb9,
+	    0xdc, 0xd9, 0x4f, 0x70,
+	0xb1, 0xd4, 0x51, 0xde, 0x4e, 0xdd, 0x66, 0x3a, 0x6c, 0x5d, 0x15, 0x3e,
+	    0x9b, 0x49, 0xef, 0x90,
+	0x8c, 0x56, 0x7e, 0x85, 0x1d, 0x45, 0x33, 0xcb, 0xa9, 0x7a, 0x77, 0x8c,
+	    0xfe, 0x8a, 0xf0, 0x71,
+	0x65, 0xd6, 0x4f, 0x69, 0x62, 0x3f, 0x27, 0xe9, 0x69, 0x54, 0xa7, 0x42,
+	    0xd8, 0x9b, 0xf9, 0x2a,
+	0x2c, 0xac, 0x72, 0xae, 0x79, 0x43, 0x43, 0xea, 0xe8, 0x3b, 0x5e, 0xf0,
+	    0xdb, 0xf6, 0x70, 0xe4,
+	0x2d, 0xad, 0xb6, 0x5e, 0x3e, 0xbc, 0x5f, 0x7a, 0xe3, 0x85, 0xda, 0x9e,
+	    0x38, 0xa2, 0x41, 0xba,
+	0xd6, 0x11, 0xbf, 0xaf, 0xf9, 0x81, 0xd6, 0x8b, 0x08, 0x7e, 0xa8, 0x0f,
+	    0x78, 0x36, 0x4d, 0xa6,
+	0x08, 0x94, 0xf5, 0x3f, 0x17, 0x30, 0x61, 0xd0, 0x48, 0x5b, 0xa7, 0x9f,
+	    0xba, 0x3f, 0xf2, 0xea,
+	0x5e, 0xcd, 0x08, 0x9e, 0x30, 0x0d, 0x6a, 0x27, 0xe7, 0xc6, 0x0a, 0x54,
+	    0xd6, 0x87, 0xe8, 0xe3,
+	0xf8, 0x3a, 0x31, 0xb0, 0x35, 0x83, 0xb0, 0x52, 0x26, 0x3a, 0x02, 0xc9,
+	    0xd7, 0xa6, 0x79, 0x07,
+	0xac, 0x46, 0xff, 0xe7, 0xd6, 0xe0, 0xb9, 0xef, 0x67, 0xc4, 0x30, 0xc5,
+	    0xe7, 0x56, 0xae, 0xee,
+	0xd1, 0xc1, 0x2a, 0xff, 0x55, 0x6e, 0x41, 0x14, 0xa6, 0x3c, 0x42, 0x55,
+	    0xa8, 0xea, 0x73, 0x5d,
+	0x7e, 0x3f, 0x80, 0x02, 0x01, 0x29, 0x63, 0x80, 0xea, 0x69, 0x90, 0xc6,
+	    0x4a, 0xeb, 0x3b, 0x55,
+	0xd3, 0x54, 0x90, 0xd4, 0x12, 0xa1, 0x93, 0x81, 0xcb, 0x68, 0x98, 0x37,
+	    0xe2, 0xe8, 0x65, 0x7c,
+	0xbe, 0xc4, 0x99, 0xc5, 0x93, 0x6c, 0x66, 0x81, 0xc0, 0x16, 0x91, 0xc7,
+	    0xba, 0xe9, 0xce, 0x6e,
+	0xe4, 0xff, 0xd1, 0x87, 0xe8, 0xa8, 0xea, 0x91, 0x6b, 0x6a, 0xb3, 0x8c,
+	    0x74, 0xe1, 0xf9, 0xd9,
+	0x67, 0x02, 0xd0, 0x0f, 0x0c, 0xb3, 0x4a, 0xa8, 0x49, 0xa2, 0x34, 0x51,
+	    0xff, 0xeb, 0xad, 0xe7,
+	0x59, 0xcb, 0x6e, 0xed, 0x76, 0xeb, 0x5a, 0x7b, 0xc1, 0xc4, 0xe3, 0xb0,
+	    0xf8, 0x16, 0xa4, 0xe6,
+	0xd0, 0x31, 0xb1, 0x69, 0x63, 0xc6, 0x0b, 0x7b, 0xc4, 0xc5, 0xa5, 0x0a,
+	    0x5c, 0x38, 0xf0, 0x30,
+	0x29, 0x1b, 0xf6, 0x3d, 0xae, 0x2f, 0x31, 0xbb, 0x6e, 0xcd, 0xdb, 0x98,
+	    0xdd, 0xe6, 0x74, 0x63,
+	0xbd, 0xc1, 0x56, 0x2c, 0x5d, 0x73, 0xe5, 0x88, 0x06, 0xfd, 0xfe, 0x05,
+	    0xff, 0x66, 0xdd, 0x76,
+	0x47, 0xdc, 0xd2, 0x8e, 0xa0, 0xa2, 0xba, 0x63, 0x43, 0x30, 0x85, 0x9c,
+	    0xdd, 0xa5, 0x7b, 0xb3,
+	0xc6, 0xff, 0x9b, 0xcd, 0x9f, 0xec, 0x7f, 0x6f, 0xfd, 0x98, 0x08, 0x8d,
+	    0x7f, 0x64, 0x31, 0x1b,
+	0xf3, 0xcd, 0xd3, 0x8f, 0x64, 0xa0, 0x03, 0x08, 0xf3, 0x47, 0x7b, 0x1d,
+	    0x9c, 0x50, 0x88, 0x1d,
+	0x27, 0xd0, 0x30, 0x6e, 0xf8, 0x7d, 0x6d, 0x27, 0xc1, 0x59, 0xd4, 0xa5,
+	    0x69, 0xff, 0x28, 0xf2,
+	0x63, 0x97, 0x4e, 0x56, 0x2f, 0x4c, 0x34, 0xf0, 0xc4, 0x0e, 0x9b, 0xc0,
+	    0x56, 0x21, 0x31, 0xa6,
+	0x59, 0x1b, 0x5a, 0xc0, 0x87, 0x86, 0x31, 0x43, 0xde, 0xd4, 0x75, 0xba,
+	    0xa1, 0xe9, 0xd9, 0x9e,
+	0x04, 0x4c, 0xb5, 0x03, 0x37, 0xd4, 0x89, 0xd1, 0x1a, 0xd5, 0xe4, 0x39,
+	    0x50, 0xf8, 0xe9, 0xf3,
+	0x1e, 0x8b, 0x84, 0x86, 0x9a, 0x34, 0x72, 0x90, 0xe4, 0xf0, 0x8c, 0x64,
+	    0x73, 0x54, 0x14, 0xc3,
+	0x13, 0x35, 0xd6, 0x34, 0xb5, 0x9d, 0xfd, 0x70, 0xc9, 0x85, 0xc4, 0xa6,
+	    0x73, 0xfa, 0xa5, 0xda,
+	0xaa, 0x6b, 0x9d, 0x45, 0xb3, 0xef, 0xfe, 0x01, 0xc4, 0x54, 0xcd, 0x37,
+	    0x01, 0xf9, 0xfc, 0x57,
+	0xf3, 0xd9, 0x4d, 0xb5, 0xf6, 0xf7, 0x45, 0x41, 0xef, 0xb7, 0x9d, 0xb3,
+	    0xef, 0xfa, 0x92, 0xe8,
+	0xd3, 0xda, 0x23, 0xec, 0x8b, 0xdd, 0x3e, 0x1d, 0x8d, 0xd7, 0xb3, 0x2c,
+	    0xd2, 0xa8, 0xf7, 0x8d,
+	0x56, 0x95, 0x17, 0xc0, 0x3b, 0x72, 0x45, 0x9d, 0xcc, 0xb5, 0xe5, 0xe5,
+	    0x16, 0xa8, 0xfd, 0x1a,
+	0x93, 0x96, 0x9f, 0x60, 0x43, 0x66, 0x57, 0xeb, 0x0e, 0xd7, 0x8f, 0x4f,
+	    0xf0, 0xba, 0x74, 0x8c,
+	0xab, 0xe2, 0xe9, 0x66, 0x3c, 0x20, 0xd8, 0x44, 0x1c, 0x0d, 0x38, 0xcd,
+	    0x16, 0x8a, 0xa6, 0xd6,
+	0x4e, 0x69, 0x9e, 0x4c, 0x3f, 0xdf, 0xb6, 0x13, 0xb9, 0x9d, 0xbc, 0x10,
+	    0xdd, 0xf1, 0x31, 0x2e,
+	0xad, 0x99, 0xe2, 0xd8, 0x9e, 0x37, 0x06, 0x78, 0x6a, 0xe4, 0x76, 0xe7,
+	    0xde, 0x77, 0x70, 0xf5,
+	0xde, 0xdc, 0xbd, 0xce, 0x1d, 0xb8, 0x17, 0xaf, 0x9f, 0x53, 0xfd, 0xeb,
+	    0x5d, 0xf8, 0xa1, 0x5f,
+	0xf7, 0x18, 0x90, 0x3d, 0x3d, 0xbc, 0x07, 0x79, 0xea, 0xb5, 0x04, 0x1d,
+	    0x5e, 0x77, 0x80, 0xe2,
+	0x7f, 0x89, 0xc2, 0x4d, 0x92, 0x87, 0xf2, 0xa8, 0xa5, 0xc9, 0xe9, 0x57,
+	    0x6a, 0x2f, 0x80, 0x85,
+	0xa0, 0xfe, 0xf7, 0x96, 0xa3, 0x10, 0x02, 0x32, 0xd3, 0x4b, 0x34, 0xdc,
+	    0xeb, 0x2c, 0xc1, 0xf8,
+	0x95, 0x04, 0xaf, 0x67, 0x1d, 0x40, 0x31, 0xcb, 0x29, 0x71, 0x90, 0x56,
+	    0xe6, 0x2d, 0x23, 0x94,
+	0x8f, 0x89, 0xb1, 0x05, 0x49, 0x2c, 0x99, 0x12, 0x6d, 0x45, 0xff, 0x99,
+	    0xc3, 0x2e, 0x48, 0x54,
+	0xca, 0x75, 0xb7, 0xb4, 0x52, 0x2b, 0xf8, 0x65, 0xc0, 0x23, 0x89, 0x41,
+	    0xf7, 0x9b, 0xe4, 0x23,
+	0x73, 0xa3, 0x24, 0xc6, 0x13, 0x2d, 0xad, 0x71, 0x01, 0x7e, 0xd0, 0xf0,
+	    0x73, 0x37, 0x56, 0x52,
+	0xf2, 0xd7, 0xa1, 0xe2, 0x94, 0x2b, 0x91, 0x91, 0xc0, 0x49, 0xef, 0xd5,
+	    0x5f, 0x90, 0x19, 0x22,
+	0xff, 0x8e, 0xcf, 0x37, 0xd1, 0x28, 0xfe, 0x06, 0x34, 0x77, 0x5e, 0x9d,
+	    0xab, 0x2a, 0x86, 0xa8,
+	0xa9, 0x78, 0xb0, 0xf7, 0x97, 0xd5, 0xe6, 0x0c, 0x2b, 0x68, 0xf4, 0x85,
+	    0x5b, 0xf8, 0x40, 0xe3,
+	0xaa, 0x04, 0x11, 0x96, 0x18, 0x99, 0x86, 0xda, 0x89, 0xe6, 0xa4, 0x90,
+	    0xfe, 0x6f, 0x63, 0x4d,
+	0x80, 0x07, 0xe4, 0xfd, 0x18, 0x35, 0x6b, 0x5a, 0xae, 0xee, 0xad, 0x84,
+	    0x7f, 0x7a, 0x01, 0x18,
+	0x2a, 0xf6, 0xb1, 0xff, 0x72, 0x18, 0x03, 0x29, 0x22, 0x62, 0xea, 0x10,
+	    0x24, 0x64, 0x62, 0xa2,
+	0xe3, 0x7d, 0x6a, 0x49, 0x3e, 0xd8, 0xec, 0x80, 0x4e, 0x90, 0xc0, 0x64,
+	    0xa5, 0xe1, 0xc8, 0x4b,
+	0x37, 0xfc, 0x1a, 0xac, 0x07, 0xdc, 0x33, 0x93, 0x4d, 0x9d, 0x27, 0x02,
+	    0x6d, 0x32, 0x59, 0x4b,
+	0x18, 0x04, 0x93, 0x56, 0xb0, 0x5a, 0xff, 0xec, 0x1f, 0x2c, 0x07, 0x93,
+	    0x27, 0x1f, 0x6d, 0x61,
+	0xa9, 0xaf, 0x0b, 0x85, 0xf9, 0x22, 0x1d, 0xb9, 0x93, 0x21, 0x7e, 0xc8,
+	    0x6e, 0x66, 0x4e, 0x7b,
+	0x83, 0x1d, 0x44, 0x09, 0xc5, 0xbb, 0x96, 0x24, 0x7e, 0x1b, 0x07, 0x57,
+	    0x0c, 0xdf, 0xa0, 0x15,
+	0x03, 0x1c, 0x73, 0x10, 0x49, 0x24, 0x45, 0xae, 0x84, 0x3d, 0xa2, 0x9d,
+	    0xbb, 0xd8, 0x0f, 0x80,
+	0x03, 0xef, 0x81, 0x67, 0xdb, 0x3a, 0x1d, 0xa5, 0x48, 0x37, 0xc5, 0x56,
+	    0xc8, 0x1e, 0x88, 0x13,
+	0xa4, 0xa3, 0xab, 0x77, 0xe6, 0x98, 0x7f, 0xa0, 0xe0, 0x13, 0xa7, 0x26,
+	    0x90, 0x79, 0x62, 0xf9,
+	0x5e, 0xb0, 0xfa, 0x6c, 0xec, 0x9b, 0x6e, 0x13, 0x56, 0xf9, 0x14, 0x14,
+	    0x54, 0xa9, 0x5b, 0xc3,
+	0x53, 0xc4, 0xf6, 0x27, 0x1d, 0x98, 0x14, 0xf9, 0x9f, 0x04, 0x89, 0x34,
+	    0x37, 0xd1, 0xd6, 0x61,
+	0x6a, 0x67, 0x97, 0x34, 0x88, 0xc9, 0xc4, 0xa6, 0x28, 0x1f, 0xab, 0x50,
+	    0x7f, 0xd0, 0x77, 0x3e,
+	0x4a, 0x14, 0x19, 0x92, 0x79, 0x94, 0x9d, 0xf9, 0xe3, 0xf7, 0x0b, 0x5c,
+	    0x3b, 0xf4, 0x3e, 0x58,
+	0xd3, 0x17, 0x8e, 0x8d, 0x3e, 0x89, 0x22, 0x9f, 0x95, 0xf1, 0x5e, 0x40,
+	    0xda, 0x43, 0x9e, 0x87,
+	0x4f, 0xad, 0xd7, 0x40, 0x3f, 0xfb, 0x4f, 0xc9, 0x0f, 0x52, 0x1d, 0xd2,
+	    0x7f, 0xfb, 0x3f, 0xd9,
+	0xa0, 0x15, 0xb6, 0x9e, 0x1b, 0xc0, 0x46, 0xc9, 0xac, 0xf7, 0x4d, 0xde,
+	    0xc0, 0x38, 0xd9, 0x8a,
+	0xcf, 0x08, 0x04, 0x75, 0x6d, 0xf6, 0x83, 0xca, 0xdb, 0xf2, 0xf9, 0x42,
+	    0x0d, 0x74, 0xf5, 0xf5,
+	0x19, 0x5c, 0xce, 0xc8, 0x93, 0xd2, 0xc7, 0xea, 0xc9, 0x5a, 0x04, 0xfd,
+	    0x54, 0xdc, 0xe5, 0x12,
+	0x90, 0x5f, 0x0e, 0x04, 0x7c, 0x30, 0xf2, 0x10, 0x52, 0x10, 0x95, 0xb4,
+	    0xda, 0x82, 0xeb, 0x6c,
+	0x7f, 0x7d, 0xf9, 0x6c, 0xd2, 0x5d, 0xa3, 0xe8, 0x4b, 0xa1, 0x85, 0x8e,
+	    0xe7, 0x3c, 0xcc, 0x48,
+	0xaa, 0xdf, 0x34, 0xfa, 0x1a, 0x40, 0xb8, 0x09, 0x6b, 0xf0, 0xe1, 0x54,
+	    0x74, 0x89, 0x0a, 0x87,
+	0x0a, 0xe2, 0xfe, 0xaa, 0x1c, 0xa6, 0x0e, 0x97, 0x06, 0x3f, 0xe9, 0x38,
+	    0x10, 0x40, 0xad, 0x90,
+	0x00, 0x21, 0xd0, 0x94, 0xa7, 0xb0, 0x66, 0xd0, 0x41, 0x83, 0x0d, 0x83,
+	    0xad, 0x22, 0x6b, 0x02,
+	0xa6, 0x8f, 0xd0, 0x2f, 0xf7, 0xc2, 0x2f, 0x8b, 0xe5, 0x72, 0xe0, 0x24,
+	    0xf5, 0xa3, 0x11, 0xc3,
+	0x7e, 0x8c, 0x91, 0xf7, 0x99, 0xc6, 0xfc, 0xdd, 0xc3, 0xb1, 0x0e, 0x9f,
+	    0xd3, 0xbb, 0x75, 0x40,
+	0xe6, 0x71, 0x9e, 0xee, 0x7d, 0x07, 0x4e, 0x5e, 0x75, 0x50, 0x74, 0x97,
+	    0x38, 0x1b, 0xb3, 0x9b,
+	0xd3, 0x74, 0xd0, 0xc6, 0x7e, 0xa6, 0xfb, 0xff, 0x46, 0x35, 0x07, 0x05,
+	    0x39, 0x8b, 0x31, 0x7d,
+	0xfa, 0xc4, 0x66, 0xc5, 0x70, 0xd2, 0x93, 0xeb, 0x23, 0x84, 0x31, 0xbf,
+	    0xa4, 0xeb, 0xce, 0xf3,
+	0x0a, 0x2a, 0xb1, 0x43, 0x15, 0x00, 0x22, 0xd1, 0xbc, 0x0c, 0x1e, 0x37,
+	    0x93, 0xa5, 0x1a, 0x5a,
+	0x04, 0x87, 0xa0, 0xec, 0x9e, 0xcf, 0xea, 0x6a, 0x48, 0xed, 0x44, 0x51,
+	    0x94, 0x81, 0xd5, 0xba,
+	0xac, 0xf9, 0xd2, 0x9c, 0xf7, 0x6d, 0xe8, 0x5a, 0x15, 0x62, 0xe3, 0x56,
+	    0xfa, 0xf9, 0x43, 0x4f,
+	0xca, 0x87, 0x24, 0x6d, 0x11, 0xc8, 0x87, 0x58, 0xfe, 0x63, 0xcb, 0x3d,
+	    0xf8, 0x67, 0x4b, 0x5f,
+	0x95, 0x86, 0x93, 0x58, 0x93, 0xa4, 0x43, 0x3f, 0xcb, 0x59, 0x43, 0xcc,
+	    0xa5, 0x44, 0xf1, 0xd9,
+	0x2c, 0x21, 0x44, 0x2c, 0xf5, 0x0f, 0xc7, 0x1b, 0xfa, 0x45, 0xb9, 0xd6,
+	    0xb7, 0x0f, 0x22, 0xde,
+	0xc7, 0x7c, 0x46, 0xda, 0x4c, 0xb9, 0xba, 0x8e, 0x94, 0x8f, 0xbb, 0x39,
+	    0x95, 0xbe, 0xf4, 0xcf,
+	0xda, 0xfc, 0xba, 0x48, 0x7b, 0x51, 0xac, 0x43, 0xb9, 0x0b, 0x8b, 0x1c,
+	    0xbc, 0xe7, 0xfe, 0x48,
+	0xad, 0x1e, 0xa9, 0xac, 0xa9, 0xc3, 0x33, 0x7b, 0x49, 0xbe, 0xb3, 0xfa,
+	    0x23, 0x6c, 0x1a, 0x2a,
+	0xa9, 0x36, 0xd9, 0x02, 0x22, 0xb6, 0xe6, 0x53, 0xc7, 0x90, 0x8a, 0x8f,
+	    0x72, 0x20, 0x9a, 0x16,
+	0x3b, 0x4c, 0xfd, 0x85, 0x18, 0xbe, 0xc5, 0xb0, 0x69, 0x93, 0x84, 0xf1,
+	    0xab, 0x5e, 0xf3, 0xc3,
+	0xa0, 0xb7, 0x65, 0x13, 0xd1, 0x1f, 0x6d, 0xb2, 0xe2, 0xa0, 0xeb, 0xc5,
+	    0x07, 0x97, 0x15, 0xf3,
+	0xa1, 0xb6, 0x8f, 0xa8, 0x16, 0x38, 0x7e, 0xa7, 0x0e, 0xb7, 0xae, 0xcd,
+	    0x23, 0x5c, 0x8c, 0xc7,
+	0x19, 0xb4, 0x4d, 0xb8, 0xa3, 0x41, 0x0c, 0x6a, 0xc3, 0x5d, 0xfc, 0xf2,
+	    0x70, 0x6e, 0x27, 0x2d,
+	0x54, 0x95, 0xb7, 0xfb, 0xeb, 0x56, 0x3a, 0x70, 0xc9, 0x62, 0xcd, 0x52,
+	    0x92, 0x9b, 0x45, 0xe7,
+	0xa0, 0x66, 0xb4, 0xd6, 0x84, 0xf4, 0x55, 0x70, 0x45, 0xdc, 0xfc, 0x94,
+	    0xcc, 0xf9, 0x32, 0xd7,
+	0xa1, 0x15, 0xd7, 0x3c, 0x04, 0x28, 0x45, 0x61, 0xe7, 0xdf, 0x9b, 0x5e,
+	    0xf4, 0x97, 0x92, 0xf9,
+	0x1e, 0xda, 0x4d, 0xa7, 0xd7, 0xfc, 0x0e, 0x59, 0x52, 0xbd, 0x23, 0x69,
+	    0x95, 0x69, 0x7b, 0xbd,
+	0x8c, 0x36, 0x0a, 0xe1, 0x9e, 0x84, 0xeb, 0x81, 0x1f, 0x0c, 0xa4, 0xbc,
+	    0xce, 0x54, 0xe2, 0xbd,
+	0x0d, 0x35, 0x9d, 0x3f, 0x12, 0x15, 0x0f, 0x58, 0x9e, 0x4f, 0xd1, 0x93,
+	    0x15, 0x4b, 0xfe, 0xdc,
+	0x9e, 0x9d, 0xb9, 0xfd, 0xdd, 0x21, 0x6a, 0x84, 0xdb, 0x99, 0x2a, 0xcf,
+	    0x7d, 0xed, 0x6b, 0x0d,
+	0xc7, 0x9f, 0x99, 0x30, 0x38, 0x3e, 0xf2, 0x88, 0x2c, 0xd3, 0x29, 0x11,
+	    0x5a, 0x39, 0x17, 0xa9,
+	0x53, 0x14, 0x2c, 0xf6, 0xaa, 0x60, 0x26, 0xf6, 0xea, 0xbd, 0xc4, 0x01,
+	    0x79, 0x06, 0x80, 0xb5,
+	0xcf, 0x9a, 0x1e, 0x27, 0xf2, 0xfc, 0x17, 0x4c, 0x14, 0xd3, 0xa2, 0xd0,
+	    0x98, 0xbf, 0x4f, 0x51,
+	0xae, 0x8f, 0x46, 0x90, 0x42, 0xc3, 0x5f, 0xef, 0x6d, 0xb8, 0xe9, 0xfb,
+	    0x80, 0xdc, 0xdb, 0x3b,
+	0x7f, 0xd8, 0x5b, 0x2f, 0x6f, 0x31, 0x1e, 0xa4, 0x39, 0x58, 0x34, 0x00,
+	    0xb9, 0x51, 0x1a, 0x8c,
+	0xfa, 0x07, 0xb2, 0xef, 0x17, 0xea, 0xc5, 0x4e, 0xc3, 0xa6, 0x8a, 0x47,
+	    0xba, 0x25, 0x61, 0xb3,
+	0xa0, 0x0f, 0x34, 0x74, 0x24, 0xab, 0x41, 0xb1, 0xcc, 0x00, 0xbb, 0x80,
+	    0x93, 0x6f, 0x7b, 0x8c,
+	0x20, 0x80, 0x06, 0x91, 0xfd, 0x3a, 0xe7, 0xc1, 0x9d, 0x4c, 0xa3, 0x85,
+	    0x33, 0xcc, 0x12, 0xe7,
+	0x26, 0x8f, 0xe9, 0x3b, 0xd3, 0xae, 0x68, 0x8f, 0xbf, 0x35, 0xef, 0x16,
+	    0xb9, 0x95, 0xe8, 0x22,
+	0x61, 0x62, 0x91, 0x6b, 0xb6, 0xda, 0xc8, 0x83, 0xcf, 0x18, 0xa6, 0xd0,
+	    0xa3, 0xb4, 0x2b, 0x70,
+	0xbe, 0xa9, 0x46, 0x0d, 0x79, 0x97, 0xac, 0x1f, 0xf4, 0x19, 0xaf, 0xc5,
+	    0x39, 0x45, 0x37, 0x56,
+	0xa7, 0xa8, 0x25, 0xc6, 0xeb, 0x2d, 0x21, 0x56, 0x7e, 0x48, 0xe2, 0xb2,
+	    0x09, 0x6d, 0x02, 0xf2,
+	0x37, 0xf8, 0x42, 0xd0, 0x97, 0x6a, 0x72, 0x9f, 0xa7, 0x45, 0x36, 0x08,
+	    0xef, 0x0d, 0x65, 0x9a,
+	0xeb, 0xfb, 0x55, 0x36, 0x94, 0x84, 0x44, 0xda, 0x4d, 0xcc, 0xa2, 0x0c,
+	    0x75, 0xc6, 0xda, 0x09,
+	0x8e, 0xc1, 0x1f, 0xe6, 0xef, 0x7f, 0x51, 0xcb, 0x69, 0xb5, 0xab, 0xc2,
+	    0x21, 0xcb, 0x33, 0xe7,
+	0x25, 0x06, 0x95, 0x8e, 0xb4, 0x94, 0x09, 0x65, 0x22, 0x0f, 0x3b, 0x4f,
+	    0xbb, 0x0c, 0xe6, 0xb9,
+	0xa9, 0x4c, 0xc4, 0xc8, 0x56, 0xeb, 0x0c, 0x8a, 0x4e, 0xb1, 0xc0, 0xe8,
+	    0x16, 0x08, 0x63, 0x3a,
+	0xb8, 0x68, 0x5a, 0xb4, 0xff, 0x60, 0x62, 0x48, 0x18, 0x52, 0xa4, 0xdc,
+	    0xba, 0xce, 0x7d, 0x71,
+	0x8c, 0xcc, 0xcb, 0x48, 0xe5, 0xf1, 0xc3, 0x1a, 0xf2, 0xef, 0xad, 0x54,
+	    0xb2, 0x6d, 0x73, 0xa2,
+	0x76, 0xae, 0x92, 0x72, 0x3c, 0x6d, 0xe3, 0x87, 0xdb, 0x02, 0x4c, 0x8e,
+	    0xa7, 0xf2, 0x57, 0x7e,
+	0x1f, 0xe0, 0xc8, 0xb7, 0x36, 0x4b, 0x74, 0x17, 0x8f, 0x5d, 0x05, 0x95,
+	    0xd1, 0xf1, 0x63, 0x6d,
+	0x29, 0x53, 0x57, 0xbf, 0x4e, 0x20, 0xdc, 0xad, 0x4c, 0xfe, 0x9d, 0xcb,
+	    0xd6, 0x30, 0xdc, 0x81,
+	0xa6, 0xd9, 0x22, 0x81, 0x8b, 0xaf, 0x6a, 0x50, 0x43, 0x12, 0x30, 0x4f,
+	    0x05, 0x3d, 0xd1, 0xde,
+	0xa7, 0x9a, 0x38, 0xe4, 0x05, 0xba, 0xb9, 0xcf, 0x42, 0x36, 0x66, 0x92,
+	    0x50, 0x8c, 0x7e, 0x26,
+	0x32, 0x5b, 0x19, 0xc5, 0x49, 0x84, 0xd0, 0x1d, 0x9d, 0x15, 0x01, 0x9a,
+	    0xf3, 0x79, 0x4d, 0xb6,
+	0xd8, 0xb8, 0x73, 0x8f, 0xbe, 0x88, 0x58, 0x12, 0xe4, 0x14, 0x4b, 0xcb,
+	    0x51, 0x09, 0xd5, 0x2b,
+	0x07, 0x89, 0x05, 0xd8, 0x22, 0x8a, 0x35, 0x46, 0xc6, 0xdd, 0x6a, 0xa7,
+	    0x53, 0xa3, 0x58, 0x83,
+	0x8d, 0x9d, 0xab, 0xe9, 0x3c, 0xb1, 0x04, 0xc2, 0x46, 0xa8, 0x62, 0xba,
+	    0x66, 0xaa, 0x49, 0x74,
+	0xa0, 0xe3, 0xbc, 0x77, 0x3e, 0xf3, 0xa9, 0x4a, 0x91, 0x53, 0xa9, 0x9d,
+	    0xd9, 0xf9, 0x1f, 0x8b,
+	0x48, 0x91, 0x31, 0x7e, 0xd0, 0x68, 0x24, 0x3a, 0xc7, 0x18, 0xcc, 0x1b,
+	    0x5d, 0xa6, 0x2f, 0x65,
+	0x4c, 0x61, 0x08, 0xa9, 0x1b, 0x5f, 0xe2, 0x2d, 0x89, 0x56, 0x55, 0x5e,
+	    0x7c, 0xf7, 0x29, 0xe8,
+	0xe0, 0xa0, 0xd1, 0x7f, 0xbd, 0x3d, 0x67, 0x3d, 0xcc, 0xb1, 0x2b, 0xdf,
+	    0x06, 0xc6, 0x7e, 0xec,
+	0xc1, 0x78, 0x42, 0x8c, 0x36, 0xc7, 0xfa, 0x93, 0xb4, 0xd7, 0x7f, 0x9e,
+	    0xc1, 0x63, 0xb3, 0x9f,
+	0xd6, 0x6b, 0xf5, 0x9b, 0xf1, 0xec, 0x16, 0xf0, 0x58, 0xfa, 0xe6, 0x02,
+	    0x7d, 0xdf, 0x7f, 0x27,
+	0x06, 0x13, 0x3c, 0xe9, 0x5b, 0xa1, 0x77, 0x03, 0x9b, 0x48, 0xbf, 0x8f,
+	    0x05, 0x70, 0xb0, 0xa7,
+	0x3d, 0xc0, 0x87, 0xc1, 0xbd, 0xdf, 0xe7, 0x19, 0xe7, 0xa4, 0xf9, 0xe3,
+	    0xd1, 0x8b, 0xdf, 0xee,
+	0xfc, 0xfb, 0x9e, 0x76, 0xd6, 0xa0, 0x0e, 0xc0, 0x26, 0x75, 0xce, 0x21,
+	    0xf5, 0x7f, 0x03, 0x7c,
+	0xd4, 0x2a, 0x7f, 0x62, 0x13, 0xaa, 0x40, 0x36, 0xb8, 0x44, 0x29, 0x09,
+	    0x6d, 0xa3, 0xaa, 0x58,
+	0x39, 0x3e, 0xda, 0xea, 0xa5, 0x09, 0xf1, 0x3f, 0xa4, 0x69, 0x05, 0x45,
+	    0xf0, 0x57, 0x26, 0x13,
+	0xee, 0x5b, 0xd7, 0x93, 0xeb, 0x66, 0x2b, 0xed, 0x2e, 0x87, 0x64, 0x6b,
+	    0x29, 0xb2, 0x58, 0x66,
+	0xf1, 0xe1, 0x66, 0xdc, 0xa3, 0xab, 0xe0, 0xa5, 0xaf, 0x75, 0xf2, 0x8d,
+	    0xbf, 0x55, 0x97, 0x30,
+	0xf4, 0xe0, 0x5b, 0x30, 0x57, 0x0e, 0xe8, 0x34, 0x63, 0xde, 0x80, 0x47,
+	    0x71, 0x4a, 0x59, 0xc1,
+	0x68, 0x78, 0x55, 0x28, 0x35, 0xbd, 0x13, 0x63, 0x2f, 0x57, 0xd4, 0x85,
+	    0x36, 0x33, 0x51, 0xa8,
+	0xa3, 0x2a, 0x91, 0x5f, 0x77, 0x58, 0xc9, 0x15, 0x38, 0xdc, 0x29, 0x09,
+	    0xbd, 0xc4, 0xa5, 0x8e,
+	0x31, 0xb5, 0x62, 0x4f, 0x10, 0xea, 0x0c, 0xc8, 0x2e, 0x7d, 0x72, 0xc2,
+	    0xe5, 0x45, 0x51, 0x3d,
+	0xac, 0x36, 0x4f, 0x9a, 0x40, 0xf9, 0x8e, 0x58, 0xc0, 0x7f, 0xf1, 0xd4,
+	    0xf8, 0x36, 0x43, 0xb9,
+	0xd2, 0x87, 0xb3, 0x0f, 0x9a, 0x79, 0x4d, 0x2c, 0x6d, 0x15, 0xa6, 0x1e,
+	    0x7d, 0x6b, 0x39, 0x87,
+	0x72, 0x06, 0x6b, 0xea, 0xab, 0xe9, 0xc4, 0x45, 0x1f, 0x14, 0xba, 0x59,
+	    0x22, 0x46, 0xf3, 0x7b,
+	0xaf, 0x0d, 0x72, 0xa6, 0xea, 0xe1, 0x41, 0x0c, 0xbd, 0xdc, 0x8c, 0xcf,
+	    0x0e, 0xe8, 0x6b, 0x3c,
+	0x2b, 0x2c, 0x95, 0xda, 0x43, 0xb9, 0x20, 0x78, 0xfc, 0x50, 0x2a, 0x0c,
+	    0xac, 0x52, 0xc6, 0xa1,
+	0x2b, 0x51, 0x1c, 0xa2, 0x61, 0x23, 0xcb, 0x90, 0x43, 0x38, 0x1d, 0x51,
+	    0xf4, 0x1b, 0x53, 0x6b,
+	0x13, 0x90, 0x4c, 0x63, 0x3a, 0x50, 0x61, 0x79, 0x5d, 0xc5, 0xa2, 0x7a,
+	    0xd9, 0x2d, 0x0c, 0x7a,
+	0xe8, 0xd2, 0x94, 0x92, 0x32, 0x72, 0xeb, 0xa6, 0x62, 0xbb, 0xa2, 0xc4,
+	    0x14, 0xfc, 0xae, 0xf0,
+	0xd2, 0xf4, 0x13, 0xcc, 0xc4, 0x1a, 0xfc, 0x47, 0x90, 0xd0, 0x48, 0x45,
+	    0xf9, 0xb0, 0x3a, 0xcb,
+	0x26, 0xf5, 0x8c, 0xe5, 0x90, 0x2e, 0x98, 0x27, 0x9b, 0xec, 0xcb, 0xa1,
+	    0x15, 0x71, 0x15, 0x11,
+	0x0b, 0x91, 0xd5, 0x93, 0x37, 0x45, 0x7f, 0xb6, 0xe3, 0x98, 0x83, 0x9e,
+	    0x9d, 0xfe, 0xf4, 0x31,
+	0xaa, 0x3f, 0x40, 0x42, 0x7a, 0x13, 0x8b, 0xc6, 0x46, 0xdc, 0x24, 0x0e,
+	    0x92, 0xb9, 0xae, 0x98,
+	0xd6, 0x9a, 0x7c, 0xce, 0xb7, 0x28, 0x36, 0xef, 0x98, 0x0e, 0xfd, 0x90,
+	    0x84, 0xe5, 0x1d, 0xc7,
+	0x5b, 0xd4, 0xed, 0xc2, 0xc9, 0x69, 0x7e, 0x0b, 0x5e, 0x9b, 0x0a, 0x0f,
+	    0x4a, 0xb9, 0xd9, 0xa8,
+	0x04, 0xd6, 0xb6, 0xce, 0x46, 0xd9, 0x7d, 0x1b, 0x17, 0x9a, 0x45, 0x0c,
+	    0x0a, 0xb5, 0xe6, 0x93,
+	0x69, 0x9e, 0xdd, 0x0a, 0x7a, 0xa4, 0x7c, 0x2e, 0x71, 0x8e, 0xa4, 0x7d,
+	    0x97, 0xbc, 0x9a, 0xf8,
+	0x92, 0x3d, 0xb8, 0xb7, 0xd6, 0xfd, 0xa8, 0xd2, 0x6b, 0xfa, 0x81, 0x8f,
+	    0xdc, 0x78, 0x55, 0x3f,
+	0x0d, 0xc5, 0x9f, 0xab, 0xdf, 0xf5, 0xf7, 0x0a, 0xfd, 0x98, 0x8d, 0x1f,
+	    0x12, 0xbb, 0x35, 0xcb,
+	0x65, 0x32, 0x95, 0x2f, 0x63, 0x14, 0x36, 0x3f, 0x95, 0x3c, 0x16, 0x4c,
+	    0x79, 0x76, 0x59, 0xfb,
+	0x8f, 0x1d, 0x81, 0x8e, 0x6a, 0xfe, 0x8f, 0xe2, 0xcb, 0xa3, 0x70, 0x74,
+	    0x8f, 0xf3, 0x3c, 0x7d,
+	0xc4, 0xf9, 0x98, 0x9e, 0x33, 0x46, 0xbe, 0x7f, 0xca, 0x00, 0x2e, 0xda,
+	    0xfa, 0xee, 0xf3, 0x38,
+	0x2a, 0x13, 0x61, 0xc8, 0xb8, 0x5e, 0x08, 0xb1, 0x5b, 0x42, 0x43, 0x94,
+	    0x5d, 0x0b, 0xff, 0xb9,
+	0x18, 0xfa, 0x14, 0xfb, 0xed, 0xbb, 0x55, 0x11, 0xac, 0xd0, 0xa6, 0x73,
+	    0x5a, 0xf4, 0x5f, 0xe8,
+	0x0e, 0x4d, 0xb8, 0xe4, 0x1a, 0xad, 0xa8, 0xc0, 0x04, 0x5b, 0x14, 0x84,
+	    0x24, 0xf0, 0x50, 0x30,
+	0x33, 0xb8, 0x29, 0x62, 0xea, 0xda, 0x98, 0xcd, 0x71, 0x5a, 0xfe, 0x08,
+	    0xf6, 0x73, 0x19, 0xe4,
+	0xa2, 0x02, 0xd8, 0x05, 0x37, 0x39, 0xd2, 0x47, 0x3f, 0x46, 0x3d, 0xcd,
+	    0x2e, 0x2f, 0xe1, 0xb9,
+	0xa1, 0xa2, 0x8d, 0x91, 0xe4, 0xdd, 0xd8, 0x57, 0x1d, 0x4c, 0x21, 0xa7,
+	    0xd1, 0x2c, 0x60, 0xaa,
+	0x77, 0x12, 0xd6, 0xe4, 0xf9, 0x27, 0x00, 0x58, 0x5e, 0x06, 0xd3, 0x00,
+	    0xd3, 0x00, 0x6e, 0x32,
+	0x20, 0x85, 0x5f, 0xd0, 0x47, 0x52, 0x01, 0xf6, 0x24, 0xc5, 0xe0, 0xe7,
+	    0x71, 0x9a, 0x49, 0x4d,
+	0x00, 0xa1, 0x7a, 0xf4, 0xee, 0x89, 0x88, 0xb8, 0xc1, 0x86, 0xf9, 0x63,
+	    0x5f, 0x03, 0x10, 0xd7,
+	0xe4, 0xe7, 0xde, 0xaa, 0x7a, 0x28, 0xf1, 0x30, 0xe7, 0xb3, 0xdf, 0x73,
+	    0x18, 0x23, 0x80, 0x8a,
+	0xa6, 0x27, 0xb8, 0xf3, 0x98, 0x79, 0x20, 0xd7, 0x7b, 0x68, 0xcb, 0x92,
+	    0xfd, 0x78, 0x50, 0x56,
+	0x8e, 0x4b, 0x9b, 0x9e, 0x99, 0x83, 0x8d, 0xde, 0xa8, 0x52, 0x4a, 0x38,
+	    0xde, 0x4a, 0x3b, 0xe9,
+	0x61, 0x48, 0xda, 0x88, 0x3d, 0x21, 0xeb, 0xc1, 0x88, 0x07, 0xc3, 0x5a,
+	    0xda, 0x69, 0xcb, 0x45,
+	0xa7, 0x45, 0xb3, 0xcd, 0xc5, 0x80, 0xda, 0xdf, 0xfa, 0xcb, 0x73, 0x99,
+	    0xea, 0xbc, 0x1b, 0x47,
+	0x0c, 0xb4, 0x91, 0xc8, 0x4a, 0x35, 0x47, 0x73, 0x7e, 0x38, 0x52, 0xfd,
+	    0xd6, 0xce, 0x72, 0x9f,
+	0xc9, 0x0d, 0xdc, 0xf8, 0xf0, 0x6e, 0x24, 0x45, 0xa0, 0x4e, 0xb2, 0x7a,
+	    0xd8, 0x09, 0xa2, 0xcb,
+	0x2c, 0xd1, 0xfb, 0xb3, 0x36, 0x23, 0xc6, 0x1b, 0x21, 0x9f, 0x73, 0x0f,
+	    0x10, 0x9f, 0x43, 0x48,
+	0xb8, 0xfb, 0x70, 0xec, 0xb1, 0x80, 0x25, 0xd8, 0x20, 0x0c, 0xa3, 0x5a,
+	    0x26, 0x60, 0xbe, 0x7e,
+	0x30, 0xdd, 0x79, 0xa4, 0x72, 0xb0, 0x34, 0xb0, 0x81, 0x4b, 0x4e, 0xa0,
+	    0x43, 0x20, 0x8c, 0x14,
+	0x63, 0x29, 0x1c, 0xe6, 0xda, 0xe0, 0x11, 0xd2, 0x9e, 0x57, 0x94, 0xa9,
+	    0xf3, 0xd6, 0xfa, 0x79,
+	0xa0, 0xa9, 0xbf, 0x6d, 0xb0, 0x7d, 0x76, 0x47, 0x62, 0x95, 0x2d, 0xe2,
+	    0x32, 0xe1, 0xe1, 0xe2,
+	0xfa, 0xe5, 0xf2, 0x7c, 0x6d, 0xde, 0xef, 0xf9, 0x40, 0x3d, 0xbb, 0xd7,
+	    0xd2, 0x43, 0x84, 0x99,
+	0xd7, 0x0f, 0x94, 0xfa, 0x18, 0xc1, 0xb8, 0x9b, 0xa8, 0x05, 0xac, 0xc3,
+	    0x8f, 0x7b, 0xfb, 0x09,
+	0xd7, 0x8f, 0x97, 0xd4, 0x35, 0xb7, 0x14, 0x39, 0x65, 0x85, 0x4c, 0x76,
+	    0xae, 0x7a, 0x62, 0xb7,
+	0x81, 0xf7, 0x15, 0x9e, 0x0f, 0x8a, 0x0f, 0xe3, 0x93, 0x40, 0xd3, 0xdd,
+	    0x5b, 0x7d, 0xe1, 0x39,
+	0x2a, 0x5a, 0xc0, 0xcb, 0x99, 0xc3, 0xa8, 0x0e, 0xe5, 0x87, 0x87, 0xf4,
+	    0x50, 0x71, 0xbd, 0xf8,
+	0xa8, 0x07, 0x2a, 0x09, 0x20, 0xd5, 0xf1, 0x68, 0x24, 0x43, 0x6e, 0x44,
+	    0x5c, 0xf8, 0x6f, 0x58,
+	0x05, 0x1a, 0xed, 0xfa, 0x18, 0x99, 0x89, 0x5a, 0x5a, 0xad, 0x18, 0x3e,
+	    0xd7, 0x56, 0x39, 0x51,
+	0xc9, 0x1e, 0x43, 0x7e, 0xc4, 0x21, 0x74, 0xcf, 0x17, 0x57, 0x6f, 0x45,
+	    0x7e, 0xb1, 0x87, 0x14,
+	0xd6, 0x2a, 0xd1, 0xa1, 0xb1, 0x80, 0xa5, 0x47, 0xf9, 0x96, 0xa7, 0x0f,
+	    0xf1, 0x4b, 0xa1, 0xb6,
+	0x2c, 0xa4, 0x16, 0x8b, 0xd3, 0xcd, 0xac, 0x16, 0x97, 0xfd, 0x79, 0x1e,
+	    0x19, 0xe2, 0xb6, 0xd0,
+	0xd6, 0x52, 0x86, 0xcd, 0xda, 0x92, 0xa5, 0x08, 0xdb, 0xac, 0xe0, 0x2d,
+	    0xd8, 0x18, 0x5d, 0x09,
+	0xac, 0xc3, 0xdd, 0xcf, 0x78, 0x3a, 0x6f, 0x16, 0x1f, 0x3d, 0xaf, 0x6f,
+	    0x27, 0xb1, 0x1f, 0xe1,
+	0xbf, 0x5d, 0x58, 0x2e, 0x99, 0x53, 0x21, 0xff, 0x88, 0x0a, 0xe1, 0x29,
+	    0x58, 0x3a, 0x21, 0x86,
+	0x7d, 0xce, 0xd8, 0x0a, 0xf4, 0x5f, 0x88, 0xe5, 0x86, 0x49, 0xea, 0x27,
+	    0xf3, 0xf0, 0xf7, 0x50,
+	0x32, 0x44, 0x4f, 0x65, 0xb6, 0x28, 0x5b, 0xd4, 0x76, 0x57, 0xa3, 0xde,
+	    0x53, 0xe8, 0xc9, 0x02,
+	0xf3, 0xa6, 0xf8, 0x07, 0x31, 0xcc, 0x39, 0xbb, 0x61, 0x43, 0xeb, 0x1f,
+	    0x73, 0xa0, 0xf4, 0x3b,
+	0x4d, 0x0a, 0x89, 0xfd, 0xf6, 0xa7, 0x63, 0x32, 0x62, 0xd8, 0x9d, 0xb5,
+	    0x67, 0xa2, 0xa0, 0x1b,
+	0x90, 0xc6, 0xb4, 0x57, 0x62, 0x04, 0x56, 0x4b, 0x36, 0x69, 0x30, 0x7a,
+	    0xe8, 0xa6, 0xe8, 0xd6,
+	0x3a, 0x0f, 0x7b, 0x91, 0xd5, 0x85, 0x30, 0x8b, 0xae, 0x54, 0xd0, 0x70,
+	    0xda, 0x80, 0x2b, 0x00,
+	0x80, 0x0c, 0xf2, 0x04, 0x3a, 0x0b, 0x62, 0xa4, 0x0c, 0x97, 0xf2, 0x03,
+	    0x57, 0x82, 0x79, 0x6e,
+	0xc3, 0x86, 0xe1, 0x72, 0x63, 0x56, 0x6f, 0x5e, 0x2c, 0x76, 0xc1, 0xe4,
+	    0xf1, 0x18, 0x28, 0x19,
+	0x65, 0x20, 0xc3, 0x4e, 0x48, 0xab, 0x32, 0x4c, 0x0c, 0x87, 0x8a, 0x9c,
+	    0x1e, 0x38, 0xea, 0x63,
+	0x1c, 0xcb, 0xfc, 0x7c, 0x3e, 0x09, 0xc5, 0xbe, 0x30, 0x3b, 0xe2, 0x36,
+	    0xdf, 0xfe, 0x7c, 0x49,
+	0xff, 0x6e, 0xb5, 0x1b, 0x1e, 0x2d, 0x23, 0xae, 0x90, 0x47, 0xd3, 0x9c,
+	    0x14, 0xe7, 0x22, 0x1b,
+	0xbe, 0x7f, 0x74, 0x1e, 0x9b, 0x20, 0x33, 0x33, 0x4a, 0xf9, 0x2b, 0xdd,
+	    0xee, 0xad, 0xb0, 0x4f,
+	0x2e, 0x1d, 0x55, 0xee, 0xf7, 0x7d, 0x0d, 0xcf, 0x84, 0xc1, 0xf4, 0x68,
+	    0x95, 0xa8, 0x3a, 0x73,
+	0x1f, 0x96, 0xb1, 0x5e, 0x19, 0x2f, 0x6f, 0x8a, 0xcf, 0xd2, 0x5a, 0x1c,
+	    0x95, 0xce, 0x2e, 0x6b,
+	0xa8, 0xfe, 0x1e, 0xa3, 0x9e, 0x11, 0x08, 0x2c, 0x37, 0x68, 0x73, 0xfe,
+	    0x52, 0x4c, 0x42, 0xab,
+	0x93, 0xc0, 0xe6, 0x41, 0xe3, 0x5b, 0x60, 0xf1, 0xce, 0xa6, 0x93, 0x79,
+	    0x5c, 0x8b, 0x7b, 0xaf,
+	0x22, 0x23, 0x24, 0x04, 0x86, 0xd1, 0xcb, 0x5a, 0x64, 0x6b, 0xa4, 0x97,
+	    0x30, 0xeb, 0xd3, 0x55,
+	0xcc, 0xc0, 0xd4, 0x14, 0x87, 0xe3, 0xd0, 0xc1, 0x3e, 0x27, 0xb0, 0x34,
+	    0xd3, 0x0e, 0x45, 0x6b,
+	0x00, 0xdf, 0x9d, 0xc0, 0x7e, 0x63, 0xb5, 0x27, 0xa6, 0xea, 0x55, 0x53,
+	    0xb8, 0xbe, 0xca, 0x63,
+	0x25, 0x8c, 0x95, 0xd0, 0x7f, 0x62, 0x86, 0xc3, 0x65, 0xcc, 0x85, 0x48,
+	    0x77, 0x94, 0xbd, 0x1b,
+	0x25, 0x34, 0xda, 0x67, 0x57, 0xb0, 0xa7, 0x66, 0x32, 0x1e, 0xa7, 0x94,
+	    0x58, 0x78, 0xab, 0x3a,
+	0xb6, 0x1e, 0xd6, 0x25, 0x1d, 0x1a, 0xbc, 0xea, 0xc4, 0xdf, 0xf3, 0x08,
+	    0xd3, 0x46, 0xa5, 0x9a,
+	0x53, 0x92, 0x87, 0xc5, 0xb5, 0x16, 0xb5, 0xfe, 0xb5, 0x29, 0x21, 0x42,
+	    0xb5, 0xfa, 0xe8, 0x35,
+	0x83, 0xd5, 0x3d, 0xc4, 0x8f, 0x26, 0xaf, 0x80, 0xca, 0x7c, 0xc7, 0x52,
+	    0x36, 0x94, 0x38, 0xa3,
+	0xbe, 0x90, 0xde, 0x0c, 0x8e, 0x99, 0x08, 0x72, 0x0d, 0xdc, 0x72, 0xcc,
+	    0x00, 0x07, 0x28, 0x1e,
+	0x5a, 0x58, 0xd6, 0xb9, 0x9c, 0x18, 0xaa, 0x36, 0x4d, 0x78, 0x26, 0xf9,
+	    0x73, 0x46, 0x25, 0x4d,
+	0x80, 0x9e, 0x9f, 0xc8, 0x76, 0x6b, 0x56, 0x6b, 0xe0, 0xd9, 0x8d, 0x0a,
+	    0x0b, 0x57, 0x33, 0x61,
+	0x9e, 0xf9, 0x3c, 0x7d, 0x9f, 0xf8, 0xbd, 0x39, 0x43, 0xf4, 0x53, 0xc0,
+	    0x27, 0x70, 0x69, 0xb4,
+	0x1d, 0x80, 0xd8, 0xf6, 0xb1, 0x1a, 0x0e, 0xef, 0x8e, 0x23, 0xbc, 0x8c,
+	    0x2b, 0x43, 0xd6, 0x1d,
+	0xed, 0xcd, 0x72, 0x2f, 0x9c, 0xdd, 0x84, 0x7e, 0x3f, 0xc4, 0x32, 0x7a,
+	    0x44, 0x31, 0xdf, 0xfa,
+	0xda, 0xd1, 0x76, 0x0f, 0xb5, 0x13, 0x40, 0xd2, 0xe8, 0x0e, 0xd1, 0x3f,
+	    0xe9, 0x8b, 0x67, 0x5b,
+	0x4e, 0xd0, 0xdd, 0x27, 0xbf, 0xfd, 0x47, 0x05, 0x43, 0xd2, 0x20, 0xff,
+	    0xdb, 0xff, 0x28, 0x62,
+	0x81, 0x0f, 0xa0, 0x18, 0x23, 0x71, 0x4e, 0xe7, 0x8a, 0x8b, 0x86, 0x18,
+	    0x56, 0xf0, 0x20, 0xd2,
+	0x6a, 0x0f, 0x48, 0xe5, 0x61, 0x66, 0x22, 0xcf, 0x47, 0xba, 0x0b, 0x36,
+	    0xf3, 0xc5, 0x29, 0x06,
+	0x01, 0x46, 0xbb, 0xe3, 0x17, 0x62, 0x59, 0x25, 0xe8, 0x20, 0x32, 0x5a,
+	    0x73, 0xc2, 0x49, 0x31,
+	0xd9, 0xe3, 0x8a, 0x91, 0xfa, 0xd4, 0x0f, 0xc0, 0xaa, 0x43, 0xc9, 0x09,
+	    0x38, 0x0a, 0xd5, 0xaf,
+	0xf7, 0x57, 0x04, 0xbb, 0x9f, 0x89, 0x46, 0x88, 0xa9, 0x77, 0xf6, 0x86,
+	    0x26, 0xcb, 0x5f, 0xab,
+	0xf2, 0xa6, 0x2b, 0x94, 0x17, 0x6b, 0x09, 0x4b, 0x69, 0xb0, 0xb2, 0x9c,
+	    0xc3, 0x28, 0xb8, 0xc5,
+	0xd6, 0x71, 0x15, 0xda, 0x7b, 0x65, 0xea, 0xd0, 0xad, 0xe9, 0x46, 0x9d,
+	    0x0c, 0xdd, 0x31, 0xab,
+	0x5e, 0x7a, 0x9c, 0x12, 0x6a, 0x81, 0x8f, 0x4f, 0xa5, 0x05, 0x20, 0x7d,
+	    0x76, 0x18, 0x5b, 0x91,
+	0x6b, 0x28, 0x42, 0xd4, 0xa2, 0x2e, 0xe2, 0x35, 0x7b, 0xcc, 0xd0, 0xd3,
+	    0xb1, 0xb9, 0x9b, 0x7e,
+	0x28, 0x49, 0x3e, 0x7e, 0xe6, 0x2f, 0x9a, 0xd1, 0x89, 0xa4, 0x96, 0xf4,
+	    0xb8, 0xc6, 0xfb, 0x28,
+	0xe4, 0x11, 0xd3, 0x0b, 0x39, 0xf5, 0x91, 0xef, 0xda, 0x04, 0x3f, 0xb2,
+	    0xd9, 0x2a, 0x0f, 0xcf,
+	0x60, 0xa0, 0x25, 0x4e, 0x38, 0xda, 0xb7, 0xd1, 0x0d, 0x8d, 0x0c, 0x4e,
+	    0xa5, 0x07, 0xed, 0x16,
+	0xbf, 0xd0, 0x16, 0xbf, 0x70, 0xb1, 0x8a, 0x66, 0xab, 0xf3, 0x0d, 0x2e,
+	    0x2d, 0x88, 0xc9, 0x43,
+	0x0d, 0x9d, 0x26, 0x2f, 0x71, 0x36, 0x65, 0x3f, 0x95, 0x47, 0x4d, 0x4d,
+	    0xfa, 0x12, 0x83, 0xcc,
+	0x69, 0x4c, 0xa5, 0xe9, 0x71, 0xad, 0x6d, 0x0c, 0x88, 0xb1, 0x13, 0x99,
+	    0x01, 0xc3, 0x6a, 0x26,
+	0x28, 0x4d, 0xab, 0xcb, 0x89, 0xe2, 0x91, 0x02, 0xab, 0x6f, 0xe5, 0x41,
+	    0xf5, 0x30, 0x10, 0xe6,
+	0xcb, 0x9a, 0xcc, 0xcd, 0xd9, 0x59, 0x1c, 0x61, 0x42, 0x80, 0x03, 0xe3,
+	    0xba, 0x73, 0x52, 0x00,
+	0xde, 0x54, 0x9e, 0x8d, 0xda, 0x75, 0x18, 0x56, 0xe4, 0x11, 0xc8, 0xb6,
+	    0x35, 0xdc, 0xc5, 0x7d,
+	0x18, 0xbf, 0xdb, 0x67, 0xa4, 0xb7, 0x16, 0x49, 0xd4, 0xd9, 0x9d, 0xb4,
+	    0x38, 0xa3, 0x0e, 0x36,
+	0x27, 0x80, 0xb7, 0x25, 0x92, 0x9c, 0xdd, 0x49, 0x4f, 0x57, 0x0a, 0x84,
+	    0x50, 0xdc, 0xd3, 0x44,
+	0x7e, 0x54, 0xde, 0xc6, 0x81, 0x99, 0x94, 0xb9, 0x8c, 0xab, 0x48, 0x06,
+	    0x92, 0xdf, 0xec, 0xa3,
+	0xaf, 0x86, 0xc4, 0xd0, 0xb4, 0x06, 0x09, 0xf6, 0xab, 0x46, 0xf4, 0x0b,
+	    0x9a, 0x7a, 0x7b, 0xc7,
+	0xda, 0xb9, 0x97, 0xb5, 0x32, 0x20, 0xee, 0x6f, 0x15, 0xf2, 0xad, 0xe1,
+	    0x12, 0xf7, 0x33, 0xd6,
+	0x5e, 0x18, 0x9d, 0x7c, 0xdb, 0x31, 0xf9, 0x75, 0xba, 0xb0, 0x8f, 0xe2,
+	    0x04, 0x6c, 0xb6, 0x95,
+	0xae, 0xab, 0x22, 0xff, 0xbc, 0x99, 0x9e, 0x2c, 0x03, 0xaf, 0xc2, 0x28,
+	    0x28, 0x03, 0x44, 0x98,
+	0x42, 0xb3, 0xb4, 0x1b, 0xc6, 0x7b, 0xea, 0x50, 0x73, 0x14, 0xa9, 0xd9,
+	    0x0a, 0x79, 0x59, 0x4c,
+	0xa8, 0xb1, 0x14, 0x09, 0xe8, 0xee, 0x37, 0x10, 0xee, 0xc1, 0xaf, 0x52,
+	    0x8f, 0x7a, 0x0f, 0x68,
+	0xee, 0x1b, 0x88, 0xbb, 0xd1, 0xea, 0xe0, 0x51, 0xdd, 0x16, 0x5f, 0x38,
+	    0x5c, 0x86, 0x40, 0xf5,
+	0x02, 0xaa, 0xe6, 0x90, 0x9b, 0xb0, 0x28, 0x59, 0x9f, 0x0a, 0x90, 0x8a,
+	    0x81, 0x21, 0xde, 0x9e,
+	0x11, 0x06, 0xf6, 0x54, 0xb9, 0x19, 0xdb, 0xbf, 0x8a, 0xfb, 0xa6, 0xf8,
+	    0x9b, 0xfc, 0x41, 0xf5,
+	0x82, 0xca, 0x03, 0x1d, 0xf6, 0x3f, 0x29, 0x59, 0xc8, 0xb3, 0xf0, 0x0f,
+	    0x1a, 0xd5, 0xe9, 0xbf,
+	0x40, 0x3c, 0x8d, 0xbf, 0x44, 0x51, 0x09, 0x0a, 0x81, 0xd2, 0xb5, 0x0e,
+	    0x7f, 0xd2, 0x3a, 0x03,
+	0x27, 0xe1, 0xd8, 0x84, 0xd9, 0x2c, 0x38, 0xc3, 0xc1, 0x30, 0xd6, 0x43,
+	    0x55, 0xa0, 0x2f, 0x74,
+	0xfe, 0xc3, 0xc0, 0xd4, 0x91, 0xaf, 0x61, 0x30, 0x01, 0xfa, 0xe0, 0x22,
+	    0x53, 0x71, 0xe1, 0xcf,
+	0xff, 0x99, 0x99, 0xbb, 0x37, 0xac, 0x68, 0x31, 0xa3, 0xc2, 0xbd, 0xf7,
+	    0x3d, 0x13, 0x77, 0x6c,
+	0x79, 0x48, 0x0d, 0xd5, 0x36, 0xad, 0x19, 0x44, 0xf6, 0xe7, 0x64, 0x55,
+	    0x55, 0x73, 0xe3, 0x59,
+	0x00, 0x14, 0xfa, 0x44, 0xa5, 0x09, 0x8f, 0x10, 0x68, 0x1b, 0xca, 0x9d,
+	    0x29, 0xe8, 0xfb, 0xd6,
+	0x5b, 0xc5, 0xe0, 0x72, 0x11, 0x1d, 0xc3, 0xd7, 0xb0, 0x68, 0x77, 0xf4,
+	    0xd7, 0xdc, 0x40, 0x21,
+	0x79, 0x2b, 0xb3, 0x37, 0x16, 0xb0, 0xce, 0x52, 0x67, 0x39, 0x2a, 0x70,
+	    0xd0, 0x2d, 0x09, 0xf4,
+	0xc5, 0x2c, 0x76, 0x35, 0x60, 0xc2, 0xaf, 0x4e, 0x2c, 0x83, 0xc1, 0x64,
+	    0xfa, 0xe8, 0xe2, 0xf6,
+	0xc7, 0x93, 0x9a, 0xaa, 0xf5, 0xc1, 0xd0, 0x6a, 0x6d, 0xd3, 0x8c, 0x4b,
+	    0x1e, 0x41, 0x3c, 0x7c,
+	0xf6, 0x92, 0x90, 0xed, 0x69, 0x04, 0x9c, 0x2e, 0x76, 0x2d, 0xb9, 0xd3,
+	    0xfc, 0x69, 0x31, 0x6d,
+	0x73, 0x91, 0x0f, 0x8a, 0x77, 0xa9, 0x13, 0xdf, 0xcc, 0xd1, 0x24, 0xcf,
+	    0xcc, 0xa8, 0x0a, 0x6d,
+	0x32, 0x90, 0x38, 0x58, 0x57, 0xc2, 0x85, 0xd3, 0x55, 0x0d, 0x44, 0x3d,
+	    0xce, 0x46, 0x1a, 0x52,
+	0xf7, 0xce, 0xda, 0xa6, 0x1a, 0x70, 0x4c, 0xde, 0x38, 0x63, 0xc0, 0x7d,
+	    0xfd, 0x3d, 0x12, 0x42,
+	0xef, 0x2c, 0x83, 0xb5, 0xe0, 0xc3, 0x42, 0x85, 0x87, 0x2e, 0x43, 0x39,
+	    0x95, 0xa4, 0xa1, 0x01,
+	0x7f, 0x25, 0x4f, 0xca, 0x4b, 0xcc, 0xd7, 0x09, 0x39, 0xab, 0x8d, 0x52,
+	    0x3f, 0xb1, 0xcf, 0xa8,
+	0x03, 0x22, 0xd5, 0xee, 0x41, 0x72, 0xdb, 0x68, 0xa9, 0xab, 0xb3, 0x9b,
+	    0x6a, 0x4b, 0x1e, 0x79,
+	0x22, 0x73, 0x64, 0x9e, 0xe0, 0x4d, 0x98, 0x3d, 0x67, 0x02, 0xa2, 0xc4,
+	    0xcb, 0x2d, 0x75, 0x80,
+	0xc0, 0x9a, 0xba, 0xaa, 0x33, 0x21, 0x38, 0xf2, 0x61, 0x96, 0xe2, 0x54,
+	    0x25, 0x74, 0x08, 0xa3,
+	0xae, 0x10, 0xdd, 0x03, 0xec, 0xf7, 0x6c, 0xb5, 0x01, 0x54, 0x61, 0x49,
+	    0x1d, 0x23, 0xaa, 0x7b,
+	0xc5, 0xde, 0x0e, 0xf5, 0x4a, 0x1e, 0xba, 0x13, 0xb9, 0x73, 0xaf, 0x8f,
+	    0x1e, 0xb7, 0x3e, 0x3d,
+	0x81, 0x39, 0x84, 0x70, 0x71, 0xb9, 0x12, 0x52, 0x8d, 0x57, 0x8c, 0x56,
+	    0xa8, 0x41, 0x64, 0xd3,
+	0x03, 0x18, 0x8c, 0x60, 0x7c, 0xb8, 0x02, 0x57, 0x8e, 0x56, 0x38, 0x05,
+	    0x1d, 0x80, 0x31, 0x84,
+	0x6c, 0xdf, 0x02, 0x37, 0x36, 0xa9, 0x4b, 0x52, 0x8e, 0xb5, 0x55, 0x1d,
+	    0x43, 0x9a, 0x13, 0x77,
+	0x4c, 0xf4, 0xf7, 0xd5, 0x25, 0xbf, 0x2b, 0x57, 0x0c, 0x94, 0x61, 0x73,
+	    0x8a, 0x21, 0x8a, 0x0f,
+	0xd3, 0x31, 0xf6, 0x7f, 0x9f, 0x28, 0xf6, 0x57, 0x1d, 0xdc, 0x8c, 0x1e,
+	    0xd2, 0xba, 0x38, 0x6b,
+	0xc6, 0x32, 0x0e, 0xec, 0x5f, 0xde, 0xfe, 0x57, 0x10, 0xc2, 0x65, 0xbe,
+	    0x85, 0xda, 0x79, 0x6b,
+	0xe4, 0x67, 0x95, 0xbf, 0x94, 0x15, 0xb3, 0x2f, 0x93, 0xf3, 0xb4, 0xa5,
+	    0x5d, 0x05, 0xef, 0x72,
+	0x0d, 0x36, 0xd1, 0x98, 0x54, 0xff, 0xae, 0xdd, 0xad, 0x94, 0x7f, 0x3a,
+	    0x58, 0x06, 0x38, 0x7e,
+	0xce, 0x37, 0xe2, 0xea, 0xb1, 0xfd, 0x71, 0xe8, 0xc6, 0x9e, 0x4f, 0xfd,
+	    0x53, 0xf3, 0x2c, 0xc9,
+	0x05, 0x92, 0x56, 0x21, 0x0c, 0x7f, 0xca, 0x98, 0x94, 0x40, 0xc0, 0xc2,
+	    0x15, 0xf2, 0xb1, 0x89,
+	0x47, 0xf7, 0x4b, 0xeb, 0x8d, 0x1c, 0x78, 0x96, 0x4f, 0x41, 0xc5, 0xde,
+	    0x82, 0x01, 0x5d, 0x5f,
+	0xfa, 0xde, 0x57, 0xc0, 0x1c, 0x3a, 0xd3, 0x7e, 0x18, 0x62, 0x04, 0x80,
+	    0x97, 0xf2, 0xff, 0x7e,
+	0x2e, 0xdf, 0xa9, 0xfb, 0xf1, 0x83, 0xca, 0xfb, 0x64, 0xdc, 0x42, 0x1b,
+	    0x3e, 0x22, 0xb3, 0xa0,
+	0xcd, 0xde, 0xee, 0xb5, 0xe4, 0x87, 0x9b, 0xd8, 0x6b, 0x0c, 0x67, 0xf6,
+	    0xf0, 0xbe, 0xbe, 0x31,
+	0x01, 0xfd, 0xd3, 0xfb, 0x1d, 0xdf, 0xae, 0x7b, 0x39, 0x4b, 0x12, 0x28,
+	    0x53, 0x6f, 0xb1, 0xea,
+	0x34, 0xb7, 0xd9, 0x55, 0x97, 0x8e, 0x67, 0x99, 0xd1, 0x0e, 0x59, 0xa4,
+	    0x19, 0x22, 0x7b, 0xde,
+	0xdb, 0xf9, 0x2c, 0xd6, 0x12, 0x2c, 0x2e, 0x67, 0xff, 0x4b, 0x10, 0xb8,
+	    0x0b, 0xc9, 0xef, 0x2a,
+	0xa0, 0x60, 0x5f, 0xab, 0x70, 0xda, 0x40, 0x74, 0xeb, 0x49, 0xd4, 0x9e,
+	    0xa6, 0x2a, 0x6e, 0xbb,
+	0x84, 0xe6, 0x44, 0xdc, 0xf1, 0x39, 0xd0, 0x0f, 0xa3, 0x96, 0xc4, 0x54,
+	    0x73, 0xe7, 0x76, 0xb3,
+	0x0c, 0xa1, 0x1a, 0xab, 0x13, 0xea, 0x68, 0x48, 0x27, 0xb6, 0xd8, 0x0a,
+	    0x74, 0xc7, 0x7a, 0x3a,
+	0x63, 0x07, 0x54, 0x3c, 0x89, 0xd7, 0x6c, 0x81, 0xca, 0x4c, 0x35, 0x15,
+	    0x80, 0xb9, 0x74, 0x1e,
+	0xe0, 0x06, 0x66, 0x6f, 0x73, 0xdf, 0x8d, 0x5e, 0xa2, 0x5a, 0xca, 0xcf,
+	    0x73, 0xc6, 0x83, 0x3b,
+	0xe8, 0x84, 0xb9, 0xbc, 0xfe, 0xf5, 0xde, 0x2b, 0x98, 0x51, 0xa9, 0xde,
+	    0xa4, 0xc5, 0x59, 0x86,
+	0x71, 0x4f, 0xb5, 0xad, 0x4f, 0x23, 0x1a, 0x5f, 0x22, 0x78, 0x4b, 0x4e,
+	    0xb0, 0xca, 0x12, 0x3b,
+	0x76, 0x85, 0x02, 0x1d, 0xb1, 0x21, 0x53, 0x5e, 0x68, 0x59, 0xc7, 0x1f,
+	    0x62, 0x00, 0x6a, 0xd2,
+	0x0a, 0x1d, 0x82, 0xd0, 0x1d, 0x85, 0xe8, 0xdc, 0x6f, 0xc0, 0xf6, 0x5a,
+	    0x7f, 0xc2, 0x63, 0xa3,
+	0x7b, 0x87, 0x3c, 0x36, 0x17, 0xd8, 0xc0, 0x5f, 0xe0, 0x5e, 0xb1, 0x7c,
+	    0xd9, 0x2e, 0x68, 0x64,
+	0x53, 0x0c, 0xb7, 0x3f, 0x64, 0x43, 0x3b, 0xd3, 0xd5, 0x40, 0x7f, 0x1f,
+	    0x28, 0x0a, 0xfb, 0x08,
+	0x85, 0x83, 0xd2, 0x17, 0x1a, 0x9d, 0x2c, 0x25, 0x6e, 0x32, 0x3b, 0xca,
+	    0xad, 0x32, 0xf1, 0x7c,
+	0x21, 0x7d, 0x0e, 0x87, 0x13, 0xb2, 0x58, 0xca, 0x09, 0x5c, 0xb1, 0xdf,
+	    0xfe, 0xf7, 0xfe, 0x69,
+	0xea, 0x5f, 0xd7, 0x16, 0x92, 0x38, 0x5f, 0xa0, 0x99, 0x5b, 0x8e, 0x01,
+	    0x69, 0x8f, 0xb2, 0x1e,
+	0x5e, 0xce, 0xab, 0x34, 0xdb, 0x5f, 0x0f, 0xf0, 0x52, 0x1e, 0x19, 0xf5,
+	    0xed, 0xfe, 0x51, 0x33,
+	0xa6, 0x99, 0x9e, 0x44, 0x91, 0x76, 0x06, 0x52, 0x64, 0x9c, 0x6e, 0x04,
+	    0x6e, 0x6f, 0x74, 0x2f,
+	0x54, 0x15, 0x60, 0x46, 0x63, 0x3f, 0x9c, 0x4d, 0xfd, 0x88, 0x74, 0xe1,
+	    0xf6, 0x97, 0x17, 0x77,
+	0x49, 0x72, 0xcb, 0x26, 0x13, 0x49, 0x20, 0x65, 0xa7, 0xb7, 0x30, 0x83,
+	    0xd1, 0xb6, 0x8d, 0x54,
+	0x06, 0xea, 0x4f, 0x57, 0x01, 0x45, 0x75, 0x93, 0x1e, 0x5b, 0x75, 0xa4,
+	    0x12, 0x6c, 0xe7, 0x76,
+	0xd5, 0xb9, 0xb8, 0x3d, 0xf2, 0x1b, 0x68, 0x18, 0x78, 0x15, 0x6b, 0x28,
+	    0x34, 0x8c, 0xf5, 0x68,
+	0xea, 0xe8, 0xe8, 0x3c, 0xd2, 0xba, 0x3e, 0xa5, 0x98, 0xf8, 0xb2, 0x54,
+	    0xb1, 0xfa, 0x3f, 0x76,
+	0x5d, 0x79, 0xf9, 0x3c, 0x51, 0xb9, 0x69, 0x18, 0xdb, 0x00, 0xad, 0x4f,
+	    0x54, 0x75, 0x71, 0x9f,
+	0xca, 0xed, 0x23, 0xee, 0xd7, 0x9d, 0x27, 0x89, 0x87, 0x44, 0x3f, 0xae,
+	    0xd7, 0x1f, 0x1f, 0xd8,
+	0xff, 0x59, 0x9c, 0xcd, 0x99, 0x91, 0x6e, 0x9b, 0x52, 0xd0, 0xf1, 0x1a,
+	    0x93, 0x06, 0x27, 0x32,
+	0xd0, 0x81, 0x0e, 0x88, 0x5d, 0x88, 0x50, 0x0b, 0xef, 0xd0, 0xed, 0x78,
+	    0x64, 0x58, 0xf9, 0x4c,
+	0x7f, 0x7c, 0xd2, 0x49, 0xff, 0xd5, 0x83, 0x39, 0x4b, 0xdf, 0xcf, 0xf1,
+	    0xfc, 0x65, 0xf4, 0x83,
+	0x5a, 0x1c, 0x6f, 0x27, 0xbd, 0xe5, 0x0d, 0x4b, 0xed, 0x97, 0x1f, 0xb4,
+	    0x38, 0x3d, 0x5b, 0x6c,
+	0x89, 0xe2, 0x22, 0xf6, 0x09, 0x31, 0x50, 0x20, 0x17, 0xcd, 0x88, 0xd9,
+	    0xbd, 0x69, 0x9d, 0x77,
+	0x03, 0x78, 0x96, 0xa7, 0xdf, 0x42, 0x66, 0xd0, 0x65, 0x44, 0x90, 0xc5,
+	    0x37, 0x3c, 0x3b, 0x02,
+	0x6f, 0x21, 0xd8, 0x75, 0x33, 0xce, 0x4c, 0x71, 0x87, 0x32, 0x65, 0xd9,
+	    0x29, 0x63, 0xca, 0x1f,
+	0x05, 0x97, 0x97, 0xa7, 0x5f, 0x60, 0x1f, 0xd1, 0xe7, 0x6c, 0xeb, 0x20,
+	    0x3e, 0x80, 0x39, 0x74,
+	0xbf, 0xcb, 0x87, 0x01, 0x18, 0x7b, 0x0e, 0x4b, 0x25, 0xbc, 0xc8, 0x9d,
+	    0x50, 0x5f, 0x56, 0xf3,
+	0x66, 0x81, 0xb1, 0xe2, 0xb2, 0x1a, 0x20, 0x7f, 0x74, 0x06, 0x42, 0x85,
+	    0x48, 0xe3, 0xcd, 0x38,
+	0x4c, 0xc5, 0x4d, 0x38, 0x40, 0x59, 0x67, 0x4a, 0x75, 0x8b, 0x2b, 0x43,
+	    0xe5, 0x32, 0x10, 0x29,
+	0xe6, 0x83, 0x29, 0xaa, 0x3f, 0xe5, 0xc1, 0x8c, 0xc1, 0x6f, 0x0f, 0xb1,
+	    0x74, 0x3c, 0x72, 0x4e,
+	0x51, 0x25, 0xaa, 0x16, 0xf5, 0x4b, 0x66, 0x41, 0x0f, 0x38, 0xe8, 0x6c,
+	    0x20, 0x47, 0x18, 0xe1,
+	0xfd, 0x86, 0x94, 0xaa, 0x7f, 0x56, 0x1c, 0xd8, 0x6b, 0x66, 0x0d, 0x38,
+	    0xb6, 0x4a, 0xbf, 0xfa,
+	0x2f, 0xca, 0xb1, 0xf0, 0x77, 0x09, 0x6d, 0xc9, 0xec, 0x4f, 0x13, 0xdf,
+	    0x54, 0x39, 0x72, 0x10,
+	0x28, 0x3a, 0xd5, 0xaf, 0x10, 0x06, 0xef, 0xb9, 0x4d, 0x73, 0x1c, 0x8b,
+	    0x3c, 0xb4, 0x03, 0x8a,
+	0x1e, 0x18, 0xec, 0xad, 0xe3, 0xa3, 0x0e, 0x15, 0xed, 0xe1, 0x59, 0x93,
+	    0x43, 0x97, 0x58, 0x31,
+	0xa8, 0x8c, 0x06, 0xcc, 0x1d, 0xa5, 0xae, 0xaa, 0xee, 0x4c, 0x21, 0x9d,
+	    0xb6, 0x97, 0x37, 0x50,
+	0xa8, 0x95, 0x23, 0x1e, 0x35, 0xa3, 0xd4, 0x18, 0xf6, 0x42, 0xf5, 0x1d,
+	    0x25, 0xac, 0x63, 0x7b,
+	0xec, 0x22, 0x69, 0xdb, 0xd6, 0x80, 0x45, 0x88, 0x4b, 0x42, 0xa3, 0xff,
+	    0xec, 0x5b, 0xf7, 0x71,
+	0xa8, 0xfc, 0xf0, 0x75, 0x5a, 0x1d, 0x8c, 0x51, 0x06, 0xc0, 0xea, 0x44,
+	    0x70, 0xad, 0x4f, 0x7c,
+	0xcc, 0x38, 0x7e, 0xa8, 0x57, 0x44, 0x75, 0xd4, 0x8e, 0x12, 0x47, 0x91,
+	    0xd4, 0x0e, 0x98, 0x18,
+	0x1b, 0xcf, 0x77, 0x14, 0x96, 0x1d, 0x8d, 0x50, 0x8e, 0xc9, 0x75, 0x33,
+	    0x65, 0xff, 0x3b, 0xf1,
+	0x5a, 0x3e, 0xfb, 0x13, 0xe1, 0xc3, 0x3c, 0xd5, 0x0e, 0x30, 0x9b, 0x03,
+	    0x71, 0x57, 0xda, 0xd2,
+	0xc7, 0xeb, 0xeb, 0xb5, 0x0e, 0x15, 0x01, 0x66, 0x23, 0x17, 0x36, 0x34,
+	    0xf6, 0x84, 0x0e, 0x2d,
+	0xd6, 0x1c, 0x57, 0x30, 0x27, 0x48, 0x44, 0xcf, 0x98, 0xdb, 0x23, 0x91,
+	    0x00, 0x03, 0x45, 0x47,
+	0x29, 0x2b, 0xdd, 0xf7, 0xd8, 0xa9, 0xb5, 0x5e, 0x78, 0xd8, 0x28, 0xf6,
+	    0x17, 0x49, 0x4d, 0x41,
+	0x27, 0x9f, 0x15, 0xa4, 0x8f, 0xf5, 0x45, 0x4f, 0x6a, 0xb5, 0x3d, 0x0b,
+	    0x5c, 0xb5, 0x3c, 0x2f,
+	0xdb, 0x65, 0x15, 0x26, 0xc0, 0x8b, 0x9a, 0xd9, 0x02, 0x7e, 0xe0, 0xa9,
+	    0x17, 0xf7, 0x7c, 0x8d,
+	0xde, 0x6c, 0x57, 0xe0, 0xbc, 0xb4, 0xec, 0x29, 0x4b, 0x76, 0x97, 0xdc,
+	    0x8e, 0x9c, 0x35, 0xc9,
+	0x57, 0x47, 0xdc, 0x74, 0xba, 0x38, 0xe3, 0x58, 0x82, 0x77, 0x37, 0xc1,
+	    0xfa, 0x38, 0x8f, 0xa5,
+	0x21, 0xd9, 0x10, 0xdd, 0x1c, 0x6e, 0xed, 0xc8, 0x87, 0x5a, 0x87, 0xf8,
+	    0x23, 0x04, 0x64, 0x27,
+	0xd1, 0x98, 0x6c, 0x8c, 0xc9, 0xac, 0x8d, 0x95, 0x60, 0x23, 0x62, 0x99,
+	    0x78, 0xee, 0x50, 0x23,
+	0x1b, 0x32, 0xd9, 0xd8, 0xcc, 0xff, 0x1c, 0xf2, 0x9a, 0x5b, 0x9e, 0x49,
+	    0xf8, 0xf0, 0xe3, 0x84,
+	0x57, 0xe2, 0x5f, 0x4b, 0xfb, 0x5f, 0x28, 0x6b, 0x61, 0x23, 0xf7, 0x6b,
+	    0xc1, 0x0b, 0xcf, 0xa9,
+	0xc5, 0x04, 0xe1, 0x3c, 0x1e, 0xc0, 0x7f, 0xbb, 0xe5, 0x62, 0xa6, 0x70,
+	    0x58, 0xbe, 0x3a, 0xf3,
+	0x70, 0xaf, 0xca, 0x19, 0x34, 0xad, 0x2e, 0x18, 0xcd, 0xc6, 0x50, 0xb0,
+	    0xc1, 0xbd, 0x9f, 0x92,
+	0x04, 0x69, 0x48, 0x40, 0x2b, 0x94, 0x8b, 0xa2, 0x51, 0x49, 0xbe, 0x08,
+	    0xd5, 0xc5, 0x16, 0xf2,
+	0xf4, 0xad, 0xff, 0x2c, 0x79, 0x13, 0x10, 0x61, 0xdc, 0xef, 0xe9, 0x02,
+	    0x2d, 0x6d, 0x31, 0xc1,
+	0x76, 0x0c, 0x29, 0xef, 0x78, 0x12, 0x1f, 0xc0, 0xf5, 0x03, 0x8e, 0x32,
+	    0xba, 0x6c, 0x46, 0x80,
+	0x06, 0x25, 0x55, 0xd4, 0xb1, 0x65, 0x5a, 0x40, 0xe1, 0x49, 0x73, 0xfa,
+	    0x8e, 0x92, 0xee, 0x22,
+	0xa0, 0x03, 0x64, 0x16, 0x90, 0xf1, 0x50, 0xf4, 0xe2, 0xcd, 0x58, 0x6a,
+	    0xb7, 0x91, 0xc3, 0x65,
+	0x00, 0x4e, 0x2d, 0xc5, 0x6e, 0x06, 0x5b, 0x21, 0x61, 0x40, 0xaf, 0xfe,
+	    0xb9, 0xf0, 0x45, 0x2f,
+	0x22, 0x8d, 0x18, 0x4a, 0xad, 0x93, 0xd9, 0x93, 0x62, 0xcf, 0x6f, 0x86,
+	    0x3b, 0xcc, 0x62, 0x49,
+	0xbf, 0x05, 0x42, 0x58, 0x2c, 0xdd, 0x32, 0xa5, 0xa1, 0xd9, 0x12, 0x5f,
+	    0x6c, 0x2a, 0x06, 0xf3,
+	0xa8, 0x81, 0x19, 0xec, 0x04, 0x88, 0x1c, 0x4a, 0xa2, 0x18, 0x7c, 0x4f,
+	    0x6d, 0x62, 0x49, 0xf2,
+	0x2b, 0x0c, 0x23, 0xfe, 0xe0, 0xde, 0xbf, 0xbb, 0xd8, 0x42, 0x51, 0x67,
+	    0xde, 0xa2, 0x8b, 0xfb,
+	0x0b, 0x23, 0x9e, 0xf7, 0x3c, 0x20, 0x3b, 0x24, 0x20, 0x9a, 0xf2, 0x4e,
+	    0xe1, 0xca, 0x3d, 0xaa,
+	0x88, 0x24, 0x62, 0x56, 0x96, 0xa1, 0x50, 0x8a, 0xc8, 0x04, 0xe0, 0x68,
+	    0xdf, 0x7a, 0x32, 0xda,
+	0x02, 0xc2, 0x94, 0xcf, 0x0b, 0x82, 0x3a, 0x38, 0xe6, 0x42, 0x84, 0x73,
+	    0x57, 0x23, 0xbb, 0x2b,
+	0xc9, 0xb1, 0xbd, 0xdb, 0x71, 0xc8, 0x41, 0x99, 0xc2, 0x41, 0x72, 0x77,
+	    0x46, 0xda, 0x73, 0x89,
+	0x70, 0x00, 0xa9, 0x43, 0x4d, 0xdb, 0x3b, 0x39, 0x67, 0xc2, 0xba, 0xf9,
+	    0xac, 0x2e, 0x13, 0x53,
+	0x18, 0x6d, 0xde, 0x7b, 0x93, 0x55, 0x6a, 0x8d, 0xe0, 0x90, 0xed, 0xdf,
+	    0xd7, 0xdd, 0x46, 0x6b,
+	0x82, 0x1c, 0xb7, 0x64, 0xeb, 0x90, 0x89, 0x4f, 0x88, 0x00, 0x5c, 0xe0,
+	    0x38, 0x33, 0x65, 0xc0,
+	0x1b, 0x1f, 0xfd, 0xf6, 0x84, 0x39, 0x4b, 0x8d, 0x1f, 0xf9, 0x80, 0x21,
+	    0xb5, 0xcb, 0x07, 0x90,
+	0x02, 0x15, 0x98, 0x7f, 0x50, 0x7c, 0x07, 0xb5, 0xc0, 0xd3, 0x17, 0x64,
+	    0x18, 0x02, 0x7c, 0x10,
+	0xd5, 0x1b, 0x1f, 0xe0, 0xfa, 0x67, 0x50, 0x02, 0xe0, 0x1c, 0xb3, 0xe0,
+	    0x19, 0xe2, 0x2c, 0x91,
+	0xd8, 0x18, 0xb2, 0x47, 0x58, 0xb3, 0x24, 0x72, 0x66, 0x9f, 0x6a, 0x05,
+	    0x9b, 0x35, 0x7d, 0x11,
+	0x59, 0x19, 0x27, 0xd6, 0x8c, 0xd0, 0x75, 0x83, 0xa3, 0x52, 0x55, 0xfb,
+	    0x16, 0x82, 0x07, 0x2f,
+	0x00, 0x1a, 0x4d, 0xea, 0x37, 0xe2, 0x07, 0xf4, 0x40, 0x51, 0x83, 0xc7,
+	    0xf7, 0x3b, 0x0a, 0x73,
+	0x89, 0x92, 0x92, 0x62, 0xd1, 0x09, 0x28, 0x84, 0x4b, 0xb8, 0xee, 0xdf,
+	    0x08, 0x3a, 0x0a, 0x7a,
+	0x42, 0x28, 0xb0, 0xb5, 0x3f, 0xf1, 0x14, 0xbc, 0xca, 0xf4, 0xe0, 0xba,
+	    0x98, 0xfa, 0x78, 0x6b,
+	0x09, 0x92, 0x47, 0xd9, 0xd7, 0xc5, 0x77, 0xe8, 0x53, 0x57, 0x1d, 0xe1,
+	    0x98, 0x5c, 0x8e, 0x1d,
+	0xa8, 0xb4, 0xa7, 0x6e, 0x85, 0x2b, 0x8a, 0x4b, 0xc8, 0xbb, 0x69, 0x39,
+	    0xbc, 0xd3, 0x0c, 0x33,
+	0x89, 0x1a, 0x62, 0xd2, 0xec, 0xc8, 0xde, 0x24, 0xc9, 0x5a, 0xb7, 0xe2,
+	    0xaa, 0x08, 0xce, 0x3a,
+	0xa9, 0x15, 0x90, 0x46, 0x3f, 0xe9, 0x26, 0xdf, 0x08, 0xa2, 0x36, 0x76,
+	    0x7d, 0xa6, 0x4b, 0xcf,
+	0x0b, 0x96, 0x20, 0x3c, 0x60, 0x7e, 0xdf, 0x89, 0x89, 0xa5, 0xf0, 0x1c,
+	    0x66, 0xbc, 0x9b, 0xab,
+	0x08, 0x19, 0x7d, 0xc2, 0x57, 0x94, 0x27, 0x7b, 0xc9, 0x2a, 0x4f, 0x8e,
+	    0x85, 0xde, 0xdb, 0x60,
+	0x47, 0x3f, 0xf4, 0x1d, 0x90, 0x34, 0x9c, 0xb0, 0x54, 0xc8, 0x88, 0x16,
+	    0xf9, 0x4f, 0x10, 0x42,
+	0x01, 0x8e, 0x90, 0xe4, 0x36, 0xe1, 0x18, 0x37, 0x2e, 0x90, 0x78, 0x62,
+	    0x1c, 0x60, 0x59, 0x81,
+	0x8d, 0x3d, 0x05, 0x65, 0x63, 0xc7, 0x37, 0xd2, 0xf0, 0xe2, 0x11, 0x55,
+	    0xb6, 0x05, 0x77, 0x3a,
+	0x91, 0xc1, 0x12, 0xe5, 0xb6, 0xe3, 0xc6, 0x40, 0xbd, 0xaf, 0x86, 0xc4,
+	    0x51, 0x6e, 0x00, 0x03,
+	0xf1, 0x89, 0x07, 0xb5, 0xcc, 0x0f, 0x08, 0xe0, 0x47, 0xa3, 0xd6, 0xd9,
+	    0x28, 0x40, 0x64, 0x29,
+	0xa6, 0x0f, 0x5b, 0x51, 0xc3, 0x60, 0x40, 0xa2, 0x1b, 0x4d, 0xaf, 0x65,
+	    0xa5, 0x76, 0x2b, 0xb8,
+	0x25, 0x80, 0x82, 0x43, 0x6a, 0xe2, 0x09, 0xe1, 0xc7, 0x81, 0x02, 0xdb,
+	    0x1e, 0x51, 0x92, 0xb1,
+	0x26, 0x0f, 0x4e, 0x60, 0xfc, 0x02, 0x69, 0x91, 0x45, 0xcf, 0xdf, 0xdb,
+	    0x11, 0x43, 0x2a, 0xf9,
+	0x2c, 0x85, 0xb6, 0xe0, 0x77, 0xf9, 0x50, 0x22, 0x4d, 0xca, 0xe0, 0x99,
+	    0x5a, 0x20, 0x00, 0x9f,
+	0x4e, 0x69, 0x0a, 0x04, 0x91, 0x04, 0x32, 0x2b, 0x26, 0xb8, 0xaf, 0xd4,
+	    0xf8, 0x56, 0xa3, 0x1a,
+	0xfc, 0x77, 0xe3, 0x9e, 0xa8, 0x1e, 0x0d, 0x16, 0x0e, 0xda, 0xd5, 0xdf,
+	    0xc1, 0x4b, 0x3b, 0x79,
+	0x89, 0x2b, 0x3a, 0x9b, 0xd8, 0x8a, 0xbf, 0x39, 0xd1, 0x46, 0xe1, 0xa4,
+	    0xb5, 0xda, 0xe2, 0xa8,
+	0x8c, 0xa4, 0x62, 0xbf, 0xfe, 0xec, 0x02, 0x10, 0xed, 0xa9, 0x27, 0xf9,
+	    0xb5, 0x4a, 0x12, 0x38,
+	0x4c, 0x32, 0x4f, 0x45, 0x74, 0xd9, 0xbc, 0x05, 0xec, 0xcb, 0x5a, 0x40,
+	    0xd3, 0x39, 0x1f, 0x29,
+	0xcd, 0x51, 0x4b, 0xc5, 0x0a, 0x3a, 0x4c, 0x89, 0x4c, 0xc6, 0xad, 0xfd,
+	    0xda, 0x1b, 0x13, 0xd9,
+	0x86, 0x20, 0xaf, 0x99, 0x0d, 0xed, 0xf3, 0x78, 0x6e, 0x47, 0x18, 0x60,
+	    0x01, 0x44, 0x74, 0xe0,
+	0x20, 0x30, 0x1c, 0x75, 0x44, 0x04, 0x54, 0xe3, 0x9f, 0xdd, 0xa6, 0x29,
+	    0x9f, 0xb4, 0x66, 0x87,
+	0x07, 0x9c, 0x55, 0xb1, 0x94, 0x3e, 0xad, 0x00, 0x9a, 0xb1, 0x36, 0x25,
+	    0xf5, 0x21, 0xb6, 0xfc,
+	0x65, 0xf0, 0x05, 0x9d, 0x38, 0xbf, 0x3f, 0xa7, 0x47, 0x7f, 0x8f, 0x17,
+	    0x1a, 0xb0, 0xad, 0x82,
+	0xd9, 0x3d, 0xf5, 0x93, 0x00, 0x3c, 0xe2, 0x4c, 0xc1, 0x7e, 0x7d, 0x7e,
+	    0xfc, 0x46, 0x68, 0xc4,
+	0x87, 0x1e, 0xd2, 0xc2, 0x5d, 0x31, 0x4c, 0x32, 0x98, 0xdb, 0x03, 0x15,
+	    0x08, 0x59, 0xf5, 0x22,
+	0x2f, 0x9a, 0xcf, 0xd9, 0xef, 0x1e, 0x76, 0xf6, 0xc4, 0xd8, 0x2f, 0x85,
+	    0x0d, 0x56, 0x1a, 0x21,
+	0x24, 0xde, 0x65, 0x81, 0x24, 0xe2, 0x15, 0xa7, 0xe9, 0xdb, 0x26, 0x56,
+	    0x00, 0x59, 0x0d, 0x93,
+	0xa9, 0x9a, 0x48, 0x42, 0x30, 0xa1, 0x77, 0xf2, 0x44, 0xd1, 0x8a, 0x04,
+	    0x8d, 0x5a, 0x33, 0xe5,
+	0xae, 0xb0, 0xfe, 0x62, 0x57, 0xe9, 0xa3, 0x9b, 0x58, 0x27, 0x25, 0x94,
+	    0x04, 0x0d, 0x56, 0x18,
+	0x24, 0x26, 0x0e, 0x84, 0xb1, 0x12, 0x61, 0xf6, 0xef, 0x91, 0xf3, 0xff,
+	    0x35, 0xc8, 0x5a, 0xe9,
+	0xef, 0x45, 0xe7, 0x1e, 0x88, 0x0e, 0xa7, 0x56, 0x8d, 0x98, 0xa4, 0x91,
+	    0xc0, 0xb8, 0x17, 0x4b,
+	0x5a, 0x94, 0xd7, 0x9b, 0x54, 0xea, 0xf9, 0xd9, 0x12, 0x57, 0x81, 0x96,
+	    0x70, 0x7d, 0x6c, 0xce,
+	0x8d, 0x91, 0x26, 0x32, 0x1a, 0x13, 0xfe, 0x83, 0x0d, 0xfc, 0xa5, 0x5f,
+	    0x8c, 0x53, 0x66, 0x5e,
+	0x8e, 0x15, 0x88, 0xd6, 0xd4, 0x3b, 0x06, 0x78, 0x66, 0x3b, 0x2d, 0xc5,
+	    0x05, 0x62, 0x6d, 0xdb,
+	0x0d, 0x98, 0x05, 0x3c, 0x70, 0x15, 0x0f, 0x69, 0xeb, 0x47, 0xa4, 0xd0,
+	    0x80, 0x2b, 0x6b, 0x39,
+	0x03, 0x92, 0x58, 0xd9, 0x4b, 0xdb, 0x7d, 0x19, 0x6d, 0x97, 0x97, 0x3d,
+	    0x79, 0x0a, 0x90, 0xfd,
+	0x00, 0xdb, 0xd8, 0xbc, 0x23, 0x55, 0xe3, 0xdd, 0x48, 0x02, 0x16, 0x6b,
+	    0xf1, 0x9f, 0x68, 0x50,
+	0xaf, 0x8a, 0xf7, 0x69, 0x32, 0x62, 0xa3, 0x42, 0x72, 0x13, 0x58, 0xc8,
+	    0xfc, 0x7a, 0x03, 0x85,
+	0xf3, 0x4b, 0x39, 0xfa, 0x82, 0x6f, 0x8e, 0xbc, 0xc6, 0x39, 0x89, 0xb4,
+	    0x28, 0xd3, 0x0d, 0xf3,
+	0x03, 0x2b, 0xe9, 0x17, 0x96, 0x2e, 0xe1, 0xb3, 0xe3, 0x10, 0x2d, 0x53,
+	    0x26, 0x9e, 0x7a, 0xf0,
+	0xfd, 0xdb, 0x20, 0x32, 0x9f, 0xa2, 0xc0, 0x90, 0xf8, 0xe5, 0xf0, 0xd0,
+	    0x61, 0x02, 0xf3, 0xf5,
+	0xf4, 0xa8, 0x9c, 0x4c, 0x33, 0xa6, 0x0a, 0xc7, 0x67, 0xce, 0xa7, 0x33,
+	    0xee, 0xd3, 0xfe, 0x70,
+	0x23, 0xf9, 0x45, 0x85, 0xce, 0x25, 0x44, 0x92, 0x46, 0xcb, 0x6b, 0x9a,
+	    0x5f, 0x04, 0x5e, 0x6c,
+	0x68, 0x43, 0xcc, 0x75, 0xd7, 0xe7, 0xaa, 0x40, 0xfb, 0xe8, 0x83, 0x77,
+	    0x60, 0x3e, 0xb9, 0x6a,
+	0x4b, 0xb7, 0xc8, 0x11, 0x73, 0x27, 0x48, 0x2c, 0xeb, 0x2d, 0x7e, 0xb2,
+	    0x5b, 0x88, 0x32, 0x48,
+	0x0d, 0x06, 0x4a, 0x09, 0x96, 0x24, 0x4b, 0x5a, 0x0a, 0xb9, 0x0d, 0x3e,
+	    0x41, 0xc9, 0x7b, 0x8b,
+	0x81, 0xb7, 0x03, 0x3f, 0x67, 0x97, 0x29, 0xcb, 0x4a, 0x49, 0xad, 0x11,
+	    0x98, 0xc5, 0xd4, 0xbd,
+	0x8f, 0xb0, 0xf0, 0x3a, 0x38, 0x47, 0x11, 0x59, 0x6a, 0x4a, 0x08, 0x4e,
+	    0xad, 0x07, 0x7c, 0x70,
+	0x7c, 0xa3, 0x92, 0x7d, 0x16, 0x6e, 0xf2, 0x1a, 0x28, 0xab, 0xb3, 0xac,
+	    0x32, 0x91, 0x72, 0xa7,
+	0xc3, 0xbc, 0x15, 0xce, 0x13, 0x80, 0xcf, 0x9a, 0xe7, 0xe0, 0x25, 0x3b,
+	    0x68, 0x01, 0xe7, 0x2b,
+	0x7d, 0x6b, 0x8e, 0x2f, 0x15, 0x83, 0xc3, 0x9a, 0x46, 0xe3, 0x17, 0xe8,
+	    0x99, 0x9d, 0xeb, 0x4a,
+	0xfb, 0x6b, 0x10, 0xcf, 0x9b, 0x25, 0x48, 0x9b, 0xef, 0xb0, 0x63, 0xe2,
+	    0xb8, 0x6b, 0x23, 0x82,
+	0xf7, 0x16, 0x3c, 0x64, 0x3c, 0x33, 0x74, 0x16, 0x71, 0x5d, 0xd5, 0x42,
+	    0x54, 0x8d, 0x73, 0x72,
+	0xa3, 0x15, 0x08, 0x10, 0x42, 0x81, 0xdc, 0xdd, 0xbf, 0x13, 0xa2, 0x89,
+	    0xd6, 0x6a, 0x09, 0xfa,
+	0x01, 0x98, 0xd4, 0x91, 0x90, 0x21, 0xf9, 0x3e, 0xe1, 0x22, 0xcd, 0xb4,
+	    0xc3, 0xd5, 0x07, 0xf3,
+	0xe0, 0x53, 0xb3, 0xac, 0x53, 0xcc, 0x83, 0x60, 0x00, 0x55, 0xeb, 0xd3,
+	    0x98, 0x82, 0xe4, 0xb2,
+	0x40, 0x93, 0x79, 0x5b, 0x87, 0xbd, 0x42, 0x82, 0x02, 0x7c, 0xb0, 0x92,
+	    0x53, 0xf4, 0x34, 0xaf,
+	0x8f, 0x1a, 0x24, 0x60, 0xb3, 0xd5, 0xf0, 0xc1, 0x5b, 0xfa, 0x07, 0xc2,
+	    0x0c, 0x64, 0xd5, 0x32,
+	0x2e, 0xcb, 0xe5, 0x4f, 0xb3, 0xb6, 0x2c, 0x87, 0xc6, 0xdd, 0x3d, 0xd9,
+	    0x77, 0xf5, 0x73, 0xf8,
+	0xcb, 0x1a, 0xad, 0xd7, 0xf2, 0x3a, 0xfd, 0x83, 0x81, 0xb0, 0x00, 0xf5,
+	    0xc4, 0x17, 0x7e, 0xce,
+	0x2a, 0x54, 0x87, 0xfe, 0xd3, 0xc9, 0xe4, 0xe0, 0xcb, 0x1a, 0x8e, 0xa4,
+	    0x99, 0x6a, 0x54, 0x67,
+	0x8a, 0x1f, 0x03, 0xef, 0x41, 0xbe, 0xe0, 0x98, 0x6f, 0x39, 0x66, 0x98,
+	    0x4a, 0xfe, 0x07, 0x0b,
+	0x4a, 0x0a, 0xde, 0x2a, 0x1f, 0x3e, 0xcc, 0xfe, 0xee, 0xa8, 0x6f, 0xa5,
+	    0x9b, 0xba, 0x7d, 0x91,
+	0x08, 0x9c, 0x74, 0x08, 0xd2, 0xca, 0xdf, 0x49, 0x7c, 0x17, 0x27, 0x9d,
+	    0x14, 0x1b, 0xd6, 0xbb,
+	0x12, 0xbd, 0xcc, 0x8c, 0x99, 0x70, 0xc6, 0x18, 0xb3, 0xfd, 0xec, 0x17,
+	    0x7c, 0xb7, 0xee, 0xaa,
+	0x49, 0xfa, 0xc6, 0x10, 0x1b, 0xbe, 0x0c, 0x4f, 0x4f, 0xf2, 0xf6, 0x1e,
+	    0xfa, 0x19, 0x7f, 0xf9,
+	0x56, 0xb1, 0x50, 0x49, 0xef, 0x0f, 0x42, 0x1a, 0x6e, 0xd3, 0x58, 0xc9,
+	    0x7b, 0x73, 0x31, 0xde,
+	0x8f, 0xc4, 0x02, 0x7d, 0x9d, 0x7e, 0xfb, 0x8a, 0xdf, 0x50, 0xf7, 0xfb,
+	    0x7a, 0x71, 0xa9, 0x80,
+	0x01, 0x62, 0x47, 0xf9, 0xe5, 0x06, 0x30, 0x2f, 0x42, 0x1b, 0xd2, 0x36,
+	    0x55, 0x0e, 0x78, 0x70,
+	0x17, 0x87, 0xe5, 0xfe, 0xa9, 0xec, 0x94, 0xa0, 0x51, 0xc9, 0x54, 0xa4,
+	    0x15, 0xe9, 0x19, 0xfc,
+	0x09, 0xe0, 0xd9, 0xf9, 0x92, 0x79, 0xa3, 0xcb, 0xd2, 0x8f, 0x8f, 0x1a,
+	    0xf5, 0x42, 0x25, 0x6d,
+	0x24, 0x09, 0x69, 0x02, 0x47, 0xae, 0xc1, 0xb7, 0xba, 0x77, 0xbc, 0x45,
+	    0xe6, 0x64, 0xdd, 0xb3,
+	0xa5, 0xc4, 0x60, 0x25, 0xa4, 0xea, 0x2a, 0x2f, 0x2e, 0xf5, 0x30, 0x3f,
+	    0x33, 0xee, 0x56, 0x7b,
+	0xc6, 0xe6, 0x17, 0xad, 0x24, 0x29, 0xa8, 0x74, 0x8f, 0xe6, 0x9a, 0x77,
+	    0x56, 0x75, 0xe1, 0xd7,
+	0x17, 0x79, 0xf2, 0xaf, 0x18, 0x6b, 0x08, 0x05, 0xe2, 0x62, 0x35, 0x20,
+	    0x3f, 0x3d, 0x23, 0x31,
+	0xe7, 0xea, 0x51, 0xb9, 0x87, 0xea, 0xdd, 0x57, 0xf4, 0x9d, 0x39, 0x2e,
+	    0x18, 0xa5, 0x5d, 0xe8,
+	0x8e, 0xa0, 0xd9, 0x29, 0xbd, 0xc4, 0x62, 0x2a, 0x6c, 0xc9, 0x4a, 0x26,
+	    0xb5, 0x19, 0x52, 0xe7,
+	0x2b, 0xcb, 0xac, 0x9a, 0x6e, 0x19, 0x80, 0xda, 0x5f, 0xcf, 0x02, 0xc1,
+	    0xd2, 0x6f, 0x1c, 0x69,
+	0xcd, 0xca, 0x44, 0x75, 0x4a, 0xa0, 0x36, 0x3a, 0xff, 0x7e, 0x4b, 0x0b,
+	    0xef, 0x4d, 0x74, 0x57,
+	0x8b, 0x70, 0x43, 0xb7, 0xae, 0x4e, 0xc9, 0x72, 0x6c, 0x34, 0xb9, 0x7f,
+	    0x9d, 0x66, 0x1c, 0x4c,
+	0xef, 0x0f, 0x1f, 0xd5, 0x7d, 0xa8, 0xca, 0x94, 0x5e, 0x81, 0x79, 0x6f,
+	    0xde, 0x6c, 0x7f, 0x08,
+	0x21, 0x07, 0x8b, 0x9e, 0x09, 0x50, 0xea, 0x89, 0xc3, 0xc0, 0x56, 0x0d,
+	    0x28, 0x6b, 0x11, 0x6f,
+	0x71, 0x23, 0x9a, 0x21, 0xff, 0xaa, 0x8c, 0x15, 0x43, 0xac, 0xaa, 0xec,
+	    0xb9, 0xce, 0x53, 0x6b,
+	0x82, 0x20, 0x47, 0xda, 0x60, 0xc1, 0x80, 0x5c, 0x6e, 0x8e, 0xff, 0x3f,
+	    0x97, 0xf4, 0xdb, 0x8e,
+	0x22, 0x98, 0xa2, 0x6e, 0xd8, 0xfd, 0xf4, 0x82, 0x6c, 0xb0, 0x0c, 0xb6,
+	    0xd3, 0xeb, 0x93, 0x70,
+	0xa5, 0x6c, 0x11, 0xf0, 0xb8, 0x37, 0x38, 0x92, 0x75, 0xb1, 0xde, 0xb2,
+	    0x74, 0x71, 0x25, 0x01,
+	0x46, 0x82, 0xfd, 0x3b, 0xb2, 0x52, 0xf5, 0xda, 0x63, 0x9e, 0xc7, 0xc1,
+	    0x0b, 0x9c, 0x4d, 0x21,
+	0xb5, 0x9e, 0xef, 0xd7, 0xdf, 0xff, 0xfd, 0xef, 0xcb, 0x9f, 0x02, 0xe7,
+	    0x75, 0xbc, 0x64, 0x46,
+	0x45, 0x3d, 0xbd, 0x41, 0xd3, 0x1f, 0xc0, 0x91, 0x5a, 0xdb, 0xaa, 0x24,
+	    0x64, 0xb6, 0x3f, 0xd5,
+	0x03, 0x38, 0x28, 0x29, 0xb8, 0xc8, 0xef, 0xb4, 0x01, 0x9b, 0xdb, 0x74,
+	    0x76, 0x92, 0x43, 0x7a,
+	0x22, 0x32, 0x9d, 0xc2, 0x56, 0xda, 0xe5, 0xa5, 0x96, 0x9a, 0xf5, 0x63,
+	    0xf0, 0x0d, 0x78, 0xe2,
+	0x06, 0x16, 0x0a, 0x27, 0x37, 0xa8, 0xea, 0x71, 0x67, 0x5f, 0xc7, 0x15,
+	    0x75, 0xdf, 0x46, 0x89,
+	0x39, 0x97, 0xaa, 0xfc, 0x9b, 0xbc, 0x37, 0x2e, 0x6c, 0x18, 0x26, 0x5e,
+	    0xed, 0x59, 0x24, 0x9b,
+	0x8e, 0xdb, 0x94, 0x6d, 0x49, 0x32, 0x8c, 0xa5, 0x15, 0x95, 0xec, 0x09,
+	    0x96, 0x9d, 0x47, 0x89,
+	0xed, 0x97, 0x30, 0x7e, 0xc0, 0x7a, 0xf7, 0x0e, 0x5b, 0xde, 0xa2, 0x5c,
+	    0x78, 0x77, 0xf1, 0x0d,
+	0xab, 0x02, 0xb9, 0xae, 0xc9, 0xf9, 0x6e, 0x53, 0x01, 0x96, 0x2f, 0x8f,
+	    0x02, 0x04, 0x50, 0x39,
+	0xaa, 0x11, 0x7f, 0x44, 0x3f, 0xfc, 0x4e, 0x3a, 0x90, 0xd3, 0x52, 0x8c,
+	    0x3f, 0xdc, 0x56, 0xea,
+	0x41, 0x82, 0x54, 0x99, 0xfd, 0xfd, 0x10, 0x7e, 0x56, 0x54, 0x5e, 0x3c,
+	    0xf3, 0xf3, 0x35, 0x7c,
+	0x8a, 0x3f, 0xc7, 0x73, 0x8d, 0x98, 0x67, 0x6e, 0xea, 0xf3, 0x8f, 0x2d,
+	    0x7d, 0xf0, 0xd7, 0x25,
+	0xbf, 0xd2, 0xa7, 0x73, 0xd8, 0xff, 0xbf, 0x3e, 0x9d, 0xc4, 0x87, 0x3d,
+	    0x5e, 0xbc, 0x3a, 0xf3,
+	0x2a, 0xad, 0x38, 0x75, 0x64, 0x2b, 0x07, 0xc8, 0x9c, 0x8d, 0x52, 0xb1,
+	    0x51, 0x12, 0x00, 0x14,
+	0x09, 0xfc, 0x97, 0x54, 0x59, 0x8a, 0x43, 0x30, 0x3a, 0x01, 0x8a, 0x47,
+	    0xba, 0x25, 0x55, 0x46,
+	0x4a, 0x4b, 0xc1, 0xc2, 0x96, 0xd2, 0xe8, 0x29, 0x25, 0x3d, 0xaf, 0x81,
+	    0xb8, 0x6f, 0xc9, 0xfc,
+	0x93, 0x82, 0x5d, 0x01, 0xb9, 0x0d, 0xe6, 0x6f, 0x74, 0x9f, 0xa3, 0x85,
+	    0x7f, 0x21, 0x56, 0x78,
+	0x04, 0x27, 0x40, 0x25, 0xd4, 0xa9, 0x22, 0x71, 0x12, 0xcf, 0xd1, 0xe0,
+	    0x4c, 0xf5, 0xa0, 0x01,
+	0x49, 0x7f, 0xf6, 0x14, 0x27, 0xda, 0x0c, 0x9c, 0x20, 0xba, 0xab, 0xf0,
+	    0x4d, 0xf4, 0x98, 0xb1,
+	0x7d, 0x09, 0xbf, 0x14, 0x79, 0xee, 0xa9, 0x50, 0xb2, 0x04, 0x8b, 0x64,
+	    0x71, 0x4e, 0x45, 0x72,
+	0x06, 0xaf, 0x65, 0x26, 0xe5, 0xae, 0x21, 0x73, 0xc5, 0xcc, 0x83, 0x74,
+	    0x70, 0x63, 0x13, 0xf7,
+	0xe1, 0x07, 0xdc, 0xa9, 0x1e, 0x09, 0xd2, 0xb8, 0x51, 0x26, 0x15, 0x19,
+	    0xe8, 0xeb, 0x96, 0xe0,
+	0x09, 0x72, 0x71, 0x14, 0xbc, 0xd6, 0x1c, 0xba, 0xe7, 0x2b, 0xd2, 0x2d,
+	    0x91, 0x2a, 0x51, 0x3f,
+	0x7f, 0xbf, 0xef, 0xe5, 0x91, 0x67, 0xd3, 0xc4, 0xd4, 0x42, 0x3f, 0xa9,
+	    0x9e, 0x88, 0x9c, 0xe8,
+	0xe7, 0xba, 0xbc, 0xbc, 0x69, 0x28, 0x3b, 0xac, 0x44, 0xc6, 0x4f, 0x3f,
+	    0x95, 0xcb, 0x78, 0xbb,
+	0x32, 0xa1, 0xe2, 0xa6, 0xe7, 0xa5, 0xaa, 0x59, 0x3a, 0x0e, 0xd4, 0x2b,
+	    0xef, 0xca, 0xc9, 0x2b,
+	0x33, 0xac, 0x77, 0x2c, 0x9b, 0x32, 0x22, 0x48, 0xe6, 0x0f, 0x75, 0x58,
+	    0xba, 0xc2, 0x56, 0x38,
+	0xbe, 0x07, 0xe3, 0xc7, 0x9b, 0xac, 0x07, 0x85, 0x23, 0x7f, 0xdb, 0x83,
+	    0x07, 0x33, 0x73, 0x69,
+	0x5b, 0x30, 0x74, 0x2d, 0x1b, 0x39, 0x0f, 0x95, 0xa8, 0x6f, 0xc8, 0x8e,
+	    0xe3, 0xc2, 0x22, 0xbc,
+	0x02, 0x0b, 0x7b, 0xbf, 0x4c, 0xa5, 0x34, 0x4a, 0x89, 0xa1, 0x40, 0x36,
+	    0x6c, 0x7a, 0xb6, 0x6f,
+	0x52, 0x11, 0x4c, 0x88, 0x2d, 0x3f, 0x99, 0xa3, 0x1d, 0xcb, 0xbc, 0xb1,
+	    0xfc, 0xfa, 0xa0, 0xf7,
+	0x57, 0x02, 0x16, 0x01, 0xcb, 0xf9, 0x0f, 0xa3, 0x72, 0x5a, 0x93, 0xe2,
+	    0x93, 0x02, 0x52, 0x81,
+	0xa7, 0x91, 0xb5, 0x6a, 0x32, 0x3e, 0x3b, 0x11, 0xba, 0x48, 0x09, 0x26,
+	    0xdf, 0xdc, 0xe7, 0xfd,
+	0xfe, 0x17, 0x00, 0xa2, 0x68, 0x76, 0xd4, 0x81, 0xa4, 0x29, 0xc1, 0xf7,
+	    0x5f, 0x7b, 0x54, 0xf4,
+	0xdb, 0x24, 0xaa, 0x80, 0xda, 0x9d, 0xdc, 0x91, 0xa5, 0x08, 0x4d, 0x70,
+	    0x23, 0xfc, 0x7b, 0xe8,
+	0xc3, 0xb6, 0x87, 0x8c, 0x3d, 0xcb, 0x95, 0x6c, 0xe3, 0x5e, 0xe7, 0x1d,
+	    0xf2, 0xd7, 0xfa, 0xe9,
+	0xa5, 0x0c, 0xd7, 0xd7, 0x00, 0xea, 0xa2, 0x75, 0xf5, 0x4b, 0xe5, 0x0f,
+	    0x5f, 0x7a, 0x0b, 0xcf,
+	0xc1, 0x1b, 0x7d, 0x4e, 0x99, 0x87, 0xb0, 0xdb, 0x42, 0x17, 0x42, 0x93,
+	    0x56, 0x39, 0x77, 0xeb,
+	0x55, 0x90, 0xc8, 0x8f, 0xe5, 0xda, 0x4a, 0x8a, 0x09, 0xd7, 0x22, 0x8d,
+	    0x4d, 0x3b, 0xe0, 0xf7,
+	0xc9, 0x1e, 0xef, 0xef, 0x4b, 0x78, 0x49, 0x4b, 0xec, 0xf7, 0xad, 0x5e,
+	    0xcc, 0xf1, 0x2f, 0x13,
+	0xaa, 0x01, 0x2c, 0x29, 0x61, 0x98, 0x61, 0xbf, 0x00, 0x54, 0xcb, 0x51,
+	    0x58, 0x15, 0xd3, 0xb7,
+	0x42, 0xcd, 0xdc, 0xce, 0xa8, 0x34, 0x28, 0xa9, 0xc6, 0x51, 0xa9, 0xdd,
+	    0x5c, 0xd3, 0x59, 0x2b,
+	0x53, 0xa8, 0xf0, 0x8c, 0xf1, 0xf5, 0xcf, 0x16, 0x6d, 0x2f, 0xa0, 0x5d,
+	    0x18, 0x2c, 0x39, 0xf5,
+	0x5f, 0xbd, 0x47, 0xcf, 0x8e, 0x50, 0x29, 0xad, 0x03, 0x56, 0x07, 0x97,
+	    0x90, 0x5d, 0x5a, 0xe6,
+	0x97, 0x5d, 0xf1, 0x8c, 0xbd, 0x6d, 0x08, 0xb9, 0xbb, 0x22, 0x1f, 0xe5,
+	    0xdc, 0x72, 0x7e, 0xaa,
+	0x0c, 0xc2, 0x60, 0xff, 0x73, 0x2d, 0xd5, 0xdd, 0xa5, 0x96, 0x60, 0x55,
+	    0x72, 0x67, 0x4e, 0x2e,
+	0xee, 0x50, 0x51, 0xfd, 0xa6, 0xe3, 0xb8, 0xb6, 0x07, 0xf9, 0x3f, 0x4f,
+	    0x56, 0x01, 0xbd, 0x3f,
+	0x09, 0x0f, 0xda, 0xfc, 0xab, 0x2b, 0xca, 0xdb, 0xc4, 0x79, 0x33, 0x61,
+	    0x59, 0xa0, 0x13, 0x80,
+	0xfd, 0x2c, 0xeb, 0xf9, 0x64, 0xaf, 0x95, 0xb7, 0xfa, 0xb3, 0x15, 0xc7,
+	    0x9b, 0x45, 0xdc, 0xa2,
+	0x02, 0xb6, 0xa8, 0x4a, 0xeb, 0xe6, 0x08, 0x92, 0xeb, 0x65, 0xe5, 0x21,
+	    0x9c, 0xad, 0x7d, 0x21,
+	0x3f, 0x02, 0x5c, 0x34, 0xfc, 0x6d, 0x22, 0x73, 0xe4, 0x65, 0xc2, 0x85,
+	    0x7d, 0x4a, 0xdd, 0xa3,
+	0xca, 0x26, 0x20, 0x0d, 0x7d, 0x0e, 0xe0, 0xe7, 0xec, 0x9d, 0xf9, 0x63,
+	    0x5e, 0x3c, 0x6f, 0x20,
+	0x7f, 0xd6, 0xb6, 0x42, 0x91, 0xd5, 0xe8, 0x00, 0xf3, 0xab, 0x29, 0x84,
+	    0xaf, 0x48, 0x35, 0xcd,
+	0xe5, 0x59, 0x9a, 0x75, 0x9d, 0xa5, 0x7a, 0x3e, 0xce, 0x8f, 0x66, 0xdd,
+	    0x72, 0x84, 0xea, 0xf7,
+	0x51, 0x81, 0x82, 0x7c, 0x2e, 0x4a, 0xd6, 0x49, 0x6f, 0x6f, 0x2d, 0xb6,
+	    0xf8, 0x4f, 0x45, 0xab,
+	0x65, 0x7b, 0x18, 0x4d, 0x3d, 0x57, 0xcc, 0x49, 0x8c, 0xc5, 0xea, 0x87,
+	    0x79, 0x4c, 0xa9, 0x08,
+	0xf5, 0x7a, 0x13, 0xe1, 0x8d, 0xe6, 0x74, 0x48, 0x9e, 0x42, 0x28, 0xff,
+	    0xdb, 0x46, 0xd5, 0x67,
+	0x08, 0x97, 0xff, 0x57, 0x18, 0xfe, 0x10, 0x7b, 0x4d, 0x8c, 0x61, 0x9f,
+	    0x6a, 0xcc, 0xf9, 0x61,
+	0x3b, 0x78, 0x66, 0x61, 0x5e, 0x36, 0xa9, 0x34, 0xb2, 0x91, 0x05, 0x0d,
+	    0x6b, 0x81, 0xf6, 0x55,
+	0xf6, 0x7a, 0x58, 0x0f, 0xbe, 0x7b, 0x67, 0xbc, 0xea, 0x7a, 0xcd, 0x0a,
+	    0xbe, 0x31, 0x78, 0xdf,
+	0xbc, 0xfe, 0xeb, 0xa6, 0x83, 0xed, 0xbb, 0xf6, 0xb5, 0xc5, 0x1c, 0xbf,
+	    0xce, 0x42, 0x1a, 0x23,
+	0x64, 0xd2, 0x87, 0x36, 0x5f, 0xd3, 0x66, 0x3d, 0x8f, 0xb4, 0xd6, 0xa7,
+	    0x77, 0xb0, 0xec, 0x7f,
+	0x09, 0x4e, 0x92, 0x32, 0x5d, 0xbc, 0x02, 0x12, 0xc6, 0x71, 0x7c, 0x5f,
+	    0x7d, 0xf7, 0xf8, 0x0f,
+	0xc4, 0x53, 0x27, 0xf5, 0x5f, 0xf1, 0x0b, 0x9e, 0x47, 0xb7, 0xb9, 0x88,
+	    0x08, 0xa3, 0x99, 0xf1,
+	0x5a, 0xd1, 0xbf, 0xf0, 0x5e, 0xf7, 0x69, 0xb2, 0xe9, 0x92, 0x5a, 0x65,
+	    0x54, 0x5c, 0x3d, 0xef,
+	0xdb, 0x35, 0x1e, 0x86, 0x42, 0x61, 0xb4, 0x6f, 0x67, 0xde, 0x0f, 0xc1,
+	    0xd7, 0x0b, 0x3a, 0xef,
+	0xcc, 0x64, 0xec, 0x2f, 0x7f, 0xf7, 0x44, 0x92, 0x63, 0xfc, 0xc7, 0x68,
+	    0x80, 0xb7, 0x35, 0x30,
+	0x84, 0x4b, 0xe9, 0xf8, 0xb3, 0x2d, 0xf7, 0x67, 0xf8, 0x47, 0x59, 0x9c,
+	    0x28, 0x09, 0x81, 0xa0,
+	0xd3, 0x31, 0x29, 0xb1, 0xcc, 0xa7, 0x19, 0x77, 0xf1, 0x4b, 0x26, 0x3e,
+	    0x23, 0x06, 0xfb, 0x02,
+	0x4c, 0x89, 0x9c, 0x3e, 0x92, 0xfa, 0x95, 0x96, 0xb0, 0x29, 0x23, 0x89,
+	    0xdd, 0x57, 0x9a, 0xf8,
+	0x51, 0x36, 0x1f, 0x2a, 0x85, 0x1a, 0x67, 0x12, 0xc8, 0x70, 0x2b, 0x3a,
+	    0x22, 0x13, 0xe7, 0x66,
+	0x80, 0x05, 0x20, 0xba, 0x00, 0x59, 0x14, 0x0b, 0x34, 0xf9, 0xa4, 0x94,
+	    0x8c, 0x0f, 0xbc, 0xe1,
+	0xdb, 0x34, 0x9e, 0x2f, 0x30, 0xf9, 0xa8, 0x5b, 0xad, 0xc9, 0xf7, 0x3f,
+	    0x9e, 0xb4, 0x36, 0xb9,
+	0x56, 0x3a, 0x26, 0x42, 0xcb, 0xb4, 0x08, 0xaf, 0xc2, 0xd1, 0x51, 0x4e,
+	    0xf3, 0x51, 0xfb, 0xc9,
+	0x5f, 0xec, 0xb7, 0x5c, 0xf9, 0x10, 0xbe, 0x77, 0x56, 0x6f, 0xe9, 0x6d,
+	    0x03, 0xf7, 0xf0, 0x8b,
+	0xe2, 0x6b, 0xa5, 0x08, 0x57, 0x76, 0x09, 0xbb, 0x95, 0xae, 0x64, 0x7c,
+	    0xdc, 0x53, 0xc8, 0xe3,
+	0x46, 0xae, 0xe1, 0x57, 0x79, 0xb7, 0xbf, 0x77, 0x1a, 0xd7, 0x7d, 0xec,
+	    0x83, 0x4e, 0x26, 0xa0,
+	0x74, 0xa0, 0xb8, 0xd4, 0xcf, 0x2f, 0x28, 0xf0, 0xff, 0x4f, 0x69, 0x2c,
+	    0xf5, 0x1f, 0x5c, 0x2f,
+	0x27, 0xac, 0xf0, 0x33, 0xb2, 0x27, 0x12, 0x20, 0xe2, 0x4c, 0x47, 0x1c,
+	    0x26, 0xa4, 0x90, 0x03,
+	0x78, 0xd7, 0xe1, 0x41, 0xb1, 0xaf, 0x71, 0x81, 0x7c, 0x4f, 0xca, 0x23,
+	    0xab, 0x6e, 0x95, 0x21,
+	0x7a, 0xbc, 0x01, 0xc9, 0xd1, 0x2c, 0x53, 0xde, 0x62, 0x45, 0x09, 0xb7,
+	    0x63, 0x02, 0xd0, 0xc2,
+	0x82, 0x8c, 0xfe, 0x7d, 0x9d, 0xa2, 0xe7, 0xc1, 0xb6, 0x47, 0x40, 0x02,
+	    0x73, 0x14, 0xd8, 0x22,
+	0x81, 0x12, 0x1d, 0x70, 0x15, 0xd5, 0x26, 0x4d, 0xaa, 0xb4, 0x5a, 0xf0,
+	    0x07, 0xe1, 0x79, 0x11,
+	0xa2, 0x09, 0xc1, 0x05, 0x96, 0x0a, 0x91, 0x18, 0x1a, 0xcb, 0x11, 0x7d,
+	    0x3f, 0x6c, 0x0a, 0xb3,
+	0x2f, 0x08, 0x82, 0xac, 0x9f, 0x65, 0xf5, 0xe2, 0xee, 0x4d, 0x19, 0x89,
+	    0x78, 0x61, 0x38, 0xb8,
+	0xf7, 0x97, 0x36, 0x6e, 0x59, 0x68, 0x42, 0xa8, 0x2b, 0xb8, 0xc8, 0x28,
+	    0xfb, 0x6e, 0x5e, 0x07,
+	0x2f, 0xa2, 0xd0, 0x1d, 0xba, 0x2f, 0x22, 0xe8, 0xea, 0xc1, 0xe2, 0x18,
+	    0xbc, 0x96, 0xc3, 0x99,
+	0x91, 0xde, 0xfb, 0x8f, 0x9d, 0x71, 0x6b, 0xab, 0xea, 0x1f, 0xe2, 0x0c,
+	    0xbb, 0x29, 0x9e, 0x08,
+	0x0b, 0xac, 0x03, 0xf4, 0x3a, 0x2d, 0x9d, 0xdb, 0x4b, 0x48, 0x9a, 0xbf,
+	    0x6b, 0x99, 0xd2, 0x5b,
+	0x6b, 0x84, 0xc5, 0xe4, 0xce, 0x1d, 0x1e, 0x99, 0xe9, 0xcc, 0xa3, 0xf0,
+	    0xfb, 0x02, 0x72, 0xb6,
+	0xa7, 0x00, 0x4d, 0x3e, 0x3a, 0x8d, 0x30, 0x8b, 0xcf, 0xe0, 0x69, 0x55,
+	    0xa7, 0x3c, 0x65, 0x38,
+	0xc3, 0x4f, 0x64, 0x61, 0x18, 0x49, 0x6d, 0x54, 0x2a, 0xcf, 0xb1, 0xed,
+	    0xd9, 0xbc, 0xb6, 0xa6,
+	0x5e, 0x52, 0x95, 0x74, 0x9b, 0x80, 0x23, 0xc9, 0x15, 0xe0, 0x80, 0x7d,
+	    0xa0, 0x2f, 0xe3, 0xf3,
+	0x5c, 0xc6, 0x7d, 0x00, 0x4b, 0x68, 0x12, 0xc2, 0x21, 0x40, 0x20, 0xc6,
+	    0xcf, 0x1c, 0xdc, 0x78,
+	0xf1, 0xd7, 0x53, 0x61, 0xb3, 0x32, 0x64, 0x32, 0x43, 0x21, 0xfa, 0xd2,
+	    0xc6, 0x61, 0x0d, 0x11,
+	0x2f, 0xbf, 0x45, 0x78, 0x7e, 0x70, 0x6d, 0x86, 0x83, 0xa2, 0x2a, 0x2a,
+	    0xd4, 0x69, 0x4c, 0xe7,
+	0xc0, 0x17, 0x1d, 0xe7, 0x12, 0x35, 0x25, 0x61, 0x42, 0x5c, 0x25, 0x5a,
+	    0x8a, 0x62, 0x53, 0x33,
+	0xa6, 0x99, 0xc7, 0xb3, 0x31, 0xb5, 0x6c, 0x0a, 0xce, 0x59, 0xd0, 0x02,
+	    0x93, 0x6f, 0x74, 0x23,
+	0x57, 0xb8, 0x0b, 0x56, 0x9d, 0x0b, 0xe8, 0x92, 0xdc, 0xa8, 0xe6, 0x1c,
+	    0x67, 0x3a, 0x17, 0xc3,
+	0x49, 0x72, 0x9c, 0xde, 0x57, 0x3d, 0x28, 0xc6, 0x43, 0x09, 0x54, 0x03,
+	    0x72, 0x96, 0xd1, 0xc2,
+	0xdb, 0x18, 0xf5, 0xc5, 0x10, 0x3a, 0xc8, 0x0e, 0x16, 0x04, 0x84, 0xd1,
+	    0x54, 0x71, 0x7f, 0xfb,
+	0x02, 0x91, 0x8e, 0xc4, 0x78, 0x37, 0x76, 0x08, 0x62, 0xd3, 0xcd, 0x9a,
+	    0x07, 0x74, 0x08, 0xa0,
+	0x61, 0x28, 0x75, 0xef, 0x0a, 0xc8, 0xd2, 0xda, 0x2a, 0x86, 0x8d, 0x7a,
+	    0x1b, 0xf4, 0x27, 0x03,
+	0xa9, 0x5a, 0x07, 0xb0, 0x0b, 0x59, 0x50, 0x4b, 0x6a, 0x12, 0x4c, 0xab,
+	    0xdc, 0x34, 0x13, 0x06,
+	0x40, 0x8a, 0xf1, 0x9b, 0x50, 0xd0, 0x67, 0xdb, 0xaa, 0xe4, 0xc6, 0x3e,
+	    0x1e, 0x3a, 0x74, 0xf9,
+	0x8b, 0xe3, 0x39, 0x5e, 0x72, 0x34, 0xad, 0x93, 0x50, 0xe3, 0xf2, 0x7d,
+	    0xdb, 0x7a, 0xf1, 0xe8,
+	0xaa, 0xb2, 0x36, 0xa3, 0xb4, 0xbb, 0xfe, 0x3a, 0xe7, 0x1f, 0xfa, 0x6c,
+	    0xda, 0x7b, 0x79, 0x2b,
+	0x84, 0xc1, 0xc5, 0xbf, 0x89, 0x68, 0x6c, 0x41, 0x19, 0x50, 0x23, 0xf0,
+	    0x59, 0x78, 0x1b, 0xa7,
+	0xc9, 0xfb, 0x48, 0x9d, 0xa3, 0x73, 0x9d, 0x8d, 0xa3, 0xae, 0xa9, 0xeb,
+	    0x58, 0x3e, 0x06, 0x60,
+	0x25, 0xe0, 0x28, 0xfb, 0xf5, 0xaf, 0x76, 0xd2, 0x4c, 0xcf, 0x0a, 0x79,
+	    0xf7, 0x85, 0xf8, 0x2c,
+	0x2f, 0xc3, 0xd0, 0x94, 0x10, 0xa5, 0xbe, 0xd0, 0xc7, 0xc2, 0x11, 0x50,
+	    0x35, 0xa1, 0x7f, 0x2e,
+	0x88, 0x77, 0xc1, 0x43, 0xe3, 0x22, 0x51, 0x83, 0xca, 0x49, 0x0e, 0xc5,
+	    0xf0, 0xf9, 0xf2, 0xda,
+	0x51, 0x72, 0x91, 0xc7, 0x4a, 0xac, 0x3a, 0xc3, 0xc9, 0xcc, 0xc6, 0xbf,
+	    0x70, 0x60, 0xcb, 0x66,
+	0x6d, 0x8b, 0x71, 0xae, 0x02, 0xe9, 0xd4, 0x20, 0xca, 0xc8, 0x30, 0xf6,
+	    0x4f, 0x88, 0xf8, 0x15,
+	0xee, 0x7e, 0x4a, 0x34, 0x36, 0x05, 0x40, 0x89, 0xeb, 0xc8, 0x1f, 0x08,
+	    0x36, 0xe1, 0xe1, 0x71,
+	0x72, 0x89, 0xf9, 0x4a, 0x14, 0x01, 0xd1, 0x01, 0x35, 0xa3, 0x91, 0xd1,
+	    0x91, 0xeb, 0x0b, 0x42,
+	0x6e, 0x5c, 0xb7, 0x7e, 0x97, 0x08, 0x82, 0x54, 0x66, 0x38, 0x80, 0xf5,
+	    0x31, 0x4d, 0x85, 0xaa,
+	0xf0, 0xf9, 0xc2, 0xbb, 0x32, 0xa5, 0x52, 0x6e, 0x13, 0xc5, 0xb2, 0xd4,
+	    0xa0, 0xf3, 0x1d, 0x26,
+	0x0b, 0xeb, 0xa0, 0x1f, 0xbe, 0xa4, 0x6a, 0x15, 0xec, 0x41, 0xc2, 0x3a,
+	    0xa4, 0xab, 0xf8, 0x0b,
+	0x7c, 0x3b, 0xe9, 0xe0, 0x3f, 0xa7, 0x39, 0x2a, 0x6f, 0xcc, 0x00, 0xda,
+	    0xf8, 0x41, 0x93, 0xdc,
+	0x64, 0x88, 0xa1, 0x1b, 0x3e, 0x50, 0x33, 0xd9, 0x4f, 0xc8, 0x79, 0x75,
+	    0x7c, 0xb4, 0x00, 0x4a,
+	0x2a, 0x28, 0x73, 0xee, 0x3a, 0x5d, 0x2c, 0x88, 0x0e, 0x61, 0xca, 0x1e,
+	    0xde, 0xfa, 0xea, 0x4b,
+	0x77, 0x2f, 0x76, 0xda, 0x43, 0xc4, 0x04, 0x7c, 0xa6, 0xc2, 0x42, 0x6e,
+	    0xf8, 0xe9, 0xfb, 0x72,
+	0xac, 0xc6, 0xbd, 0xad, 0x9a, 0x03, 0xe4, 0x59, 0xae, 0x40, 0xbb, 0xe6,
+	    0xed, 0xbe, 0x7c, 0xab,
+	0x70, 0x2e, 0x2b, 0x43, 0xd8, 0xed, 0x29, 0x4c, 0x24, 0xab, 0x3b, 0x97,
+	    0xfb, 0x64, 0x3c, 0x96,
+	0xa6, 0x37, 0x77, 0x75, 0xb8, 0xf1, 0x4c, 0x20, 0x61, 0x1a, 0xe9, 0x30,
+	    0xd9, 0x51, 0x4c, 0x21,
+	0xed, 0x9c, 0xed, 0xf0, 0x54, 0xb5, 0xf5, 0x50, 0xe7, 0x99, 0x68, 0x48,
+	    0x88, 0x70, 0x03, 0x73,
+	0x82, 0x9d, 0xbf, 0x85, 0x5f, 0xbd, 0x0f, 0x41, 0x66, 0x9a, 0x8d, 0x58,
+	    0xee, 0x9f, 0xc1, 0x01,
+	0xa5, 0x9b, 0xcb, 0x75, 0x91, 0x1e, 0xe3, 0x43, 0xd9, 0xdc, 0x95, 0x93,
+	    0x14, 0xe8, 0x1a, 0x62,
+	0x11, 0x62, 0xe8, 0xc4, 0x7e, 0x39, 0x54, 0xc8, 0x11, 0x22, 0xce, 0x1c,
+	    0x8d, 0x8f, 0x6c, 0xc1,
+	0x0a, 0x86, 0x8c, 0x60, 0x7c, 0xb8, 0x81, 0x1e, 0x67, 0x6e, 0x85, 0x72,
+	    0x35, 0xaa, 0xb8, 0x11,
+	0xcd, 0x75, 0x85, 0x60, 0x2d, 0xb9, 0xaa, 0x31, 0x0f, 0xbf, 0xb5, 0x0b,
+	    0x9a, 0xc9, 0x32, 0xd1,
+	0x5b, 0xb4, 0x14, 0xf0, 0x16, 0xc8, 0x7c, 0x77, 0x8c, 0x03, 0x20, 0xce,
+	    0xc0, 0x80, 0xa0, 0xf8,
+	0x1f, 0xce, 0xf2, 0xbf, 0x9d, 0x39, 0x56, 0xca, 0x10, 0xd5, 0x9e, 0x48,
+	    0x6c, 0xb7, 0xbe, 0x18,
+	0x2c, 0xfb, 0xfc, 0x15, 0xd6, 0xdd, 0x46, 0xd8, 0x2e, 0xc6, 0xc0, 0x43,
+	    0x1e, 0xd9, 0xdf, 0xe9,
+	0xee, 0x95, 0xc7, 0x7c, 0x38, 0x37, 0x7d, 0xfc, 0xad, 0xca, 0x27, 0xdd,
+	    0x94, 0x01, 0x17, 0x4b,
+	0x56, 0x94, 0x3f, 0x77, 0x77, 0xf6, 0x47, 0x39, 0x83, 0xb8, 0xe9, 0x43,
+	    0x16, 0x20, 0x9d, 0x4e,
+	0x57, 0x28, 0x4a, 0x5d, 0x0a, 0x11, 0xad, 0x75, 0x11, 0x52, 0xab, 0xe6,
+	    0x4d, 0xfc, 0x30, 0x6f,
+	0x2f, 0x39, 0xa6, 0x82, 0x0c, 0x09, 0x7e, 0xc1, 0x45, 0x48, 0xae, 0x6a,
+	    0x9e, 0xf2, 0xbe, 0xfc,
+	0x91, 0x10, 0xf2, 0x4b, 0xee, 0xc1, 0x49, 0x8e, 0x51, 0x85, 0x37, 0x93,
+	    0xe9, 0xf8, 0xf3, 0x73,
+	0x57, 0x4e, 0x55, 0xbf, 0xc9, 0xa4, 0x2f, 0x7f, 0xc8, 0x10, 0x4b, 0x80,
+	    0x5c, 0xbe, 0x5e, 0xa1,
+	0x04, 0x8d, 0x3b, 0x4a, 0x23, 0x7a, 0xed, 0xe7, 0x9e, 0x1d, 0x93, 0xaf,
+	    0xd5, 0x71, 0x51, 0x1f,
+	0xe4, 0x5e, 0x77, 0xed, 0x4d, 0x63, 0x9b, 0x7e, 0xce, 0xfc, 0xea, 0x9c,
+	    0xf2, 0x23, 0x7f, 0xa5,
+	0x6b, 0x61, 0x39, 0xfb, 0x80, 0x6f, 0xf2, 0xe1, 0xd4, 0x00, 0x51, 0x39,
+	    0x4e, 0x64, 0x08, 0x67,
+	0x3e, 0x98, 0x4d, 0xe7, 0x30, 0xa9, 0xfe, 0x4b, 0x17, 0x4b, 0x9e, 0x89,
+	    0xd7, 0x7b, 0x20, 0xe7,
+	0xa9, 0x0b, 0xc6, 0xbf, 0xef, 0xa3, 0xc7, 0x7f, 0x60, 0xf1, 0x2b, 0x1b,
+	    0x32, 0xea, 0x11, 0x4b,
+	0xe4, 0x06, 0x48, 0xad, 0x17, 0x88, 0x41, 0x70, 0x97, 0x66, 0x23, 0x07,
+	    0x2f, 0x1a, 0x81, 0x9c,
+	0x1d, 0x8b, 0x41, 0x54, 0xb0, 0x4e, 0xc2, 0x9c, 0xca, 0x04, 0x2e, 0x1b,
+	    0xb0, 0x90, 0x5f, 0x30,
+	0xb0, 0xb3, 0x99, 0x78, 0x6c, 0x8a, 0xfe, 0xd5, 0x1a, 0x7a, 0x00, 0x75,
+	    0xa8, 0x6b, 0x02, 0xf1,
+	0x4a, 0xf7, 0x05, 0xf7, 0x6b, 0x28, 0x92, 0xef, 0x6c, 0xc5, 0xea, 0xae,
+	    0xba, 0x38, 0xce, 0x7e,
+	0xdd, 0x8a, 0x86, 0x7a, 0xea, 0x39, 0x63, 0xba, 0xaf, 0xef, 0xb8, 0x5e,
+	    0x19, 0x66, 0xa8, 0x67,
+	0x5d, 0x48, 0x43, 0x88, 0x3d, 0x31, 0xce, 0x2d, 0x7f, 0x75, 0x2c, 0xcf,
+	    0x5a, 0xcd, 0xac, 0xa8,
+	0xab, 0x7a, 0x33, 0xe6, 0x14, 0x5d, 0x23, 0xc3, 0x65, 0x46, 0xc3, 0x29,
+	    0x5b, 0xcc, 0xf8, 0xfa,
+	0x02, 0xcc, 0x55, 0xe0, 0xed, 0xb7, 0x7d, 0x95, 0x4e, 0x0e, 0x89, 0x5e,
+	    0x5c, 0x04, 0x52, 0xc9,
+	0x38, 0x5b, 0xe1, 0x22, 0xca, 0x91, 0xfd, 0xc8, 0x92, 0x70, 0xd5, 0x9d,
+	    0xae, 0x62, 0x23, 0xee,
+	0x21, 0x03, 0xc3, 0xc9, 0x94, 0x63, 0x4a, 0x69, 0x1e, 0x2d, 0xd1, 0x1e,
+	    0xae, 0x2c, 0xf3, 0xb9,
+	0x89, 0x09, 0x74, 0x06, 0x72, 0x6c, 0x74, 0x84, 0xc7, 0x0d, 0x6f, 0x02,
+	    0x78, 0xc2, 0x62, 0x04,
+	0x66, 0xd9, 0xa3, 0xf2, 0x13, 0xd1, 0xb7, 0xd6, 0x08, 0x33, 0x8c, 0xa0,
+	    0x79, 0x3b, 0x58, 0xe2,
+	0x12, 0xc5, 0x4c, 0x8d, 0x2e, 0x3b, 0x04, 0xb4, 0x69, 0xb9, 0x53, 0x7b,
+	    0x77, 0x81, 0xc5, 0xf9,
+	0x93, 0xb0, 0x45, 0x9c, 0xcc, 0x5e, 0x6b, 0x04, 0x09, 0x71, 0x85, 0x90,
+	    0xe8, 0x30, 0xf7, 0xe2,
+	0x87, 0xb2, 0x48, 0xb2, 0xb7, 0x83, 0x23, 0x14, 0xc0, 0x13, 0x43, 0x73,
+	    0x9d, 0x32, 0x43, 0x64,
+	0xa0, 0x10, 0x90, 0x2c, 0xf3, 0x7b, 0x0d, 0xe4, 0xef, 0x37, 0xd5, 0x97,
+	    0x5c, 0x3b, 0x04, 0x59,
+	0xa1, 0x72, 0x13, 0x56, 0x0c, 0x3d, 0x21, 0xb7, 0xa9, 0xd6, 0xa2, 0x55,
+	    0x92, 0xd6, 0xf1, 0x45,
+	0xfa, 0x91, 0xc4, 0x23, 0xc5, 0x00, 0xfe, 0x44, 0x37, 0x48, 0xeb, 0xd8,
+	    0x9a, 0x55, 0x4f, 0x55,
+	0xfb, 0x54, 0x34, 0x2e, 0xb5, 0xfc, 0xe6, 0x62, 0xcd, 0x5f, 0x8d, 0x06,
+	    0xd1, 0xd7, 0x9a, 0x73,
+	0xd4, 0x5b, 0xf4, 0xcc, 0x72, 0x3e, 0xfa, 0x8c, 0xe5, 0x19, 0xf6, 0xaf,
+	    0x65, 0x75, 0x92, 0xa9,
+	0x88, 0xb8, 0x09, 0x18, 0x61, 0xbb, 0x8f, 0xdc, 0x5a, 0xed, 0xbe, 0xb8,
+	    0xfc, 0xd8, 0xc7, 0xb1,
+	0xb3, 0xb7, 0x73, 0x6e, 0x19, 0x31, 0x07, 0x81, 0x81, 0x5b, 0xcf, 0xbd,
+	    0x7f, 0xdb, 0xdf, 0x6a,
+	0x8f, 0x00, 0xd6, 0xd0, 0xda, 0x33, 0xa5, 0xc9, 0xe1, 0x50, 0x5f, 0xa1,
+	    0x39, 0x39, 0x26, 0xca,
+	0x8e, 0x5e, 0x49, 0x24, 0xa3, 0x71, 0x40, 0x10, 0x6a, 0xe7, 0x45, 0xee,
+	    0xac, 0xa7, 0x8e, 0xc1,
+	0x57, 0x1b, 0xb0, 0x8d, 0x04, 0xb3, 0xb2, 0x8b, 0x09, 0xab, 0x46, 0x04,
+	    0x7b, 0x3f, 0x40, 0x7b,
+	0xa9, 0x6e, 0xb9, 0x9d, 0xaa, 0x73, 0xd5, 0x6d, 0xb8, 0xff, 0xb2, 0x10,
+	    0x78, 0xcb, 0x6f, 0xfa,
+	0xad, 0xaf, 0x16, 0x42, 0x43, 0x24, 0x61, 0x5c, 0x3d, 0x57, 0x07, 0xbf,
+	    0x27, 0x9c, 0xa3, 0x86,
+	0x50, 0xdc, 0x9b, 0x88, 0x17, 0x60, 0x4f, 0x05, 0xe5, 0x1f, 0x14, 0x44,
+	    0x14, 0xef, 0x56, 0xa3,
+	0xec, 0x02, 0xe0, 0x1a, 0x13, 0x31, 0x7e, 0x21, 0xd4, 0x5c, 0xbd, 0xd4,
+	    0xd7, 0x66, 0x8d, 0x70,
+	0xee, 0x74, 0x9e, 0x98, 0x65, 0x74, 0x85, 0x41, 0x3b, 0x80, 0x21, 0x55,
+	    0x56, 0x65, 0xca, 0xe0,
+	0xe7, 0xf6, 0x4b, 0xd1, 0xa5, 0xe1, 0x10, 0xb7, 0x99, 0x4b, 0xef, 0x55,
+	    0x2a, 0x6a, 0x94, 0xa5,
+	0xa7, 0x04, 0xf6, 0xf6, 0xe9, 0x09, 0x69, 0x62, 0xdb, 0x39, 0x67, 0x9d,
+	    0x25, 0xe4, 0x9c, 0xb4,
+	0xa6, 0x05, 0x57, 0x67, 0xb6, 0x5a, 0xcb, 0x4f, 0xbb, 0xc6, 0xa9, 0x8b,
+	    0xd6, 0x3e, 0x19, 0xa3,
+	0xda, 0x80, 0xb5, 0xf6, 0xb8, 0x79, 0xdc, 0x2d, 0x33, 0x9a, 0x2c, 0xc3,
+	    0xbd, 0x15, 0x11, 0x51,
+	0xcb, 0x0a, 0x52, 0xf2, 0x60, 0xc9, 0x22, 0x73, 0xbc, 0x07, 0xcb, 0xf3,
+	    0xf4, 0x48, 0x3c, 0x24,
+	0x6d, 0x33, 0x25, 0xaa, 0x9c, 0xb8, 0x81, 0x9a, 0xb0, 0x6b, 0xb6, 0x4e,
+	    0x48, 0xa4, 0x3b, 0xe6,
+	0xe9, 0xcb, 0xd8, 0xb6, 0x5d, 0xa6, 0xfa, 0xae, 0x03, 0xc3, 0xda, 0x3d,
+	    0x40, 0xe6, 0x0b, 0xf3,
+	0x6c, 0x71, 0x63, 0x13, 0x02, 0xac, 0x09, 0xd1, 0x37, 0xa6, 0x25, 0xe9,
+	    0xb4, 0x67, 0xa7, 0x0b,
+	0x0f, 0x4c, 0xfb, 0x37, 0xf4, 0xb0, 0xbb, 0x7c, 0xe9, 0xd0, 0x2b, 0x40,
+	    0xbc, 0xcb, 0x02, 0xed,
+	0xa9, 0x83, 0x5d, 0xd5, 0xeb, 0x3a, 0xb2, 0xef, 0xeb, 0xa2, 0x5e, 0x86,
+	    0x97, 0xa1, 0x00, 0xde,
+	0x40, 0xe9, 0x7a, 0xa3, 0x1f, 0xec, 0x2e, 0xe4, 0x4e, 0x6f, 0x3a, 0x27,
+	    0x3e, 0xe7, 0xd7, 0xa9,
+	0x88, 0x84, 0xeb, 0x4a, 0xe1, 0x8e, 0x4d, 0xcf, 0x10, 0x63, 0x95, 0xca,
+	    0x37, 0xad, 0x0b, 0xfc,
+	0x28, 0xcd, 0xd1, 0xac, 0xbd, 0x00, 0xc6, 0x25, 0x7a, 0x13, 0x7d, 0x0c,
+	    0xf9, 0xa0, 0x87, 0xf4,
+	0xab, 0x16, 0x5c, 0x6e, 0xec, 0x7b, 0xf9, 0x4a, 0x73, 0x9d, 0x6f, 0x45,
+	    0x47, 0x44, 0xd3, 0x16,
+	0x0a, 0x57, 0x04, 0xbe, 0x11, 0xf3, 0x67, 0xb2, 0x1e, 0x21, 0xb8, 0x76,
+	    0x79, 0xf2, 0x21, 0xc3,
+	0xb7, 0x1f, 0xa1, 0x03, 0xe8, 0xf1, 0xce, 0xab, 0x41, 0x2d, 0x0f, 0x58,
+	    0x7b, 0x74, 0x92, 0x61,
+	0x84, 0xf2, 0xae, 0x34, 0x37, 0xb7, 0xfd, 0x36, 0x06, 0xd5, 0x38, 0xb2,
+	    0xf3, 0x03, 0x16, 0x82,
+	0x7a, 0xd6, 0xd7, 0x33, 0x49, 0x3a, 0x35, 0x91, 0x44, 0x01, 0x57, 0x52,
+	    0xae, 0x57, 0x0c, 0x60,
+	0x3f, 0x1e, 0xe5, 0xa5, 0x1a, 0x37, 0xa8, 0xac, 0x49, 0x09, 0x4b, 0x87,
+	    0xea, 0x08, 0xaa, 0x0c,
+	0x23, 0x37, 0x3e, 0x58, 0xb0, 0x0f, 0xe2, 0x0b, 0xe2, 0xba, 0xd6, 0x57,
+	    0x02, 0x7f, 0x23, 0x31,
+	0x83, 0xd5, 0x93, 0xea, 0x56, 0x18, 0x14, 0x18, 0x6a, 0x71, 0x50, 0xb9,
+	    0x02, 0xab, 0x7f, 0x56,
+	0x89, 0x07, 0x94, 0xec, 0x57, 0x7b, 0x16, 0x80, 0xcd, 0x54, 0x68, 0x2c,
+	    0xd2, 0xd7, 0xad, 0xe6,
+	0x1e, 0x03, 0xf7, 0x9e, 0x3e, 0xeb, 0x3e, 0x3e, 0x63, 0x94, 0xe6, 0xa7,
+	    0xff, 0x9e, 0x26, 0xed,
+	0x57, 0xd8, 0xa7, 0x7c, 0xd2, 0xf8, 0x7d, 0xb6, 0x17, 0x41, 0x8f, 0xcf,
+	    0xbe, 0x07, 0x97, 0x75,
+	0xbd, 0xd6, 0xcf, 0x38, 0x2a, 0xf9, 0x92, 0xc4, 0x70, 0x87, 0x2f, 0xdd,
+	    0xde, 0x1b, 0xa5, 0x17,
+	0x0a, 0x68, 0x75, 0xbd, 0x4a, 0xd0, 0xa6, 0x94, 0xa4, 0xff, 0xcc, 0x05,
+	    0xcd, 0x09, 0x59, 0xe6,
+	0xce, 0x62, 0xd0, 0x7f, 0x57, 0xb0, 0xee, 0x12, 0xf1, 0x90, 0xb8, 0xed,
+	    0x4c, 0xb1, 0xf4, 0x80,
+	0x57, 0xa2, 0x81, 0xab, 0xbd, 0xc4, 0x3f, 0xee, 0x91, 0xfe, 0x21, 0xd1,
+	    0x98, 0xbc, 0xaf, 0xb3,
+	0xaf, 0x4b, 0x10, 0xac, 0x9d, 0xdc, 0x80, 0xca, 0x4e, 0x5e, 0x44, 0x19,
+	    0xef, 0x02, 0xf8, 0x24,
+	0x3b, 0xf4, 0x7f, 0x43, 0xd2, 0x60, 0x7f, 0xc8, 0xc6, 0x8b, 0x43, 0x3b,
+	    0xd4, 0xb4, 0x0d, 0x67,
+	0x0f, 0xfe, 0x37, 0xa6, 0x13, 0x03, 0x69, 0x15, 0xe0, 0x4a, 0xa6, 0x60,
+	    0xdc, 0xe7, 0xbf, 0x46,
+	0x8e, 0xdd, 0xc9, 0x01, 0x15, 0x21, 0x15, 0x23, 0xa6, 0x44, 0x35, 0x57,
+	    0x3b, 0xaa, 0x69, 0xbb,
+	0xdf, 0x0e, 0x61, 0xb5, 0xe2, 0x56, 0x99, 0xf7, 0xab, 0x45, 0x9f, 0x75,
+	    0xd5, 0x4f, 0x4a, 0x70,
+	0xfd, 0xfb, 0xa1, 0x26, 0x21, 0x81, 0x0f, 0x1c, 0xab, 0x2d, 0x77, 0x9d,
+	    0x76, 0x67, 0x88, 0xdd,
+	0xc2, 0x0d, 0x78, 0xb2, 0x91, 0x21, 0x56, 0xf4, 0x3a, 0x5d, 0x62, 0x94,
+	    0x5f, 0x29, 0x7f, 0x04,
+	0xe0, 0xf9, 0x39, 0x62, 0x33, 0x3d, 0x0f, 0x31, 0xc2, 0xe9, 0x40, 0x94,
+	    0xe1, 0xd2, 0x4b, 0x4f,
+	0x0f, 0xf3, 0x2f, 0x37, 0xd0, 0xd7, 0x82, 0x72, 0xbc, 0x4b, 0x48, 0x51,
+	    0x51, 0xe0, 0x79, 0x2f,
+	0xa9, 0xb7, 0xdd, 0xec, 0xa4, 0x81, 0x63, 0x09, 0xe9, 0x43, 0x04, 0x5f,
+	    0x2e, 0x19, 0x12, 0x50,
+	0x8b, 0x1e, 0x51, 0x2a, 0x1d, 0xe2, 0x15, 0xc1, 0x4f, 0x82, 0x36, 0xb8,
+	    0x47, 0xc5, 0x63, 0xa3,
+	0xa4, 0x07, 0x32, 0x7d, 0xe7, 0x3b, 0x93, 0xef, 0xe6, 0x08, 0x6c, 0x5e,
+	    0xa2, 0x39, 0x1f, 0x7b,
+	0xa8, 0x43, 0xe4, 0x9f, 0x2b, 0xf9, 0x74, 0xc5, 0x3d, 0xb0, 0xd3, 0x9c,
+	    0x30, 0xc3, 0xe2, 0x59,
+	0x4f, 0x51, 0xc3, 0xaa, 0xbb, 0xa0, 0x92, 0x9d, 0x7b, 0x4f, 0x83, 0x0e,
+	    0x79, 0xd4, 0x8e, 0xb7,
+	0xe2, 0x25, 0x4b, 0x6e, 0x28, 0xc8, 0xec, 0xfc, 0x6c, 0x41, 0x84, 0x9e,
+	    0x5f, 0xe8, 0xef, 0xcc,
+	0x3d, 0x73, 0x89, 0x50, 0xf1, 0x21, 0x97, 0xe8, 0xcc, 0xf6, 0xb3, 0x6f,
+	    0x3a, 0x63, 0xe7, 0xdc,
+	0x60, 0x27, 0x33, 0xdf, 0x1b, 0xb9, 0xe4, 0x09, 0xc3, 0x97, 0xfd, 0x9f,
+	    0xbd, 0xc0, 0x1e, 0x82,
+	0xb2, 0x1a, 0x8c, 0x24, 0x0b, 0xa4, 0x84, 0x48, 0xfc, 0x9d, 0xaa, 0xa3,
+	    0xba, 0xc3, 0x56, 0x94,
+	0x82, 0x5d, 0xc9, 0xe3, 0x1f, 0xee, 0x62, 0x15, 0x16, 0x94, 0xcb, 0xb3,
+	    0xb9, 0xa2, 0xd8, 0x03,
+	0x12, 0x73, 0x3b, 0xb4, 0x11, 0xcd, 0x6b, 0x05, 0xf0, 0x9f, 0xc5, 0xd2,
+	    0xe5, 0xd6, 0x5b, 0xd6,
+	0x48, 0x2a, 0xb3, 0x34, 0xcd, 0xcc, 0xc2, 0x99, 0x5d, 0xfa, 0x3d, 0xb7,
+	    0xf4, 0x1f, 0x60, 0x50,
+	0x83, 0x78, 0xc0, 0xf4, 0xbc, 0x0b, 0xc0, 0x10, 0x66, 0x5b, 0xb4, 0x56,
+	    0x40, 0xff, 0x84, 0xb2,
+	0x5f, 0xea, 0x0c, 0x51, 0xaa, 0x9a, 0x24, 0xb6, 0x0d, 0x17, 0xbe, 0xf0,
+	    0x70, 0xd7, 0x81, 0x3e,
+	0x20, 0xd1, 0xfe, 0x75, 0x32, 0x69, 0x35, 0x4b, 0xf4, 0xd6, 0x55, 0x07,
+	    0x0f, 0x1a, 0x2d, 0x67,
+	0xa8, 0x1a, 0x5e, 0x05, 0xff, 0x3e, 0x52, 0x76, 0xe5, 0x8f, 0xbd, 0x52,
+	    0xb3, 0x35, 0x61, 0xf2,
+	0x49, 0x1c, 0xb8, 0x2c, 0x4e, 0xe7, 0xa7, 0xd8, 0x13, 0xd6, 0xa8, 0xfc,
+	    0xb2, 0x30, 0x2e, 0x12,
+	0x28, 0x90, 0x6d, 0xdc, 0x77, 0xe2, 0x1c, 0xca, 0x56, 0x09, 0x92, 0x38,
+	    0x67, 0xf5, 0x7e, 0xfa,
+	0x99, 0x93, 0x6b, 0xe2, 0x66, 0x67, 0x4c, 0x36, 0xee, 0x32, 0x68, 0xde,
+	    0xf5, 0xdc, 0xcf, 0xc0,
+	0x27, 0x57, 0x3a, 0x60, 0x9a, 0x4e, 0xe6, 0x52, 0x5a, 0x19, 0x97, 0x18,
+	    0x10, 0xd3, 0x14, 0xc8,
+	0xdd, 0x72, 0x40, 0xbf, 0x4e, 0xb3, 0x53, 0x00, 0xbb, 0x13, 0xd1, 0x48,
+	    0xf5, 0x3e, 0x54, 0xda,
+	0xe9, 0x19, 0x94, 0xed, 0x47, 0x7f, 0xa4, 0xdc, 0x1c, 0x81, 0x1e, 0xe5,
+	    0x39, 0x7b, 0xf8, 0x5b,
+	0xaa, 0xc3, 0xdf, 0xc9, 0x3d, 0x36, 0x56, 0x0f, 0xd9, 0x18, 0xd0, 0x20,
+	    0xf9, 0x4e, 0x07, 0x4d,
+	0xad, 0x44, 0x49, 0x92, 0x52, 0xee, 0x80, 0xc3, 0xd4, 0xcf, 0xad, 0x55,
+	    0x98, 0x5f, 0x8c, 0x71,
+	0x3d, 0x76, 0x98, 0x76, 0x34, 0xab, 0xab, 0x5c, 0xc5, 0xcd, 0x9a, 0xf6,
+	    0x08, 0xdf, 0x16, 0x7a,
+	0x64, 0x85, 0x00, 0xb6, 0x26, 0x25, 0x37, 0x50, 0xbe, 0x1c, 0x47, 0x48,
+	    0x9f, 0x85, 0x9a, 0x73,
+	0x04, 0x9d, 0x6f, 0xa7, 0xb6, 0x28, 0x8e, 0x61, 0x65, 0x80, 0x1d, 0x58,
+	    0x1e, 0xa6, 0x48, 0xd3,
+	0xc3, 0xef, 0x11, 0xec, 0xe6, 0xa3, 0x6b, 0x35, 0x36, 0x6e, 0x79, 0xba,
+	    0xda, 0x1c, 0x5e, 0x06,
+	0x08, 0x2b, 0xd8, 0xae, 0xae, 0xeb, 0x68, 0x73, 0x39, 0xa4, 0x26, 0xe4,
+	    0xf8, 0xba, 0xcc, 0x6d,
+	0x83, 0xc4, 0xb0, 0x46, 0xea, 0x2d, 0xf2, 0x01, 0xa6, 0xc3, 0xa1, 0x76,
+	    0x54, 0x46, 0xe9, 0x60,
+	0x16, 0x53, 0x59, 0xb8, 0xd5, 0xa9, 0xb1, 0x07, 0x4b, 0x84, 0x31, 0x7f,
+	    0x34, 0xa4, 0x30, 0xd5,
+	0x62, 0x78, 0xf1, 0xb1, 0x15, 0x60, 0x08, 0xef, 0x64, 0x8b, 0x99, 0xd0,
+	    0x40, 0xa5, 0x18, 0x95,
+	0xf3, 0x05, 0xc2, 0xa4, 0x4e, 0xea, 0xae, 0xc5, 0x7b, 0xc8, 0x1e, 0x5d,
+	    0xd8, 0x1e, 0xb4, 0x85,
+	0xf8, 0x00, 0xd0, 0xd9, 0xe0, 0x0f, 0x02, 0xc4, 0x4b, 0x02, 0x59, 0xcd,
+	    0xd1, 0x85, 0xc0, 0xf5,
+	0x03, 0x27, 0x28, 0x87, 0x9a, 0xc8, 0x5b, 0x49, 0x33, 0xc4, 0xcd, 0x29,
+	    0x35, 0x8e, 0x0b, 0xf1,
+	0x64, 0x42, 0xff, 0x61, 0x57, 0xa8, 0x54, 0xbf, 0x94, 0x7f, 0x85, 0x39,
+	    0x17, 0x38, 0x3a, 0x4e,
+	0x87, 0xb2, 0xdc, 0xbe, 0x1c, 0xa3, 0x24, 0x2c, 0x60, 0x80, 0xf5, 0x2f,
+	    0x58, 0xf4, 0xea, 0xce,
+	0x2b, 0x70, 0x5e, 0xbc, 0xfe, 0x52, 0x85, 0x72, 0xe3, 0x8f, 0x9a, 0xcc,
+	    0x4b, 0xe0, 0x8f, 0xd9,
+	0xc2, 0x86, 0x57, 0xad, 0x32, 0xa1, 0x23, 0x83, 0x52, 0x03, 0x8b, 0x34,
+	    0x23, 0x52, 0x19, 0x5a,
+	0xef, 0x89, 0x54, 0xa7, 0x9f, 0xd4, 0x74, 0x59, 0x4d, 0xd8, 0x04, 0xfb,
+	    0xa4, 0xe6, 0xf0, 0xa6,
+	0x04, 0x33, 0xba, 0xa8, 0x55, 0x0b, 0x72, 0xb1, 0xb0, 0xd3, 0xfe, 0xbb,
+	    0xcf, 0x5d, 0xec, 0xcb,
+	0xe8, 0xd3, 0x76, 0x4d, 0x06, 0xf7, 0x4d, 0x2b, 0xc4, 0x77, 0x82, 0xf7,
+	    0x1f, 0x95, 0xa1, 0x23,
+	0x8a, 0x60, 0xb4, 0x7f, 0x50, 0xf0, 0x92, 0x02, 0x69, 0xd4, 0x3d, 0x96,
+	    0x70, 0x0e, 0xf7, 0x48,
+	0xa3, 0x2b, 0x77, 0x83, 0xb3, 0x6b, 0x69, 0x31, 0x57, 0x41, 0x12, 0xf0,
+	    0x3f, 0x7b, 0x2b, 0x82,
+	0x2c, 0x8f, 0x9c, 0xdb, 0xc8, 0x34, 0x4e, 0x19, 0x60, 0x0f, 0x8c, 0x64,
+	    0xd8, 0x54, 0xee, 0xb2,
+	0x3f, 0x68, 0xd6, 0x3e, 0x9b, 0xfa, 0x74, 0xb4, 0x19, 0x58, 0x7e, 0x74,
+	    0xd9, 0x75, 0x85, 0xb5,
+	0x59, 0x1f, 0x0b, 0xe7, 0xb7, 0x36, 0x09, 0xa5, 0xef, 0x9a, 0xcd, 0xf7,
+	    0x55, 0xfd, 0x77, 0xc6,
+	0x86, 0x17, 0xab, 0xb3, 0x5e, 0xfe, 0x24, 0xd9, 0x40, 0x95, 0xc5, 0xe7,
+	    0x54, 0xf1, 0x1e, 0x75,
+	0xd9, 0x1b, 0xa3, 0xaa, 0xbe, 0xaf, 0x0e, 0x39, 0x4e, 0xd2, 0x19, 0x3d,
+	    0x71, 0xba, 0x71, 0xe6,
+	0x91, 0xf0, 0x1a, 0xed, 0x17, 0xb6, 0x8a, 0xc9, 0x47, 0xd6, 0xc0, 0xb8,
+	    0x88, 0x5a, 0x87, 0x75,
+	0xdf, 0x4f, 0xe4, 0xfc, 0x9e, 0xb5, 0xb1, 0xd8, 0xce, 0xd5, 0x72, 0x6a,
+	    0x94, 0xbe, 0xf6, 0x9b,
+	0xab, 0x50, 0x3f, 0x85, 0xc7, 0x0f, 0x5f, 0x11, 0xbb, 0xd6, 0x1b, 0x4c,
+	    0x71, 0x56, 0xd9, 0x78,
+	0x6e, 0x8e, 0xc0, 0xab, 0x9d, 0x39, 0x29, 0x08, 0xec, 0xd8, 0x84, 0x46,
+	    0xdf, 0x7b, 0xc1, 0xb5,
+	0xf2, 0x41, 0xb4, 0xf5, 0x55, 0xb2, 0xf6, 0xda, 0x6a, 0x9d, 0xa4, 0xbe,
+	    0xd8, 0xbc, 0xbe, 0xf0,
+	0x91, 0x40, 0xf5, 0xe7, 0x55, 0xfa, 0xfc, 0x89, 0xe0, 0x98, 0xf3, 0xfe,
+	    0xcd, 0x86, 0xd6, 0x85,
+	0xdc, 0x4a, 0x58, 0xd9, 0x54, 0x24, 0x43, 0xfd, 0x6d, 0xdb, 0xff, 0xff,
+	    0xff, 0xff, 0x3a, 0xef,
+	0xeb, 0x31, 0x34, 0x77, 0x7e, 0x2f, 0xd0, 0xad, 0x51, 0x30, 0x23, 0x95,
+	    0x56, 0xdb, 0x51, 0x0e,
+	0xe4, 0xfe, 0x8e, 0x7f, 0x70, 0x8b, 0x69, 0x1c, 0xe0, 0x2d, 0xb3, 0x4a,
+	    0x80, 0xcc, 0x7f, 0x2d,
+	0x3b, 0x5d, 0xbc, 0x75, 0x24, 0x2b, 0x90, 0x20, 0xd0, 0x44, 0x4b, 0x7e,
+	    0x2d, 0xde, 0xb0, 0x56,
+	0x5f, 0x09, 0xd1, 0x81, 0x97, 0xeb, 0x7f, 0x18, 0x62, 0x45, 0xcb, 0x67,
+	    0x62, 0xe9, 0xd7, 0xd1,
+	0x7e, 0x0f, 0xc8, 0x40, 0xb4, 0xb7, 0x68, 0xe5, 0xc4, 0x86, 0xa8, 0xd4,
+	    0x9e, 0xcb, 0xdf, 0x61,
+	0xa2, 0xba, 0xcc, 0xf3, 0x12, 0x05, 0xe8, 0xc8, 0xa2, 0x26, 0xda, 0x46,
+	    0x33, 0x69, 0xc1, 0xd0,
+	0xf6, 0xab, 0x71, 0xfd, 0xb0, 0xe4, 0xe1, 0xf5, 0x44, 0xd5, 0x75, 0x1e,
+	    0xb9, 0x69, 0x77, 0x6d,
+	0xad, 0x98, 0x4e, 0x49, 0x13, 0xe0, 0x22, 0x41, 0xfb, 0x05, 0xa6, 0x06,
+	    0x70, 0xe4, 0xd8, 0xe0,
+	0xba, 0x45, 0x98, 0x6e, 0xe7, 0x33, 0x63, 0x1c, 0xe9, 0x24, 0x15, 0x66,
+	    0x69, 0x97, 0x8a, 0x46,
+	0x84, 0x6b, 0x8a, 0xf1, 0x09, 0x72, 0x22, 0x7f, 0xd3, 0x46, 0xe2, 0x74,
+	    0xae, 0x05, 0xf8, 0x01,
+	0x2d, 0x11, 0x22, 0x6b, 0x63, 0xb1, 0x75, 0x05, 0x6b, 0x2f, 0xad, 0x88,
+	    0x19, 0xe0, 0xa0, 0x9c,
+	0x1a, 0x34, 0x8b, 0x99, 0xdc, 0xd1, 0x42, 0x27, 0x74, 0x84, 0x24, 0xa6,
+	    0x2c, 0xfd, 0x7c, 0xe9,
+	0x72, 0xa3, 0x52, 0x3e, 0xf1, 0xfd, 0xc8, 0xcc, 0x44, 0x4a, 0x74, 0x96,
+	    0xff, 0xc7, 0x34, 0x5f,
+	0xaa, 0x48, 0x35, 0x2e, 0x35, 0xf2, 0xf8, 0x0e, 0xbc, 0x23, 0x6b, 0x9e,
+	    0xa7, 0x29, 0xe3, 0x3a,
+	0xa8, 0x9d, 0xfd, 0x71, 0xfa, 0x6e, 0x36, 0xa9, 0x69, 0x55, 0xab, 0x69,
+	    0x3a, 0x11, 0xf5, 0xdc,
+	0x7c, 0x6a, 0x92, 0xcc, 0x3e, 0x10, 0x39, 0x78, 0xca, 0xce, 0x68, 0x7a,
+	    0xdf, 0xa4, 0xe3, 0x40,
+	0x60, 0xb0, 0x14, 0x9a, 0x4c, 0xc4, 0xd3, 0x5f, 0x17, 0x50, 0xb4, 0x35,
+	    0x76, 0xb8, 0x7d, 0xa4,
+	0x80, 0xe0, 0x5c, 0x10, 0x74, 0xd4, 0x24, 0x4a, 0xcd, 0x5c, 0x67, 0x93,
+	    0xd0, 0xd0, 0x10, 0x83,
+	0xa2, 0x14, 0xd5, 0x9f, 0x9a, 0x86, 0x32, 0xa7, 0x30, 0x36, 0x23, 0x82,
+	    0x5c, 0x7f, 0xf2, 0xff,
+	0x2c, 0xe5, 0xb5, 0x66, 0xdb, 0x56, 0x62, 0x8c, 0x5e, 0x8e, 0xcd, 0x4a,
+	    0x18, 0x82, 0xfe, 0x3f,
+	0x2c, 0xab, 0x57, 0xcf, 0x91, 0xb1, 0x2a, 0xe7, 0x9f, 0x5b, 0xcf, 0x97,
+	    0x4a, 0xd5, 0x2b, 0x20,
+	0xa3, 0x57, 0x9a, 0x36, 0xc4, 0xc8, 0xe4, 0x0b, 0x96, 0x39, 0x60, 0x14,
+	    0x77, 0x47, 0xe9, 0x29,
+	0x6b, 0x5b, 0xd3, 0xa0, 0x4d, 0xab, 0x8a, 0xe0, 0xd1, 0xf4, 0xed, 0xd5,
+	    0xa9, 0x49, 0x42, 0xa5,
+	0xa0, 0x46, 0xdb, 0xb7, 0x4c, 0xea, 0x3a, 0x31, 0xea, 0x4c, 0x61, 0x95,
+	    0xe4, 0xfc, 0x4e, 0x98,
+	0x60, 0x49, 0xbe, 0x7f, 0x5e, 0x7a, 0x45, 0x46, 0xe7, 0xf5, 0x45, 0xeb,
+	    0x76, 0xa7, 0x7f, 0xa9,
+	0x88, 0x9b, 0xb6, 0x6f, 0x57, 0x5c, 0xff, 0xf8, 0x29, 0x65, 0x14, 0x8b,
+	    0x8c, 0x76, 0x27, 0x88,
+	0xb0, 0x1c, 0x0d, 0xba, 0x14, 0x5f, 0xc1, 0x26, 0x01, 0x99, 0x28, 0x28,
+	    0x07, 0x38, 0x77, 0x9b,
+	0xc1, 0x66, 0xb7, 0x6e, 0x8b, 0x96, 0x15, 0xb8, 0x70, 0xf6, 0x2b, 0xc2,
+	    0x5a, 0x3a, 0xf9, 0x4d,
+	0x24, 0x96, 0x12, 0x32, 0xc7, 0xbd, 0xf4, 0x9e, 0xd1, 0xe3, 0x29, 0x1f,
+	    0x0a, 0xd3, 0xf6, 0x47,
+	0x2d, 0xa5, 0x68, 0x26, 0xb6, 0x40, 0x22, 0x03, 0x08, 0x6c, 0xa0, 0xd0,
+	    0x92, 0x2c, 0x90, 0x36,
+	0x27, 0x0c, 0xef, 0x36, 0x4f, 0xbd, 0xec, 0xae, 0xec, 0xf7, 0xc0, 0x1e,
+	    0xc6, 0xf3, 0x56, 0x19,
+	0xb5, 0x04, 0xa9, 0xb8, 0x04, 0xb2, 0xcc, 0x7d, 0x8e, 0x1c, 0xc9, 0x9f,
+	    0x9b, 0xeb, 0xdf, 0x86,
+	0x56, 0xc2, 0x1f, 0xe4, 0x94, 0x22, 0xa0, 0x3c, 0x22, 0x34, 0xf8, 0x06,
+	    0xbd, 0x63, 0x84, 0x8d,
+	0xf4, 0x57, 0x57, 0xfe, 0x87, 0xec, 0x6d, 0x3c, 0x73, 0xb5, 0x86, 0x9e,
+	    0x3d, 0xec, 0x5a, 0x0b,
+	0x21, 0x3d, 0x61, 0x53, 0xf5, 0xaf, 0xe7, 0x39, 0xf6, 0x76, 0xbf, 0x82,
+	    0xf5, 0xb0, 0x21, 0x1b,
+	0x7c, 0x05, 0xd6, 0xef, 0x95, 0xd8, 0xec, 0x20, 0xfb, 0x87, 0x46, 0x44,
+	    0xbb, 0x80, 0x58, 0xc7,
+	0xf9, 0x29, 0x1d, 0xbd, 0x65, 0xa4, 0x48, 0x32, 0x47, 0xcb, 0x9f, 0x8b,
+	    0x1e, 0x69, 0x56, 0xa7,
+	0x75, 0x2a, 0xfe, 0x33, 0xe8, 0x38, 0x72, 0x70, 0xe4, 0x58, 0x1f, 0xf2,
+	    0x20, 0xca, 0x38, 0x7a,
+	0x6d, 0xc2, 0x21, 0xc2, 0x33, 0x5b, 0x21, 0xdb, 0x86, 0xcb, 0x8e, 0x9a,
+	    0x7b, 0x3d, 0xcd, 0x2d,
+	0x5b, 0x88, 0x3a, 0xa9, 0x6a, 0x06, 0x06, 0x34, 0xa4, 0xe7, 0x24, 0x66,
+	    0xac, 0x18, 0xa2, 0x70,
+	0xce, 0x88, 0xa6, 0xe2, 0x1c, 0xea, 0x14, 0x86, 0xc0, 0xc5, 0x49, 0x5d,
+	    0x7e, 0x19, 0x23, 0x98,
+	0xbf, 0xd8, 0x8c, 0xb3, 0x99, 0x0d, 0x47, 0xd2, 0xd9, 0x84, 0x41, 0xc6,
+	    0x5d, 0x52, 0x6b, 0x22,
+	0x8a, 0xf8, 0x29, 0xd2, 0x61, 0xa5, 0x25, 0x49, 0xa4, 0xc7, 0x4c, 0x5c,
+	    0xa0, 0x39, 0x13, 0xe4,
+	0x38, 0xe7, 0x7a, 0x18, 0x24, 0xa4, 0xff, 0xbe, 0xc3, 0x41, 0x3f, 0xbb,
+	    0xd3, 0x64, 0xa2, 0xda,
+	0x71, 0x21, 0xda, 0xb1, 0xeb, 0xcf, 0xb2, 0x1b, 0xe5, 0xa0, 0x2d, 0x88,
+	    0x29, 0x1a, 0xc0, 0xde,
+	0x5a, 0xbc, 0x94, 0x58, 0xea, 0x2e, 0xc0, 0x4a, 0x4c, 0x62, 0x84, 0x57,
+	    0xb6, 0xdc, 0xf4, 0x1a,
+	0xfa, 0x85, 0x18, 0x30, 0xfe, 0xa2, 0xb7, 0x94, 0xfd, 0xda, 0x33, 0x93,
+	    0x75, 0x63, 0x63, 0xe3,
+	0xbc, 0xe9, 0x4d, 0xac, 0x13, 0x02, 0xdb, 0x09, 0xad, 0xf9, 0x57, 0xec,
+	    0xc0, 0xe5, 0xbd, 0xe2,
+	0x04, 0xcd, 0x74, 0xb6, 0x74, 0x1f, 0xe2, 0x9f, 0x9b, 0x7d, 0xea, 0x06,
+	    0xaa, 0x5b, 0xec, 0x1e,
+	0xa7, 0xd3, 0x6c, 0xc2, 0x8f, 0x0e, 0x03, 0x2d, 0x94, 0x07, 0x82, 0x4b,
+	    0x3c, 0x2a, 0xe5, 0x0f,
+	0x81, 0xef, 0x05, 0xf5, 0xde, 0x91, 0xe7, 0x1f, 0x13, 0xbc, 0xe1, 0x75,
+	    0x71, 0xd1, 0xef, 0xe7,
+	0xa3, 0x01, 0x86, 0xe9, 0x64, 0x46, 0x35, 0xa3, 0x7c, 0x5b, 0xe5, 0xbf,
+	    0xf3, 0xca, 0x00, 0xb4,
+	0xab, 0x12, 0x86, 0xc6, 0x81, 0x41, 0x13, 0xc4, 0x8b, 0xb6, 0x89, 0x81,
+	    0x55, 0xb4, 0x4c, 0x52,
+	0x21, 0x2d, 0x36, 0x0d, 0x7f, 0x64, 0x26, 0x32, 0x1b, 0xd1, 0xa6, 0x36,
+	    0x1f, 0xa4, 0xe1, 0x03,
+	0xaa, 0x56, 0x45, 0xf9, 0x3a, 0xf4, 0x0a, 0xc3, 0x94, 0x76, 0xb0, 0x80,
+	    0xd7, 0xd7, 0x83, 0x94,
+	0x4e, 0x4c, 0xd3, 0xeb, 0x3a, 0x31, 0xff, 0x1b, 0x77, 0x1a, 0x84, 0x91,
+	    0x96, 0xd7, 0xe6, 0x74,
+	0x3c, 0xd5, 0xf7, 0xb0, 0x52, 0xfa, 0xb6, 0xe1, 0xd5, 0x52, 0xac, 0x2a,
+	    0x0b, 0xb8, 0x3c, 0x42,
+	0x9e, 0x44, 0x09, 0x2e, 0xc5, 0xaa, 0x6b, 0xbc, 0xa5, 0xca, 0x06, 0x4d,
+	    0x09, 0xe9, 0xd8, 0xe4,
+	0xc4, 0x97, 0xf8, 0x7b, 0x68, 0xd9, 0xb3, 0xcb, 0xb4, 0x7e, 0xbb, 0x43,
+	    0xcf, 0xc6, 0xd7, 0x93,
+	0x50, 0xd4, 0x9c, 0x2a, 0x41, 0x78, 0x9b, 0xc8, 0x8b, 0xd4, 0x07, 0x4c,
+	    0x81, 0x56, 0x04, 0xcb,
+	0x2d, 0xfc, 0x64, 0x8e, 0x96, 0xa7, 0xe1, 0xda, 0x6d, 0x73, 0xee, 0x7b,
+	    0x86, 0xad, 0xe5, 0xdb,
+	0x2b, 0xa4, 0x96, 0xd6, 0xdf, 0x3c, 0x00, 0xfd, 0x96, 0xd2, 0xad, 0xb9,
+	    0x82, 0x5b, 0xa7, 0x92,
+	0x45, 0xdc, 0xa1, 0xa9, 0x45, 0x15, 0xd7, 0x99, 0x8c, 0xe8, 0x40, 0xc6,
+	    0xf8, 0x37, 0x6c, 0x59,
+	0x41, 0xae, 0xc7, 0x2c, 0x3b, 0x12, 0x42, 0x3c, 0x2d, 0xff, 0xe8, 0x81,
+	    0x35, 0x6e, 0x48, 0x15,
+	0xd4, 0x91, 0x40, 0xdc, 0xb8, 0xa1, 0x6e, 0x26, 0xa1, 0xc3, 0x54, 0xf4,
+	    0x2e, 0x1f, 0x9d, 0x01,
+	0x35, 0xac, 0xda, 0x9e, 0x17, 0x9b, 0x41, 0x23, 0xa4, 0xb7, 0x7d, 0xc4,
+	    0xd1, 0x7e, 0xa6, 0x38,
+	0x48, 0x53, 0xd9, 0xf6, 0x14, 0xaf, 0x67, 0xd2, 0x4c, 0x03, 0x48, 0x25,
+	    0x5f, 0x9f, 0x98, 0x56,
+	0x43, 0xa3, 0xdf, 0xf8, 0x99, 0x78, 0xe2, 0xd9, 0xf1, 0x0e, 0x02, 0xbf,
+	    0xd2, 0x83, 0x66, 0xe0,
+	0x28, 0xab, 0xc3, 0xae, 0x13, 0xb4, 0x00, 0x1a, 0x28, 0xb5, 0xaf, 0x95,
+	    0xf1, 0x24, 0x68, 0x55,
+	0xcb, 0x06, 0xb7, 0xb9, 0x17, 0xa8, 0x66, 0x4c, 0x45, 0xed, 0x17, 0x9a,
+	    0xff, 0x68, 0x11, 0x52,
+	0xa8, 0x45, 0xff, 0x20, 0x9c, 0xa4, 0x2f, 0x5c, 0x42, 0x16, 0xef, 0xc1,
+	    0xd4, 0x45, 0x99, 0xb9,
+	0xcd, 0xaa, 0x36, 0xd1, 0xf5, 0xd3, 0x26, 0x0f, 0x60, 0x22, 0x24, 0x32,
+	    0x2a, 0x11, 0x0a, 0x42,
+	0xe1, 0x79, 0xf4, 0xe5, 0xa9, 0x6a, 0x6d, 0x6f, 0xbd, 0xfe, 0x2f, 0x15,
+	    0xed, 0xfb, 0xf2, 0x29,
+	0x31, 0x4b, 0xec, 0xe7, 0x96, 0xd4, 0x38, 0xda, 0xa0, 0x2a, 0xf9, 0x5a,
+	    0xe6, 0x72, 0x79, 0x69,
+	0xce, 0x81, 0xc8, 0x36, 0x9e, 0xa8, 0x83, 0xd8, 0x6b, 0xba, 0xc3, 0x5a,
+	    0xde, 0x71, 0x5f, 0xf5,
+	0x60, 0x7a, 0xec, 0x63, 0x53, 0x24, 0x45, 0xdb, 0x95, 0xcf, 0x6d, 0x5b,
+	    0xe5, 0x24, 0x12, 0xae,
+	0x88, 0x0f, 0x02, 0x55, 0x43, 0x87, 0xed, 0x8a, 0x56, 0x3b, 0xad, 0x16,
+	    0xcc, 0xf3, 0x74, 0xfc,
+	0xac, 0x0b, 0xf8, 0x6c, 0xfb, 0x82, 0xe7, 0xfc, 0x02, 0xf2, 0x65, 0x27,
+	    0x8a, 0xb0, 0x46, 0xab,
+	0xb9, 0x1c, 0xbb, 0x59, 0x73, 0x47, 0x13, 0x26, 0xf5, 0xbe, 0x13, 0x00,
+	    0xd6, 0xd2, 0x1b, 0x44,
+	0x28, 0x14, 0x6b, 0x2e, 0x38, 0xac, 0xe0, 0x9b, 0x67, 0xb2, 0xf0, 0x80,
+	    0xdb, 0xb4, 0x7a, 0x86,
+	0xc1, 0x93, 0xdd, 0x37, 0x95, 0x39, 0x17, 0xb4, 0x03, 0x58, 0xae, 0x4c,
+	    0x96, 0x3f, 0x56, 0x45,
+	0x49, 0x12, 0xab, 0xe2, 0x12, 0x6a, 0x22, 0x74, 0x09, 0x5c, 0xcc, 0x45,
+	    0x5b, 0x51, 0x36, 0x72,
+	0x2c, 0x53, 0x05, 0xa6, 0x75, 0x29, 0x03, 0x65, 0x0b, 0x18, 0x94, 0x43,
+	    0xd4, 0x86, 0x73, 0x97,
+	0x40, 0x90, 0xd4, 0xb3, 0x14, 0x0c, 0x0f, 0x31, 0x0a, 0x17, 0xc7, 0xf9,
+	    0x99, 0x50, 0x94, 0x22,
+	0x24, 0x0f, 0x04, 0xd8, 0x4b, 0x5a, 0x6e, 0x0e, 0xd9, 0x4b, 0xe6, 0x1b,
+	    0x86, 0x7b, 0x04, 0xd4,
+	0xa6, 0x96, 0xcb, 0xa7, 0x1e, 0x57, 0x1a, 0xe3, 0xbf, 0x16, 0x3f, 0x34,
+	    0x27, 0xc0, 0x61, 0x45,
+	0xd9, 0xd1, 0x05, 0xdd, 0x01, 0x3e, 0x3d, 0x83, 0x1d, 0x14, 0x79, 0x9e,
+	    0x2c, 0xeb, 0xdd, 0xcf,
+	0x97, 0xe3, 0x32, 0xa6, 0x9e, 0xb5, 0xfe, 0x50, 0x3b, 0x54, 0x0d, 0xca,
+	    0xd9, 0x35, 0xf4, 0x7b,
+	0xa4, 0x59, 0x91, 0xfe, 0x4a, 0x3b, 0x2c, 0x18, 0xfa, 0x1a, 0x56, 0x74,
+	    0x5b, 0x75, 0x1c, 0xce,
+	0xc2, 0x5d, 0x36, 0x73, 0x0a, 0xfe, 0x60, 0xbe, 0x88, 0xda, 0x79, 0xfc,
+	    0x35, 0xd9, 0x39, 0x48,
+	0xc0, 0x17, 0x39, 0xa5, 0x8b, 0xac, 0x5c, 0x8a, 0x88, 0x59, 0x68, 0xde,
+	    0xda, 0x16, 0x35, 0x29,
+	0x43, 0xb4, 0x37, 0xb0, 0x1e, 0x76, 0x7e, 0x3d, 0xb2, 0xf8, 0xcb, 0xce,
+	    0xd3, 0xfc, 0xd3, 0xd2,
+	0x5a, 0xa8, 0xb9, 0x21, 0xcd, 0x7e, 0x75, 0xd5, 0x4e, 0x1e, 0xc8, 0x11,
+	    0x86, 0x5f, 0x30, 0x7c,
+	0xc0, 0x3e, 0x9a, 0xc7, 0x1d, 0xc0, 0x51, 0x09, 0xc8, 0xdd, 0x4e, 0xbb,
+	    0x5f, 0x3f, 0x50, 0xc6,
+	0xde, 0x93, 0x15, 0xd2, 0x9e, 0xca, 0x4c, 0x01, 0xec, 0xee, 0x17, 0x8c,
+	    0xfa, 0x10, 0x31, 0x79,
+	0x40, 0xee, 0x0f, 0x7c, 0x86, 0xe0, 0x61, 0x9c, 0x0b, 0xde, 0x5c, 0x66,
+	    0xfd, 0x8f, 0x58, 0x32,
+	0xa9, 0xc2, 0xa8, 0x0f, 0x12, 0x3a, 0xa0, 0xd1, 0xc8, 0xcd, 0x08, 0xe1,
+	    0x96, 0x32, 0x50, 0x03,
+	0x3d, 0x85, 0x68, 0x86, 0xcc, 0x01, 0x06, 0xf6, 0x2d, 0xcc, 0x28, 0x71,
+	    0xa8, 0x57, 0x75, 0xef,
+	0x25, 0x02, 0x96, 0x79, 0x48, 0xad, 0xca, 0x04, 0x65, 0x3d, 0xb9, 0x07,
+	    0x51, 0xca, 0x0e, 0x37,
+	0x07, 0x44, 0xe5, 0x64, 0x9e, 0xcf, 0xa9, 0xc2, 0x66, 0x83, 0x46, 0x49,
+	    0x07, 0x3c, 0xe5, 0x24,
+	0xf1, 0x94, 0x51, 0xc2, 0x42, 0x25, 0x08, 0xad, 0xad, 0x60, 0xf6, 0xe4,
+	    0xd6, 0x83, 0x50, 0xd6,
+	0x55, 0xec, 0x13, 0xa7, 0xb4, 0x65, 0xdc, 0x01, 0x73, 0xca, 0xa6, 0x94,
+	    0xd7, 0x60, 0xd9, 0xbc,
+	0x80, 0x7e, 0x76, 0xb8, 0x67, 0x75, 0x66, 0x65, 0x0e, 0x57, 0xc9, 0x07,
+	    0xc6, 0xeb, 0x30, 0x5e,
+	0x22, 0x78, 0xd7, 0x32, 0x77, 0x26, 0xcd, 0x00, 0xfb, 0xc8, 0x06, 0x49,
+	    0x74, 0xe4, 0xe7, 0x68,
+	0x6c, 0xf8, 0xc0, 0x13, 0x1d, 0xbc, 0x0c, 0xeb, 0xac, 0x67, 0xeb, 0x08,
+	    0xf9, 0x84, 0xd8, 0xe9,
+	0x81, 0xc8, 0xd1, 0x39, 0xbc, 0x16, 0xaa, 0x48, 0xa6, 0xe3, 0xdd, 0xce,
+	    0xdd, 0xf6, 0x5d, 0x0d,
+	0x6d, 0x09, 0x33, 0xfc, 0x10, 0xa7, 0x93, 0x38, 0x6f, 0xae, 0x77, 0xd4,
+	    0x51, 0x17, 0x71, 0xef,
+	0xe5, 0x08, 0x6b, 0x72, 0x91, 0xea, 0x1d, 0xfa, 0xca, 0xc8, 0x20, 0xb5,
+	    0xde, 0x2b, 0x63, 0x2c,
+	0x8c, 0x88, 0x50, 0xbd, 0x9a, 0x01, 0xc5, 0xce, 0xba, 0xef, 0xfc, 0xea,
+	    0x29, 0x2c, 0xd5, 0xb8,
+	0xa3, 0x20, 0x69, 0x8a, 0x90, 0xef, 0xc5, 0x38, 0xee, 0x38, 0x88, 0x1c,
+	    0x7e, 0xfd, 0x33, 0x14,
+	0x2d, 0xeb, 0x9b, 0xff, 0x2a, 0xec, 0x44, 0xcb, 0x3e, 0x3f, 0x2c, 0x6f,
+	    0x5c, 0xea, 0x3b, 0xb9,
+	0x23, 0x22, 0xe8, 0xb4, 0x9e, 0x6d, 0xe8, 0x34, 0x32, 0xb3, 0xc3, 0x8e,
+	    0x7c, 0xeb, 0x80, 0xa6,
+	0x47, 0x24, 0x48, 0x14, 0x7c, 0xb8, 0xf4, 0x7a, 0x27, 0xdd, 0x36, 0xc8,
+	    0x17, 0x44, 0x7e, 0x24,
+	0xce, 0xf5, 0x94, 0x04, 0x37, 0xb9, 0xdb, 0xc8, 0xb3, 0xdb, 0xa2, 0xd4,
+	    0xf7, 0x36, 0xb2, 0x70,
+	0x20, 0x1f, 0xb9, 0x05, 0x06, 0x60, 0x4e, 0x84, 0x45, 0xbe, 0xa3, 0x06,
+	    0xf2, 0x68, 0xbd, 0x63,
+	0xb0, 0x62, 0xe0, 0xd1, 0xbc, 0xa8, 0x3c, 0x37, 0xb6, 0x59, 0x3c, 0x55,
+	    0x09, 0xd0, 0x99, 0xad,
+	0xab, 0x32, 0x50, 0xa4, 0xc9, 0x1f, 0xc5, 0x11, 0xe2, 0x79, 0x20, 0xa0,
+	    0x46, 0xb8, 0xe6, 0x5e,
+	0x86, 0x4a, 0xb8, 0xaa, 0xc4, 0xd0, 0xff, 0xc2, 0x1b, 0x2a, 0x84, 0xd1,
+	    0xd4, 0xb9, 0xf6, 0x03,
+	0x8e, 0xd4, 0x9d, 0xc3, 0x4f, 0xf4, 0x0d, 0x53, 0x52, 0x94, 0x64, 0x65,
+	    0x58, 0xb9, 0xd9, 0xb1,
+	0x58, 0x1a, 0xd5, 0x2c, 0x3a, 0x4a, 0x46, 0x4f, 0x10, 0x95, 0x6f, 0x75,
+	    0x59, 0x75, 0x58, 0x8c,
+	0xcd, 0x1b, 0x94, 0xe8, 0x0f, 0xed, 0x8d, 0x48, 0xc0, 0x25, 0x76, 0xd2,
+	    0xaa, 0xfb, 0x10, 0x3f,
+	0x45, 0x94, 0x95, 0x7c, 0x91, 0x04, 0x06, 0x8a, 0x6e, 0x76, 0x06, 0x8f,
+	    0x5f, 0x56, 0xd5, 0x78,
+	0x20, 0xdb, 0x5f, 0x0b, 0xf0, 0xd4, 0x4f, 0xd8, 0xeb, 0x7b, 0xf3, 0x3f,
+	    0xcf, 0xcb, 0x39, 0xf9,
+	0xcd, 0x8f, 0xd7, 0xbb, 0x04, 0xd9, 0x9f, 0xc9, 0x8f, 0xcd, 0x6f, 0x1f,
+	    0xbd, 0x4b, 0x1d, 0x31,
+	0xc7, 0xdf, 0x81, 0x31, 0xcb, 0x2a, 0xf5, 0x36, 0x68, 0x0c, 0x8e, 0xc9,
+	    0xdd, 0xfa, 0x3a, 0x66,
+	0xc4, 0xbe, 0xd0, 0x7f, 0x39, 0x9e, 0x03, 0xba, 0x25, 0x9f, 0x86, 0xb8,
+	    0x21, 0xfb, 0xf0, 0x38,
+	0x88, 0x33, 0x1c, 0x3e, 0x1d, 0xfe, 0xbd, 0x2c, 0xe8, 0x4e, 0x03, 0xf6,
+	    0x5d, 0x9b, 0x50, 0x6a,
+	0x8d, 0x30, 0x20, 0x25, 0x13, 0xb2, 0xfc, 0x82, 0x60, 0x9d, 0x8d, 0x57,
+	    0x5c, 0xbe, 0x3a, 0xe8,
+	0x5e, 0x4f, 0x27, 0xa1, 0x16, 0x22, 0x80, 0xc8, 0x9c, 0x8d, 0x34, 0x52,
+	    0xd2, 0xa7, 0xfe, 0x59,
+	0xa0, 0x6d, 0x3f, 0xf4, 0xe5, 0xd8, 0x43, 0x30, 0x3a, 0x81, 0x27, 0x73,
+	    0x93, 0x81, 0x51, 0x80,
+	0xd0, 0x04, 0x81, 0x81, 0xc2, 0x70, 0xea, 0x29, 0x25, 0xbd, 0x18, 0xc7,
+	    0xaf, 0x42, 0x6b, 0x80,
+	0x80, 0x63, 0x49, 0xec, 0xf6, 0xbf, 0xd9, 0xb4, 0x22, 0x97, 0xd1, 0x84,
+	    0x09, 0x27, 0x4c, 0xd8,
+	0x0b, 0xa5, 0xbe, 0xe4, 0xfb, 0x27, 0xe8, 0xd2, 0x02, 0xa4, 0x6d, 0x2e,
+	    0xb6, 0xe3, 0xd8, 0x16,
+	0x41, 0x44, 0x20, 0xd6, 0x93, 0x4d, 0x01, 0x5a, 0xe4, 0xf0, 0x0e, 0x42,
+	    0xa3, 0x75, 0x4d, 0xf9,
+	0x05, 0x84, 0x6d, 0xd7, 0xd0, 0x2c, 0x91, 0x09, 0xdd, 0xcb, 0xd0, 0x53,
+	    0x38, 0x73, 0x73, 0xae,
+	0x85, 0xfc, 0xf1, 0xb5, 0xdb, 0x8a, 0x4a, 0x4b, 0xff, 0xb2, 0x6b, 0x4e,
+	    0xac, 0x67, 0x58, 0x09,
+	0xaf, 0x85, 0x39, 0x56, 0xc1, 0xd5, 0x40, 0x37, 0x22, 0x0a, 0xb1, 0x2b,
+	    0xf4, 0x65, 0xd1, 0xae,
+	0x76, 0x9b, 0x71, 0x15, 0xb4, 0x32, 0xc3, 0xa7, 0x3a, 0x2d, 0x21, 0xde,
+	    0x81, 0x2d, 0x7d, 0x35,
+	0x63, 0xfb, 0xac, 0xe4, 0x8f, 0x47, 0x98, 0xa8, 0xf7, 0xc4, 0x68, 0xa9,
+	    0x8b, 0x23, 0xd6, 0x21,
+	0xf2, 0xf4, 0x0f, 0x43, 0x14, 0x49, 0xdb, 0x60, 0x0d, 0x09, 0xb8, 0x3a,
+	    0x75, 0x0e, 0xe8, 0x3a,
+	0xf5, 0x4c, 0x55, 0xfe, 0x16, 0x5c, 0xc3, 0x56, 0x72, 0x0e, 0xba, 0xae,
+	    0xdc, 0x99, 0x8a, 0x1e,
+	0x11, 0x4c, 0x0a, 0xb5, 0x1c, 0x8d, 0xdd, 0xfc, 0x6d, 0x78, 0x8a, 0x53,
+	    0xfa, 0xe5, 0x9c, 0x66,
+	0x8c, 0x55, 0x1c, 0x27, 0xed, 0x4e, 0x1c, 0x29, 0xcc, 0x17, 0x43, 0x2b,
+	    0x82, 0x68, 0x14, 0x59,
+	0xf8, 0x06, 0x9b, 0x5f, 0x36, 0x29, 0x9b, 0x29, 0x70, 0xc2, 0xd9, 0x9f,
+	    0x7a, 0xe5, 0x5e, 0x18,
+	0x48, 0xc1, 0xfa, 0x82, 0xd9, 0x3f, 0x75, 0x60, 0x72, 0x3c, 0xef, 0xa6,
+	    0xb9, 0x6b, 0xfe, 0x14,
+	0x44, 0x71, 0xb2, 0xed, 0x92, 0x54, 0x26, 0x23, 0x03, 0x8e, 0xd4, 0x56,
+	    0x0e, 0x51, 0x7b, 0x87,
+	0x41, 0x91, 0xd7, 0x1a, 0x5b, 0x56, 0x2f, 0x32, 0x8a, 0xad, 0xb3, 0xd3,
+	    0x72, 0xb5, 0x3a, 0xad,
+	0xe9, 0xc2, 0xb3, 0xe9, 0x12, 0x98, 0xb1, 0xc2, 0xcf, 0xa5, 0x5d, 0x6d,
+	    0x88, 0x7e, 0x4a, 0xa2,
+	0x61, 0xab, 0xbc, 0xc0, 0xd2, 0x95, 0xb5, 0x06, 0x46, 0xa0, 0x53, 0x84,
+	    0x32, 0x72, 0x74, 0x00,
+	0xd4, 0x1a, 0x9a, 0x70, 0xd8, 0xf3, 0x64, 0xa0, 0x61, 0x5a, 0x54, 0x39,
+	    0x92, 0x7a, 0x3d, 0x43,
+	0x22, 0xc7, 0x11, 0x3a, 0x5b, 0x39, 0xc2, 0x63, 0x62, 0xfe, 0x85, 0x68,
+	    0x51, 0x70, 0x75, 0x01,
+	0x58, 0x18, 0x6a, 0x42, 0x52, 0x98, 0x67, 0x73, 0x6b, 0x8f, 0xbd, 0xb1,
+	    0xd6, 0xfc, 0x5c, 0xbc,
+	0x50, 0xb7, 0xfe, 0x88, 0xd1, 0x5b, 0xad, 0xd8, 0xe8, 0x47, 0x6d, 0x44,
+	    0xfc, 0xb5, 0x2e, 0x05,
+	0x2f, 0xd0, 0x2e, 0xef, 0x9a, 0xba, 0x7f, 0x78, 0x23, 0x2c, 0x19, 0x03,
+	    0x3d, 0x76, 0xa7, 0xfb,
+	0xca, 0xdd, 0xb5, 0xbd, 0xfc, 0x95, 0x29, 0x0d, 0x89, 0x5e, 0x3b, 0x33,
+	    0xf9, 0xfa, 0x1d, 0x0b,
+	0x95, 0x11, 0xbf, 0x6e, 0x35, 0x96, 0x01, 0x97, 0x88, 0xe0, 0x5f, 0x65,
+	    0xdc, 0x76, 0x7e, 0x3a,
+	0xa8, 0x18, 0xa0, 0x3d, 0xf8, 0x7c, 0x2e, 0x9b, 0x16, 0xdb, 0x56, 0x0e,
+	    0xf8, 0x58, 0xc6, 0xb0,
+	0x54, 0x2c, 0x1a, 0x43, 0xd0, 0x8b, 0x7e, 0xb9, 0xc8, 0x5b, 0x59, 0x9c,
+	    0x3b, 0x7b, 0xd0, 0x2b,
+	0x8e, 0x1d, 0xe1, 0x69, 0x6c, 0x9a, 0xd3, 0xf8, 0x0b, 0x58, 0x13, 0x8f,
+	    0x3b, 0xf4, 0x10, 0xf4,
+	0xad, 0xac, 0x91, 0x47, 0xbf, 0x90, 0x7f, 0xbc, 0x02, 0xae, 0x57, 0x99,
+	    0x58, 0x79, 0xe0, 0xfe,
+	0xaf, 0x83, 0x0b, 0x83, 0x87, 0x9f, 0x2f, 0x6a, 0x7b, 0xc3, 0x88, 0x17,
+	    0xf5, 0x3f, 0x6e, 0x10,
+	0x09, 0x2a, 0x93, 0x88, 0x16, 0x31, 0x26, 0x08, 0x24, 0x3a, 0x18, 0x44,
+	    0x37, 0x26, 0x65, 0x12,
+	0xef, 0x81, 0x5e, 0x40, 0x6d, 0x54, 0x6f, 0x9e, 0xe2, 0x77, 0xeb, 0x6e,
+	    0xa8, 0x4d, 0x79, 0x3e,
+	0x64, 0x7c, 0x9e, 0x73, 0xea, 0xe3, 0x53, 0xcf, 0x1b, 0x81, 0xc7, 0x30,
+	    0x74, 0x9c, 0xbf, 0x43,
+	0x02, 0xcc, 0xc0, 0x03, 0x75, 0x5b, 0x29, 0xec, 0xe1, 0xdf, 0x0d, 0x84,
+	    0xd4, 0xac, 0xea, 0xd0,
+	0x87, 0x2d, 0xd0, 0x86, 0xea, 0xaa, 0x87, 0xf4, 0x6b, 0x38, 0xa1, 0xe3,
+	    0xf2, 0xe3, 0xe3, 0x85,
+	0x90, 0xc8, 0x99, 0xc5, 0x16, 0x0e, 0x03, 0x05, 0x39, 0x47, 0x3e, 0x97,
+	    0xde, 0xe9, 0x51, 0x03,
+	0x83, 0x88, 0x05, 0x73, 0x18, 0xa5, 0x29, 0x04, 0xc9, 0xd7, 0xa9, 0x7e,
+	    0x74, 0xe1, 0x7b, 0x9e,
+	0xa9, 0x57, 0x62, 0xef, 0xa4, 0x5d, 0x6a, 0xd9, 0xc3, 0x65, 0x1e, 0x50,
+	    0xc2, 0x37, 0xa4, 0x9e,
+	0x68, 0x08, 0xf4, 0xfc, 0x19, 0x04, 0x68, 0x4a, 0xcd, 0xd6, 0xc2, 0x23,
+	    0x3e, 0x89, 0x9c, 0x4c,
+	0x5a, 0x80, 0x77, 0x8b, 0x9e, 0xaa, 0x67, 0xb8, 0xa6, 0x67, 0x73, 0xf7,
+	    0xa5, 0x37, 0x4d, 0xbb,
+	0x8e, 0xd9, 0x7f, 0x2d, 0xfd, 0x34, 0x05, 0x9b, 0xac, 0xcf, 0xac, 0xc4,
+	    0x3c, 0x78, 0x02, 0x48,
+	0x7a, 0x81, 0x55, 0x4f, 0x93, 0xa0, 0xca, 0xfa, 0xb1, 0x47, 0xa2, 0x77,
+	    0x3d, 0xcc, 0x60, 0x5e,
+	0x8f, 0xef, 0x3e, 0x44, 0x7d, 0x19, 0x7b, 0x78, 0x4b, 0xa1, 0xa0, 0x6e,
+	    0xfc, 0xeb, 0x69, 0x4a,
+	0x2d, 0x83, 0x8b, 0x51, 0xb8, 0x5a, 0x77, 0x21, 0x33, 0xd2, 0x8b, 0xed,
+	    0xfc, 0x9c, 0xc3, 0xd7,
+	0x0d, 0x8b, 0xbd, 0x2c, 0xad, 0x04, 0xaf, 0xb1, 0x3c, 0xd4, 0xdf, 0xfa,
+	    0x7e, 0x65, 0x67, 0x72,
+	0x02, 0x31, 0x3b, 0x64, 0x98, 0x1d, 0x1c, 0x5a, 0xe8, 0x2b, 0xd4, 0x10,
+	    0x60, 0xff, 0x7e, 0x24,
+	0x23, 0x58, 0xba, 0x33, 0xde, 0xf5, 0xe6, 0x69, 0x84, 0xd7, 0x9c, 0xf6,
+	    0xd4, 0x76, 0xb2, 0x70,
+	0x20, 0x1f, 0xfd, 0x65, 0xd7, 0xb0, 0x24, 0x5f, 0x00, 0x90, 0x35, 0xdb,
+	    0x22, 0xf4, 0xa9, 0xa8,
+	0xd9, 0x33, 0x97, 0x27, 0x15, 0x1c, 0x4c, 0x2f, 0x46, 0x92, 0xbc, 0xb7,
+	    0xf6, 0x3a, 0x04, 0x2a,
+	0xca, 0xd9, 0x56, 0x35, 0xda, 0x1f, 0x0c, 0x1f, 0xd7, 0x0f, 0xa4, 0x7e,
+	    0x15, 0x94, 0xac, 0x2e,
+	0xc1, 0x6e, 0x44, 0x5c, 0xba, 0x18, 0xbc, 0x0b, 0x41, 0x2e, 0x84, 0x74,
+	    0x72, 0x6f, 0x3d, 0xf2,
+	0x86, 0x65, 0xd3, 0xcf, 0x5d, 0x33, 0xf1, 0x67, 0xdd, 0x9c, 0x8d, 0x65,
+	    0xf3, 0x4c, 0x50, 0x2b,
+	0x41, 0x2c, 0xbb, 0x44, 0x85, 0x18, 0x44, 0x0f, 0xeb, 0x95, 0xa7, 0xf6,
+	    0x54, 0xf1, 0xb1, 0x7a,
+	0x5e, 0x29, 0x02, 0xfd, 0x4d, 0xb7, 0x56, 0x00, 0x3a, 0xd5, 0xd6, 0xcf,
+	    0x9b, 0x59, 0xdc, 0x69,
+	0xa1, 0x44, 0x8e, 0x1c, 0xdb, 0x0d, 0x5c, 0x9a, 0x6c, 0xb9, 0xb2, 0xb7,
+	    0x74, 0xc9, 0x59, 0x8d,
+	0x4d, 0x19, 0x37, 0x76, 0x38, 0x21, 0x35, 0x49, 0x4d, 0xb4, 0x8f, 0x4a,
+	    0xf5, 0x3a, 0x57, 0x86,
+	0x2d, 0x9c, 0xf5, 0x9d, 0x1e, 0xa0, 0x65, 0x9b, 0x4e, 0x9a, 0xb3, 0xa7,
+	    0xf4, 0x39, 0x53, 0x27,
+	0x7c, 0xde, 0xc1, 0xbd, 0x5c, 0x3a, 0x2b, 0x2e, 0x68, 0x07, 0x7e, 0xe9,
+	    0x1d, 0x74, 0xae, 0x23,
+	0x8c, 0x86, 0x4b, 0xdb, 0xb8, 0xab, 0x40, 0xc7, 0x8d, 0x9d, 0x6e, 0x7a,
+	    0x17, 0xc8, 0x3a, 0x22,
+	0x29, 0x6d, 0xe7, 0x3c, 0x6e, 0x15, 0x06, 0x6f, 0x91, 0x6a, 0x8f, 0x1f,
+	    0xf6, 0xf1, 0x5e, 0xbd,
+	0xef, 0xd0, 0x2f, 0x23, 0x9b, 0xa3, 0xff, 0xbc, 0xcb, 0x52, 0x57, 0xaf,
+	    0x7d, 0xe8, 0x91, 0x62,
+	0xff, 0x06, 0x40, 0x1d, 0x8d, 0x2a, 0x8c, 0x11, 0xe1, 0x3f, 0x50, 0xbc,
+	    0x5e, 0x3f, 0x8a, 0x92,
+	0xb3, 0xc0, 0xae, 0x39, 0x6d, 0x27, 0x60, 0x34, 0xa8, 0x28, 0x8e, 0x56,
+	    0x31, 0xdb, 0x70, 0x34,
+	0x21, 0x0b, 0x03, 0x16, 0xa4, 0xf3, 0xd1, 0xc8, 0xfb, 0xe9, 0x90, 0x43,
+	    0x6f, 0x9f, 0x31, 0x2c,
+	0x7e, 0x41, 0x7b, 0xd4, 0x78, 0xb2, 0x2b, 0x01, 0x94, 0xec, 0xe4, 0x72,
+	    0x7c, 0x15, 0xe4, 0x22,
+	0x26, 0xab, 0xfd, 0x24, 0x19, 0x16, 0xd0, 0xf1, 0xce, 0xe6, 0x6f, 0x38,
+	    0x73, 0x36, 0x83, 0x6d,
+	0xe8, 0x41, 0xf6, 0x69, 0xcf, 0x2a, 0xf4, 0x1f, 0x9d, 0xba, 0xa3, 0x96,
+	    0xd1, 0x99, 0xe5, 0x3f,
+	0x21, 0x8d, 0x98, 0xd4, 0x37, 0xd9, 0xf1, 0x03, 0xec, 0x99, 0xb1, 0x24,
+	    0x3f, 0xed, 0x73, 0xe1,
+	0x6d, 0xa8, 0xfb, 0xaa, 0x2a, 0x98, 0xe0, 0xef, 0x1a, 0xba, 0x32, 0x85,
+	    0x15, 0x68, 0x5a, 0xa2,
+	0xac, 0x80, 0xfa, 0x2b, 0xf1, 0x99, 0xb2, 0x5b, 0xeb, 0xcb, 0xd7, 0x4b,
+	    0xce, 0x62, 0x0a, 0x9c,
+	0x64, 0x0e, 0xb4, 0x20, 0xba, 0x4c, 0xe1, 0x1f, 0xe8, 0xb6, 0x88, 0xe4,
+	    0xea, 0x34, 0xe3, 0x4c,
+	0x8e, 0x10, 0xfb, 0x8f, 0x7e, 0x80, 0x24, 0xda, 0x44, 0x47, 0x16, 0x52,
+	    0xb0, 0x67, 0xcb, 0xd1,
+	0x89, 0x10, 0xb5, 0x20, 0x3a, 0x6a, 0x45, 0xdb, 0xcd, 0xe6, 0x63, 0x35,
+	    0x64, 0x24, 0xe6, 0x2a,
+	0xfd, 0x4d, 0x99, 0x4c, 0x66, 0xd3, 0x7d, 0x92, 0xb6, 0xbd, 0x66, 0x8e,
+	    0x25, 0x0c, 0x31, 0x23,
+	0x6a, 0x6d, 0x75, 0x6d, 0xba, 0xd2, 0xde, 0x5c, 0x6b, 0xdf, 0xd6, 0x7b,
+	    0xfa, 0xe5, 0x3c, 0x3b,
+	0xe8, 0x4d, 0xf8, 0xfc, 0x39, 0xf1, 0xe0, 0x55, 0xcc, 0x37, 0x13, 0x09,
+	    0x57, 0x68, 0x35, 0x5f,
+	0x5b, 0x6b, 0x70, 0xf8, 0x6c, 0xa4, 0x92, 0xbf, 0x99, 0x54, 0xdf, 0x9f,
+	    0xdd, 0x94, 0x98, 0xf2,
+	0xdf, 0x52, 0x82, 0xeb, 0xbd, 0x66, 0x2e, 0x53, 0x14, 0xff, 0xac, 0x63,
+	    0xa2, 0x78, 0xb4, 0x6f,
+	0xa3, 0x06, 0x1c, 0xcb, 0xc0, 0xcd, 0xdc, 0xad, 0x33, 0xfa, 0x1c, 0x59,
+	    0x71, 0xac, 0x59, 0xaa,
+	0x93, 0xf4, 0xcd, 0x80, 0xcf, 0x32, 0x82, 0x50, 0xd8, 0x72, 0x97, 0x48,
+	    0xf8, 0x76, 0x1b, 0xf3,
+	0x2e, 0xe5, 0xa2, 0xfb, 0x68, 0x71, 0xcb, 0x89, 0x29, 0x62, 0xd7, 0xb4,
+	    0xcc, 0x7a, 0x10, 0x0f,
+	0x24, 0x57, 0x10, 0x3a, 0x51, 0x38, 0xaf, 0x02, 0xe0, 0x1c, 0xf4, 0x17,
+	    0xd1, 0x66, 0x32, 0xd7,
+	0x8f, 0x18, 0x6a, 0x68, 0xd8, 0x51, 0x24, 0x72, 0x66, 0x0f, 0xa4, 0xb4,
+	    0x51, 0x73, 0x1a, 0x45,
+	0x88, 0x18, 0x52, 0x36, 0x36, 0xbd, 0x4d, 0x93, 0x41, 0x33, 0x6d, 0x95,
+	    0x72, 0xd0, 0x5b, 0xb3,
+	0x5c, 0xb7, 0x74, 0xda, 0x10, 0x75, 0x25, 0x73, 0xe6, 0x9d, 0xac, 0xd9,
+	    0x52, 0x19, 0x0e, 0x8d,
+	0xaf, 0x68, 0x59, 0x3f, 0xc9, 0x69, 0x47, 0x2c, 0x45, 0x89, 0x97, 0x5c,
+	    0x50, 0x89, 0x6e, 0x32,
+	0x0d, 0x16, 0x33, 0xc3, 0xe0, 0xe4, 0x1c, 0xa6, 0x5d, 0xad, 0xe6, 0xa1,
+	    0x21, 0xa7, 0x97, 0xcf,
+	0xb4, 0x97, 0x2b, 0x12, 0x03, 0xc6, 0xd7, 0xb0, 0x75, 0x50, 0x57, 0x21,
+	    0x3e, 0xe7, 0x9f, 0x39,
+	0xac, 0xe1, 0xa0, 0x19, 0xc6, 0x9c, 0x8a, 0x7e, 0x00, 0x2a, 0xf1, 0x99,
+	    0x7b, 0x33, 0xe6, 0x1b,
+	0xae, 0x5c, 0x84, 0x31, 0xba, 0xa9, 0x2e, 0x6a, 0x6f, 0x58, 0xb4, 0xed,
+	    0x7b, 0xdc, 0x76, 0x7d,
+	0xdc, 0x71, 0xce, 0xa3, 0x65, 0x36, 0xea, 0x9a, 0x28, 0x82, 0x90, 0x7e,
+	    0xc9, 0xbc, 0x01, 0xce,
+	0xe0, 0x5a, 0x57, 0x30, 0x9c, 0xe5, 0x6f, 0x39, 0x95, 0x51, 0xed, 0x12,
+	    0xfc, 0x85, 0xf2, 0x46,
+	0x40, 0xee, 0xcb, 0x41, 0x46, 0xe7, 0x27, 0x7b, 0xea, 0x3d, 0xe7, 0x3a,
+	    0x39, 0x5f, 0x83, 0x74,
+	0xfb, 0x86, 0x0b, 0x7d, 0xc1, 0x1c, 0xac, 0x10, 0x24, 0x1e, 0x8f, 0xa2,
+	    0x4a, 0xd8, 0x0f, 0x64,
+	0xf2, 0x78, 0x69, 0x94, 0xb4, 0x3e, 0x6a, 0x09, 0xae, 0xa5, 0x80, 0xc9,
+	    0xac, 0x40, 0x50, 0x32,
+	0x27, 0x99, 0x1e, 0x5c, 0x6d, 0xe0, 0x4f, 0x25, 0x2d, 0xcd, 0x0e, 0x16,
+	    0x75, 0x43, 0x31, 0x1a,
+	0x70, 0x8a, 0x16, 0x93, 0x83, 0x5d, 0x82, 0xd1, 0x69, 0x3e, 0x81, 0x06,
+	    0x74, 0x5c, 0xdf, 0xa0,
+	0x52, 0xc5, 0xc8, 0x7b, 0xfd, 0xe0, 0xb4, 0x04, 0xa4, 0xe4, 0xb5, 0xe4,
+	    0x55, 0x02, 0xc8, 0x20,
+	0x65, 0x62, 0x4c, 0x34, 0xa0, 0xc0, 0x07, 0x8f, 0x4f, 0x87, 0x57, 0xa8,
+	    0x34, 0x40, 0x3b, 0x0a,
+	0xfa, 0x29, 0xbb, 0x50, 0xe0, 0x09, 0xb3, 0x8b, 0x52, 0x0b, 0xab, 0x49,
+	    0x75, 0xe0, 0x17, 0x54,
+	0x26, 0x58, 0xd1, 0xb8, 0x32, 0x58, 0xe2, 0xac, 0xb8, 0xd9, 0x81, 0x50,
+	    0x74, 0xa6, 0xa0, 0x88,
+	0xbe, 0x09, 0x5f, 0x70, 0x1a, 0xfa, 0x4a, 0xc2, 0xea, 0x85, 0x69, 0x3e,
+	    0x3f, 0xc9, 0x5b, 0x2a,
+	0xac, 0x80, 0x6a, 0x92, 0xc2, 0x76, 0x36, 0x1e, 0x7e, 0x8e, 0x82, 0xc4,
+	    0x3e, 0xc8, 0x79, 0x8b,
+	0x2f, 0x8c, 0xc3, 0x6d, 0x2b, 0x77, 0x41, 0x23, 0xc0, 0x84, 0xa4, 0xab,
+	    0xca, 0x2c, 0xab, 0x8b,
+	0x2e, 0x3e, 0x90, 0xd8, 0x4b, 0xa1, 0x83, 0x2b, 0x6a, 0x8a, 0x2c, 0xbb,
+	    0xcb, 0x2d, 0xce, 0x6e,
+	0xe5, 0xc8, 0xdc, 0x72, 0xc2, 0xa3, 0xa9, 0x63, 0x48, 0x57, 0xa2, 0x5e,
+	    0x4f, 0xae, 0xce, 0x38,
+	0x82, 0xcc, 0xbc, 0xbc, 0xe8, 0x50, 0x20, 0x7b, 0xec, 0xcb, 0x42, 0xb9,
+	    0x6c, 0xd4, 0x59, 0xfb,
+	0x60, 0x21, 0xd1, 0x76, 0x61, 0x33, 0x2c, 0xe9, 0xcf, 0x29, 0x36, 0x09,
+	    0xd8, 0x8c, 0xab, 0xfa,
+	0xe2, 0xcd, 0xfd, 0x3d, 0x60, 0x72, 0xf3, 0xbe, 0x6e, 0x45, 0x43, 0xe0,
+	    0x2a, 0x66, 0x34, 0xc3,
+	0x77, 0x3d, 0x08, 0xf9, 0xae, 0x30, 0x52, 0x9f, 0x8d, 0x01, 0xeb, 0x56,
+	    0x70, 0xff, 0x12, 0xe2,
+	0x0b, 0x0e, 0xd3, 0xe9, 0x5d, 0xbc, 0xbe, 0xa1, 0x51, 0x00, 0xc4, 0x34,
+	    0x53, 0xb9, 0x3b, 0xb2,
+	0x05, 0x2d, 0x5a, 0xc0, 0x09, 0x24, 0xf5, 0xba, 0x7f, 0xda, 0xd5, 0xe3,
+	    0x70, 0x7f, 0x77, 0xd1,
+	0xdd, 0x3c, 0x41, 0x0c, 0xb6, 0xc3, 0x1b, 0x9e, 0x99, 0x73, 0xc5, 0x90,
+	    0x56, 0x96, 0xdd, 0x5c,
+	0xcd, 0x45, 0xbc, 0x31, 0xb4, 0x48, 0x4c, 0x32, 0x98, 0xdb, 0xfc, 0xee,
+	    0xf4, 0xe3, 0x97, 0xf5,
+	0x86, 0x6a, 0x58, 0x34, 0xb5, 0xbd, 0x44, 0x22, 0xd8, 0xda, 0x23, 0x27,
+	    0xf5, 0xe2, 0x5e, 0x47,
+	0x8c, 0x0c, 0x0e, 0x37, 0x15, 0xb9, 0x4d, 0x33, 0x39, 0xd9, 0x64, 0x85,
+	    0x09, 0xb4, 0xad, 0x72,
+	0x14, 0x38, 0x60, 0x27, 0xb3, 0xb8, 0x45, 0x23, 0x1c, 0xd8, 0x6b, 0x95,
+	    0x78, 0x71, 0x86, 0x7a,
+	0xa4, 0x0b, 0x0a, 0xf0, 0xaa, 0x67, 0x23, 0xd9, 0x54, 0x51, 0x26, 0x35,
+	    0x87, 0x75, 0x3c, 0xd8,
+	0xd6, 0x04, 0x4d, 0xde, 0x35, 0xf8, 0xb9, 0x22, 0x06, 0x2a, 0xab, 0x87,
+	    0x96, 0xbd, 0x90, 0x8d,
+	0x5b, 0x27, 0x18, 0xbe, 0x1d, 0xd4, 0xb7, 0xcb, 0x67, 0x98, 0xd5, 0xaf,
+	    0x0f, 0x71, 0x7d, 0x8c,
+	0x5e, 0x36, 0x70, 0x60, 0x99, 0x06, 0x2c, 0x3f, 0xce, 0x74, 0xe5, 0x08,
+	    0x8f, 0x54, 0xc2, 0x4e,
+	0x08, 0x27, 0x86, 0x8e, 0x2b, 0x3e, 0x16, 0xab, 0xe2, 0xd1, 0xf2, 0xae,
+	    0x6e, 0xfa, 0x56, 0xeb,
+	0x8e, 0x62, 0xee, 0x23, 0x3f, 0x66, 0xd9, 0xc6, 0xb7, 0x2c, 0x3e, 0x03,
+	    0x34, 0xbc, 0xa7, 0x6f,
+	0x8d, 0xfb, 0x9f, 0x36, 0x9e, 0x25, 0x3d, 0x94, 0x4d, 0x9f, 0x86, 0xdb,
+	    0x5f, 0x01, 0x69, 0xdd,
+	0x64, 0xdb, 0xc7, 0x5b, 0x86, 0xe8, 0x26, 0x6a, 0x4a, 0xe0, 0xff, 0xff,
+	    0xff, 0xff, 0xa7, 0xb1,
+	0xd8, 0xc3, 0xf8, 0x36, 0xef, 0x3b, 0x52, 0x5e, 0xbb, 0x2e, 0x44, 0x14,
+	    0x54, 0x9f, 0x5d, 0x63,
+	0x67, 0x43, 0x89, 0x6b, 0xb6, 0x60, 0x61, 0x5e, 0x20, 0x45, 0xc6, 0x64,
+	    0x51, 0xc5, 0x3b, 0xf2,
+	0xb2, 0xad, 0xac, 0x76, 0x33, 0x6d, 0xac, 0xba, 0xa3, 0x46, 0xab, 0x94,
+	    0xf6, 0xbd, 0xc8, 0x93,
+	0x20, 0xac, 0xd0, 0x5e, 0x34, 0x8c, 0x78, 0x71, 0x97, 0x0f, 0x4f, 0x64,
+	    0x6d, 0xc0, 0xf1, 0xfe,
+	0xbe, 0xf3, 0xfa, 0xa6, 0x36, 0x4a, 0x41, 0x06, 0xbd, 0x28, 0xbf, 0xa2,
+	    0x3c, 0x62, 0xf1, 0x0e,
+	0x80, 0x0b, 0xe0, 0x96, 0xc7, 0xfa, 0x08, 0x99, 0x4b, 0x78, 0x9e, 0x9c,
+	    0xd5, 0xae, 0xee, 0x2e,
+	0x5f, 0xda, 0x81, 0x7a, 0x9a, 0x4a, 0x6f, 0xc1, 0x1c, 0xe9, 0xa0, 0xe9,
+	    0x73, 0x6d, 0xa9, 0x6e,
+	0xa7, 0x8a, 0x6e, 0xaa, 0xf8, 0x58, 0xf5, 0xe2, 0xe1, 0x4d, 0x5b, 0xd5,
+	    0xbd, 0xb7, 0xd4, 0x7b,
+	0x6e, 0x4a, 0x52, 0x04, 0xbd, 0x87, 0x1e, 0x6e, 0x36, 0x4c, 0x23, 0x9c,
+	    0xa0, 0x0b, 0xdc, 0xdf,
+	0xd7, 0x03, 0x55, 0xfc, 0x1d, 0x89, 0x7a, 0x5a, 0xba, 0x2c, 0x93, 0x4f,
+	    0x37, 0x2b, 0xc2, 0xd6,
+	0x77, 0xa7, 0x57, 0x1c, 0xe7, 0x87, 0x52, 0x56, 0xce, 0xaa, 0xa0, 0x89,
+	    0xde, 0xd3, 0x1c, 0x6a,
+	0xe3, 0xaf, 0x50, 0x6e, 0xb7, 0x8a, 0x23, 0xc2, 0x44, 0x36, 0x10, 0x19,
+	    0xb1, 0xc8, 0x1b, 0x72,
+	0xad, 0x1c, 0x97, 0xec, 0xed, 0x4c, 0x13, 0x37, 0xf3, 0xb0, 0x12, 0x35,
+	    0x97, 0x2c, 0xb2, 0x50,
+	0xac, 0xf2, 0x37, 0xd8, 0x70, 0x52, 0xe5, 0xeb, 0x65, 0x90, 0x1b, 0x8c,
+	    0x57, 0x62, 0xbb, 0x41,
+	0x2d, 0x1e, 0x9d, 0xa2, 0xda, 0x85, 0x93, 0x99, 0xec, 0x22, 0x09, 0xb6,
+	    0x58, 0x79, 0x75, 0xa0,
+	0xf7, 0x4d, 0x8d, 0xac, 0x24, 0xbf, 0x3d, 0xdd, 0xc8, 0x8f, 0x73, 0xc8,
+	    0xff, 0x69, 0x51, 0xee,
+	0x4a, 0x03, 0x80, 0x1b, 0xcb, 0xbd, 0xf4, 0x56, 0x53, 0x2c, 0xfc, 0xba,
+	    0xb6, 0x84, 0x2c, 0xc7,
+	0xc8, 0x02, 0x9e, 0x95, 0xce, 0xbc, 0x9c, 0x56, 0x71, 0xda, 0xc2, 0x26,
+	    0x75, 0xfc, 0x7b, 0x29,
+	0xe8, 0xf1, 0x66, 0x7f, 0x59, 0x51, 0xed, 0x49, 0x16, 0xd9, 0x73, 0x54,
+	    0x3a, 0x32, 0x27, 0x7b,
+	0xe2, 0x1c, 0xdb, 0x31, 0x46, 0xce, 0x54, 0x57, 0x00, 0x48, 0xe3, 0x2b,
+	    0x1a, 0x85, 0x1d, 0xfa,
+	0xd3, 0x5b, 0x39, 0x5c, 0x59, 0x4b, 0x34, 0x40, 0x7c, 0x5b, 0x46, 0x66,
+	    0x73, 0x16, 0xfb, 0xb6,
+	0x9c, 0x7b, 0x9c, 0x3e, 0xc8, 0xe0, 0x5d, 0x96, 0x9c, 0x17, 0xe4, 0xa4,
+	    0x72, 0x7a, 0x44, 0xc3,
+	0xa0, 0x0d, 0x41, 0x34, 0x0d, 0x35, 0x0c, 0xec, 0x47, 0x89, 0xed, 0xb5,
+	    0xd2, 0x79, 0x72, 0x5e,
+	0xc0, 0x13, 0x36, 0xea, 0x4c, 0x39, 0xd2, 0x93, 0xd0, 0xb5, 0xbd, 0xaa,
+	    0x20, 0x7a, 0x2f, 0xe0,
+	0xdf, 0xb5, 0x90, 0xee, 0xc7, 0xe5, 0x72, 0x5e, 0xea, 0x4f, 0xc8, 0x37,
+	    0x68, 0xd7, 0x07, 0x67,
+	0x0d, 0x94, 0xf6, 0xbb, 0xc0, 0x36, 0x43, 0xa7, 0x84, 0x35, 0x28, 0x4d,
+	    0x91, 0x29, 0x52, 0xdb,
+	0xeb, 0xea, 0x47, 0xd4, 0xf7, 0xa7, 0xd6, 0x59, 0xe4, 0x55, 0xf4, 0x5e,
+	    0x1c, 0xd5, 0xf0, 0xe6,
+	0xaf, 0xfb, 0xef, 0x9f, 0xf8, 0x36, 0xdb, 0xb0, 0x04, 0x39, 0xe1, 0x8f,
+	    0x7c, 0x6d, 0x3f, 0xb0,
+	0xb8, 0x14, 0xae, 0x4a, 0xc6, 0x7d, 0xee, 0x6a, 0x48, 0x6c, 0x2d, 0xcb,
+	    0xdb, 0xf5, 0xb6, 0xd0,
+	0xd6, 0x52, 0xf6, 0x4f, 0x02, 0x90, 0x07, 0x70, 0xce, 0x5b, 0xc4, 0xcf,
+	    0x5a, 0xed, 0xc1, 0x21,
+	0x56, 0xa3, 0x2b, 0x4f, 0x08, 0x3f, 0x2f, 0x49, 0xe0, 0x8e, 0xe1, 0x0d,
+	    0xf6, 0xa3, 0xc8, 0x66,
+	0xff, 0x88, 0xd6, 0xad, 0x3b, 0x20, 0x0f, 0xe4, 0x48, 0x59, 0x00, 0xf8,
+	    0xfd, 0x36, 0xbc, 0xe0,
+	0xe4, 0x21, 0x98, 0xf9, 0xfd, 0xe3, 0xf0, 0x37, 0xaf, 0xca, 0xce, 0x97,
+	    0xa1, 0x43, 0x10, 0xfc,
+	0xa9, 0x8c, 0x73, 0xf4, 0xb9, 0x0c, 0x03, 0xd0, 0xe9, 0x7c, 0x24, 0xb2,
+	    0x00, 0xa0, 0xf7, 0x87,
+	0x92, 0x06, 0x61, 0x5e, 0xdb, 0x0f, 0x30, 0xa7, 0x88, 0x15, 0xe3, 0xd4,
+	    0xb6, 0x4f, 0xd4, 0x97,
+	0x9b, 0xce, 0x76, 0xf5, 0x7c, 0xc0, 0x41, 0x2e, 0x38, 0x4a, 0xaf, 0x92,
+	    0x3e, 0x80, 0xe6, 0x54,
+	0xfd, 0x1f, 0xb0, 0xac, 0xed, 0x0f, 0xd3, 0xc6, 0x9a, 0xa7, 0x5f, 0xbc,
+	    0x35, 0xeb, 0xd0, 0xc9,
+	0x64, 0x81, 0xcf, 0xa9, 0x7c, 0xda, 0xc0, 0x01, 0x6d, 0x5a, 0xf0, 0xc1,
+	    0xb6, 0xea, 0x61, 0x04,
+	0xb5, 0x33, 0x1c, 0xcb, 0x46, 0x79, 0x54, 0xc2, 0xde, 0xc2, 0x89, 0x40,
+	    0x75, 0xe0, 0x17, 0xb1,
+	0x95, 0xca, 0xbc, 0xf7, 0x60, 0xc7, 0x47, 0xd7, 0x38, 0x5a, 0x99, 0x37,
+	    0x69, 0xe8, 0xe2, 0x9a,
+	0x15, 0xe6, 0xb0, 0x0f, 0xe7, 0x25, 0xb1, 0xca, 0xf8, 0x89, 0x09, 0x9f,
+	    0x7a, 0x47, 0xef, 0x5a,
+	0x0c, 0xd9, 0xf3, 0x20, 0x72, 0xeb, 0x92, 0x9e, 0xc8, 0xea, 0x4d, 0x1a,
+	    0xd2, 0xeb, 0x9e, 0x94,
+	0x79, 0xc8, 0xf5, 0xab, 0x6f, 0x5f, 0x9b, 0x12, 0x49, 0x49, 0x63, 0x3e,
+	    0xba, 0xee, 0x96, 0x2a,
+	0xb7, 0x24, 0x73, 0x5d, 0x10, 0x20, 0xfb, 0x62, 0x38, 0xd0, 0x0c, 0x3e,
+	    0x50, 0xe7, 0x78, 0x48,
+	0xc4, 0x83, 0xbc, 0xa1, 0x5e, 0x07, 0x89, 0x4e, 0xc9, 0x7c, 0x92, 0x2e,
+	    0x50, 0xe1, 0x33, 0x65,
+	0xa8, 0x9f, 0xac, 0xaf, 0xa0, 0x7d, 0xfe, 0x98, 0xcd, 0xc9, 0xb0, 0xc1,
+	    0xfc, 0xaf, 0x2b, 0xca,
+	0x9e, 0xc3, 0x1e, 0xcb, 0xf5, 0xd1, 0x13, 0x2f, 0x91, 0x45, 0xb9, 0xb0,
+	    0x7d, 0xe3, 0xd3, 0xb3,
+	0x2d, 0xc0, 0xbb, 0xb5, 0x64, 0x04, 0x64, 0x19, 0x8c, 0x3f, 0x22, 0x7c,
+	    0xd9, 0x34, 0x44, 0xe0,
+	0xd7, 0xf5, 0xae, 0x84, 0x97, 0xf1, 0x6d, 0x25, 0x83, 0x9c, 0x8b, 0xf8,
+	    0x85, 0x2c, 0x94, 0x6c,
+	0x9a, 0xca, 0x78, 0xd4, 0x5e, 0x32, 0x5c, 0x18, 0x33, 0xde, 0x17, 0x13,
+	    0xa0, 0xef, 0x1d, 0x78,
+	0x97, 0xd7, 0xfb, 0x23, 0x3c, 0x19, 0xe3, 0xe5, 0xc6, 0x5f, 0xec, 0xb3,
+	    0x79, 0x91, 0x2d, 0xe8,
+	0x99, 0x2c, 0x4a, 0x66, 0xdf, 0x3d, 0xfd, 0xef, 0xf1, 0x9f, 0xc0, 0x44,
+	    0x2d, 0x27, 0xf4, 0x33,
+	0x0c, 0xb4, 0x84, 0x6c, 0x68, 0xb9, 0x24, 0xfb, 0x87, 0xdb, 0x58, 0x64,
+	    0x7f, 0x90, 0x12, 0x77,
+	0xa5, 0x52, 0xfb, 0x54, 0x85, 0x67, 0x7b, 0x02, 0x6f, 0xda, 0x6c, 0x31,
+	    0x75, 0x00, 0x3f, 0x3c,
+	0x4d, 0xd5, 0xff, 0xc5, 0x24, 0xbe, 0x55, 0xf7, 0x64, 0xd5, 0xcd, 0xb7,
+	    0xfe, 0xf9, 0xc8, 0xb1,
+	0xcc, 0x98, 0xd5, 0x45, 0xb5, 0xbf, 0xa6, 0xf1, 0x98, 0xae, 0xf9, 0xb0,
+	    0x76, 0xf9, 0x9f, 0x32,
+	0xdf, 0xda, 0x98, 0xeb, 0x7e, 0x17, 0x60, 0xec, 0x42, 0x9a, 0x95, 0x2a,
+	    0x0b, 0x4a, 0x9a, 0xf8,
+	0x92, 0xf7, 0x90, 0x2a, 0xb0, 0x1f, 0x46, 0xc9, 0x40, 0x5b, 0xe6, 0xaa,
+	    0x1e, 0x65, 0xa1, 0x35,
+	0x0d, 0xc5, 0x71, 0xfd, 0x57, 0x79, 0x38, 0xb0, 0x0d, 0xbf, 0x89, 0x1c,
+	    0xb5, 0x7d, 0xef, 0x8e,
+	0x46, 0x93, 0x37, 0x5f, 0x8b, 0x16, 0xc0, 0xc8, 0xc8, 0x2f, 0x46, 0x50,
+	    0x7d, 0x7b, 0xe1, 0xf8,
+	0xd1, 0x9a, 0xf0, 0x4c, 0x8c, 0xee, 0x2d, 0xe8, 0x15, 0x45, 0x55, 0x78,
+	    0xa2, 0x1a, 0x7c, 0x38,
+	0xc4, 0x9e, 0xfe, 0x6b, 0x2f, 0xff, 0xe9, 0x10, 0xed, 0x95, 0x9c, 0xfa,
+	    0xaa, 0x60, 0x11, 0xdc,
+	0x0f, 0x6f, 0xdf, 0x7d, 0xb6, 0xce, 0xb7, 0x96, 0xb1, 0x9c, 0xa9, 0x7c,
+	    0xfa, 0x55, 0x3f, 0x5a,
+	0xbb, 0x84, 0xe0, 0x26, 0xb9, 0x74, 0xdb, 0x0b, 0xaf, 0xd0, 0x54, 0xa0,
+	    0x06, 0x03, 0xa3, 0x9e,
+	0xdc, 0xf6, 0x2c, 0x06, 0xee, 0x26, 0x77, 0xdb, 0xa9, 0xc9, 0x35, 0x21,
+	    0xd7, 0x76, 0x6b, 0x14,
+	0xd4, 0x5c, 0x90, 0x08, 0x17, 0x08, 0xb4, 0xab, 0xa0, 0xd7, 0xf0, 0xf6,
+	    0xd7, 0x94, 0x5f, 0x9a,
+	0x84, 0xa9, 0xa1, 0x45, 0x31, 0xad, 0x73, 0x21, 0x33, 0xbf, 0x51, 0xd9,
+	    0xf4, 0x9d, 0xa2, 0x4e,
+	0x3c, 0xff, 0x37, 0x97, 0x11, 0x2b, 0x51, 0x0c, 0x28, 0x2a, 0x09, 0xf2,
+	    0xd3, 0x96, 0x57, 0xb9,
+	0x4e, 0x46, 0xb8, 0xc6, 0x17, 0x1d, 0xb1, 0x8e, 0xa3, 0x72, 0x2f, 0x36,
+	    0x5c, 0x06, 0x97, 0x82,
+	0xbf, 0xd4, 0x40, 0x91, 0xb2, 0xaf, 0x78, 0x75, 0x45, 0xe7, 0x50, 0xac,
+	    0xf0, 0x98, 0x1f, 0x5f,
+	0xf5, 0xf0, 0xb9, 0x62, 0x31, 0x20, 0x2c, 0x13, 0x50, 0x59, 0x15, 0xb5,
+	    0xda, 0x60, 0xf8, 0x68,
+	0xf8, 0x0b, 0x32, 0xb7, 0x32, 0xad, 0x7f, 0xd1, 0x08, 0xf7, 0xf3, 0xf0,
+	    0x90, 0x07, 0xa1, 0x3e,
+	0xd4, 0xed, 0xba, 0x7c, 0xac, 0x21, 0x85, 0xac, 0x5e, 0xcc, 0x96, 0x6b,
+	    0xd9, 0x66, 0x38, 0x1c,
+	0x8c, 0x1f, 0xea, 0x1f, 0x2d, 0x24, 0x65, 0xc9, 0xea, 0x09, 0xc4, 0xaf,
+	    0x5d, 0xc2, 0x5d, 0x3a,
+	0x8c, 0xa1, 0x07, 0xfd, 0x67, 0x25, 0x2b, 0xd3, 0x64, 0x47, 0x30, 0xbb,
+	    0x04, 0x8c, 0x2d, 0x40,
+	0x59, 0xaf, 0x91, 0x1c, 0xba, 0x19, 0xa4, 0x0b, 0xa9, 0x5a, 0xf9, 0x39,
+	    0x04, 0xd6, 0x19, 0x5f,
+	0x0c, 0x47, 0xbd, 0xae, 0xc7, 0xf1, 0x68, 0x2f, 0x94, 0xb3, 0x66, 0x8e,
+	    0x82, 0x28, 0x65, 0x23,
+	0x48, 0x6d, 0xaa, 0x1c, 0x35, 0xa6, 0x3d, 0x83, 0xaa, 0xdb, 0x5c, 0xfe,
+	    0x5e, 0x24, 0xb9, 0x6d,
+	0x53, 0xf3, 0x6c, 0xc9, 0xef, 0xec, 0x69, 0xf7, 0x3d, 0xc3, 0xf0, 0x6a,
+	    0x7b, 0xe4, 0x15, 0xbb,
+	0x89, 0x8a, 0xcf, 0xbf, 0xbf, 0xdb, 0x20, 0x5d, 0x36, 0xce, 0xa3, 0x59,
+	    0x0f, 0x6c, 0x06, 0x40,
+	0x60, 0x8b, 0xd2, 0xe6, 0x4d, 0x39, 0xce, 0xe8, 0xe2, 0x54, 0xb7, 0xb7,
+	    0x42, 0xc4, 0x1e, 0x6a,
+	0xd2, 0x8c, 0x60, 0x14, 0xcd, 0x11, 0x43, 0xb1, 0x02, 0x50, 0xfd, 0x30,
+	    0x06, 0x30, 0x05, 0x83,
+	0xe0, 0xaf, 0x05, 0xfa, 0x13, 0x73, 0x05, 0xc3, 0x1f, 0x8d, 0xcb, 0xaa,
+	    0xb4, 0x3c, 0xc9, 0x14,
+	0xaf, 0x99, 0x21, 0xd7, 0x32, 0xe7, 0x0a, 0x42, 0x65, 0xde, 0x62, 0x77,
+	    0x72, 0x35, 0xcc, 0xad,
+	0x81, 0x12, 0x78, 0xf5, 0x93, 0xcb, 0x2a, 0xe6, 0x01, 0x62, 0xaf, 0xc3,
+	    0xd3, 0xcb, 0xe0, 0x42,
+	0x3b, 0x1d, 0x02, 0xb6, 0xd8, 0xee, 0x82, 0xef, 0x50, 0x28, 0x8c, 0xf3,
+	    0x18, 0x7a, 0x65, 0xd2,
+	0x03, 0xe9, 0x80, 0xa2, 0xb4, 0x8e, 0x86, 0xde, 0x66, 0xf9, 0xf3, 0x44,
+	    0x76, 0xd2, 0xcf, 0xae,
+	0x2c, 0x91, 0x79, 0xb7, 0x58, 0xcc, 0x4b, 0x93, 0x1c, 0x0a, 0x5d, 0x8b,
+	    0xf5, 0xb5, 0xc1, 0x73,
+	0x0a, 0x10, 0x64, 0x93, 0xf6, 0xb5, 0x44, 0xaa, 0x83, 0x3c, 0x21, 0x88,
+	    0x5a, 0xa8, 0x09, 0x58,
+	0x21, 0x89, 0x0e, 0xc2, 0xc8, 0xe5, 0xa1, 0x84, 0x9e, 0xe9, 0xa6, 0x47,
+	    0x58, 0x4a, 0xc1, 0x73,
+	0x25, 0x9c, 0xf9, 0x1e, 0xd3, 0xbc, 0x2f, 0xd4, 0xcb, 0xdb, 0x9f, 0x2f,
+	    0x1e, 0x2a, 0x30, 0xf9,
+	0xa1, 0xa9, 0x20, 0xe6, 0x64, 0xef, 0x68, 0xa8, 0x54, 0x5d, 0xff, 0xbf,
+	    0xc0, 0x76, 0x3f, 0x88,
+	0x6e, 0x1a, 0xa6, 0xce, 0x37, 0xb7, 0x82, 0x16, 0x83, 0x18, 0xff, 0x96,
+	    0xd9, 0x19, 0x36, 0xfc,
+	0xae, 0xb3, 0xc0, 0xbe, 0x78, 0xc0, 0x20, 0x04, 0xc7, 0x50, 0x5d, 0xfe,
+	    0xfc, 0x3c, 0xcf, 0xa4,
+	0x0b, 0xef, 0x38, 0x2f, 0x38, 0x3a, 0x97, 0xb0, 0xf5, 0x53, 0xe8, 0x0f,
+	    0xa6, 0x8e, 0x76, 0x79,
+	0x46, 0xef, 0xb7, 0x1a, 0x9f, 0xcb, 0x21, 0x04, 0xcf, 0x83, 0x1f, 0x04,
+	    0x2b, 0x79, 0xab, 0x19,
+	0x02, 0x5b, 0x9a, 0x84, 0x9c, 0xf1, 0x4e, 0x24, 0xad, 0xcf, 0x1f, 0xd7,
+	    0x82, 0xe0, 0xdb, 0x29,
+	0xff, 0x14, 0xf0, 0x1e, 0x13, 0x81, 0x00, 0xdc, 0xe9, 0xcc, 0x3d, 0x44,
+	    0xbe, 0x77, 0x66, 0x3c,
+	0x7a, 0x57, 0xd9, 0x83, 0xc0, 0x91, 0x63, 0x15, 0x2f, 0xa6, 0x16, 0xb8,
+	    0xbf, 0x54, 0x5a, 0xd1,
+	0x06, 0xc5, 0xb2, 0xea, 0x91, 0xe3, 0x2e, 0xc8, 0x70, 0x50, 0x12, 0x59,
+	    0x00, 0x1f, 0x9f, 0xc0,
+	0x03, 0x80, 0x73, 0xc2, 0x69, 0x53, 0x8f, 0x9d, 0xa7, 0x47, 0x57, 0xc7,
+	    0x86, 0xa7, 0x22, 0x0d,
+	0xb8, 0xd8, 0xf0, 0xd2, 0xfe, 0x74, 0xc0, 0x9c, 0x57, 0x88, 0xd5, 0x49,
+	    0x3d, 0x68, 0x59, 0xad,
+	0x2a, 0x8b, 0x5e, 0x37, 0x9e, 0x7e, 0x8e, 0x9d, 0xf5, 0xfa, 0xd6, 0xc2,
+	    0x4f, 0x9b, 0x67, 0xb1,
+	0x70, 0xfa, 0xf1, 0x46, 0xe8, 0xe7, 0x84, 0x43, 0xc3, 0x78, 0x02, 0x09,
+	    0x5a, 0xd1, 0x95, 0x2e,
+	0xed, 0x57, 0x3a, 0x49, 0x63, 0x88, 0x49, 0x55, 0x4a, 0xba, 0x0f, 0x71,
+	    0x88, 0x2d, 0xac, 0x55,
+	0xac, 0x36, 0x14, 0x9c, 0x9d, 0xe1, 0x05, 0xd8, 0x11, 0xcd, 0x9a, 0xcf,
+	    0xbd, 0x69, 0x79, 0x3a,
+	0xf8, 0xc8, 0x63, 0x6b, 0x11, 0xae, 0x81, 0x51, 0x6f, 0xaf, 0x14, 0x18,
+	    0xb7, 0x4f, 0x33, 0xbf,
+	0x00, 0x0d, 0x93, 0xe0, 0x1f, 0x2c, 0x4c, 0x1f, 0xfe, 0x9f, 0x13, 0xb5,
+	    0x15, 0x08, 0xed, 0xb5,
+	0x8c, 0xc4, 0x22, 0x2a, 0x93, 0xe0, 0x48, 0xc6, 0xbd, 0x8e, 0xba, 0x47,
+	    0x96, 0x8f, 0xd5, 0xb8,
+	0xf6, 0xef, 0x94, 0xa3, 0x92, 0xec, 0x42, 0x85, 0xba, 0xae, 0xa4, 0x9c,
+	    0x5b, 0x10, 0x43, 0x35,
+	0x2d, 0xeb, 0x27, 0x3d, 0x75, 0x75, 0xb7, 0x0d, 0x33, 0x6f, 0x53, 0x7c,
+	    0xf8, 0x8a, 0xaf, 0x8b,
+	0xf1, 0x89, 0x03, 0xda, 0xa4, 0xf3, 0x80, 0x8b, 0x4c, 0x3e, 0x3b, 0xeb,
+	    0x4e, 0xe2, 0x9b, 0xc5,
+	0xfe, 0x98, 0x47, 0x99, 0xea, 0x1f, 0x14, 0x93, 0xc5, 0x01, 0x92, 0xc3,
+	    0xd7, 0x75, 0x64, 0x86,
+	0xa5, 0x81, 0x07, 0xf8, 0xe0, 0x4d, 0x5e, 0x16, 0x64, 0xd3, 0x2f, 0x5a,
+	    0xab, 0x8a, 0xa0, 0xfc,
+	0x2b, 0x04, 0xc2, 0x76, 0x66, 0xf2, 0x6d, 0x37, 0x19, 0xbe, 0x93, 0x45,
+	    0x8c, 0x5d, 0x92, 0xea,
+	0x84, 0x13, 0x10, 0xc8, 0x61, 0x76, 0x82, 0x74, 0x27, 0xc8, 0xd7, 0xa4,
+	    0x8d, 0x10, 0x94, 0x11,
+	0xc7, 0xf8, 0x44, 0xd8, 0xba, 0xb9, 0x4b, 0xbc, 0x9b, 0x56, 0x00, 0x58,
+	    0xd7, 0x6b, 0x95, 0xa0,
+	0xbd, 0xaa, 0xa6, 0xd3, 0xb5, 0xfd, 0x2a, 0x70, 0x66, 0xb6, 0x43, 0x6d,
+	    0x8c, 0x28, 0x80, 0x2c,
+	0x47, 0xc0, 0x18, 0x42, 0xb8, 0xd4, 0x6d, 0xea, 0xa6, 0xdd, 0x41, 0x85,
+	    0x0d, 0x9a, 0x57, 0x59,
+	0x14, 0x0a, 0x20, 0x35, 0x0a, 0x3d, 0x47, 0x11, 0xc3, 0xd1, 0x9e, 0x0d,
+	    0x7a, 0x4a, 0xa5, 0x34,
+	0x6c, 0x94, 0x01, 0xb9, 0xd7, 0x1d, 0x7e, 0xa6, 0x5f, 0x8c, 0xc8, 0x06,
+	    0x03, 0xf4, 0x14, 0x65,
+	0xc4, 0xf0, 0xcf, 0x8d, 0x7c, 0x2d, 0x3a, 0xbe, 0x18, 0x27, 0x99, 0x42,
+	    0xa3, 0x02, 0x88, 0xf5,
+	0x71, 0xdb, 0xf9, 0xbd, 0xb8, 0xf6, 0x88, 0x5d, 0x17, 0x21, 0x6c, 0xb8,
+	    0xfa, 0x43, 0x50, 0xdc,
+	0x44, 0x32, 0x89, 0xce, 0x65, 0x10, 0xe0, 0xab, 0xeb, 0x92, 0xd5, 0x90,
+	    0x89, 0xae, 0x36, 0xbd,
+	0x60, 0xdb, 0x60, 0x4c, 0x1c, 0x2e, 0xfe, 0x2f, 0xcf, 0x56, 0x94, 0x28,
+	    0x8f, 0x7a, 0xae, 0x4b,
+	0xe7, 0x10, 0xb4, 0xdb, 0x9c, 0x09, 0xa2, 0x0a, 0x67, 0xd2, 0x0a, 0x40,
+	    0x8a, 0xf2, 0x09, 0x4f,
+	0xdb, 0x98, 0x9f, 0x4d, 0xbb, 0x94, 0x98, 0x09, 0x6c, 0x96, 0xf7, 0xaf,
+	    0x17, 0xf8, 0xc3, 0x54,
+	0x10, 0x12, 0x4f, 0xc5, 0x33, 0xb2, 0x1f, 0xbf, 0x9e, 0x52, 0x4b, 0x80,
+	    0x5c, 0xbe, 0x60, 0x02,
+	0x62, 0x0d, 0xba, 0xf7, 0xda, 0x8b, 0x44, 0x5c, 0xf3, 0x25, 0x46, 0x6e,
+	    0xf7, 0x70, 0xa4, 0x34,
+	0x7e, 0x11, 0xf6, 0x23, 0x7a, 0x84, 0x20, 0x00, 0x2f, 0x5d, 0x4c, 0xe4,
+	    0xf0, 0xe0, 0x1b, 0x2f,
+	0xa1, 0x42, 0xe3, 0x01, 0x7b, 0xe7, 0x29, 0xce, 0x3d, 0xe3, 0xae, 0xc3,
+	    0x2d, 0xee, 0xce, 0xe1,
+	0xb3, 0xf2, 0x88, 0xe6, 0x71, 0x6f, 0xe1, 0x39, 0x7c, 0x0c, 0x25, 0xc6,
+	    0x55, 0xee, 0x38, 0x55,
+	0xe2, 0xd1, 0xbe, 0xd3, 0xf3, 0xf7, 0xf4, 0x12, 0xe1, 0x21, 0xe8, 0x23,
+	    0x5c, 0xbf, 0xe4, 0xd5,
+	0xd6, 0x67, 0x48, 0xa5, 0xd1, 0xa5, 0x30, 0x54, 0x97, 0x16, 0x8b, 0x33,
+	    0x5d, 0xba, 0x39, 0xa9,
+	0x8e, 0xda, 0xbf, 0xd3, 0xf9, 0x80, 0xec, 0x83, 0x9a, 0x42, 0xd1, 0x5c,
+	    0x2d, 0xbb, 0x20, 0xba,
+	0x7c, 0x8c, 0xf3, 0xa6, 0x45, 0x88, 0xfe, 0xdc, 0x2a, 0x2e, 0x66, 0xf0,
+	    0x2c, 0xba, 0x7c, 0x0e,
+	0xe9, 0x8b, 0xe3, 0x16, 0xc8, 0x9c, 0x4c, 0xca, 0x4c, 0xf5, 0xc0, 0x9e,
+	    0x5e, 0x2b, 0xf1, 0xe8,
+	0x2b, 0xf8, 0x62, 0x96, 0x1f, 0xf2, 0xae, 0x5a, 0xf6, 0xb4, 0x62, 0x34,
+	    0xa0, 0x26, 0x23, 0xfa,
+	0x04, 0x07, 0xa4, 0xfc, 0x04, 0x38, 0xd3, 0x88, 0x97, 0x55, 0x14, 0x1d,
+	    0xd1, 0x76, 0x75, 0x1f,
+	0x68, 0x88, 0x1b, 0x57, 0x24, 0x37, 0x0d, 0x5b, 0xa9, 0x63, 0xc1, 0xa6,
+	    0xa5, 0x74, 0x98, 0x71,
+	0x0c, 0x96, 0x25, 0xbd, 0xc0, 0x3c, 0x75, 0x8a, 0xaa, 0xed, 0xca, 0x69,
+	    0x25, 0x93, 0x3d, 0xce,
+	0xd8, 0x4c, 0x61, 0x03, 0xe2, 0xd1, 0x8e, 0x86, 0xb6, 0xcc, 0x4d, 0x8f,
+	    0xdf, 0xe0, 0x4b, 0x36,
+	0x29, 0xbe, 0xbd, 0xd7, 0x4f, 0xb3, 0x6b, 0x96, 0x23, 0x41, 0x43, 0x49,
+	    0xb9, 0xb0, 0xa7, 0xd9,
+	0x77, 0x2f, 0x68, 0x6b, 0x47, 0xca, 0x4a, 0x8a, 0xb1, 0x92, 0x89, 0xda,
+	    0x30, 0x0b, 0x51, 0x20,
+	0x02, 0xea, 0x7b, 0xf6, 0x52, 0xcf, 0x72, 0x89, 0x63, 0x53, 0x78, 0x36,
+	    0x70, 0x78, 0x05, 0xc8,
+	0x68, 0x7b, 0xf2, 0x92, 0xd8, 0x1b, 0x8f, 0x50, 0x65, 0x63, 0x5c, 0x38,
+	    0xb7, 0x7c, 0x8f, 0xd9,
+	0xa9, 0x78, 0x7e, 0xf6, 0xb7, 0xc3, 0x2b, 0x8d, 0xe6, 0xc0, 0x90, 0x55,
+	    0xd8, 0x83, 0xc1, 0x4c,
+	0x8b, 0x10, 0x5e, 0x66, 0x3d, 0x3e, 0xa1, 0xd1, 0xc9, 0xf7, 0xdf, 0x57,
+	    0x08, 0xf1, 0xe1, 0x48,
+	0xa5, 0x02, 0xc4, 0x98, 0x9c, 0x59, 0xb8, 0x60, 0x9e, 0x74, 0x10, 0x1f,
+	    0x87, 0x18, 0xbb, 0xee,
+	0xd5, 0xa0, 0xcc, 0x79, 0x33, 0xbc, 0xbe, 0xef, 0xad, 0xfe, 0x03, 0x0b,
+	    0x57, 0x88, 0x85, 0x3d,
+	0x86, 0xe3, 0xc5, 0xc5, 0xb2, 0x44, 0xf9, 0xa3, 0x61, 0x82, 0xb2, 0xa5,
+	    0xfa, 0x37, 0x3a, 0xeb,
+	0x51, 0x19, 0xcd, 0xee, 0xbb, 0x9c, 0x3b, 0xf5, 0x88, 0xd1, 0x9f, 0x95,
+	    0xf5, 0xf5, 0x54, 0x28,
+	0x28, 0xb8, 0x79, 0x7e, 0x19, 0x98, 0x03, 0x85, 0x81, 0x29, 0x6d, 0x5c,
+	    0x5c, 0x89, 0x4e, 0x89,
+	0x29, 0x19, 0x87, 0xef, 0x3e, 0xa8, 0x56, 0x2c, 0x80, 0x28, 0x7d, 0x7c,
+	    0x69, 0xf2, 0x47, 0x04,
+	0xf6, 0x68, 0xbd, 0x76, 0xbe, 0xe1, 0xbb, 0x41, 0x3c, 0x9c, 0x57, 0x21,
+	    0x11, 0x16, 0x0f, 0x9c,
+	0xab, 0x69, 0xf1, 0x9b, 0x58, 0x98, 0xdf, 0x21, 0x9d, 0x50, 0x0f, 0x80,
+	    0xff, 0x29, 0x2e, 0x4e,
+	0xd6, 0x5d, 0x50, 0x4c, 0x3f, 0x2b, 0xd6, 0x9a, 0x81, 0x99, 0xce, 0x79,
+	    0x38, 0x75, 0x31, 0xa3,
+	0xa6, 0xbb, 0xbf, 0xe5, 0x3b, 0x3d, 0xdf, 0x0b, 0x8b, 0x11, 0xcc, 0xec,
+	    0x58, 0x7c, 0x17, 0x8d,
+	0x8c, 0x93, 0x50, 0xcd, 0xba, 0x76, 0x29, 0xde, 0x81, 0xfb, 0x10, 0x7d,
+	    0xdb, 0x5f, 0xd3, 0x19,
+	0x9f, 0xb2, 0xc3, 0x77, 0xcb, 0x3f, 0x3e, 0xe3, 0x3b, 0xeb, 0x1f, 0x95,
+	    0x19, 0x7b, 0x00, 0xf1,
+	0x88, 0x8d, 0x12, 0xb4, 0x04, 0x65, 0x19, 0xc4, 0x54, 0xbd, 0x08, 0xd8,
+	    0x37, 0x98, 0xb8, 0x6d,
+	0x26, 0x8c, 0x9b, 0x1e, 0xf1, 0x14, 0x46, 0x34, 0xa4, 0x42, 0x28, 0x44,
+	    0xbe, 0x62, 0xba, 0x63,
+	0x80, 0xee, 0xd7, 0x2d, 0xea, 0x67, 0xc9, 0xd3, 0xc6, 0x73, 0x26, 0xcd,
+	    0x21, 0xad, 0xf2, 0x11,
+	0xfa, 0x80, 0x56, 0xd5, 0x16, 0xe5, 0x09, 0xc0, 0x49, 0xce, 0xe0, 0x29,
+	    0x30, 0x6a, 0xcc, 0x00,
+	0x85, 0x50, 0xbe, 0x75, 0x12, 0xe6, 0x22, 0x54, 0xad, 0x57, 0xc8, 0x98,
+	    0xdb, 0x62, 0x16, 0xc1,
+	0x6c, 0x03, 0x80, 0xd0, 0xeb, 0xe4, 0xd8, 0x82, 0xcf, 0x16, 0x64, 0xe6,
+	    0xda, 0x87, 0x83, 0x5c,
+	0x48, 0x0b, 0x3a, 0xd7, 0x69, 0xa8, 0x2b, 0x21, 0xba, 0x69, 0x71, 0xa7,
+	    0x82, 0x4b, 0xe9, 0xa0,
+	0x63, 0x28, 0xc5, 0x4f, 0x1e, 0x57, 0xce, 0x75, 0x30, 0x6c, 0x39, 0xfa,
+	    0x3d, 0xed, 0x7d, 0x1a,
+	0xff, 0xca, 0x15, 0x2a, 0xc8, 0x82, 0xc9, 0xda, 0x51, 0x39, 0xb6, 0xce,
+	    0x7e, 0xee, 0x32, 0x1e,
+	0x80, 0xc8, 0x81, 0x6d, 0x76, 0xa0, 0x9d, 0x13, 0xac, 0x66, 0x2b, 0xce,
+	    0x75, 0x18, 0xfb, 0x49,
+	0x71, 0x52, 0x04, 0xcb, 0x4d, 0x17, 0x4a, 0x55, 0x6b, 0x8b, 0xc2, 0x1f,
+	    0x7d, 0xe1, 0xc7, 0x3f,
+	0xc0, 0x01, 0xe8, 0x65, 0xfd, 0x54, 0xaa, 0x48, 0xf9, 0xa7, 0x7b, 0xb3,
+	    0x1b, 0xe6, 0xd4, 0xbb,
+	0xe6, 0x9c, 0xce, 0x42, 0x97, 0x9e, 0x78, 0x6a, 0x86, 0xa5, 0xf0, 0x11,
+	    0x1e, 0x13, 0xc5, 0x21,
+	0xd2, 0x22, 0x6a, 0x1f, 0xb1, 0xef, 0xab, 0x41, 0x35, 0x58, 0x85, 0xfa,
+	    0x41, 0x4a, 0x1d, 0x79,
+	0x0b, 0x98, 0xc7, 0xcb, 0x9e, 0x82, 0x7d, 0x44, 0xf0, 0x9b, 0x63, 0x1c,
+	    0xf3, 0x6f, 0x48, 0x44,
+	0x57, 0x24, 0xeb, 0x1e, 0x31, 0x18, 0x28, 0x7f, 0xb6, 0xd7, 0xf3, 0x73,
+	    0x36, 0x86, 0xe3, 0x1f,
+	0x3a, 0x92, 0xe8, 0x75, 0xb8, 0xbd, 0xb4, 0x2b, 0xc9, 0xd9, 0x8a, 0xb6,
+	    0xd7, 0xb1, 0x6c, 0x1f,
+	0x7b, 0xb0, 0xf3, 0x92, 0x33, 0x6a, 0xad, 0x36, 0x0e, 0x6b, 0xab, 0x32,
+	    0x26, 0x69, 0xa1, 0x83,
+	0xa4, 0xf2, 0x5a, 0x75, 0x95, 0x12, 0xb3, 0x98, 0xd8, 0x27, 0x8f, 0x5c,
+	    0x97, 0x18, 0xea, 0x1e,
+	0xa7, 0xf3, 0xa4, 0xb3, 0x6d, 0x22, 0x3b, 0x9e, 0x65, 0x9e, 0x85, 0x48,
+	    0x78, 0x91, 0x3b, 0xfb,
+	0x20, 0x74, 0xe4, 0x3a, 0x36, 0x3f, 0x53, 0x13, 0xfa, 0xc6, 0x31, 0xc6,
+	    0x0e, 0xe6, 0x6c, 0xe3,
+	0x4e, 0x6a, 0xbe, 0xec, 0xc0, 0x41, 0xec, 0xcd, 0x99, 0x00, 0x38, 0x56,
+	    0x0f, 0xf7, 0xc7, 0x2c,
+	0x5f, 0x4d, 0xbb, 0xfa, 0x49, 0x6b, 0x9d, 0x69, 0xe0, 0x0d, 0x35, 0x1f,
+	    0x64, 0xf2, 0xd6, 0x62,
+	0xc6, 0x48, 0x4d, 0x24, 0x3b, 0xba, 0x8e, 0xc8, 0x1d, 0x42, 0x3d, 0x46,
+	    0xee, 0xb5, 0x26, 0x8f,
+	0x30, 0x8a, 0x19, 0xdc, 0x12, 0x32, 0x30, 0x86, 0xec, 0xe4, 0xce, 0xb7,
+	    0x86, 0xa8, 0x6f, 0x97,
+	0x21, 0x32, 0x0e, 0xec, 0x5f, 0x3e, 0x3a, 0xfd, 0xec, 0xd7, 0x64, 0x87,
+	    0x7b, 0x63, 0xe0, 0xaa,
+	0x84, 0x68, 0x9f, 0xbf, 0xb1, 0x15, 0xa7, 0x6c, 0xee, 0x2f, 0xcb, 0xdd,
+	    0x07, 0x71, 0x57, 0x9f,
+	0x54, 0xd9, 0x6f, 0x3b, 0xe1, 0x3a, 0x9c, 0x2d, 0x31, 0x3d, 0xb7, 0xdd,
+	    0x0e, 0x50, 0xd9, 0xfb,
+	0x8f, 0x63, 0x4a, 0x4b, 0xc5, 0xd9, 0x05, 0x28, 0xed, 0x9a, 0x3c, 0xd6,
+	    0xfe, 0xec, 0x7f, 0xe7,
+	0xc4, 0xd9, 0x3a, 0x24, 0xe3, 0xf9, 0xc9, 0xfb, 0xe2, 0xd1, 0x7a, 0x7a,
+	    0x08, 0xa4, 0xdc, 0x6e,
+	0x59, 0x15, 0xdf, 0xf6, 0x45, 0x33, 0xc0, 0xcf, 0x61, 0xdc, 0x37, 0x03,
+	    0xf8, 0xfa, 0x35, 0xed,
+	0xd9, 0x30, 0x4c, 0xd8, 0x13, 0xda, 0x17, 0x84, 0x8f, 0x9f, 0x20, 0xff,
+	    0xdb, 0x72, 0x7f, 0xfd,
+	0x08, 0x42, 0x9e, 0x3d, 0x31, 0xc1, 0x80, 0x53, 0xc4, 0x31, 0x27, 0x1c,
+	    0x56, 0xc9, 0xd7, 0x00,
+	0x07, 0xc8, 0xd1, 0x88, 0xb4, 0x8a, 0xe3, 0x77, 0xbc, 0xf7, 0xa0, 0xa4,
+	    0xf2, 0x2f, 0x9b, 0xeb,
+	0xfb, 0xa2, 0xbf, 0x3c, 0xb3, 0xb2, 0xee, 0x52, 0x4c, 0x11, 0x4e, 0xa7,
+	    0x62, 0xc3, 0x70, 0xf9,
+	0xcb, 0x4e, 0xf1, 0xa8, 0x71, 0xdc, 0xa2, 0xab, 0xc2, 0x63, 0x93, 0x11,
+	    0x5e, 0x61, 0x7e, 0xa5,
+	0x6a, 0x09, 0x76, 0xb7, 0xfa, 0x66, 0x00, 0xfd, 0xe3, 0xcc, 0xcf, 0x2c,
+	    0xd0, 0x03, 0x72, 0xf5,
+	0xf4, 0x89, 0xa0, 0xd2, 0xef, 0x64, 0x1f, 0x80, 0x4b, 0x4a, 0xb8, 0xc6,
+	    0x35, 0x68, 0xce, 0xbe,
+	0x26, 0xb6, 0x1a, 0xd5, 0x6d, 0x28, 0xd1, 0x83, 0x40, 0x45, 0x53, 0xe1,
+	    0x87, 0x74, 0x9d, 0x81,
+	0x22, 0xff, 0x65, 0x2a, 0x59, 0x5e, 0x39, 0xd1, 0x9d, 0x4a, 0xa2, 0x52,
+	    0x72, 0xd8, 0x7d, 0xf9,
+	0xab, 0x48, 0x31, 0xee, 0x98, 0x18, 0x82, 0x76, 0xb9, 0x94, 0x25, 0x2d,
+	    0xd5, 0x64, 0xaa, 0x6b,
+	0xaa, 0x8a, 0x8d, 0xe1, 0x99, 0xf2, 0x7a, 0x3b, 0x48, 0xc2, 0xe2, 0x6c,
+	    0x49, 0xc6, 0x31, 0x39,
+	0x09, 0xa5, 0xbd, 0x34, 0x7a, 0x0a, 0xbc, 0x52, 0x15, 0x0b, 0xfb, 0x56,
+	    0x19, 0xe0, 0xad, 0xea,
+	0x05, 0xb6, 0x0b, 0x99, 0xea, 0x90, 0x4e, 0xdb, 0x65, 0xc0, 0xfd, 0xcc,
+	    0x03, 0x7b, 0x3c, 0x98,
+	0x35, 0x2c, 0x79, 0xdf, 0x2f, 0x26, 0x58, 0x69, 0xe9, 0x4a, 0x12, 0x30,
+	    0x50, 0x2c, 0x34, 0x01,
+	0x1b, 0x40, 0xce, 0x78, 0x28, 0x77, 0x3a, 0x3c, 0x0c, 0xc6, 0xd2, 0x8c,
+	    0xa4, 0x62, 0xd3, 0xa1,
+	0x1a, 0x43, 0xc5, 0xb1, 0x9a, 0xd5, 0x03, 0xf5, 0x2b, 0x41, 0xcc, 0x25,
+	    0x58, 0x6a, 0x35, 0x05,
+	0xaf, 0x0e, 0x73, 0xa7, 0x8b, 0x62, 0xdf, 0x9b, 0x2a, 0xb0, 0x1b, 0x61,
+	    0xe1, 0x64, 0xd1, 0x20,
+	0x2a, 0x82, 0xd4, 0x1d, 0xd1, 0x3f, 0x46, 0xa2, 0x8b, 0x34, 0xcd, 0x3d,
+	    0xd7, 0x32, 0xf3, 0x14,
+	0x0e, 0x38, 0xec, 0x34, 0x2f, 0x3e, 0xa5, 0x94, 0x52, 0x93, 0xfa, 0x49,
+	    0x75, 0x33, 0x5c, 0xa9,
+	0x05, 0x63, 0xe5, 0x87, 0xc9, 0x3f, 0xae, 0x43, 0x1d, 0x59, 0xce, 0xd2,
+	    0xf6, 0x1b, 0x22, 0xee,
+	0x78, 0x4e, 0xed, 0xd1, 0xca, 0xb8, 0xa5, 0x42, 0x99, 0xd2, 0x42, 0x84,
+	    0x8e, 0x33, 0x73, 0x31,
+	0x24, 0x3f, 0x9c, 0xf5, 0xb0, 0x23, 0x6c, 0x99, 0x43, 0x16, 0x78, 0xe6,
+	    0xe9, 0x6f, 0x1f, 0xeb,
+	0x48, 0x57, 0xf6, 0x3c, 0x99, 0x7a, 0x17, 0xa8, 0xc2, 0xca, 0x27, 0x04,
+	    0x6f, 0xa4, 0x95, 0x3d,
+	0x44, 0xed, 0xd3, 0xa7, 0x93, 0xb6, 0x0f, 0x34, 0x9a, 0x14, 0x71, 0x93,
+	    0x0d, 0xfb, 0x11, 0x75,
+	0x87, 0x79, 0x94, 0xfe, 0x16, 0xbb, 0xf1, 0x6e, 0xe0, 0x97, 0x1d, 0x2d,
+	    0x91, 0x8a, 0xea, 0x13,
+	0x29, 0x78, 0x06, 0x6e, 0xba, 0x7b, 0xef, 0xc8, 0x2e, 0xda, 0x56, 0x51,
+	    0x52, 0x7e, 0x21, 0xf6,
+	0xf0, 0xb6, 0xc8, 0x4d, 0x72, 0x93, 0x06, 0xbd, 0x29, 0x52, 0xe6, 0x3e,
+	    0x7c, 0x3d, 0xbe, 0x8b,
+	0xe8, 0xa7, 0x8d, 0x09, 0xfe, 0xe1, 0x0f, 0x2c, 0x88, 0x85, 0x1f, 0x54,
+	    0x9b, 0x5a, 0xda, 0xe2,
+	0x42, 0x88, 0x1f, 0x82, 0xc9, 0x8f, 0x59, 0x3d, 0xf6, 0x79, 0xa5, 0x5f,
+	    0x7b, 0x38, 0x06, 0xf7,
+	0x22, 0x70, 0x8c, 0xd1, 0xc5, 0x27, 0xf9, 0x92, 0xb7, 0x80, 0xae, 0x1c,
+	    0x35, 0xad, 0x4e, 0xc3,
+	0xe5, 0xb6, 0x86, 0xc5, 0x08, 0xab, 0xb7, 0xa7, 0x9e, 0xa1, 0xa6, 0x0c,
+	    0x27, 0x8c, 0x6f, 0x0b,
+	0xc1, 0xd8, 0xb3, 0xab, 0x37, 0xc8, 0x68, 0xb7, 0xb2, 0x5a, 0x17, 0x35,
+	    0xab, 0xf3, 0x29, 0xd4,
+	0x4a, 0xb0, 0x77, 0x22, 0x88, 0x18, 0xcf, 0x3e, 0xe9, 0xaa, 0x20, 0xe1,
+	    0x0d, 0x2f, 0x7e, 0xe0,
+	0x44, 0x05, 0xc0, 0x46, 0xfa, 0x2b, 0x66, 0xc0, 0xe8, 0x4b, 0x13, 0x10,
+	    0x88, 0x05, 0x88, 0x2c,
+	0x89, 0x3a, 0x96, 0x2f, 0xb2, 0xe0, 0x40, 0x15, 0x26, 0xc9, 0x8a, 0x26,
+	    0xd0, 0xf7, 0xdc, 0x2d,
+	0x27, 0x77, 0xa5, 0xe5, 0xa7, 0xc0, 0x61, 0xc1, 0x25, 0xa7, 0xef, 0x14,
+	    0x50, 0x49, 0x01, 0xeb,
+	0x49, 0xc3, 0xc9, 0xb7, 0xcb, 0xae, 0x41, 0x14, 0xa6, 0xc1, 0x18, 0x2d,
+	    0x49, 0x57, 0x24, 0x53,
+	0xe7, 0x7b, 0x9f, 0x01, 0xdc, 0xdd, 0xb0, 0x9f, 0x2e, 0x3f, 0x35, 0xe4,
+	    0xd6, 0x4d, 0x9a, 0xaf,
+	0x55, 0x30, 0x11, 0x91, 0xea, 0xd3, 0x42, 0x90, 0xeb, 0x3b, 0xdc, 0x5a,
+	    0xf6, 0x6c, 0xa1, 0xbe,
+	0xee, 0x5d, 0x1c, 0x3d, 0x5c, 0xff, 0x7b, 0xe1, 0x2c, 0x0a, 0xc9, 0x07,
+	    0x9c, 0xe0, 0x37, 0xd7,
+	0xac, 0xc4, 0x52, 0xd9, 0x96, 0x97, 0x02, 0x57, 0xb8, 0x38, 0xfd, 0x17,
+	    0x9f, 0xa5, 0xf8, 0xd1,
+	0x91, 0x75, 0xe8, 0xf0, 0xbf, 0xae, 0x4a, 0xd7, 0x06, 0x3a, 0xec, 0x21,
+	    0x0e, 0xa6, 0x83, 0x65,
+	0x98, 0xd4, 0xca, 0xbe, 0x43, 0xa4, 0xde, 0xc4, 0x2e, 0xc9, 0x65, 0x3e,
+	    0xde, 0xe7, 0x8e, 0x8f,
+	0xa3, 0xa3, 0x2b, 0xdb, 0x7d, 0xa5, 0x8c, 0xa9, 0xef, 0x19, 0xd2, 0xab,
+	    0xab, 0xab, 0x75, 0xa3,
+	0x8d, 0x24, 0xe1, 0xe4, 0x3e, 0xad, 0xac, 0xc8, 0x49, 0x46, 0x5b, 0x00,
+	    0xf9, 0x66, 0xb9, 0xfc,
+	0x71, 0x4d, 0xdd, 0x7e, 0xe1, 0x53, 0x48, 0x94, 0xb5, 0xca, 0xab, 0xb9,
+	    0x5d, 0xfc, 0xba, 0xfa,
+	0x05, 0xcf, 0x7a, 0x7a, 0x3d, 0xe5, 0x45, 0x3d, 0x9d, 0xc7, 0x82, 0x7a,
+	    0x57, 0x74, 0x54, 0xba,
+	0x88, 0xa5, 0xd8, 0xff, 0x61, 0x71, 0x81, 0x64, 0x6f, 0x51, 0xc9, 0xed,
+	    0x56, 0xbf, 0xb0, 0xed,
+	0xf0, 0xcc, 0x7a, 0xb7, 0x09, 0xe2, 0x38, 0xf9, 0x29, 0xbd, 0x24, 0x7e,
+	    0xd9, 0xa6, 0x97, 0x2f,
+	0xd8, 0x03, 0xb3, 0x02, 0x5d, 0xb1, 0x6d, 0x36, 0xc1, 0x2f, 0x3c, 0x44,
+	    0xd8, 0xff, 0x88, 0xe9,
+	0x19, 0x6e, 0xb6, 0x94, 0xf7, 0xb5, 0x39, 0x36, 0x4a, 0x2e, 0xfa, 0x67,
+	    0x3e, 0x5b, 0xb5, 0x9c,
+	0x20, 0x46, 0x1a, 0xe7, 0xd0, 0xdc, 0x99, 0x26, 0x43, 0xd6, 0x01, 0x23,
+	    0xb2, 0x29, 0x16, 0x3f,
+	0x52, 0xfd, 0xa5, 0x0a, 0x37, 0xa4, 0x64, 0x27, 0x40, 0x52, 0x3d, 0x4b,
+	    0x63, 0xb6, 0x06, 0xdc,
+	0xc2, 0x60, 0x5c, 0xfb, 0x91, 0x39, 0x70, 0xa5, 0xe7, 0xda, 0xcd, 0x1a,
+	    0x86, 0x0f, 0x32, 0xe0,
+	0x2f, 0xd9, 0x41, 0xa9, 0xaa, 0xe9, 0x46, 0x01, 0xad, 0x7e, 0xfc, 0x84,
+	    0x8c, 0xb5, 0xd3, 0x32,
+	0x4e, 0xf6, 0xbc, 0x75, 0x11, 0xf7, 0xd6, 0x75, 0x3a, 0x30, 0x2f, 0x0a,
+	    0x30, 0xad, 0x0c, 0xdd,
+	0x77, 0xe3, 0x56, 0x99, 0xdc, 0x66, 0x1f, 0xf7, 0x0c, 0x01, 0x27, 0xaa,
+	    0xf1, 0x0e, 0x18, 0x8c,
+	0xf2, 0x35, 0x30, 0xec, 0x1f, 0xe8, 0xcd, 0x4c, 0x6a, 0xab, 0x73, 0xdc,
+	    0x52, 0x70, 0x10, 0x9c,
+	0xb3, 0x66, 0x6e, 0x5a, 0x12, 0x4e, 0x29, 0x5c, 0x49, 0x2d, 0x06, 0xec,
+	    0x53, 0x9a, 0x83, 0x15,
+	0xad, 0xaa, 0x90, 0xb6, 0x40, 0x2b, 0xed, 0x43, 0xaa, 0x77, 0x97, 0x50,
+	    0xcf, 0x08, 0x11, 0x9c,
+	0x3b, 0x44, 0xab, 0x82, 0x45, 0x0a, 0x28, 0x53, 0xe3, 0x96, 0xf5, 0xfd,
+	    0xa0, 0x04, 0x41, 0x3b,
+	0xb2, 0x8e, 0xc2, 0x3f, 0x42, 0xb0, 0x08, 0x75, 0x05, 0x6a, 0x9d, 0x6a,
+	    0x2a, 0xb0, 0xfe, 0x25,
+	0xac, 0x93, 0x2e, 0x82, 0x35, 0x48, 0x45, 0xa4, 0xb2, 0x60, 0x2e, 0x41,
+	    0x77, 0x9d, 0x8f, 0x41,
+	0xa8, 0x45, 0xb8, 0xe7, 0xcd, 0x7b, 0x76, 0x18, 0x3c, 0x02, 0xaf, 0xea,
+	    0xfa, 0x45, 0x8f, 0xe4,
+	0x8b, 0x99, 0x78, 0xe1, 0xcb, 0xfd, 0xd0, 0xe5, 0x0b, 0x2b, 0x3f, 0x03,
+	    0x4d, 0xbe, 0x23, 0xa0,
+	0xd8, 0x23, 0x10, 0x3a, 0x0f, 0xad, 0x80, 0xa2, 0xc0, 0xc3, 0x1c, 0x4b,
+	    0x71, 0x12, 0xb1, 0x4a,
+	0x07, 0x1a, 0xee, 0xd9, 0x12, 0x73, 0x38, 0xcd, 0x63, 0xfa, 0xe6, 0x32,
+	    0xb0, 0xc2, 0x2e, 0x6e,
+	0x59, 0x9e, 0xfe, 0xff, 0x69, 0x4e, 0x4b, 0x0f, 0x63, 0x99, 0x54, 0x56,
+	    0xdd, 0x13, 0x19, 0xd1,
+	0xd9, 0xb6, 0xd3, 0xf3, 0xe9, 0x61, 0x9d, 0xc9, 0xc1, 0x01, 0x11, 0xc6,
+	    0x5d, 0x6e, 0x9f, 0x45,
+	0x04, 0x4d, 0x00, 0xe5, 0xa9, 0x8b, 0xc0, 0xe2, 0x9f, 0xcb, 0x57, 0x86,
+	    0xd0, 0x60, 0x70, 0x00,
+	0x0b, 0x0a, 0xf7, 0xb6, 0x37, 0x88, 0xf7, 0x86, 0x20, 0x10, 0xb8, 0xd4,
+	    0x4d, 0x6a, 0xed, 0xc3,
+	0x8b, 0x62, 0x65, 0x3f, 0x31, 0x43, 0x0b, 0x65, 0x61, 0x40, 0xce, 0x07,
+	    0xb2, 0x26, 0xd9, 0x23,
+	0xb0, 0x31, 0x5a, 0xca, 0x66, 0xae, 0x21, 0x56, 0xa0, 0xed, 0x59, 0x89,
+	    0x45, 0x66, 0x54, 0x32,
+	0x6a, 0xfd, 0xd6, 0xe0, 0xb9, 0xd1, 0xca, 0x6a, 0xc5, 0xc5, 0x6d, 0x5f,
+	    0x51, 0x19, 0x53, 0x38,
+	0x08, 0x49, 0x21, 0x04, 0x7a, 0xa7, 0x7a, 0x3a, 0x2f, 0x46, 0x92, 0xcf,
+	    0xd5, 0x94, 0x57, 0x37,
+	0xaa, 0x48, 0xdb, 0x14, 0x4d, 0xb7, 0xf4, 0xd6, 0x29, 0x9c, 0xed, 0x2b,
+	    0x39, 0xc9, 0xe7, 0x3d,
+	0x04, 0x4a, 0x18, 0x99, 0xb3, 0x70, 0xaf, 0x46, 0x6a, 0x90, 0xe3, 0x3f,
+	    0x7c, 0x2a, 0xba, 0x6c,
+	0x87, 0xa1, 0xe2, 0xa6, 0xf3, 0x9d, 0x2a, 0xea, 0x4b, 0x31, 0x57, 0x65,
+	    0xd8, 0xcb, 0xce, 0xdc,
+	0x52, 0xa2, 0xf4, 0xfd, 0xd3, 0x44, 0xa5, 0x83, 0xc9, 0x45, 0xda, 0x3c,
+	    0x4f, 0x2f, 0x98, 0xdb,
+	0x82, 0x04, 0xd9, 0x4f, 0x08, 0x6f, 0x09, 0x68, 0x69, 0x4d, 0xf5, 0x0f,
+	    0x55, 0xe8, 0xe3, 0x64,
+	0x0e, 0xde, 0xb3, 0x6f, 0xf0, 0x20, 0xa4, 0x1b, 0xeb, 0x42, 0x58, 0x6f,
+	    0xdd, 0xb4, 0x50, 0x5d,
+	0x97, 0x75, 0xbf, 0x0a, 0x31, 0x80, 0x5c, 0x30, 0x89, 0x61, 0x54, 0x58,
+	    0xe6, 0xd0, 0x75, 0x14,
+	0x0b, 0x14, 0xc4, 0x81, 0xe4, 0xac, 0x9c, 0x39, 0xcc, 0x58, 0x61, 0xcb,
+	    0xd2, 0x77, 0x3d, 0x6e,
+	0xa6, 0x31, 0x3a, 0x1e, 0x45, 0xa4, 0xd5, 0x39, 0x94, 0x59, 0xcb, 0x81,
+	    0x72, 0x8e, 0xa1, 0x1e,
+	0x5a, 0x8e, 0x26, 0xca, 0x48, 0xcf, 0x1b, 0x8e, 0xd9, 0x11, 0x32, 0x5b,
+	    0x08, 0x7c, 0x45, 0xa6,
+	0x9d, 0xef, 0xfc, 0x3b, 0xb0, 0x1c, 0x8b, 0xfb, 0xe2, 0x09, 0xcc, 0xed,
+	    0xab, 0xe9, 0x96, 0x0b,
+	0x54, 0xa0, 0xb4, 0xb6, 0x72, 0x75, 0xe3, 0xab, 0x65, 0x76, 0x85, 0xef,
+	    0x37, 0xe5, 0x6d, 0x3d,
+	0x6e, 0x54, 0x79, 0xa7, 0xf1, 0xe9, 0xd5, 0x0c, 0x17, 0xea, 0xfa, 0x61,
+	    0xd1, 0x0d, 0x92, 0x8d,
+	0xd0, 0xa2, 0xb5, 0xf1, 0xd8, 0x38, 0xb2, 0x93, 0xe5, 0x74, 0xfd, 0x92,
+	    0xd7, 0x35, 0xe7, 0x72,
+	0x2e, 0x61, 0x16, 0xa8, 0xe1, 0xc5, 0x0a, 0xa8, 0x20, 0x69, 0xf6, 0xf3,
+	    0xc3, 0x05, 0x8e, 0xe7,
+	0x2f, 0x3a, 0x4e, 0x65, 0xe9, 0x45, 0x47, 0xf6, 0xcc, 0xdf, 0xa0, 0x70,
+	    0xda, 0x7f, 0x83, 0xad,
+	0xc3, 0x15, 0xa8, 0xd7, 0x4d, 0xa6, 0x37, 0xdb, 0xcc, 0x34, 0xef, 0x2f,
+	    0x25, 0x65, 0x94, 0x77,
+	0x05, 0x16, 0x30, 0xd2, 0x2c, 0xe6, 0x04, 0x31, 0x4c, 0xdd, 0x97, 0xd2,
+	    0x9a, 0x5b, 0x19, 0x16,
+	0xc3, 0x75, 0x46, 0xb3, 0x3c, 0x1f, 0x7d, 0x6c, 0x4c, 0x16, 0x82, 0x99,
+	    0x7c, 0x5f, 0x9a, 0x36,
+	0x2f, 0xd6, 0x33, 0x58, 0x11, 0x33, 0xfa, 0x9a, 0x6d, 0x7e, 0x80, 0x1e,
+	    0x7f, 0xe0, 0x55, 0xc8,
+	0x15, 0x93, 0x5c, 0x23, 0x16, 0x33, 0x97, 0x48, 0x59, 0xf1, 0xfc, 0x69,
+	    0xdc, 0x34, 0x20, 0xf9,
+	0x8d, 0x7f, 0x0f, 0x79, 0x23, 0x7d, 0xbf, 0x02, 0x66, 0x22, 0x1f, 0x5c,
+	    0xa4, 0x3d, 0xe0, 0xfb,
+	0x63, 0xee, 0x9f, 0xe4, 0xe3, 0x10, 0x10, 0xdf, 0x76, 0x5b, 0x8e, 0xd7,
+	    0xd9, 0x46, 0x4e, 0xa6,
+	0x21, 0xc3, 0x07, 0x32, 0x98, 0x3c, 0x39, 0x36, 0x7e, 0xfa, 0xe3, 0x41,
+	    0x77, 0x11, 0x9e, 0x90,
+	0xea, 0x5f, 0x81, 0x65, 0x49, 0x7f, 0x11, 0xda, 0xe6, 0xb9, 0x6b, 0xe7,
+	    0x86, 0xa0, 0x7d, 0x66,
+	0x83, 0xa0, 0xcb, 0x13, 0x96, 0x63, 0xe4, 0x22, 0x24, 0x7c, 0xbf, 0x97,
+	    0x93, 0x43, 0xa0, 0x1b,
+	0xc9, 0xc6, 0x60, 0x74, 0x32, 0x0b, 0x0d, 0x9f, 0x46, 0x85, 0x8c, 0x14,
+	    0x65, 0x50, 0xe8, 0xd6,
+	0x3e, 0x15, 0x5a, 0xa5, 0x9b, 0xa8, 0x72, 0x70, 0xe4, 0x87, 0xe8, 0xe6,
+	    0x5b, 0xa7, 0x7c, 0x33,
+	0x80, 0x5d, 0x41, 0x34, 0x35, 0x25, 0x11, 0x60, 0x93, 0xcb, 0x0b, 0xe3,
+	    0xee, 0x02, 0xa9, 0x0f,
+	0x8f, 0x0f, 0x79, 0xd5, 0x9e, 0xca, 0x26, 0xad, 0x45, 0xe3, 0x20, 0x45,
+	    0xf3, 0x6a, 0xcf, 0x68,
+	0xbb, 0xed, 0x1d, 0x95, 0xe9, 0x3e, 0xed, 0xaa, 0x3b, 0xcd, 0x92, 0x26,
+	    0x7e, 0x2a, 0x93, 0x84,
+	0xfa, 0x22, 0x57, 0x70, 0x7f, 0x76, 0x44, 0x13, 0xa4, 0xf8, 0x9a, 0x3b,
+	    0x5b, 0x12, 0x1b, 0x4c,
+	0x52, 0x75, 0xeb, 0x9f, 0x7d, 0xdb, 0xf3, 0xd7, 0x67, 0x47, 0xb5, 0xab,
+	    0xa3, 0x73, 0x53, 0x1f,
+	0x7c, 0xc9, 0x52, 0xd8, 0x64, 0xdd, 0x97, 0xd3, 0x19, 0x0d, 0xa7, 0xbb,
+	    0xba, 0x19, 0x6a, 0xa8,
+	0x4f, 0x88, 0xda, 0x9e, 0xe5, 0xa3, 0xf9, 0x08, 0xc1, 0x4a, 0x89, 0x14,
+	    0xd3, 0x4a, 0x31, 0x59,
+	0x74, 0x81, 0x35, 0x2e, 0x19, 0x16, 0xbb, 0x1c, 0xc0, 0x4b, 0x02, 0x46,
+	    0x59, 0xce, 0x1b, 0x8d,
+	0x80, 0xcf, 0xdb, 0x1f, 0x96, 0xa1, 0x73, 0x2b, 0x96, 0xd5, 0x3e, 0xaf,
+	    0x90, 0x65, 0x32, 0xc8,
+	0x2a, 0xd0, 0x62, 0xdd, 0x9e, 0x45, 0x61, 0xbb, 0x87, 0x8d, 0x22, 0x1d,
+	    0x20, 0x60, 0xd9, 0xf9,
+	0xe5, 0xf3, 0x0d, 0x02, 0x4f, 0x24, 0x30, 0xe2, 0x6c, 0x91, 0xcc, 0x06,
+	    0x8b, 0x4f, 0x52, 0x94,
+	0xc4, 0x12, 0x17, 0x18, 0xc2, 0xdd, 0x26, 0xb3, 0x30, 0xd8, 0xac, 0xd4,
+	    0xce, 0xb0, 0x6f, 0xe1,
+	0xc4, 0x3a, 0x09, 0xf8, 0x2a, 0x4d, 0xf5, 0x5e, 0x1a, 0x2f, 0xd5, 0xe7,
+	    0x0b, 0xff, 0x5f, 0x17,
+	0x83, 0xa7, 0x12, 0x0c, 0x40, 0x25, 0xbd, 0xf4, 0xc1, 0x91, 0x7d, 0xab,
+	    0xcf, 0xfa, 0x74, 0xeb,
+	0x2a, 0xd4, 0xb0, 0x1b, 0xc1, 0xd1, 0x13, 0x19, 0xd3, 0x42, 0xa0, 0x60,
+	    0x8d, 0x98, 0x3c, 0xa1,
+	0x05, 0xf9, 0xb4, 0xa8, 0x94, 0xd0, 0xec, 0x8d, 0x61, 0xf6, 0x9f, 0x0c,
+	    0x71, 0x8c, 0xb4, 0x0a,
+	0x47, 0x39, 0xdd, 0x38, 0xb0, 0xf5, 0x0e, 0x67, 0xdb, 0xb6, 0x48, 0x7c,
+	    0x0d, 0xab, 0x0b, 0xb7,
+	0xa4, 0x67, 0x52, 0x35, 0x93, 0xf5, 0x11, 0x77, 0xcd, 0xd2, 0x79, 0xd3,
+	    0xf1, 0x3e, 0xe6, 0x2b,
+	0x73, 0x47, 0xae, 0x8b, 0xb3, 0xbc, 0xe9, 0xe3, 0x5f, 0xda, 0xf5, 0x46,
+	    0xae, 0xb5, 0xee, 0x3b,
+	0xed, 0x44, 0x3e, 0x80, 0x3c, 0x4d, 0x7f, 0xdc, 0x18, 0xd0, 0x29, 0x58,
+	    0xd8, 0x97, 0x93, 0xe9,
+	0x53, 0x27, 0xa3, 0xc8, 0xbf, 0x87, 0x8f, 0xd6, 0xcf, 0xba, 0x48, 0x47,
+	    0x66, 0xb7, 0x57, 0xbc,
+	0x50, 0x94, 0xa3, 0x85, 0xb8, 0x0f, 0xbf, 0xfc, 0xc9, 0xb5, 0xdd, 0x2f,
+	    0xfc, 0xd9, 0x3f, 0xdd,
+	0xc7, 0x9f, 0xad, 0xf2, 0x9f, 0xba, 0x09, 0x95, 0x68, 0xff, 0x17, 0x06,
+	    0x24, 0x77, 0x26, 0xdb,
+	0x0b, 0x3d, 0x1c, 0x4b, 0x39, 0x27, 0x41, 0x18, 0x92, 0x9f, 0xa0, 0x16,
+	    0xbf, 0x32, 0x9f, 0x4f,
+	0x98, 0xa4, 0xb7, 0xc6, 0x1d, 0xb8, 0x4f, 0x91, 0x4d, 0xbb, 0xf3, 0x09,
+	    0x1f, 0x51, 0x3f, 0xd9,
+	0x1a, 0xf3, 0xbb, 0xbd, 0x3d, 0xbc, 0x2b, 0x6c, 0x14, 0x22, 0x57, 0xe2,
+	    0xcc, 0xfb, 0xfa, 0x46,
+	0x50, 0x4c, 0xe0, 0x44, 0xae, 0xad, 0x2a, 0xc2, 0xc2, 0x48, 0x2b, 0xbe,
+	    0xa7, 0x21, 0xa0, 0x10,
+	0x86, 0x41, 0xb0, 0xc4, 0xe6, 0x2e, 0x60, 0x52, 0x02, 0xb1, 0xa3, 0xaa,
+	    0xa6, 0x20, 0x40, 0xe9,
+	0x4c, 0xcd, 0xf9, 0x87, 0x91, 0x75, 0xe3, 0x43, 0x83, 0x9d, 0x3d, 0x5e,
+	    0x0e, 0x9d, 0x99, 0x95,
+	0xcd, 0x7e, 0xb1, 0xc5, 0xcd, 0x2c, 0x13, 0x71, 0x62, 0x45, 0x75, 0xb5,
+	    0x2d, 0x43, 0xb8, 0x64,
+	0x31, 0x38, 0x99, 0xf6, 0xb5, 0x34, 0x50, 0x12, 0xc0, 0x23, 0xa8, 0x40,
+	    0x25, 0x60, 0xb5, 0x6b,
+	0x30, 0x90, 0x60, 0x15, 0x17, 0x9e, 0xa7, 0x92, 0x67, 0x49, 0x87, 0xa5,
+	    0x57, 0xbe, 0xf9, 0xaf,
+	0x92, 0x4b, 0x39, 0xad, 0x3c, 0x69, 0x95, 0x83, 0x40, 0x01, 0x0e, 0xc5,
+	    0xed, 0x76, 0x97, 0xac,
+	0x40, 0xdc, 0xb1, 0x93, 0xcb, 0x65, 0x61, 0x33, 0x40, 0xec, 0xa5, 0xf7,
+	    0xd2, 0x00, 0x5b, 0x3f,
+	0xad, 0xf7, 0xe2, 0x4c, 0xaa, 0xf5, 0x1a, 0x9a, 0xbd, 0x47, 0x3e, 0xae,
+	    0x59, 0xad, 0xb2, 0x5f,
+	0xcb, 0x8b, 0x1a, 0x6f, 0x36, 0xae, 0x43, 0x77, 0xec, 0xc9, 0x75, 0x98,
+	    0xdf, 0x9c, 0x5b, 0x05,
+	0xbb, 0x6d, 0xfb, 0x2a, 0x65, 0x25, 0xa7, 0x56, 0x6b, 0x0b, 0xab, 0xde,
+	    0xf2, 0xce, 0x03, 0x01,
+	0x09, 0xeb, 0x8e, 0x15, 0x1b, 0x2f, 0xe3, 0xbd, 0xfe, 0x58, 0x28, 0x9c,
+	    0x25, 0x28, 0xa5, 0x4c,
+	0x6d, 0xb2, 0xc9, 0xa5, 0x65, 0xe7, 0x3a, 0x60, 0x4c, 0xb7, 0xea, 0x93,
+	    0xbb, 0x63, 0x2b, 0x56,
+	0xdb, 0x79, 0xca, 0xde, 0x1a, 0x55, 0x62, 0xdc, 0xc9, 0x4e, 0x0c, 0x4c,
+	    0xba, 0x62, 0x1d, 0x7b,
+	0x8e, 0x42, 0x18, 0x49, 0x9e, 0x95, 0x7c, 0xab, 0x49, 0x40, 0x6c, 0x8f,
+	    0xfe, 0x68, 0x6c, 0xa8,
+	0x17, 0x4f, 0x91, 0x58, 0x38, 0x29, 0xdf, 0x0b, 0x68, 0x4c, 0x6f, 0x8d,
+	    0x24, 0x60, 0x97, 0x04,
+	0x73, 0xb9, 0x03, 0x66, 0xb2, 0x18, 0xd4, 0x5d, 0x49, 0x56, 0x2c, 0xd4,
+	    0xf0, 0xf6, 0x34, 0xd2,
+	0x82, 0x1d, 0xf4, 0xb0, 0xb3, 0x39, 0x64, 0x34, 0x5e, 0xa8, 0x0c, 0xf3,
+	    0x55, 0xfa, 0x3d, 0x7e,
+	0x84, 0x1e, 0x3e, 0xe7, 0xf1, 0x72, 0x9d, 0xa6, 0x83, 0x72, 0xb1, 0xe5,
+	    0xf4, 0x1c, 0xa9, 0xd3,
+	0x25, 0x1f, 0x3b, 0xf7, 0x46, 0x35, 0x8d, 0x35, 0x9a, 0xc7, 0x65, 0x88,
+	    0xf7, 0x50, 0x4c, 0x6f,
+	0x81, 0x94, 0x3c, 0x46, 0xd8, 0xb8, 0x58, 0x9b, 0xc3, 0xdc, 0xdb, 0xd3,
+	    0x74, 0x3f, 0x76, 0xed,
+	0xdc, 0x98, 0x5c, 0x28, 0xb3, 0xce, 0x43, 0xf5, 0xe1, 0x51, 0x5a, 0x1c,
+	    0xf5, 0xba, 0x3d, 0x07,
+	0x16, 0x57, 0xbd, 0x2d, 0xac, 0x79, 0x51, 0x03, 0xc6, 0x14, 0xfd, 0xc1,
+	    0x0f, 0xf7, 0x1f, 0x75,
+	0x54, 0xea, 0xc4, 0x2c, 0x89, 0xac, 0x55, 0x93, 0x01, 0x02, 0x4d, 0x1d,
+	    0xe5, 0x3a, 0x6e, 0x79,
+	0xab, 0x1a, 0x8e, 0xbb, 0x99, 0x54, 0x76, 0x0f, 0x9e, 0x85, 0x4f, 0x5c,
+	    0x87, 0x77, 0x66, 0x5a,
+	0xad, 0x17, 0x0a, 0x5b, 0xb9, 0x19, 0xde, 0xa4, 0xec, 0x50, 0xca, 0x50,
+	    0xd8, 0xfb, 0xc7, 0xa1,
+	0xa8, 0x14, 0x64, 0xca, 0x66, 0x32, 0x6f, 0x8e, 0x15, 0x55, 0xcd, 0xca,
+	    0x80, 0x38, 0xab, 0x5b,
+	0x0a, 0x15, 0x23, 0x5d, 0x1a, 0x7a, 0x9b, 0x06, 0xe5, 0x3b, 0xe7, 0x99,
+	    0xff, 0x82, 0x5c, 0xcd,
+	0xc1, 0x58, 0xc6, 0x48, 0x1d, 0x30, 0xd2, 0x18, 0x95, 0x53, 0xd4, 0x0a,
+	    0x5e, 0x7a, 0xde, 0x9f,
+	0xde, 0x94, 0x71, 0x2e, 0x1a, 0xbd, 0x64, 0x1a, 0xa3, 0xd7, 0x4e, 0x78,
+	    0x0c, 0x06, 0xe4, 0xce,
+	0x53, 0x11, 0x57, 0x49, 0x95, 0xf8, 0xc7, 0x6b, 0x37, 0xd1, 0xdf, 0x8a,
+	    0x07, 0x71, 0x6f, 0x4b,
+	0x2b, 0x15, 0x70, 0x59, 0xa5, 0x07, 0x96, 0x7d, 0xd0, 0x93, 0x5f, 0xb5,
+	    0xfb, 0x80, 0x79, 0xa5,
+	0xa1, 0xec, 0xaa, 0x64, 0x55, 0x20, 0x69, 0x6d, 0xe1, 0xae, 0x20, 0x54,
+	    0xa7, 0x52, 0xf3, 0xed,
+	0x21, 0x5a, 0xa2, 0x74, 0x56, 0xde, 0xe7, 0x33, 0x43, 0x38, 0x82, 0x8a,
+	    0xbe, 0x85, 0xc6, 0x43,
+	0x88, 0xc0, 0xd9, 0x23, 0x16, 0xa6, 0x53, 0x2b, 0xc5, 0x92, 0x0e, 0x1e,
+	    0x3f, 0xa6, 0x2d, 0xe3,
+	0x90, 0x52, 0xd1, 0x93, 0xea, 0x17, 0xfe, 0xb7, 0x80, 0x6e, 0x81, 0x0f,
+	    0x26, 0x5e, 0x88, 0xc8,
+	0x24, 0x52, 0xe8, 0x0a, 0xf7, 0xab, 0x8f, 0x99, 0xc4, 0xc7, 0x60, 0x19,
+	    0xdb, 0x52, 0xdf, 0x53,
+	0x8a, 0x89, 0xfa, 0x56, 0x11, 0x6c, 0xe8, 0xf0, 0x9a, 0x4a, 0x57, 0x52,
+	    0x73, 0xa9, 0x1e, 0x67,
+	0x09, 0x84, 0x71, 0x35, 0x61, 0x7b, 0xf5, 0x93, 0xce, 0xc9, 0xb9, 0x77,
+	    0x0b, 0x5b, 0x01, 0x53,
+	0xec, 0x63, 0xab, 0xe9, 0xab, 0x48, 0x23, 0x72, 0x64, 0x63, 0xf5, 0x30,
+	    0xb4, 0xf7, 0xe2, 0xd2,
+	0x2f, 0x85, 0x82, 0xfc, 0x9e, 0x80, 0xda, 0x13, 0x68, 0x8a, 0xea, 0xcd,
+	    0x81, 0x75, 0x22, 0x0a,
+	0x59, 0x5e, 0xd2, 0x39, 0xbc, 0x23, 0x62, 0xbe, 0x26, 0x62, 0xfa, 0xf9,
+	    0x6e, 0x1e, 0x5c, 0x74,
+	0x01, 0x3c, 0x9c, 0x6d, 0xdf, 0x75, 0x68, 0x5c, 0x25, 0x61, 0x1c, 0x0b,
+	    0xfc, 0xa9, 0xa9, 0x64,
+	0xee, 0x3f, 0x50, 0xfd, 0x31, 0x20, 0xc4, 0xbf, 0xaa, 0x30, 0x03, 0xad,
+	    0xad, 0xf9, 0x66, 0x4a,
+	0x8d, 0x82, 0x72, 0x3c, 0xe9, 0x71, 0x38, 0xa6, 0x48, 0xf7, 0x15, 0x86,
+	    0xf8, 0xa3, 0x2c, 0x28,
+	0xe4, 0x26, 0xa8, 0xe0, 0x1d, 0x42, 0x1a, 0x3b, 0xba, 0xc0, 0xf2, 0x6e,
+	    0x82, 0x50, 0x83, 0x74,
+	0xaa, 0xc0, 0xf1, 0x77, 0x98, 0x67, 0xd9, 0x96, 0xce, 0x8f, 0x63, 0x10,
+	    0x51, 0x58, 0x32, 0x59,
+	0x68, 0x89, 0x7b, 0x2d, 0xac, 0x8d, 0x31, 0x80, 0x6c, 0xc9, 0x54, 0x5b,
+	    0xfb, 0xad, 0x1c, 0x26,
+	0xa6, 0x98, 0x7f, 0x86, 0x47, 0xb0, 0xb4, 0x5b, 0x42, 0x92, 0xdf, 0x22,
+	    0x20, 0xbc, 0x24, 0x34,
+	0x84, 0x19, 0xf6, 0x1e, 0xeb, 0x6e, 0x6c, 0x3a, 0x47, 0x41, 0x38, 0xb2,
+	    0x02, 0xe6, 0xd1, 0xf1,
+	0x07, 0x94, 0x65, 0x7e, 0xd3, 0xde, 0xee, 0x09, 0xc0, 0xd4, 0xad, 0xa2,
+	    0x0a, 0x92, 0x29, 0x71,
+	0x04, 0x19, 0x12, 0xd0, 0x63, 0xb9, 0x38, 0x43, 0x77, 0xdc, 0x7d, 0x4e,
+	    0xd3, 0xb2, 0x65, 0x85,
+	0xc7, 0x62, 0x74, 0x42, 0x5f, 0x6a, 0xab, 0xe2, 0x42, 0x29, 0x0b, 0x19,
+	    0x89, 0x0b, 0xfc, 0xf6,
+	0xc6, 0x3a, 0xa2, 0x07, 0x7c, 0xf4, 0xc3, 0x69, 0x98, 0x94, 0x03, 0x09,
+	    0x88, 0x0a, 0x9a, 0xb1,
+	0x70, 0x49, 0x25, 0x53, 0xc1, 0x14, 0x99, 0x78, 0xe7, 0x56, 0x0a, 0x18,
+	    0x09, 0x09, 0xb6, 0x20,
+	0xd8, 0xdb, 0x2d, 0xa6, 0x60, 0xf5, 0xd1, 0x88, 0x39, 0x28, 0x02, 0x08,
+	    0x08, 0x08, 0xa1, 0xda,
+	0x8c, 0x97, 0xa2, 0xaa, 0xe1, 0x65, 0x82, 0x5a, 0xee, 0xd7, 0xef, 0x9c,
+	    0x1f, 0x07, 0x56, 0xbd,
+	0xd0, 0x96, 0xc9, 0xe0, 0xef, 0xb1, 0x46, 0x9d, 0x0e, 0xdb, 0x46, 0x56,
+	    0xc9, 0x72, 0x47, 0xcb,
+	0x0e, 0x47, 0x08, 0xab, 0x33, 0x47, 0x17, 0xbe, 0x8f, 0xcc, 0x4f, 0xdd,
+	    0xcf, 0x3f, 0xbf, 0x19,
+	0xac, 0x7c, 0x29, 0xe0, 0x67, 0x44, 0x47, 0x1d, 0xbd, 0x9a, 0x40, 0x59,
+	    0x1c, 0xeb, 0x75, 0x8c,
+	0x4c, 0x9a, 0x24, 0x32, 0x0a, 0xe9, 0xe6, 0xf5, 0xea, 0x08, 0x09, 0x11,
+	    0x81, 0x03, 0x4e, 0x38,
+	0x0b, 0x36, 0x38, 0xea, 0x5c, 0x5d, 0xbb, 0x81, 0xcc, 0xb8, 0x01, 0x01,
+	    0x80, 0x02, 0x47, 0x9b,
+	0x0f, 0x16, 0x56, 0xe1, 0x9a, 0xb8, 0xd3, 0x84, 0xcf, 0x1e, 0x08, 0x10,
+	    0x01, 0x01, 0x24, 0xd9,
+	0xc4, 0x25, 0x97, 0xf8, 0xdc, 0x40, 0x5f, 0x0c, 0xcb, 0x52, 0x00, 0x00,
+	    0xcb, 0xca, 0x80, 0x09,
+	0xde, 0x40, 0x3b, 0xa1, 0xe7, 0xdd, 0x4e, 0xb6, 0x98, 0xeb, 0xa8, 0xdb,
+	    0xa5, 0x03, 0xbf, 0x11,
+	0x8c, 0x0d, 0x33, 0xa5, 0x1f, 0x8e, 0x7e, 0xc1, 0x83, 0xc1, 0xe6, 0xa4,
+	    0xa4, 0xc2, 0x87, 0xa5,
+	0x0f, 0x00, 0x97, 0x95, 0x7b, 0xa0, 0xf7, 0x67, 0x21, 0xed, 0x6a, 0x5a,
+	    0xb8, 0xe0, 0x61, 0x6e,
+	0xc2, 0x63, 0x4d, 0x17, 0x9f, 0x8e, 0x67, 0xaf, 0x2a, 0xb5, 0x5d, 0xc6,
+	    0xdf, 0x67, 0xe8, 0xca,
+	0xe9, 0x90, 0x20, 0x7b, 0x36, 0x4a, 0x2e, 0xe1, 0xf7, 0xed, 0x8b, 0x64,
+	    0x54, 0x34, 0xed, 0x44,
+	0x84, 0x13, 0xe0, 0x96, 0xcf, 0x27, 0xc9, 0xe5, 0xaa, 0xc4, 0x27, 0x0a,
+	    0x7d, 0xba, 0x1f, 0x5a,
+	0x86, 0xad, 0x81, 0x7a, 0x9a, 0x4a, 0x47, 0x81, 0xb2, 0xe2, 0xfe, 0x1a,
+	    0xba, 0x6b, 0x19, 0xcf,
+	0x78, 0xa3, 0x99, 0x5d, 0xd3, 0xdc, 0x07, 0x93, 0xc7, 0xc2, 0x66, 0x45,
+	    0x52, 0xc8, 0x1a, 0x05,
+	0x6b, 0x68, 0xd4, 0x3d, 0xb9, 0xd7, 0x4c, 0xb3, 0x58, 0xe7, 0x56, 0x5f,
+	    0x32, 0xc9, 0xf1, 0x47,
+	0x4a, 0x96, 0x35, 0x2d, 0x5b, 0x86, 0x44, 0x0f, 0xc8, 0xe6, 0x4e, 0xc2,
+	    0xa4, 0xc8, 0x94, 0xf6,
+	0x69, 0xd9, 0xbd, 0xbd, 0xb6, 0xf5, 0x70, 0xd8, 0x2c, 0xfe, 0xab, 0xd2,
+	    0x31, 0xe9, 0xa4, 0xdb,
+	0x0a, 0x4d, 0xc9, 0x63, 0xf3, 0x49, 0x2d, 0xc8, 0x29, 0x0b, 0xd9, 0xce,
+	    0x9b, 0xb6, 0xb5, 0xb7,
+	0xc2, 0xdb, 0xc2, 0x4e, 0x1e, 0xd7, 0xe1, 0x8a, 0x22, 0xce, 0x17, 0x12,
+	    0x38, 0x88, 0x6c, 0xe2,
+	0xf8, 0x38, 0x4b, 0x4c, 0x64, 0x6d, 0x9e, 0x8b, 0x45, 0xb8, 0x6d, 0xfc,
+	    0x2c, 0x6d, 0xb8, 0x5a,
+	0x70, 0xb1, 0xc7, 0x52, 0x94, 0x2d, 0x2d, 0xf9, 0x3f, 0xed, 0xad, 0xe1,
+	    0x5a, 0xfc, 0x0a, 0x32,
+	0x04, 0x89, 0xeb, 0x59, 0xe4, 0x0f, 0x9a, 0x06, 0xe5, 0xe9, 0xec, 0x4d,
+	    0xa8, 0x6f, 0x12, 0x78,
+	0x20, 0x52, 0x84, 0xbf, 0x58, 0xab, 0xcb, 0xa1, 0xbc, 0x52, 0xcc, 0xa1,
+	    0x74, 0x30, 0x34, 0x6f,
+	0xd4, 0x72, 0x33, 0x7c, 0x35, 0x5d, 0x7a, 0x39, 0x62, 0x31, 0x48, 0x27,
+	    0xd0, 0xae, 0x84, 0xda,
+	0x5d, 0xb3, 0x85, 0x01, 0xa4, 0x8e, 0xc8, 0xa5, 0x5d, 0x3c, 0x6c, 0x9a,
+	    0xe6, 0x8f, 0x22, 0xee,
+	0x78, 0x8c, 0x59, 0xcb, 0x9f, 0xef, 0x9d, 0xb5, 0x16, 0xfe, 0x22, 0x84,
+	    0x50, 0x8c, 0xe1, 0xd4,
+	0xa5, 0x02, 0x40, 0xc0, 0x3e, 0xc8, 0xef, 0xf3, 0x98, 0xe9, 0x00, 0x1a,
+	    0x8f, 0xd5, 0x8a, 0x17,
+	0xe1, 0x15, 0x5b, 0x94, 0x3f, 0x75, 0xa1, 0x78, 0x75, 0x15, 0x8a, 0x78,
+	    0x98, 0x27, 0x15, 0xdc,
+	0xd3, 0xbb, 0xfb, 0x45, 0x3f, 0x90, 0x73, 0x5b, 0x13, 0xfd, 0x10, 0x16,
+	    0xec, 0xab, 0x45, 0x61,
+	0x4a, 0x56, 0xcb, 0x6d, 0x5a, 0x14, 0xdd, 0xd9, 0xf9, 0x17, 0x5d, 0xe5,
+	    0xbc, 0xda, 0x56, 0x80,
+	0x64, 0xa5, 0xef, 0x67, 0x50, 0xfa, 0xc6, 0x08, 0xc9, 0xf8, 0x2d, 0x09,
+	    0x8f, 0x85, 0xda, 0x62,
+	0xc0, 0xa8, 0xc8, 0x6f, 0x73, 0x9d, 0x9a, 0xca, 0x82, 0x0b, 0x25, 0x0d,
+	    0x73, 0xd6, 0x11, 0xeb,
+	0x53, 0x87, 0xf9, 0x19, 0x4d, 0x99, 0x49, 0x25, 0xe0, 0x5e, 0x81, 0x29,
+	    0x13, 0x38, 0x25, 0x49,
+	0x0a, 0x93, 0xdf, 0x15, 0x9b, 0x4b, 0xa2, 0xc9, 0xed, 0x50, 0xdb, 0xae,
+	    0xcd, 0x99, 0x5e, 0x48,
+	0xe2, 0x5e, 0x96, 0xae, 0x30, 0x97, 0xd6, 0x71, 0x83, 0xbe, 0x96, 0xab,
+	    0xb0, 0x7f, 0x70, 0xa6,
+	0xe3, 0xe0, 0xae, 0x2d, 0x75, 0x1d, 0x4a, 0x8b, 0x4f, 0x54, 0xd2, 0x8f,
+	    0x51, 0x7e, 0xe7, 0xda,
+	0xa0, 0x7a, 0x81, 0x47, 0xd1, 0xfc, 0xbb, 0x7b, 0xea, 0x56, 0xdf, 0xe8,
+	    0xfe, 0xde, 0x37, 0x5d,
+	0xbf, 0xe1, 0x91, 0x55, 0x29, 0x94, 0x1f, 0xea, 0xed, 0x1b, 0xe7, 0x7c,
+	    0x90, 0xdd, 0x97, 0x26,
+	0x22, 0xc0, 0xde, 0x83, 0xfd, 0x43, 0x98, 0xa8, 0x94, 0x54, 0xe6, 0xa3,
+	    0xbf, 0x82, 0x9f, 0x13,
+	0x88, 0x8d, 0x7a, 0xb3, 0xe2, 0x5c, 0xb8, 0xf4, 0xd7, 0xc2, 0x47, 0x45,
+	    0x33, 0x82, 0x21, 0x27,
+	0x0b, 0x80, 0xb7, 0x65, 0x6b, 0x0f, 0x16, 0x38, 0xaf, 0xb6, 0x8f, 0x92,
+	    0xbc, 0xef, 0x41, 0xe2,
+	0x8f, 0x67, 0xbf, 0x87, 0x7e, 0x21, 0xda, 0xc8, 0xe7, 0xd3, 0x42, 0x48,
+	    0xbd, 0x61, 0x60, 0x82,
+	0x0a, 0xc4, 0x47, 0xd6, 0x7d, 0xe6, 0x48, 0x9c, 0xbb, 0x65, 0x30, 0x6a,
+	    0x8f, 0x19, 0xd1, 0x95,
+	0xc5, 0x85, 0x8e, 0xd3, 0x14, 0xc5, 0x83, 0x0d, 0x2f, 0x47, 0x2c, 0x88,
+	    0xaa, 0x64, 0xe1, 0x85,
+	0x32, 0x27, 0x61, 0x34, 0x90, 0xc8, 0x49, 0x9c, 0x33, 0xa5, 0xe7, 0x05,
+	    0x29, 0x3b, 0x21, 0x56,
+	0x83, 0xc7, 0x69, 0x46, 0x9e, 0x0a, 0x07, 0xf7, 0x32, 0x64, 0xd1, 0x84,
+	    0xc9, 0x3a, 0x7c, 0x8e,
+	0x8d, 0x23, 0x19, 0xbf, 0x12, 0x07, 0x30, 0xd7, 0x4c, 0xcc, 0xcc, 0xbe,
+	    0xa9, 0x4b, 0x02, 0x5c,
+	0x51, 0x7c, 0xe8, 0x9a, 0x19, 0x89, 0x7f, 0x9a, 0x59, 0x49, 0xfe, 0x2d,
+	    0x1f, 0xab, 0xe7, 0x1c,
+	0xe7, 0x08, 0x67, 0xfc, 0x96, 0x0e, 0xb3, 0xd6, 0xc4, 0x3e, 0x77, 0xdc,
+	    0xd2, 0x45, 0xbd, 0xe7,
+	0x8d, 0x3e, 0x58, 0x20, 0xf1, 0x70, 0xe4, 0x3f, 0x4d, 0x8b, 0x13, 0x22,
+	    0x34, 0xf9, 0xc9, 0xbb,
+	0xb1, 0xec, 0x32, 0x2e, 0x56, 0x07, 0xb6, 0x99, 0x44, 0x82, 0xa0, 0x79,
+	    0xb5, 0xbe, 0x0b, 0xab,
+	0xdf, 0x8d, 0xd0, 0xad, 0x4d, 0x00, 0x2a, 0x90, 0xb4, 0x69, 0x9c, 0x1c,
+	    0xa8, 0x10, 0x3d, 0xa4,
+	0xac, 0xc2, 0xa0, 0x4e, 0x1e, 0xce, 0xf4, 0xcb, 0x18, 0x71, 0x44, 0xf7,
+	    0x23, 0x8d, 0x35, 0x40,
+	0x8b, 0x24, 0x2b, 0x2f, 0x9b, 0xa6, 0x8c, 0x04, 0x07, 0x18, 0xed, 0x1d,
+	    0x20, 0x32, 0x25, 0x71,
+	0xee, 0x3b, 0xa5, 0x77, 0x3a, 0x54, 0x7f, 0x53, 0x2e, 0x64, 0x07, 0x37,
+	    0x88, 0x32, 0x0b, 0x63,
+	0xc9, 0x9d, 0x79, 0x67, 0x3b, 0x55, 0xab, 0x3a, 0x47, 0xa1, 0x86, 0x45,
+	    0xbf, 0x5a, 0x42, 0x8b,
+	0xcf, 0x57, 0xfb, 0x17, 0x35, 0xb6, 0x6b, 0x37, 0x65, 0x76, 0x16, 0x31,
+	    0x28, 0x14, 0x73, 0xa0,
+	0x25, 0x38, 0xf3, 0x07, 0x34, 0x1e, 0x6b, 0xc0, 0x8f, 0x7b, 0xdf, 0xb3,
+	    0x21, 0x25, 0x44, 0xdb,
+	0xee, 0xd6, 0xa1, 0x64, 0xb6, 0x44, 0x52, 0x63, 0xea, 0x79, 0x95, 0x17,
+	    0x30, 0xfa, 0x52, 0xac,
+	0x84, 0xf0, 0x2e, 0x56, 0x5c, 0x57, 0xbc, 0xfe, 0xb8, 0xd1, 0xbd, 0x7c,
+	    0x1c, 0xc7, 0xc5, 0xd0,
+	0xac, 0xf2, 0xbb, 0x56, 0x24, 0x1d, 0xce, 0xf0, 0x1b, 0xd9, 0xab, 0x72,
+	    0xfe, 0x5d, 0x53, 0xac,
+	0x04, 0x35, 0xe9, 0x26, 0xa5, 0xa1, 0x7a, 0xe0, 0xe1, 0x93, 0x85, 0xf5,
+	    0xab, 0x5c, 0x14, 0x9a,
+	0xa9, 0x8e, 0xf0, 0xdf, 0x5e, 0xb3, 0x64, 0x4a, 0x3e, 0x2d, 0x11, 0x31,
+	    0x97, 0x4e, 0x70, 0x95,
+	0x7f, 0xd7, 0x99, 0xa3, 0xce, 0xfb, 0x45, 0x3e, 0x79, 0x65, 0x0c, 0x4d,
+	    0x91, 0x52, 0x04, 0x91,
+	0x74, 0x2e, 0xe4, 0xb0, 0xdc, 0x65, 0x25, 0x55, 0x14, 0xd9, 0xe9, 0x35,
+	    0xf8, 0x55, 0x4e, 0x3b,
+	0x7b, 0x24, 0x2e, 0xc4, 0x40, 0x1a, 0x80, 0x8a, 0x4c, 0x24, 0x89, 0xb7,
+	    0x16, 0x7e, 0xa0, 0xb9,
+	0x2c, 0x37, 0xb8, 0x47, 0x1c, 0xbf, 0x50, 0x6b, 0xe2, 0x71, 0xb0, 0x64,
+	    0x15, 0x3e, 0x16, 0xeb,
+	0x29, 0x32, 0xf8, 0x7e, 0xc0, 0x30, 0xc1, 0x18, 0x71, 0x9d, 0xa0, 0x76,
+	    0xed, 0x56, 0x1f, 0xcf,
+	0x4e, 0x4b, 0x62, 0xeb, 0x57, 0xbc, 0xcc, 0x09, 0x42, 0x73, 0xbf, 0x1e,
+	    0xb0, 0xde, 0xaf, 0xa5,
+	0xc5, 0xbd, 0x3b, 0x21, 0x47, 0x3e, 0x7f, 0xad, 0x6c, 0xd1, 0xba, 0x1f,
+	    0xdd, 0x8f, 0xc3, 0x3f,
+	0x02, 0xdb, 0xc7, 0xea, 0xa8, 0xd2, 0x2e, 0x0d, 0x20, 0x4a, 0xd8, 0x21,
+	    0x54, 0x80, 0x08, 0x94,
+	0x15, 0xbd, 0x5c, 0x87, 0xb0, 0xfe, 0xe1, 0x7b, 0xbc, 0x7d, 0xa6, 0x95,
+	    0x73, 0x6c, 0x01, 0x3a,
+	0xe0, 0x99, 0x41, 0x09, 0x72, 0xdd, 0xee, 0x53, 0xa2, 0x74, 0x86, 0x9e,
+	    0x90, 0x10, 0xb6, 0x20,
+	0x20, 0xfc, 0x36, 0x24, 0x30, 0xdc, 0xc4, 0x30, 0x41, 0x83, 0x1b, 0xc9,
+	    0x43, 0x98, 0xe7, 0xd1,
+	0xeb, 0x96, 0x7f, 0x75, 0x58, 0x8b, 0xf4, 0x02, 0xa9, 0x06, 0x7c, 0xe2,
+	    0x42, 0x99, 0xe4, 0xf5,
+	0xd6, 0x66, 0xb6, 0xc4, 0x70, 0x35, 0x6b, 0x41, 0xb2, 0x2b, 0xf8, 0x75,
+	    0xde, 0x23, 0xf2, 0xcc,
+	0xb1, 0x46, 0x87, 0x3b, 0xf8, 0xa4, 0xe5, 0x03, 0x29, 0x24, 0x81, 0x13,
+	    0xde, 0x08, 0xe2, 0x9b,
+	0x38, 0x86, 0xdf, 0xc0, 0x78, 0xc5, 0x3b, 0x71, 0xc0, 0x27, 0x5c, 0x9d,
+	    0x60, 0x2a, 0xb9, 0xad,
+	0xff, 0xf5, 0x39, 0xa9, 0xef, 0xd5, 0xcf, 0x29, 0x7f, 0x7e, 0xf2, 0x2e,
+	    0x18, 0xb3, 0xb1, 0xa8,
+	0xc5, 0xa6, 0x31, 0xad, 0x53, 0x86, 0xbb, 0xa4, 0xd1, 0xbb, 0xd8, 0x23,
+	    0x13, 0xc2, 0x11, 0x4b,
+	0x63, 0x78, 0x95, 0x99, 0x73, 0xe8, 0x4e, 0xe9, 0x54, 0xf8, 0xf2, 0xd0,
+	    0xda, 0xbe, 0xca, 0x1b,
+	0xa9, 0xa6, 0xcd, 0x62, 0xf1, 0x19, 0xae, 0xa0, 0x7d, 0x99, 0x59, 0x26,
+	    0xb2, 0x89, 0x68, 0xbb,
+	0x44, 0xd1, 0xf8, 0xfd, 0x5c, 0x83, 0xd2, 0x7d, 0x72, 0xe8, 0x2d, 0xcc,
+	    0xb3, 0x0c, 0x74, 0xfc,
+	0x29, 0x00, 0xec, 0xcc, 0x97, 0x20, 0xbc, 0x89, 0x81, 0x6d, 0x3a, 0x75,
+	    0xa6, 0xe7, 0x11, 0x52,
+	0x61, 0xcc, 0x01, 0x5e, 0xd0, 0x6a, 0x12, 0xff, 0x02, 0x7c, 0x3f, 0x6f,
+	    0xd2, 0x02, 0x5f, 0xf9,
+	0xdb, 0x1f, 0xb5, 0xd9, 0x37, 0x22, 0x05, 0xeb, 0xc3, 0xeb, 0x18, 0x3a,
+	    0xd5, 0xc0, 0x47, 0xff,
+	0x0e, 0xb6, 0x92, 0x46, 0xb3, 0x76, 0xaf, 0x11, 0x72, 0xff, 0x5a, 0x1f,
+	    0x74, 0x01, 0x34, 0x6f,
+	0xd4, 0x72, 0x3b, 0x95, 0xbc, 0x3d, 0x22, 0x31, 0xee, 0xd7, 0x1e, 0x48,
+	    0xe3, 0x8a, 0x3d, 0x7f,
+	0x5d, 0xb3, 0x32, 0xa1, 0x3f, 0x30, 0x54, 0xb2, 0xd4, 0x70, 0xab, 0x04,
+	    0xd2, 0x7f, 0xf6, 0xee,
+	0xc9, 0x61, 0xe5, 0x8a, 0xb3, 0x87, 0x1d, 0xf1, 0x98, 0xf7, 0xf5, 0xb7,
+	    0xb1, 0xa8, 0x04, 0xb3,
+	0x1e, 0x95, 0xcc, 0x3b, 0x93, 0x35, 0x6a, 0x61, 0x42, 0x59, 0x03, 0x06,
+	    0x0d, 0x74, 0x29, 0x3e,
+	0xba, 0xe8, 0x3d, 0x3c, 0xd0, 0x78, 0x7f, 0xf0, 0xab, 0xb4, 0x87, 0xf4,
+	    0xf1, 0x3d, 0x0d, 0x3e,
+	0x43, 0x95, 0xfd, 0xc0, 0xb6, 0x26, 0xd2, 0xa7, 0x70, 0xfd, 0x0e, 0xf1,
+	    0x89, 0x70, 0x60, 0x3c,
+	0xab, 0x13, 0x8f, 0x35, 0xbf, 0x77, 0x7a, 0x00, 0x7f, 0x97, 0xcd, 0x97,
+	    0x40, 0x12, 0x78, 0x05,
+	0xdd, 0xbb, 0xc2, 0xf3, 0x58, 0x3a, 0xd4, 0xae, 0xa0, 0xfa, 0xf7, 0x51,
+	    0x7b, 0xac, 0xde, 0x38,
+	0x88, 0x38, 0xeb, 0x6f, 0x2b, 0x3a, 0x26, 0x47, 0xd5, 0xbb, 0xdd, 0x82,
+	    0x67, 0x62, 0xc6, 0x7a,
+	0xbe, 0xb7, 0xf9, 0x04, 0x59, 0xb9, 0xb3, 0xcb, 0x1f, 0x3f, 0xd5, 0xb2,
+	    0xb2, 0xd7, 0x5f, 0x81,
+	0xb9, 0x60, 0x8e, 0x8d, 0xc6, 0x3b, 0xae, 0x31, 0x51, 0x69, 0x1f, 0xfa,
+	    0xd7, 0xa7, 0xc4, 0x25,
+	0x22, 0x47, 0xc7, 0xc9, 0x78, 0x37, 0xbe, 0x62, 0xea, 0xec, 0xee, 0x07,
+	    0xd6, 0x71, 0x09, 0xd6,
+	0x7d, 0x29, 0xdc, 0xe8, 0x18, 0x5d, 0x5e, 0xeb, 0x07, 0xe9, 0x72, 0x78,
+	    0x67, 0x7c, 0x22, 0x20,
+	0xa9, 0x6a, 0x43, 0xc9, 0xaa, 0x1b, 0xff, 0x63, 0x81, 0xca, 0x2e, 0xca,
+	    0x5b, 0x01, 0x88, 0xf6,
+	0xf1, 0x4a, 0x4f, 0xd5, 0xd1, 0xbe, 0x01, 0xf6, 0xa7, 0x11, 0x87, 0xed,
+	    0x10, 0x4e, 0x60, 0x33,
+	0x78, 0x7f, 0xde, 0x8f, 0xe1, 0x03, 0x05, 0xbf, 0x42, 0x90, 0x98, 0x24,
+	    0x3f, 0x57, 0x3a, 0xea,
+	0x05, 0xc3, 0xea, 0xe7, 0xb6, 0xe1, 0x00, 0xcc, 0xb8, 0x60, 0xe8, 0x54,
+	    0x11, 0x3a, 0x1b, 0xa6,
+	0x73, 0x37, 0xe0, 0xf4, 0x86, 0x0f, 0x43, 0xdc, 0xea, 0x64, 0x35, 0xaa,
+	    0x3d, 0xc1, 0xa8, 0x48,
+	0x78, 0x22, 0x9b, 0x29, 0x36, 0x02, 0x01, 0xcc, 0x30, 0xa0, 0xd8, 0xca,
+	    0x77, 0xe7, 0xbd, 0x43,
+	0x31, 0xb2, 0x9e, 0xc3, 0x34, 0x72, 0xb0, 0xfc, 0x8e, 0xa6, 0x64, 0xe4,
+	    0xcc, 0xee, 0x56, 0x7f,
+	0x67, 0x8f, 0x49, 0xcf, 0x13, 0x05, 0x42, 0x81, 0x95, 0x61, 0x10, 0x6e,
+	    0xd7, 0xa5, 0x3c, 0x83,
+	0x06, 0x56, 0x9e, 0xdf, 0x92, 0x66, 0x96, 0x92, 0x1c, 0xd6, 0xc9, 0xc7,
+	    0x3b, 0x66, 0x96, 0x21,
+	0xe5, 0xb1, 0xb2, 0x95, 0x14, 0xe1, 0xbb, 0x45, 0x0f, 0x25, 0x51, 0x6f,
+	    0x55, 0xd1, 0x1a, 0xf5,
+	0xf9, 0xeb, 0x67, 0xfd, 0x02, 0x75, 0xc9, 0x55, 0x24, 0x0a, 0xb0, 0xd2,
+	    0xce, 0x13, 0x54, 0x97,
+	0xf8, 0x0a, 0xec, 0x9f, 0x9d, 0x3d, 0x7c, 0xc9, 0x07, 0x34, 0xfc, 0xcf,
+	    0x1b, 0x5d, 0xd8, 0x74,
+	0xec, 0x86, 0xf5, 0x83, 0x77, 0xf8, 0x4d, 0xbf, 0x39, 0x69, 0xe3, 0x31,
+	    0x9e, 0x1e, 0x8d, 0xe8,
+	0x9b, 0x7e, 0xed, 0x9b, 0x99, 0xcb, 0x2d, 0xb2, 0x26, 0xf9, 0xe5, 0xaa,
+	    0x1c, 0xef, 0x9b, 0x01,
+	0xf3, 0xb0, 0x55, 0x6a, 0x9f, 0xa1, 0xc4, 0x9b, 0xa6, 0xc8, 0xba, 0x0c,
+	    0x7c, 0x21, 0xcb, 0xc6,
+	0x97, 0x7f, 0xc2, 0x58, 0x9e, 0xa3, 0x7b, 0x48, 0xa4, 0x48, 0x7a, 0x38,
+	    0x4b, 0xeb, 0xbe, 0x4a,
+	0x12, 0x3c, 0xcb, 0xad, 0x1f, 0xca, 0x4d, 0x5a, 0xa5, 0xc1, 0xf1, 0xa9,
+	    0xca, 0xea, 0x4b, 0xc6,
+	0xad, 0x1f, 0xb5, 0x9d, 0x8f, 0xa9, 0x45, 0xfb, 0xec, 0x4d, 0x9e, 0xbf,
+	    0x7e, 0x65, 0x20, 0x6e,
+	0xbe, 0xab, 0x84, 0x82, 0x4b, 0xf0, 0xf4, 0xae, 0x8f, 0x6f, 0x60, 0xf8,
+	    0xe7, 0xcf, 0xb9, 0xa2,
+	0x26, 0x6e, 0x77, 0x96, 0xcd, 0x10, 0x86, 0xa1, 0x7b, 0x95, 0x07, 0x06,
+	    0xad, 0x5e, 0x6d, 0x81,
+	0xf0, 0x3f, 0x02, 0x0b, 0x48, 0x53, 0x06, 0x41, 0xe2, 0xa2, 0xa7, 0xe5,
+	    0x1f, 0x10, 0x17, 0x23,
+	0x3f, 0xcc, 0xf6, 0x97, 0xb3, 0xe3, 0x1b, 0x3f, 0x69, 0x0e, 0x7f, 0xb5,
+	    0xcd, 0x5e, 0xa7, 0xe9,
+	0x78, 0xd6, 0x8f, 0xa6, 0x3a, 0xf4, 0x15, 0x12, 0x6e, 0x75, 0xd4, 0xbf,
+	    0x09, 0xd4, 0x0a, 0xb0,
+	0xd0, 0x68, 0x54, 0x25, 0x07, 0xa7, 0x2a, 0x6e, 0x8c, 0x07, 0xa7, 0xf6,
+	    0xf5, 0xbd, 0xe4, 0x71,
+	0x59, 0xf5, 0xe4, 0x64, 0x85, 0xc9, 0xb2, 0x10, 0xb8, 0x5b, 0x2e, 0xf3,
+	    0x8d, 0xf0, 0x7b, 0xb1,
+	0x58, 0x4a, 0x55, 0x24, 0xdf, 0xa5, 0xc8, 0x6a, 0x50, 0xe2, 0xed, 0x95,
+	    0x44, 0x92, 0x0b, 0xf5,
+	0xb5, 0xe3, 0x89, 0xf1, 0x54, 0xb5, 0x4e, 0x8d, 0x91, 0xd7, 0xe2, 0x0e,
+	    0xdd, 0x38, 0xed, 0x91,
+	0x73, 0x9d, 0xd0, 0x13, 0x46, 0x39, 0x40, 0x27, 0x8c, 0x7a, 0x9e, 0xae,
+	    0x0a, 0xef, 0x23, 0x84,
+	0xf6, 0xce, 0xd9, 0x17, 0x49, 0xd9, 0x6d, 0xaa, 0x84, 0x28, 0x6c, 0x25,
+	    0x83, 0xf5, 0xe8, 0x3b,
+	0xfd, 0x99, 0x90, 0x58, 0x77, 0xe9, 0xfc, 0x48, 0xbb, 0xae, 0x60, 0x5f,
+	    0x29, 0x79, 0xb2, 0x34,
+	0xd3, 0x3d, 0x5e, 0x3d, 0x46, 0xae, 0xb1, 0x6e, 0x7a, 0x5b, 0xce, 0x05,
+	    0xd2, 0xf1, 0x38, 0x4a,
+	0xc4, 0x1f, 0xe9, 0xa1, 0x1d, 0x50, 0x85, 0x85, 0x07, 0xd0, 0x52, 0x7a,
+	    0x63, 0xfc, 0x21, 0x38,
+	0xe4, 0x43, 0x5f, 0x30, 0xb0, 0xf8, 0x88, 0x4e, 0x24, 0xd3, 0x0e, 0xc8,
+	    0x5f, 0x81, 0x49, 0x4a,
+	0x2b, 0x30, 0x6b, 0x18, 0x3f, 0x9f, 0x80, 0x85, 0xc1, 0x00, 0xa7, 0x5e,
+	    0x94, 0xce, 0x04, 0x02,
+	0x70, 0x1b, 0xc4, 0x03, 0xb1, 0xff, 0x28, 0x28, 0x88, 0x43, 0x52, 0x23,
+	    0xb9, 0x6f, 0x49, 0x76,
+	0xea, 0x02, 0x4c, 0x3a, 0x53, 0x14, 0x38, 0xb0, 0x89, 0xb0, 0xc2, 0x30,
+	    0x39, 0x83, 0xfc, 0x67,
+	0x6b, 0xf3, 0x35, 0x67, 0x6f, 0x57, 0x82, 0x81, 0x90, 0x52, 0xe9, 0x02,
+	    0x2d, 0x6d, 0x48, 0x77,
+	0x6a, 0x72, 0xcf, 0x91, 0x85, 0x8c, 0x8a, 0x91, 0x91, 0xe3, 0xe7, 0xa0,
+	    0x30, 0xc0, 0xbb, 0x32,
+	0x8c, 0x61, 0xf8, 0x60, 0x11, 0xe4, 0x70, 0xae, 0xc0, 0x4c, 0x2f, 0x9a,
+	    0x54, 0xd4, 0x02, 0x12,
+	0x6b, 0x08, 0x8d, 0x70, 0xad, 0xfa, 0x38, 0x30, 0x56, 0xc8, 0x18, 0x74,
+	    0x17, 0x24, 0x59, 0x40,
+	0xd6, 0xfa, 0x67, 0xa7, 0x8a, 0xcb, 0xdc, 0x91, 0xce, 0x49, 0xc1, 0x17,
+	    0x2d, 0xb9, 0x51, 0x7b,
+	0x82, 0x10, 0x4f, 0x32, 0x78, 0x28, 0x21, 0x02, 0xc9, 0xef, 0x35, 0xf5,
+	    0x2f, 0x47, 0x43, 0x6e,
+	0xe3, 0x99, 0xfd, 0x36, 0xbb, 0x6a, 0x34, 0x10, 0x7c, 0x4c, 0x50, 0xdf,
+	    0x1e, 0xc8, 0x74, 0x2c,
+	0xe0, 0x78, 0x2a, 0x0f, 0x5f, 0x4d, 0x8d, 0x04, 0x81, 0x38, 0x1d, 0x7e,
+	    0xda, 0x67, 0x3d, 0x34,
+	0xe0, 0x09, 0x06, 0x7b, 0x50, 0xc8, 0x12, 0x2b, 0xc4, 0xee, 0xd3, 0x5e,
+	    0xda, 0xed, 0x1d, 0x21,
+	0x62, 0x8a, 0x30, 0xff, 0x35, 0xd6, 0x8a, 0xff, 0xc9, 0x4f, 0x7b, 0x02,
+	    0xfd, 0x27, 0x78, 0xcf,
+	0xa6, 0x53, 0xc7, 0x2b, 0x00, 0x6d, 0x12, 0x80, 0x99, 0x47, 0x7e, 0x2e,
+	    0xd9, 0xb8, 0x70, 0xdf,
+	0xa7, 0x11, 0xf0, 0xdb, 0xf0, 0x22, 0xda, 0x88, 0x8d, 0x02, 0xbc, 0x78,
+	    0x30, 0xeb, 0x79, 0xce,
+	0x26, 0x11, 0xe6, 0x4b, 0x0e, 0x4a, 0x51, 0x99, 0x22, 0x4a, 0x31, 0x72,
+	    0x14, 0xc5, 0x65, 0x5f,
+	0x1a, 0x53, 0x91, 0x5c, 0x15, 0x6e, 0x5a, 0x9f, 0x49, 0x47, 0x5b, 0x0f,
+	    0x30, 0xb9, 0xdf, 0x81,
+	0xa0, 0x50, 0xfa, 0x10, 0x78, 0x32, 0x7c, 0x42, 0xe3, 0x5d, 0xb4, 0xa5,
+	    0xd7, 0x60, 0xb3, 0x30,
+	0xc4, 0x91, 0x0b, 0xd4, 0x9b, 0x4a, 0x18, 0xf7, 0xe0, 0x5f, 0xa6, 0x33,
+	    0xdd, 0x6e, 0xde, 0x81,
+	0x74, 0x53, 0xbb, 0x05, 0x3d, 0xb4, 0xc5, 0x66, 0xe2, 0xa7, 0x7a, 0x57,
+	    0x70, 0x43, 0xd2, 0x90,
+	0x21, 0x53, 0x89, 0x79, 0x49, 0x08, 0x27, 0x4e, 0x08, 0x70, 0xd7, 0xa0,
+	    0x91, 0xe3, 0x04, 0xb3,
+	0x28, 0xbc, 0xa4, 0x80, 0x3e, 0xbf, 0xc4, 0x4f, 0x95, 0x14, 0xf3, 0xfa,
+	    0xa2, 0xdf, 0x44, 0x55,
+	0x82, 0x9d, 0x4c, 0xb6, 0x72, 0x75, 0xfd, 0xf7, 0x82, 0x33, 0x8c, 0x6a,
+	    0x88, 0xd8, 0x05, 0x21,
+	0x05, 0x10, 0x42, 0x27, 0x30, 0x7e, 0xe9, 0xc5, 0x7a, 0x12, 0x70, 0xe1,
+	    0x75, 0x60, 0x4c, 0x33,
+	0x02, 0x9f, 0xb5, 0xb7, 0xf0, 0xe8, 0xcd, 0x8e, 0x3b, 0x58, 0xab, 0xa4,
+	    0x11, 0x7c, 0xd9, 0x88,
+	0xf4, 0x3b, 0x9d, 0x7d, 0x7e, 0x8d, 0x46, 0xca, 0x62, 0xf3, 0xbf, 0xeb,
+	    0x56, 0xf4, 0x5e, 0xeb,
+	0x69, 0xc2, 0xf0, 0x1c, 0x5a, 0x33, 0x7e, 0x49, 0x67, 0x79, 0xb7, 0xbb,
+	    0x78, 0xf9, 0x5e, 0x67,
+	0x0d, 0xe5, 0xd9, 0x18, 0xed, 0xb7, 0x53, 0x23, 0x83, 0x18, 0xdd, 0xb0,
+	    0xb9, 0x7b, 0x0b, 0x9b,
+	0xad, 0xc0, 0x99, 0x1d, 0x52, 0x7f, 0x41, 0x29, 0x7b, 0xf0, 0xe5, 0x69,
+	    0x79, 0x5b, 0x06, 0x2a,
+	0xa8, 0x14, 0xbe, 0x4e, 0x3f, 0xdc, 0x64, 0xc2, 0xc9, 0xa0, 0x54, 0x1c,
+	    0xab, 0x23, 0x46, 0x94,
+	0x6b, 0x12, 0x46, 0xc8, 0x9a, 0xb5, 0xf5, 0xe3, 0xc8, 0xd8, 0x2d, 0xd3,
+	    0x85, 0x81, 0xca, 0xbb,
+	0x09, 0x18, 0x9d, 0xd0, 0x19, 0x38, 0x74, 0x0b, 0x0a, 0x4f, 0x2a, 0xef,
+	    0xba, 0x2b, 0x2f, 0x99,
+	0xb6, 0x12, 0x4f, 0x3f, 0x1a, 0xb5, 0xcc, 0x07, 0xcf, 0xf3, 0x62, 0xa2,
+	    0x2e, 0x22, 0x1e, 0x3f,
+	0x8b, 0x26, 0xd8, 0xf6, 0x10, 0x01, 0x70, 0xcb, 0xa3, 0xf0, 0x07, 0xce,
+	    0xab, 0x6d, 0xbf, 0x10,
+	0x01, 0x74, 0xfe, 0x97, 0xfe, 0x83, 0x3a, 0xbb, 0xe8, 0x48, 0x88, 0x69,
+	    0x3e, 0xd5, 0x71, 0x43,
+	0xc4, 0x77, 0x61, 0xf4, 0x92, 0x2f, 0x8d, 0x53, 0x8f, 0xc9, 0x4b, 0xed,
+	    0x2f, 0x49, 0x79, 0x0c,
+	0xe9, 0x98, 0xf3, 0x13, 0xfd, 0x01, 0x88, 0xd3, 0xc1, 0x8d, 0xb9, 0xc6,
+	    0x5d, 0x1c, 0x4e, 0x45,
+	0x93, 0x8b, 0x5d, 0xd9, 0xfd, 0xab, 0xb4, 0x00, 0x05, 0x2b, 0x8e, 0xf9,
+	    0x3d, 0x52, 0x41, 0x1c,
+	0xce, 0xe1, 0xd5, 0xcd, 0x12, 0xaa, 0x00, 0xf0, 0x46, 0x22, 0x4a, 0x85,
+	    0xbb, 0x4e, 0xd5, 0x09,
+	0x4f, 0xc2, 0x58, 0xd9, 0x93, 0xa9, 0x09, 0x01, 0x85, 0x3b, 0xf0, 0x94,
+	    0x04, 0x49, 0xc0, 0x8c,
+	0x3e, 0x59, 0xd0, 0xcd, 0xde, 0xa8, 0x23, 0x72, 0x64, 0xc1, 0xcf, 0x7b,
+	    0x3c, 0x62, 0x5a, 0x78,
+	0xab, 0x8c, 0xdc, 0x9f, 0xfd, 0x0b, 0x36, 0xa8, 0x4d, 0x95, 0x32, 0x27,
+	    0xa9, 0xa8, 0x54, 0xbf,
+	0x1f, 0xc4, 0x2a, 0x2f, 0x53, 0x06, 0xc5, 0xc1, 0xce, 0xc7, 0x0e, 0xd4,
+	    0xbc, 0x8f, 0x78, 0xe3,
+	0x33, 0xc7, 0xe1, 0xfc, 0xde, 0x21, 0x69, 0x2a, 0x6f, 0xc9, 0x36, 0x8e,
+	    0x3d, 0x8c, 0xd4, 0xbb,
+	0x60, 0x0b, 0x6d, 0x6d, 0xf7, 0x69, 0x53, 0x3d, 0x4e, 0xaf, 0x0f, 0x7f,
+	    0xd1, 0x24, 0xdc, 0x48,
+	0xf8, 0x27, 0x72, 0x08, 0xe2, 0x07, 0x7a, 0xc5, 0xed, 0x8d, 0x5a, 0xe4,
+	    0xa7, 0x30, 0xba, 0x29,
+	0x05, 0x2f, 0x16, 0xae, 0x17, 0xa2, 0xda, 0x74, 0xc3, 0xc0, 0x56, 0xdb,
+	    0x8a, 0x8e, 0x23, 0x4b,
+	0xe5, 0xac, 0x92, 0x4e, 0x1c, 0xa6, 0x86, 0x6a, 0x8a, 0xfa, 0xc8, 0x31,
+	    0xed, 0x2e, 0x2f, 0xbb,
+	0x8b, 0x2d, 0x03, 0x75, 0x18, 0x5a, 0xeb, 0xbb, 0xcb, 0x22, 0x50, 0xb5,
+	    0x64, 0x40, 0x24, 0x9c,
+	0x02, 0x6d, 0x9e, 0x36, 0xae, 0x1f, 0x72, 0x00, 0xe4, 0x20, 0x3e, 0x50,
+	    0xab, 0x7d, 0x75, 0x79,
+	0x80, 0x3e, 0xca, 0xf4, 0xc2, 0x4c, 0xfc, 0x32, 0x0e, 0xb3, 0xbe, 0xbe,
+	    0x77, 0xf0, 0x6f, 0x1e,
+	0x4f, 0x81, 0x01, 0xe5, 0x4b, 0xd1, 0x6b, 0x22, 0x76, 0x79, 0x95, 0xaa,
+	    0xfc, 0xb2, 0xff, 0x1b,
+	0x00, 0x3c, 0xbb, 0xf5, 0x4a, 0x6e, 0x39, 0x42, 0xa7, 0xc5, 0xb5, 0xb5,
+	    0x77, 0x43, 0x88, 0x50,
+	0x2e, 0x9e, 0x1f, 0x24, 0x30, 0x04, 0x0c, 0x08, 0xca, 0xd9, 0x5f, 0x24,
+	    0xf5, 0xb2, 0x6c, 0x2f,
+	0x27, 0x4e, 0x7c, 0x52, 0x67, 0xf0, 0x05, 0x81, 0xe3, 0x77, 0x4b, 0xf7,
+	    0xfa, 0xf9, 0x22, 0x3a,
+	0x26, 0x0d, 0x60, 0xa7, 0xd6, 0xbd, 0x64, 0x01, 0x2f, 0xd9, 0x42, 0xc3,
+	    0x79, 0xf4, 0x45, 0x57,
+	0xbb, 0x03, 0x32, 0xdb, 0xb1, 0x27, 0xdd, 0x13, 0xe3, 0x75, 0x95, 0xe9,
+	    0x00, 0x03, 0xf0, 0x62,
+	0xcb, 0xd5, 0x72, 0x70, 0xc1, 0x89, 0x68, 0x3b, 0x4e, 0x73, 0x38, 0xdc,
+	    0x0b, 0xd8, 0x50, 0x2b,
+	0x0f, 0x89, 0x6e, 0x92, 0xd6, 0x46, 0x25, 0xc8, 0x86, 0xdb, 0x41, 0x6e,
+	    0x03, 0xfa, 0x59, 0x3b,
+	0xbc, 0xd7, 0xda, 0xf1, 0x8a, 0xe5, 0xf5, 0x90, 0x87, 0x38, 0x53, 0xcf,
+	    0x0e, 0x9f, 0xee, 0xe8,
+	0x8b, 0x98, 0x89, 0x0a, 0x39, 0x1f, 0x19, 0x3f, 0x69, 0x7f, 0x81, 0xb6,
+	    0xbe, 0x09, 0xd9, 0xfb,
+	0x24, 0x33, 0xde, 0xbc, 0x81, 0x03, 0xd2, 0x88, 0x5c, 0xd3, 0x09, 0x1f,
+	    0xc1, 0xcf, 0x10, 0x5a,
+	0xad, 0x95, 0xb8, 0xac, 0xc0, 0x62, 0x5b, 0xfc, 0xfb, 0xb9, 0x03, 0xee,
+	    0x14, 0x82, 0x23, 0xb5,
+	0xc4, 0x9c, 0x18, 0x31, 0xb8, 0x0e, 0xe7, 0x44, 0xe6, 0x8e, 0xa7, 0x11,
+	    0xf2, 0x55, 0xe2, 0xb9,
+	0xef, 0x90, 0x2f, 0xc7, 0xd1, 0x32, 0x47, 0x08, 0x4c, 0xba, 0x3f, 0x0e,
+	    0x40, 0x5d, 0x5e, 0xef,
+	0x50, 0x03, 0x86, 0x04, 0x7b, 0xc4, 0x0e, 0x85, 0x63, 0x52, 0x90, 0x24,
+	    0x50, 0x60, 0xc9, 0x0a,
+	0xf6, 0xb5, 0x68, 0x2b, 0x35, 0x63, 0x98, 0x70, 0x4b, 0x03, 0x98, 0x34,
+	    0x51, 0x61, 0x78, 0xfa,
+	0xeb, 0x7d, 0x85, 0x05, 0x13, 0x2c, 0x2f, 0x89, 0x4d, 0xc4, 0x91, 0x25,
+	    0xd0, 0x62, 0xf6, 0xe0,
+	0x3e, 0x30, 0x8a, 0xe3, 0x93, 0x23, 0x19, 0x05, 0x41, 0xd3, 0x99, 0x35,
+	    0xd1, 0x63, 0x40, 0x40,
+	0x02, 0x04, 0xc0, 0x44, 0x12, 0x24, 0x50, 0x60, 0x42, 0x44, 0xd0, 0x64,
+	    0x52, 0x64, 0x48, 0x50,
+	0x03, 0x05, 0xc8, 0x54, 0x13, 0x25, 0x58, 0x70, 0x43, 0x45, 0xd8, 0x74,
+	    0x53, 0x65, 0x41, 0x41,
+	0x82, 0x06, 0xc1, 0x45, 0x92, 0x26, 0x51, 0x61, 0xc2, 0x46, 0xd1, 0x65,
+	    0xd2, 0x66, 0x49, 0x51,
+	0x83, 0x07, 0xc9, 0x55, 0x93, 0x27, 0x59, 0x71, 0xc3, 0x47, 0xd9, 0x75,
+	    0xd3, 0x67, 0x52, 0xf6,
+	0x04, 0xa3, 0x02, 0x0e, 0x14, 0x6a, 0xa5, 0x8d, 0x4e, 0x28, 0x92, 0x2c,
+	    0x58, 0x68, 0xca, 0xe9,
+	0xb6, 0xab, 0x0a, 0x1e, 0xba, 0x6b, 0xce, 0xbc, 0x59, 0xe5, 0x9a, 0x3c,
+	    0x59, 0x69, 0xfe, 0x19,
+	0xe3, 0x75, 0x80, 0xed, 0x9a, 0x0a, 0x97, 0x2b, 0x80, 0xbf, 0x93, 0x2d,
+	    0xd8, 0x6a, 0x55, 0xf6,
+	0xdd, 0x08, 0x0a, 0xb8, 0x19, 0x56, 0x42, 0xdb, 0xaa, 0x2b, 0x9b, 0x3d,
+	    0xd9, 0x6b, 0x42, 0x48,
+	0x0a, 0x0c, 0xc2, 0x4c, 0x1a, 0x2c, 0x52, 0x68, 0x4a, 0x4c, 0xd2, 0x6c,
+	    0x5a, 0x6c, 0x4a, 0x58,
+	0x0b, 0x0d, 0xca, 0x5c, 0x1b, 0x2d, 0x5a, 0x78, 0x4b, 0x4d, 0xda, 0x7c,
+	    0x5b, 0x6d, 0x43, 0x49,
+	0x8a, 0x0e, 0xc3, 0x4d, 0x9a, 0x2e, 0x53, 0x69, 0xca, 0x4e, 0xd3, 0x6d,
+	    0xda, 0x6e, 0x4b, 0x59,
+	0x8b, 0x0f, 0xcb, 0x5d, 0x9b, 0x2f, 0x5b, 0x79, 0xcb, 0x4f, 0xdb, 0x7d,
+	    0xdb, 0x6f, 0xa3, 0xd9,
+	0x26, 0x80, 0x14, 0x06, 0x31, 0xce, 0x84, 0x67, 0x62, 0xa5, 0x94, 0xa4,
+	    0x70, 0x70, 0x2a, 0xc9,
+	0xa5, 0xb5, 0x9c, 0x94, 0x31, 0x31, 0x7c, 0xf0, 0xbe, 0xda, 0x9c, 0xb4,
+	    0x71, 0x71, 0x29, 0xfe,
+	0x81, 0x4d, 0xbf, 0x67, 0x94, 0x12, 0x11, 0xe6, 0x61, 0x5c, 0x95, 0xa5,
+	    0xf0, 0x72, 0x06, 0x96,
+	0x00, 0x18, 0x8d, 0x95, 0xb1, 0x33, 0x1a, 0x53, 0x63, 0x5b, 0x9d, 0xb5,
+	    0xf1, 0x73, 0x44, 0xc0,
+	0x22, 0x14, 0xc4, 0xc4, 0x32, 0x34, 0x54, 0xe0, 0x62, 0x54, 0xd4, 0xe4,
+	    0x72, 0x74, 0x4c, 0xd0,
+	0x23, 0x15, 0xcc, 0xd4, 0x33, 0x35, 0x5c, 0xf0, 0x63, 0x55, 0xdc, 0xf4,
+	    0x73, 0x75, 0x45, 0xc1,
+	0xa2, 0x16, 0xc5, 0xc5, 0xb2, 0x36, 0x55, 0xe1, 0xe2, 0x56, 0xd5, 0xe5,
+	    0xf2, 0x76, 0x4d, 0xd1,
+	0xa3, 0x17, 0xcd, 0xd5, 0xb3, 0x37, 0x5d, 0xf1, 0xe3, 0x57, 0xdd, 0xf5,
+	    0xf3, 0x77, 0x82, 0x4f,
+	0xa8, 0x38, 0x86, 0x8c, 0x38, 0x38, 0x69, 0xca, 0x8a, 0xe8, 0x96, 0xac,
+	    0x78, 0x78, 0x8d, 0x91,
+	0xe1, 0xa1, 0x8e, 0x9c, 0x39, 0x39, 0x9e, 0x45, 0x69, 0x57, 0x9e, 0xbc,
+	    0x79, 0x79, 0xab, 0x0f,
+	0xfc, 0x19, 0x87, 0x8d, 0xb8, 0x3a, 0x15, 0x54, 0xe0, 0x5e, 0x97, 0xad,
+	    0xf8, 0x7a, 0xaf, 0x8a,
+	0xf8, 0x7f, 0x8f, 0x9d, 0xb9, 0x3b, 0x77, 0x3f, 0x15, 0x1a, 0x9f, 0xbd,
+	    0xf9, 0x7b, 0x46, 0xc8,
+	0x2a, 0x1c, 0xc6, 0xcc, 0x3a, 0x3c, 0x56, 0xe8, 0x6a, 0x5c, 0xd6, 0xec,
+	    0x7a, 0x7c, 0x4e, 0xd8,
+	0x2b, 0x1d, 0xce, 0xdc, 0x3b, 0x3d, 0x5e, 0xf8, 0x6b, 0x5d, 0xde, 0xfc,
+	    0x7b, 0x7d, 0x47, 0xc9,
+	0xaa, 0x1e, 0xc7, 0xcd, 0xba, 0x3e, 0x57, 0xe9, 0xea, 0x5e, 0xd7, 0xed,
+	    0xfa, 0x7e, 0x4f, 0xd9,
+	0xab, 0x1f, 0xcf, 0xdd, 0xbb, 0x3f, 0x5f, 0xf9, 0xeb, 0x5f, 0xdf, 0xfd,
+	    0xfb, 0x7f, 0x59, 0xf9,
+	0x6f, 0xff, 0x4c, 0x86, 0xe8, 0x80, 0xc8, 0x06, 0xcb, 0xc2, 0xb0, 0x26,
+	    0x54, 0xe0, 0x76, 0xfd,
+	0x27, 0x82, 0xf8, 0x74, 0x5d, 0x51, 0x30, 0x18, 0xe4, 0x6e, 0xb8, 0x36,
+	    0x55, 0xe1, 0x62, 0xf2,
+	0x3b, 0xe2, 0x0d, 0x45, 0x17, 0x5f, 0x86, 0x22, 0x49, 0xc4, 0xb1, 0x27,
+	    0xd4, 0xe2, 0x50, 0xe8,
+	0x71, 0x5c, 0x5e, 0x17, 0x9d, 0x73, 0x79, 0x20, 0x1e, 0xe1, 0xb9, 0x37,
+	    0xd5, 0xe3, 0x60, 0x42,
+	0x06, 0x84, 0xe0, 0x46, 0x16, 0xa4, 0x70, 0x62, 0x46, 0xc4, 0xf0, 0x66,
+	    0x56, 0xe4, 0x68, 0x52,
+	0x07, 0x85, 0xe8, 0x56, 0x17, 0xa5, 0x78, 0x72, 0x47, 0xc5, 0xf8, 0x76,
+	    0x57, 0xe5, 0x61, 0x43,
+	0x86, 0x86, 0xe1, 0x47, 0x96, 0xa6, 0x71, 0x63, 0xc6, 0xc6, 0xf1, 0x67,
+	    0xd6, 0xe6, 0x69, 0x53,
+	0x87, 0x87, 0xe9, 0x57, 0x97, 0xa7, 0x79, 0x73, 0xc7, 0xc7, 0xf9, 0x77,
+	    0xd7, 0xe7, 0x95, 0xf5,
+	0x8f, 0x86, 0xca, 0xcc, 0x9a, 0x5d, 0x14, 0xf4, 0x4a, 0x6c, 0xb2, 0x2e,
+	    0x5c, 0xe8, 0x6a, 0x25,
+	0x05, 0xe5, 0xae, 0x59, 0x9c, 0xa7, 0x8d, 0xbf, 0xb9, 0x8b, 0xba, 0x3e,
+	    0x5d, 0xe9, 0xc3, 0x34,
+	0xa8, 0xe4, 0x33, 0xc8, 0x9e, 0x5f, 0xdc, 0xae, 0x4a, 0x3f, 0xb3, 0x2f,
+	    0xdc, 0xea, 0x03, 0xd9,
+	0x59, 0x13, 0xc3, 0xdd, 0x1b, 0x5e, 0x0c, 0xba, 0x3d, 0xc9, 0xbb, 0x3f,
+	    0xdd, 0xeb, 0x62, 0x4a,
+	0x0e, 0x8c, 0xe2, 0x4e, 0x1e, 0xac, 0x72, 0x6a, 0x4e, 0xcc, 0xf2, 0x6e,
+	    0x5e, 0xec, 0x6a, 0x5a,
+	0x0f, 0x8d, 0xea, 0x5e, 0x1f, 0xad, 0x7a, 0x7a, 0x4f, 0xcd, 0xfa, 0x7e,
+	    0x5f, 0xed, 0x63, 0x4b,
+	0x8e, 0x8e, 0xe3, 0x4f, 0x9e, 0xae, 0x73, 0x6b, 0xce, 0xce, 0xf3, 0x6f,
+	    0xde, 0xee, 0x6b, 0x5b,
+	0x8f, 0x8f, 0xeb, 0x5f, 0x9f, 0xaf, 0x7b, 0x7b, 0xcf, 0xcf, 0xfb, 0x7f,
+	    0xdf, 0xef, 0x7e, 0x83,
+	0x87, 0xd2, 0xa4, 0x86, 0x34, 0xb0, 0x54, 0xe2, 0x88, 0xdd, 0xb4, 0xa6,
+	    0x74, 0xf0, 0x16, 0x37,
+	0xda, 0x9f, 0xac, 0x96, 0x35, 0xb1, 0x04, 0xf5, 0xb3, 0xbd, 0xbc, 0xb6,
+	    0x75, 0xf1, 0x22, 0xc2,
+	0x00, 0x42, 0xa5, 0x87, 0xb4, 0xb2, 0xce, 0x21, 0xe5, 0x37, 0xb5, 0xa7,
+	    0xf4, 0xf2, 0x45, 0x15,
+	0x59, 0xd2, 0xad, 0x97, 0xb5, 0xb3, 0xda, 0xf3, 0xe9, 0xbd, 0xbd, 0xb7,
+	    0xf5, 0xf3, 0x64, 0xc2,
+	0x26, 0x94, 0xe4, 0xc6, 0x36, 0xb4, 0x74, 0xe2, 0x66, 0xd4, 0xf4, 0xe6,
+	    0x76, 0xf4, 0x6c, 0xd2,
+	0x27, 0x95, 0xec, 0xd6, 0x37, 0xb5, 0x7c, 0xf2, 0x67, 0xd5, 0xfc, 0xf6,
+	    0x77, 0xf5, 0x65, 0xc3,
+	0xa6, 0x96, 0xe5, 0xc7, 0xb6, 0xb6, 0x75, 0xe3, 0xe6, 0xd6, 0xf5, 0xe7,
+	    0xf6, 0xf6, 0x6d, 0xd3,
+	0xa7, 0x97, 0xed, 0xd7, 0xb7, 0xb7, 0x7d, 0xf3, 0xe7, 0xd7, 0xfd, 0xf7,
+	    0xf7, 0xf7, 0x76, 0x83,
+	0x4c, 0x9b, 0xa6, 0x8e, 0x3c, 0xb8, 0x16, 0xab, 0xe1, 0xd2, 0xb6, 0xae,
+	    0x7c, 0xf8, 0x99, 0x3f,
+	0x2b, 0x39, 0xae, 0x9e, 0x3d, 0xb9, 0x89, 0xbb, 0xe0, 0xd5, 0xbe, 0xbe,
+	    0x7d, 0xf9, 0x20, 0x07,
+	0x54, 0x89, 0xa7, 0x8f, 0xbc, 0xba, 0x4f, 0x8f, 0x63, 0xd8, 0xb7, 0xaf,
+	    0xfc, 0xfa, 0xa5, 0xe8,
+	0x9d, 0x19, 0xaf, 0x9f, 0xbd, 0xbb, 0x57, 0xc8, 0xcd, 0xd0, 0xbf, 0xbf,
+	    0xfd, 0xfb, 0x66, 0xca,
+	0x2e, 0x9c, 0xe6, 0xce, 0x3e, 0xbc, 0x76, 0xea, 0x6e, 0xdc, 0xf6, 0xee,
+	    0x7e, 0xfc, 0x6e, 0xda,
+	0x2f, 0x9d, 0xee, 0xde, 0x3f, 0xbd, 0x7e, 0xfa, 0x6f, 0xdd, 0xfe, 0xfe,
+	    0x7f, 0xfd, 0x67, 0xcb,
+	0xae, 0x9e, 0xe7, 0xcf, 0xbe, 0xbe, 0x77, 0xeb, 0xee, 0xde, 0xf7, 0xef,
+	    0xfe, 0xfe, 0x6f, 0xdb,
+	0xaf, 0x9f, 0xef, 0xdf, 0xbf, 0xbf, 0x7f, 0xfb, 0xef, 0xdf, 0xff, 0xff,
+	    0xc5, 0xa8
+};
+#endif
+#endif
diff --git a/drivers/input/touchscreen/gt9xx/gt9xx_update.c b/drivers/input/touchscreen/gt9xx/gt9xx_update.c
index af80eef..462d812 100644
--- a/drivers/input/touchscreen/gt9xx/gt9xx_update.c
+++ b/drivers/input/touchscreen/gt9xx/gt9xx_update.c
@@ -1,6 +1,6 @@
 /* drivers/input/touchscreen/gt9xx_update.c
  *
- * 2010 - 2012 Goodix Technology.
+ * 2010 - 2014 Goodix Technology.
  * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -14,7 +14,7 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * General Public License for more details.
  *
- * Latest Version:1.6
+ * Latest Version: 2.2
  * Author: andrew@goodix.com
  * Revision Record:
  *      V1.0:
@@ -30,28 +30,44 @@
  *          1. replace guitar_client with i2c_connect_client;
  *          2. support firmware header array update.
  *                          By Meta, 2013/03/11
+ *      V2.2:
+ *          1. multi-system supported
+ *          2. flashless update no pid vid compare
+ *                          By Meta, 2014/01/14
  */
+
+#include <linux/kthread.h>
 #include "gt9xx.h"
-#include <linux/firmware.h>
-#include <linux/workqueue.h>
-#include <linux/kernel.h>
 
-#define FIRMWARE_NAME_LEN_MAX		256
+#include <linux/namei.h>
+#include <linux/mount.h>
+#if ((GTP_AUTO_UPDATE && GTP_HEADER_FW_UPDATE) || GTP_COMPATIBLE_MODE)
+#include "gt9xx_firmware.h"
+#endif
 
 #define GUP_REG_HW_INFO             0x4220
 #define GUP_REG_FW_MSG              0x41E4
 #define GUP_REG_PID_VID             0x8140
 
-#define GOODIX_FIRMWARE_FILE_NAME	"_goodix_update_.bin"
-#define GOODIX_CONFIG_FILE_NAME		"_goodix_config_.cfg"
+#define GUP_SEARCH_FILE_TIMES       50
 
-#define FW_HEAD_LENGTH               14
-#define FW_SECTION_LENGTH            0x2000
-#define FW_DSP_ISP_LENGTH            0x1000
-#define FW_DSP_LENGTH                0x1000
-#define FW_BOOT_LENGTH               0x800
+#define UPDATE_FILE_PATH_1          "/data/_goodix_update_.bin"
+#define UPDATE_FILE_PATH_2          "/sdcard/_goodix_update_.bin"
+
+#define CONFIG_FILE_PATH_1          "/data/_goodix_config_.cfg"
+#define CONFIG_FILE_PATH_2          "/sdcard/_goodix_config_.cfg"
 
-#define PACK_SIZE                    256
+#define FW_HEAD_LENGTH               14
+#define FW_SECTION_LENGTH            0x2000	/* 8K */
+#define FW_DSP_ISP_LENGTH            0x1000	/* 4K */
+#define FW_DSP_LENGTH                0x1000	/* 4K */
+#define FW_BOOT_LENGTH               0x800	/* 2K */
+#define FW_SS51_LENGTH               (4 * FW_SECTION_LENGTH)	/* 32K */
+#define FW_BOOT_ISP_LENGTH           0x800	/* 2k */
+#define FW_GLINK_LENGTH              0x3000	/* 12k */
+#define FW_GWAKE_LENGTH              (4 * FW_SECTION_LENGTH)	/* 32k */
+
+#define PACK_SIZE                    250
 #define MAX_FRAME_CHECK_TIME         5
 
 #define _bRW_MISCTL__SRAM_BANK       0x4048
@@ -64,29 +80,45 @@
 #define _rRW_MISCTL__BOOT_OPT_B0_    0x4218
 #define _rRW_MISCTL__BOOT_CTL_       0x5094
 
-#define FAIL    0
-#define SUCCESS 1
+#define AUTO_SEARCH_BIN              0x01
+#define AUTO_SEARCH_CFG              0x02
+#define BIN_FILE_READY               0x80
+#define CFG_FILE_READY               0x08
+#define HEADER_FW_READY              0x00
 
+#pragma pack(1)
 struct st_fw_head {
-	u8  hw_info[4];		/* hardware info */
-	u8  pid[8];		/* product id   */
-	u16 vid;		/* version id   */
-} __packed;
+	u8 hw_info[4];		/* hardware info */
+	u8 pid[8];		/* product id  */
+	u16 vid;		/* version id  */
+};
+#pragma pack()
 
 struct st_update_msg {
 	u8 force_update;
 	u8 fw_flag;
-	bool need_free;
-	u8 *fw_data;
-	u32 fw_len;
-	struct st_fw_head  ic_fw_msg;
+	struct file *file;
+	struct file *cfg_file;
+	struct st_fw_head ic_fw_msg;
+	mm_segment_t old_fs;
+	u32 fw_total_len;
+	u32 fw_burned_len;
 };
 
-static struct st_update_msg update_msg;
+struct st_update_msg update_msg;
 u16 show_len;
 u16 total_len;
 u8 got_file_flag;
 u8 searching_file;
+
+static u8 gup_burn_fw_gwake_section(struct i2c_client *client, u8 *fw_section,
+				    u16 start_addr, u32 len, u8 bank_cmd);
+
+#define _CLOSE_FILE(p_file) do {\
+			if (p_file && !IS_ERR(p_file)) \
+				filp_close(p_file, NULL); \
+			} while (0)
+
 /*******************************************************
 Function:
     Read data from the i2c slave device.
@@ -97,26 +129,25 @@ Input:
     len:    GTP_ADDR_LENGTH + read bytes count
 Output:
     numbers of i2c_msgs to transfer:
-      2: succeed, otherwise: failed
+    2: succeed, otherwise: failed
 *********************************************************/
 static s32 gup_i2c_read(struct i2c_client *client, u8 *buf, s32 len)
 {
+	struct i2c_msg msgs[2];
 	s32 ret = -1;
-	u8 retries = 0;
-	struct i2c_msg msgs[2] = {
-		{
-			.flags = !I2C_M_RD,
-			.addr  = client->addr,
-			.len   = GTP_ADDR_LENGTH,
-			.buf   = &buf[0],
-		},
-		{
-			.flags = I2C_M_RD,
-			.addr  = client->addr,
-			.len   = len - GTP_ADDR_LENGTH,
-			.buf   = &buf[GTP_ADDR_LENGTH],
-		},
-	};
+	s32 retries = 0;
+
+	GTP_DEBUG_FUNC();
+
+	msgs[0].flags = !I2C_M_RD;
+	msgs[0].addr = client->addr;
+	msgs[0].len = GTP_ADDR_LENGTH;
+	msgs[0].buf = &buf[0];
+
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].addr = client->addr;
+	msgs[1].len = len - GTP_ADDR_LENGTH;
+	msgs[1].buf = &buf[GTP_ADDR_LENGTH];
 
 	while (retries < 5) {
 		ret = i2c_transfer(client->adapter, msgs, 2);
@@ -125,11 +156,6 @@ static s32 gup_i2c_read(struct i2c_client *client, u8 *buf, s32 len)
 		retries++;
 	}
 
-	if (retries == 5) {
-		dev_err(&client->dev, "I2C read retry limit over.\n");
-		ret = -EIO;
-	}
-
 	return ret;
 }
 
@@ -143,18 +169,20 @@ Input:
     len:    GTP_ADDR_LENGTH + write bytes count
 Output:
     numbers of i2c_msgs to transfer:
-	1: succeed, otherwise: failed
+    1: succeed, otherwise: failed
 *********************************************************/
-s32 gup_i2c_write(struct i2c_client *client, u8 *buf, s32 len)
+static s32 gup_i2c_write(struct i2c_client *client, u8 *buf, s32 len)
 {
+	struct i2c_msg msg;
 	s32 ret = -1;
-	u8 retries = 0;
-	struct i2c_msg msg = {
-		.flags = !I2C_M_RD,
-		.addr  = client->addr,
-		.len   = len,
-		.buf   = buf,
-	};
+	s32 retries = 0;
+
+	GTP_DEBUG_FUNC();
+
+	msg.flags = !I2C_M_RD;
+	msg.addr = client->addr;
+	msg.len = len;
+	msg.buf = buf;
 
 	while (retries < 5) {
 		ret = i2c_transfer(client->adapter, &msg, 1);
@@ -163,115 +191,123 @@ s32 gup_i2c_write(struct i2c_client *client, u8 *buf, s32 len)
 		retries++;
 	}
 
-	if (retries == 5) {
-		dev_err(&client->dev, "I2C write retry limit over.\n");
-		ret = -EIO;
-	}
-
 	return ret;
 }
 
 static s32 gup_init_panel(struct goodix_ts_data *ts)
 {
-	struct i2c_client *client = ts->client;
-	u8 *config_data;
 	s32 ret = 0;
 	s32 i = 0;
 	u8 check_sum = 0;
 	u8 opr_buf[16];
 	u8 sensor_id = 0;
+	u16 version = 0;
+
+	u8 cfg_info_group1[] = CTP_CFG_GROUP1;
+	u8 cfg_info_group2[] = CTP_CFG_GROUP2;
+	u8 cfg_info_group3[] = CTP_CFG_GROUP3;
+	u8 cfg_info_group4[] = CTP_CFG_GROUP4;
+	u8 cfg_info_group5[] = CTP_CFG_GROUP5;
+	u8 cfg_info_group6[] = CTP_CFG_GROUP6;
+	u8 *send_cfg_buf[] = {
+		cfg_info_group1, cfg_info_group2, cfg_info_group3,
+		cfg_info_group4, cfg_info_group5, cfg_info_group6
+	};
+	u8 cfg_info_len[] = {CFG_GROUP_LEN(cfg_info_group1),
+		CFG_GROUP_LEN(cfg_info_group2),
+		CFG_GROUP_LEN(cfg_info_group3),
+		CFG_GROUP_LEN(cfg_info_group4),
+		CFG_GROUP_LEN(cfg_info_group5),
+		CFG_GROUP_LEN(cfg_info_group6)
+	};
 
-	for (i = 0; i < GOODIX_MAX_CFG_GROUP; i++)
-		if (ts->pdata->config_data_len[i])
-			break;
-
-	if (i == GOODIX_MAX_CFG_GROUP) {
+	if ((!cfg_info_len[1]) && (!cfg_info_len[2]) &&
+	    (!cfg_info_len[3]) && (!cfg_info_len[4]) && (!cfg_info_len[5]))
 		sensor_id = 0;
-	} else {
-		ret = gtp_i2c_read_dbl_check(client, GTP_REG_SENSOR_ID,
-							&sensor_id, 1);
+	else {
+		ret = gtp_i2c_read_dbl_check(ts->client, GTP_REG_SENSOR_ID,
+						&sensor_id, 1);
 		if (SUCCESS == ret) {
-			if (sensor_id >= GOODIX_MAX_CFG_GROUP) {
-				pr_err("Invalid sensor_id(0x%02X), No Config Sent!",
-					sensor_id);
+			if (sensor_id >= 0x06) {
+				GTP_ERROR
+				    ("Invalid id(0x%02X), No Config Sent!",
+				     sensor_id);
 				return -EINVAL;
 			}
 		} else {
-			pr_err("Failed to get sensor_id, No config sent!");
+			GTP_ERROR("Failed to get sensor_id, No config sent!");
 			return -EINVAL;
 		}
 	}
 
-	pr_debug("Sensor ID selected: %d", sensor_id);
+	GTP_DEBUG("Sensor_ID: %d", sensor_id);
 
-	if (ts->pdata->config_data_len[sensor_id] < GTP_CONFIG_MIN_LENGTH ||
-		!ts->pdata->config_data_len[sensor_id]) {
-		pr_err("Sensor_ID(%d) matches with NULL or INVALID CONFIG GROUP!",
-				sensor_id);
+	ts->gtp_cfg_len = cfg_info_len[sensor_id];
+	if (ts->gtp_cfg_len < GTP_CONFIG_MIN_LENGTH) {
+		GTP_ERROR
+		    ("Sensor_ID(%d) matches with NULL or INVALID CONFIG GROUP!",
+		     sensor_id);
 		return -EINVAL;
 	}
 
-	ret = gtp_i2c_read_dbl_check(client, GTP_REG_CONFIG_DATA,
+	ret = gtp_i2c_read_dbl_check(ts->client, GTP_REG_CONFIG_DATA,
 					&opr_buf[0], 1);
 	if (ret == SUCCESS) {
-		pr_debug("CFG_GROUP%d Config Version: %d, IC Config Version: %d",
-			sensor_id + 1,
-			ts->pdata->config_data[sensor_id][0],
-			opr_buf[0]);
-
-		ts->pdata->config_data[sensor_id][0] = opr_buf[0];
+		GTP_DEBUG
+		    ("CFG_GROUP%d Config Version: %d, IC Config Version: %d",
+		     sensor_id + 1, send_cfg_buf[sensor_id][0], opr_buf[0]);
+		send_cfg_buf[sensor_id][0] = opr_buf[0];
 		ts->fixed_cfg = 0;
 	} else {
-		pr_err("Failed to get ic config version!No config sent!");
+		GTP_ERROR("Failed to get ic config version!No config sent!");
 		return -EINVAL;
 	}
 
-	config_data = ts->pdata->config_data[sensor_id];
-	ts->config_data = ts->pdata->config_data[sensor_id];
-	ts->gtp_cfg_len = ts->pdata->config_data_len[sensor_id];
+	memset(&config[GTP_ADDR_LENGTH], 0, GTP_CONFIG_MAX_LENGTH);
+	memcpy(&config[GTP_ADDR_LENGTH], send_cfg_buf[sensor_id],
+	       ts->gtp_cfg_len);
 
-	pr_debug("X_MAX = %d, Y_MAX = %d, TRIGGER = 0x%02x",
-	ts->abs_x_max, ts->abs_y_max, ts->int_trigger_type);
+	GTP_DEBUG("X_MAX = %d, Y_MAX = %d, TRIGGER = 0x%02x",
+		  ts->abs_x_max, ts->abs_y_max, ts->int_trigger_type);
 
-	config_data[RESOLUTION_LOC]     = (u8)GTP_MAX_WIDTH;
-	config_data[RESOLUTION_LOC + 1] = (u8)(GTP_MAX_WIDTH>>8);
-	config_data[RESOLUTION_LOC + 2] = (u8)GTP_MAX_HEIGHT;
-	config_data[RESOLUTION_LOC + 3] = (u8)(GTP_MAX_HEIGHT>>8);
+	config[RESOLUTION_LOC] = (u8)GTP_MAX_WIDTH;
+	config[RESOLUTION_LOC + 1] = (u8)(GTP_MAX_WIDTH >> 8);
+	config[RESOLUTION_LOC + 2] = (u8)GTP_MAX_HEIGHT;
+	config[RESOLUTION_LOC + 3] = (u8)(GTP_MAX_HEIGHT >> 8);
 
-	if (GTP_INT_TRIGGER == 0)  /* RISING */
-		config_data[TRIGGER_LOC] &= 0xfe;
-	else if (GTP_INT_TRIGGER == 1)  /* FALLING */
-		config_data[TRIGGER_LOC] |= 0x01;
+	if (GTP_INT_TRIGGER == 0)	/* RISING */
+		config[TRIGGER_LOC] &= 0xfe;
+	else if (GTP_INT_TRIGGER == 1)	/* FALLING */
+		config[TRIGGER_LOC] |= 0x01;
 
 	check_sum = 0;
 	for (i = GTP_ADDR_LENGTH; i < ts->gtp_cfg_len; i++)
-		check_sum += config_data[i];
+		check_sum += config[i];
+	config[ts->gtp_cfg_len] = (~check_sum) + 1;
 
-	config_data[ts->gtp_cfg_len] = (~check_sum) + 1;
-
-	ret = gtp_send_cfg(ts);
+	GTP_DEBUG_FUNC();
+	ret = gtp_send_cfg(ts->client);
 	if (ret < 0)
-		pr_err("Send config error.");
-
-	ts->config_data = NULL;
-	ts->gtp_cfg_len = 0;
+		GTP_ERROR("Send config error.");
+	gtp_read_version(ts->client, &version);
 	msleep(20);
 	return 0;
 }
 
 static u8 gup_get_ic_msg(struct i2c_client *client, u16 addr, u8 *msg, s32 len)
 {
-	u8 i = 0;
+	s32 i = 0;
 
 	msg[0] = (addr >> 8) & 0xff;
 	msg[1] = addr & 0xff;
 
-	for (i = 0; i < 5; i++)
+	for (i = 0; i < 5; i++) {
 		if (gup_i2c_read(client, msg, GTP_ADDR_LENGTH + len) > 0)
 			break;
+	}
 
 	if (i >= 5) {
-		pr_err("Read data from 0x%02x%02x failed!", msg[0], msg[1]);
+		GTP_ERROR("Read data from 0x%02x%02x failed!", msg[0], msg[1]);
 		return FAIL;
 	}
 
@@ -280,19 +316,20 @@ static u8 gup_get_ic_msg(struct i2c_client *client, u16 addr, u8 *msg, s32 len)
 
 static u8 gup_set_ic_msg(struct i2c_client *client, u16 addr, u8 val)
 {
-	u8 i = 0;
-	u8 msg[3] = {
-		(addr >> 8) & 0xff,
-		addr & 0xff,
-		val,
-	};
+	s32 i = 0;
+	u8 msg[3];
+
+	msg[0] = (addr >> 8) & 0xff;
+	msg[1] = addr & 0xff;
+	msg[2] = val;
 
-	for (i = 0; i < 5; i++)
+	for (i = 0; i < 5; i++) {
 		if (gup_i2c_write(client, msg, GTP_ADDR_LENGTH + 1) > 0)
 			break;
+	}
 
 	if (i >= 5) {
-		pr_err("Set data to 0x%02x%02x failed!", msg[0], msg[1]);
+		GTP_ERROR("Set data to 0x%02x%02x failed!", msg[0], msg[1]);
 		return FAIL;
 	}
 
@@ -302,80 +339,78 @@ static u8 gup_set_ic_msg(struct i2c_client *client, u16 addr, u8 val)
 static u8 gup_get_ic_fw_msg(struct i2c_client *client)
 {
 	s32 ret = -1;
-	u8  retry = 0;
-	u8  buf[16];
-	u8  i;
+	u8 retry = 0;
+	u8 buf[16];
+	u8 i;
 
 	/* step1:get hardware info */
-	ret = gtp_i2c_read_dbl_check(client, GUP_REG_HW_INFO,
-					&buf[GTP_ADDR_LENGTH], 4);
-	if (ret == FAIL) {
-		pr_err("get hw_info failed,exit");
+	ret =
+	    gtp_i2c_read_dbl_check(client, GUP_REG_HW_INFO,
+				   &buf[GTP_ADDR_LENGTH], 4);
+	if (FAIL == ret) {
+		GTP_ERROR("[get_ic_fw_msg]get hw_info failed,exit");
 		return FAIL;
 	}
-
-	/*  buf[2~5]: 00 06 90 00 */
+	/* buf[2~5]: 00 06 90 00 */
 	/* hw_info: 00 90 06 00 */
 	for (i = 0; i < 4; i++)
 		update_msg.ic_fw_msg.hw_info[i] = buf[GTP_ADDR_LENGTH + 3 - i];
-
-	pr_debug("IC Hardware info:%02x%02x%02x%02x",
-		update_msg.ic_fw_msg.hw_info[0],
-		update_msg.ic_fw_msg.hw_info[1],
-		update_msg.ic_fw_msg.hw_info[2],
-		update_msg.ic_fw_msg.hw_info[3]);
-
+	GTP_DEBUG("IC Hardware info:%02x%02x%02x%02x",
+		  update_msg.ic_fw_msg.hw_info[0],
+		  update_msg.ic_fw_msg.hw_info[1],
+		  update_msg.ic_fw_msg.hw_info[2],
+		  update_msg.ic_fw_msg.hw_info[3]);
 	/* step2:get firmware message */
 	for (retry = 0; retry < 2; retry++) {
 		ret = gup_get_ic_msg(client, GUP_REG_FW_MSG, buf, 1);
-		if (ret == FAIL) {
-			pr_err("Read firmware message fail.");
+		if (FAIL == ret) {
+			GTP_ERROR("Read firmware message fail.");
 			return ret;
 		}
 
 		update_msg.force_update = buf[GTP_ADDR_LENGTH];
 		if ((0xBE != update_msg.force_update) && (!retry)) {
-			pr_info("The check sum in ic is error.");
-			pr_info("The IC will be updated by force.");
+			GTP_INFO("The check sum in ic is error.");
+			GTP_INFO("The IC will be updated by force.");
 			continue;
 		}
 		break;
 	}
-	pr_debug("IC force update flag:0x%x", update_msg.force_update);
+	GTP_DEBUG("IC force update flag:0x%x", update_msg.force_update);
 
-	/*  step3:get pid & vid */
+	/* step3:get pid & vid */
 	ret = gtp_i2c_read_dbl_check(client, GUP_REG_PID_VID,
-						&buf[GTP_ADDR_LENGTH], 6);
-	if (ret == FAIL) {
-		pr_err("get pid & vid failed,exit");
+					&buf[GTP_ADDR_LENGTH], 6);
+	if (FAIL == ret) {
+		GTP_ERROR("[get_ic_fw_msg]get pid & vid failed,exit");
 		return FAIL;
 	}
 
 	memset(update_msg.ic_fw_msg.pid, 0, sizeof(update_msg.ic_fw_msg.pid));
 	memcpy(update_msg.ic_fw_msg.pid, &buf[GTP_ADDR_LENGTH], 4);
-	pr_debug("IC Product id:%s", update_msg.ic_fw_msg.pid);
-
-	/* GT9XX PID MAPPING
-	|-----FLASH-----RAM-----|
-	|------918------918-----|
-	|------968------968-----|
-	|------913------913-----|
-	|------913P-----913P----|
-	|------927------927-----|
-	|------927P-----927P----|
-	|------9110-----9110----|
-	|------9110P----9111----|*/
+	GTP_DEBUG("IC Product id:%s", update_msg.ic_fw_msg.pid);
+
+	/* GT9XX PID MAPPING */
+	/*|-----FLASH-----RAM-----|
+	   |------918------918-----|
+	   |------968------968-----|
+	   |------913------913-----|
+	   |------913P-----913P----|
+	   |------927------927-----|
+	   |------927P-----927P----|
+	   |------9110-----9110----|
+	   |------9110P----9111----| */
 	if (update_msg.ic_fw_msg.pid[0] != 0) {
 		if (!memcmp(update_msg.ic_fw_msg.pid, "9111", 4)) {
-			pr_debug("IC Mapping Product id:%s",
-					update_msg.ic_fw_msg.pid);
+			GTP_DEBUG("IC Mapping Product id:%s",
+				  update_msg.ic_fw_msg.pid);
 			memcpy(update_msg.ic_fw_msg.pid, "9110P", 5);
 		}
 	}
 
 	update_msg.ic_fw_msg.vid = buf[GTP_ADDR_LENGTH + 4] +
 				(buf[GTP_ADDR_LENGTH + 5] << 8);
-	pr_debug("IC version id:%04x", update_msg.ic_fw_msg.vid);
+	GTP_DEBUG("IC version id:%04x", update_msg.ic_fw_msg.vid);
 
 	return SUCCESS;
 }
@@ -383,17 +418,16 @@ static u8 gup_get_ic_fw_msg(struct i2c_client *client)
 s32 gup_enter_update_mode(struct i2c_client *client)
 {
 	s32 ret = -1;
-	u8 retry = 0;
+	s32 retry = 0;
 	u8 rd_buf[3];
 	struct goodix_ts_data *ts = i2c_get_clientdata(client);
 
 	/* step1:RST output low last at least 2ms */
 	gpio_direction_output(ts->pdata->reset_gpio, 0);
-	usleep(20000);
+	msleep(20);
 
 	/* step2:select I2C slave addr,INT:0--0xBA;1--0x28. */
-	gpio_direction_output(ts->pdata->irq_gpio,
-			(client->addr == GTP_I2C_ADDRESS_HIGH));
+	gpio_direction_output(ts->pdata->irq_gpio, (client->addr == 0x14));
 	msleep(20);
 
 	/* step3:RST output high reset guitar */
@@ -405,28 +439,26 @@ s32 gup_enter_update_mode(struct i2c_client *client)
 		/* step4:Hold ss51 & dsp */
 		ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
 		if (ret <= 0) {
-			pr_debug("Hold ss51 & dsp I2C error,retry:%d", retry);
+			GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
 			continue;
 		}
-
 		/* step5:Confirm hold */
 		ret = gup_get_ic_msg(client, _rRW_MISCTL__SWRST_B0_, rd_buf, 1);
 		if (ret <= 0) {
-			pr_debug("Hold ss51 & dsp I2C error,retry:%d", retry);
+			GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
 			continue;
 		}
-		if (rd_buf[GTP_ADDR_LENGTH] == 0x0C) {
-			pr_debug("Hold ss51 & dsp confirm SUCCESS");
+		if (0x0C == rd_buf[GTP_ADDR_LENGTH]) {
+			GTP_DEBUG("Hold ss51 & dsp confirm SUCCESS");
 			break;
 		}
-		pr_debug("Hold ss51 & dsp confirm 0x4180 failed,value:%d",
-					rd_buf[GTP_ADDR_LENGTH]);
+		GTP_DEBUG("Hold ss51 & dsp confirm 0x4180 failed,value:%d",
+			  rd_buf[GTP_ADDR_LENGTH]);
 	}
 	if (retry >= 200) {
-		pr_err("Enter update Hold ss51 failed.");
+		GTP_ERROR("Enter update Hold ss51 failed.");
 		return FAIL;
 	}
-
 	/* step6:DSP_CK and DSP_ALU_CK PowerOn */
 	ret = gup_set_ic_msg(client, 0x4010, 0x00);
 
@@ -434,369 +466,514 @@ s32 gup_enter_update_mode(struct i2c_client *client)
 	return ret;
 }
 
-void gup_leave_update_mode(struct i2c_client *client)
+void gup_leave_update_mode(void)
 {
-	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+	struct goodix_ts_data *ts = i2c_get_clientdata(i2c_connect_client);
 
 	gpio_direction_input(ts->pdata->irq_gpio);
-	pr_debug("reset chip.");
-	gtp_reset_guitar(ts, 20);
+
+	GTP_DEBUG("[leave_update_mode]reset chip.");
+	gtp_reset_guitar(i2c_connect_client, 20);
 }
 
-/*	Get the correct nvram data
-	The correct conditions:
-	1. the hardware info is the same
-	2. the product id is the same
-	3. the firmware version in update file is greater than the firmware
-	version in ic or the check sum in ic is wrong
-
-	Update Conditions:
-	1. Same hardware info
-	2. Same PID
-	3. File PID > IC PID
-
-	Force Update Conditions:
-	1. Wrong ic firmware checksum
-	2. INVALID IC PID or VID
-	3. IC PID == 91XX || File PID == 91XX
+/* Get the correct nvram data
+  * The correct conditions:
+  * 1. the hardware info is the same
+  * 2. the product id is the same
+  * 3. the firmware version in update file is greater than
+  * the firmware version in ic or the check sum in ic is wrong
+ */
+/* Update Conditions:
+    1. Same hardware info
+    2. Same PID
+    3. File VID > IC VID
+   Force Update Conditions:
+    1. Wrong ic firmware checksum
+    2. INVALID IC PID or VID
+    3. (IC PID == 91XX || File PID == 91XX) && (File VID > IC VID)
 */
 
-static u8 gup_enter_update_judge(struct i2c_client *client,
-					struct st_fw_head *fw_head)
+static u8 gup_enter_update_judge(struct st_fw_head *fw_head)
 {
 	u16 u16_tmp;
 	s32 i = 0;
-
+	u32 fw_len = 0;
+	s32 pid_cmp_len = 0;
 	u16_tmp = fw_head->vid;
-	fw_head->vid = (u16)(u16_tmp>>8) + (u16)(u16_tmp<<8);
-
-	pr_debug("FILE HARDWARE INFO:%02x%02x%02x%02x", fw_head->hw_info[0],
-		fw_head->hw_info[1], fw_head->hw_info[2], fw_head->hw_info[3]);
-	pr_debug("FILE PID:%s", fw_head->pid);
-	pr_debug("FILE VID:%04x", fw_head->vid);
-
-	pr_debug("IC HARDWARE INFO:%02x%02x%02x%02x",
-		update_msg.ic_fw_msg.hw_info[0],
-		update_msg.ic_fw_msg.hw_info[1],
-		update_msg.ic_fw_msg.hw_info[2],
-		update_msg.ic_fw_msg.hw_info[3]);
-	pr_debug("IC PID:%s", update_msg.ic_fw_msg.pid);
-	pr_debug("IC VID:%04x", update_msg.ic_fw_msg.vid);
-
+	fw_head->vid = (u16)(u16_tmp >> 8) + (u16)(u16_tmp << 8);
+
+	GTP_INFO("FILE HARDWARE INFO:%02x%02x%02x%02x", fw_head->hw_info[0],
+		 fw_head->hw_info[1], fw_head->hw_info[2], fw_head->hw_info[3]);
+	GTP_INFO("FILE PID:%s", fw_head->pid);
+	GTP_INFO("FILE VID:%04x", fw_head->vid);
+	GTP_INFO("IC HARDWARE INFO:%02x%02x%02x%02x",
+		 update_msg.ic_fw_msg.hw_info[0],
+		 update_msg.ic_fw_msg.hw_info[1],
+		 update_msg.ic_fw_msg.hw_info[2],
+		 update_msg.ic_fw_msg.hw_info[3]);
+	GTP_INFO("IC PID:%s", update_msg.ic_fw_msg.pid);
+	GTP_INFO("IC VID:%04x", update_msg.ic_fw_msg.vid);
+
+	if (!memcmp(fw_head->pid, "9158", 4)
+	    && !memcmp(update_msg.ic_fw_msg.pid, "915S", 4)) {
+		GTP_INFO("Update GT915S to GT9158 directly!");
+		return SUCCESS;
+	}
 	/* First two conditions */
-	if (!memcmp(fw_head->hw_info, update_msg.ic_fw_msg.hw_info,
-			sizeof(update_msg.ic_fw_msg.hw_info))) {
-		pr_debug("Get the same hardware info.");
-		if (update_msg.force_update != 0xBE) {
-			pr_info("FW chksum error,need enter update.");
-			return SUCCESS;
-		}
+	if (!memcmp
+	    (fw_head->hw_info, update_msg.ic_fw_msg.hw_info,
+	     sizeof(update_msg.ic_fw_msg.hw_info)))
+		fw_len = 42 * 1024;
+	else {
+		fw_len = fw_head->hw_info[3];
+		fw_len += (((u32)fw_head->hw_info[2]) << 8);
+		fw_len += (((u32)fw_head->hw_info[1]) << 16);
+		fw_len += (((u32)fw_head->hw_info[0]) << 24);
+	}
+	if (update_msg.fw_total_len != fw_len) {
+		GTP_ERROR
+		    ("size error, Default size: %d(%dK), actual size: %d(%dK)",
+		     fw_len, fw_len / 1024, update_msg.fw_total_len,
+		     update_msg.fw_total_len / 1024);
+		return FAIL;
+	}
+	GTP_INFO("Firmware length:%d(%dK)", update_msg.fw_total_len,
+		 update_msg.fw_total_len / 1024);
 
-		/* 20130523 start */
-		if (strlen(update_msg.ic_fw_msg.pid) < 3) {
-			pr_info("Illegal IC pid, need enter update");
-			return SUCCESS;
-		} else {
-			for (i = 0; i < 3; i++) {
-				if ((update_msg.ic_fw_msg.pid[i] < 0x30) ||
-					(update_msg.ic_fw_msg.pid[i] > 0x39)) {
-					pr_info("Illegal IC pid, out of bound, need enter update");
-					return SUCCESS;
-				}
+	if (update_msg.force_update != 0xBE) {
+		GTP_INFO("FW chksum error,need enter update.");
+		return SUCCESS;
+	}
+	/* 20130523 start */
+	if (strlen(update_msg.ic_fw_msg.pid) < 3) {
+		GTP_INFO("Illegal IC pid, need enter update");
+		return SUCCESS;
+	} else {
+		for (i = 0; i < 3; i++) {
+			if ((update_msg.ic_fw_msg.pid[i] < 0x30)
+			    || (update_msg.ic_fw_msg.pid[i] > 0x39)) {
+				GTP_INFO
+				    ("Illegal IC pid, out of bound");
+				return SUCCESS;
 			}
 		}
-		/* 20130523 end */
+	}
+	/* 20130523 end */
 
-		if ((!memcmp(fw_head->pid, update_msg.ic_fw_msg.pid,
-		(strlen(fw_head->pid) < 3 ? 3 : strlen(fw_head->pid)))) ||
-		(!memcmp(update_msg.ic_fw_msg.pid, "91XX", 4)) ||
-		(!memcmp(fw_head->pid, "91XX", 4))) {
-			if (!memcmp(fw_head->pid, "91XX", 4))
-				pr_debug("Force none same pid update mode.");
-			else
-				pr_debug("Get the same pid.");
+	pid_cmp_len = strlen(fw_head->pid);
+	if (pid_cmp_len < strlen(update_msg.ic_fw_msg.pid))
+		pid_cmp_len = strlen(update_msg.ic_fw_msg.pid);
 
-			/* The third condition */
-			if (fw_head->vid > update_msg.ic_fw_msg.vid) {
-				pr_info("Need enter update.");
-				return SUCCESS;
-			}
-			pr_err("Don't meet the third condition.");
-			pr_err("File VID <= Ic VID, update aborted!");
-		} else {
-			pr_err("File PID != Ic PID, update aborted!");
+	if ((!memcmp(fw_head->pid, update_msg.ic_fw_msg.pid, pid_cmp_len)) ||
+	    (!memcmp(update_msg.ic_fw_msg.pid, "91XX", 4)) ||
+	    (!memcmp(fw_head->pid, "91XX", 4))) {
+		if (!memcmp(fw_head->pid, "91XX", 4))
+			GTP_DEBUG("Force none same pid update mode.");
+		else
+			GTP_DEBUG("Get the same pid.");
+
+		/* The third condition */
+		if (fw_head->vid > update_msg.ic_fw_msg.vid) {
+			GTP_INFO("Need enter update.");
+			return SUCCESS;
 		}
-	} else {
-		pr_err("Different Hardware, update aborted!");
-	}
+		GTP_ERROR("Don't meet the third condition.");
+		GTP_ERROR("File VID <= Ic VID, update aborted!");
+	} else
+		GTP_ERROR("File PID != Ic PID, update aborted!");
 
 	return FAIL;
 }
 
-static s8 gup_update_config(struct i2c_client *client,
-					const struct firmware *cfg)
+#if GTP_AUTO_UPDATE_CFG
+static u8 ascii2hex(u8 a)
+{
+	s8 value = 0;
+
+	if (a >= '0' && a <= '9')
+		value = a - '0';
+	else if (a >= 'A' && a <= 'F')
+		value = a - 'A' + 0x0A;
+	else if (a >= 'a' && a <= 'f')
+		value = a - 'a' + 0x0A;
+	else
+		value = 0xff;
+
+	return value;
+}
+
+static s8 gup_update_config(struct i2c_client *client)
 {
+	s32 file_len = 0;
 	s32 ret = 0;
 	s32 i = 0;
 	s32 file_cfg_len = 0;
-	u32 chip_cfg_len = 0;
+	s32 chip_cfg_len = 0;
 	s32 count = 0;
 	u8 *buf;
+	u8 *pre_buf;
 	u8 *file_config;
-	u8 pid[8];
-	u8 high, low;
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
 
-	if (!cfg || !cfg->data) {
-		pr_err("No need to upgrade config!");
+	if (NULL == update_msg.cfg_file) {
+		GTP_ERROR("[update_cfg]No need to upgrade config!");
 		return FAIL;
 	}
+	file_len =
+	    update_msg.cfg_file->f_op->llseek(update_msg.cfg_file, 0, SEEK_END);
 
-	ret = gup_get_ic_msg(client, GUP_REG_PID_VID, pid, 6);
-	if (ret == FAIL) {
-		pr_err("Read product id & version id fail.");
-		return FAIL;
-	}
-	pid[5] = '\0';
-	pr_debug("update cfg get pid:%s", &pid[GTP_ADDR_LENGTH]);
+	chip_cfg_len = ts->gtp_cfg_len;
 
-	chip_cfg_len = 186;
-	if (!memcmp(&pid[GTP_ADDR_LENGTH], "968", 3) ||
-		!memcmp(&pid[GTP_ADDR_LENGTH], "910", 3) ||
-		!memcmp(&pid[GTP_ADDR_LENGTH], "960", 3)) {
-		chip_cfg_len = 228;
-	}
-	pr_debug("config file ASCII len:%d", cfg->size);
-	pr_debug("need config binary len:%d", chip_cfg_len);
-	if ((cfg->size + 5) < chip_cfg_len * 5) {
-		pr_err("Config length error");
-		return -EINVAL;
+	GTP_DEBUG("[update_cfg]config file len:%d", file_len);
+	GTP_DEBUG("[update_cfg]need config len:%d", chip_cfg_len);
+	if ((file_len + 5) < chip_cfg_len * 5) {
+		GTP_ERROR("Config length error");
+		return FAIL;
 	}
 
-	buf = devm_kzalloc(&client->dev, cfg->size, GFP_KERNEL);
-	if (!buf) {
-		dev_err(&client->dev, "Memory allocation failed for buf.");
-		return -ENOMEM;
-	}
+	buf = kzalloc(file_len, GFP_KERNEL);
+	pre_buf = kzalloc(file_len, GFP_KERNEL);
+	file_config = kzalloc(chip_cfg_len + GTP_ADDR_LENGTH, GFP_KERNEL);
+	update_msg.cfg_file->f_op->llseek(update_msg.cfg_file, 0, SEEK_SET);
 
-	file_config = devm_kzalloc(&client->dev, chip_cfg_len + GTP_ADDR_LENGTH,
-								GFP_KERNEL);
-	if (!file_config) {
-		dev_err(&client->dev, "Memory allocation failed.");
-		return -ENOMEM;
+	GTP_DEBUG("[update_cfg]Read config from file.");
+	ret = update_msg.cfg_file->f_op->read(update_msg.cfg_file,
+					    (char *)pre_buf, file_len,
+					    &update_msg.cfg_file->f_pos);
+	if (ret < 0) {
+		GTP_ERROR("[update_cfg]Read config file failed.");
+		goto update_cfg_file_failed;
 	}
 
-	pr_debug("Delete illgal charactor.");
-	for (i = 0, count = 0; i < cfg->size; i++) {
-		if (cfg->data[i] == ' ' || cfg->data[i] == '\r'
-					|| cfg->data[i] == '\n')
+	GTP_DEBUG("[update_cfg]Delete illgal charactor.");
+	for (i = 0, count = 0; i < file_len; i++) {
+		if (pre_buf[i] == ' ' || pre_buf[i] == '\r'
+		    || pre_buf[i] == '\n')
 			continue;
-		buf[count++] = cfg->data[i];
+		buf[count++] = pre_buf[i];
 	}
 
-	pr_debug("Ascii to hex.");
+	GTP_DEBUG("[update_cfg]Ascii to hex.");
 	file_config[0] = GTP_REG_CONFIG_DATA >> 8;
 	file_config[1] = GTP_REG_CONFIG_DATA & 0xff;
-	for (i = 0, file_cfg_len = GTP_ADDR_LENGTH; i < count; i = i + 5) {
-		if ((buf[i] == '0') && ((buf[i + 1] == 'x') ||
-						(buf[i + 1] == 'X'))) {
-			ret = hex2bin(&high, &buf[i + 2], 1);
-			if (ret) {
-				pr_err("Failed to convert high address from hex2bin");
-				return ret;
-			}
-			ret = hex2bin(&low, &buf[i + 3], 1);
-			if (ret) {
-				pr_err("Failed to convert low address from hex2bin");
-				return ret;
-			}
+	for (i = 0, file_cfg_len = GTP_ADDR_LENGTH; i < count; i += 5) {
+		if ((buf[i] == '0')
+		    && ((buf[i + 1] == 'x') || (buf[i + 1] == 'X'))) {
+			u8 high, low;
+			high = ascii2hex(buf[i + 2]);
+			low = ascii2hex(buf[i + 3]);
 
 			if ((high == 0xFF) || (low == 0xFF)) {
 				ret = 0;
-				pr_err("Illegal config file.");
-				return ret;
+				GTP_ERROR("[update_cfg]Illegal config file.");
+				goto update_cfg_file_failed;
 			}
-			file_config[file_cfg_len++] = (high<<4) + low;
+			file_config[file_cfg_len++] = (high << 4) + low;
 		} else {
 			ret = 0;
-			pr_err("Illegal config file.");
-			return ret;
+			GTP_ERROR("[update_cfg]Illegal config file.");
+			goto update_cfg_file_failed;
 		}
 	}
 
+	GTP_DEBUG("config:");
+	GTP_DEBUG_ARRAY(file_config + 2, file_cfg_len);
+
 	i = 0;
 	while (i++ < 5) {
 		ret = gup_i2c_write(client, file_config, file_cfg_len);
 		if (ret > 0) {
-			pr_info("Send config SUCCESS.");
+			GTP_INFO("[update_cfg]Send config SUCCESS.");
 			break;
 		}
-		pr_err("Send config i2c error.");
+		GTP_ERROR("[update_cfg]Send config i2c error.");
 	}
 
+update_cfg_file_failed:
+	kfree(pre_buf);
+	kfree(buf);
+	kfree(file_config);
 	return ret;
 }
+#endif
 
-static s32 gup_get_firmware_file(struct i2c_client *client,
-		struct st_update_msg *msg, u8 *path)
-{
-	s32 ret;
-	const struct firmware *fw = NULL;
-
-	ret = request_firmware(&fw, path, &client->dev);
-	if (ret < 0) {
-		dev_info(&client->dev, "Cannot get firmware - %s (%d)\n",
-					path, ret);
-		return -EEXIST;
-	}
-
-	dev_dbg(&client->dev, "Config File: %s size=%d", path, fw->size);
-	msg->fw_data =
-		devm_kzalloc(&client->dev, fw->size, GFP_KERNEL);
-	if (!msg->fw_data) {
-		dev_err(&client->dev,
-			"Not enough memory for firmware data.");
-		release_firmware(fw);
-		return -ENOMEM;
-	}
-
-	memcpy(msg->fw_data, fw->data, fw->size);
-	msg->fw_len = fw->size;
-	msg->need_free = true;
-	release_firmware(fw);
-	return 0;
-}
-
-static u8 gup_check_firmware_name(struct i2c_client *client,
-					u8 **path_p)
+#if (GTP_AUTO_UPDATE && (!GTP_HEADER_FW_UPDATE || GTP_AUTO_UPDATE_CFG))
+static void gup_search_file(s32 search_type)
 {
-	u8 len;
-	u8 *fname;
+	s32 i = 0;
+	struct file *pfile = NULL;
+	struct filename name;
 
-	if (!(*path_p)) {
-		*path_p = GOODIX_FIRMWARE_FILE_NAME;
-		return 0;
-	}
+	got_file_flag = 0x00;
 
-	len = strnlen(*path_p, FIRMWARE_NAME_LEN_MAX);
-	if (len >= FIRMWARE_NAME_LEN_MAX) {
-		dev_err(&client->dev, "firmware name too long!");
-		return -EINVAL;
-	}
+	searching_file = 1;
+	for (i = 0; i < GUP_SEARCH_FILE_TIMES; ++i) {
+		if (0 == searching_file) {
+			GTP_INFO("Force exiting file searching");
+			got_file_flag = 0x00;
+			return;
+		}
 
-	fname = strrchr(*path_p, '/');
-	if (fname) {
-		fname = fname + 1;
-		*path_p = fname;
+		if (search_type & AUTO_SEARCH_BIN) {
+			GTP_DEBUG("Search for %s, %s for fw update.(%d/%d)",
+				  UPDATE_FILE_PATH_1, UPDATE_FILE_PATH_2, i + 1,
+				  GUP_SEARCH_FILE_TIMES);
+			name.name = UPDATE_FILE_PATH_1;
+			pfile = file_open_name(&name, O_RDONLY, 0);
+			if (IS_ERR(pfile)) {
+				name.name = UPDATE_FILE_PATH_2;
+				pfile = file_open_name(&name, O_RDONLY, 0);
+				if (!IS_ERR(pfile)) {
+					GTP_INFO("Bin file: %s for fw update.",
+						 UPDATE_FILE_PATH_2);
+					got_file_flag |= BIN_FILE_READY;
+					update_msg.file = pfile;
+				}
+			} else {
+				GTP_INFO("Bin file: %s for fw update.",
+					 UPDATE_FILE_PATH_1);
+				got_file_flag |= BIN_FILE_READY;
+				update_msg.file = pfile;
+			}
+			if (got_file_flag & BIN_FILE_READY) {
+#if GTP_AUTO_UPDATE_CFG
+				if (search_type & AUTO_SEARCH_CFG)
+					i = GUP_SEARCH_FILE_TIMES;
+				else
+#endif
+				{
+					searching_file = 0;
+					return;
+				}
+			}
+		}
+#if GTP_AUTO_UPDATE_CFG
+		if ((search_type & AUTO_SEARCH_CFG)
+		    && !(got_file_flag & CFG_FILE_READY)) {
+			GTP_DEBUG("Search for %s, %s for config update.(%d/%d)",
+				  CONFIG_FILE_PATH_1, CONFIG_FILE_PATH_2, i + 1,
+				  GUP_SEARCH_FILE_TIMES);
+			name.name = CONFIG_FILE_PATH_1;
+			pfile = file_open_name(&name, O_RDONLY, 0);
+			if (IS_ERR(pfile)) {
+				name.name = CONFIG_FILE_PATH_2;
+				pfile = file_open_name(&name, O_RDONLY, 0);
+				if (!IS_ERR(pfile)) {
+					GTP_INFO
+					    ("Cfg file: %s for config update.",
+					     CONFIG_FILE_PATH_2);
+					got_file_flag |= CFG_FILE_READY;
+					update_msg.cfg_file = pfile;
+				}
+			} else {
+				GTP_INFO("Cfg file: %s for config update.",
+					 CONFIG_FILE_PATH_1);
+				got_file_flag |= CFG_FILE_READY;
+				update_msg.cfg_file = pfile;
+			}
+			if (got_file_flag & CFG_FILE_READY) {
+				searching_file = 0;
+				return;
+			}
+		}
+#endif
+		msleep(3000);
 	}
-	return 0;
+	searching_file = 0;
 }
+#endif
 
 static u8 gup_check_update_file(struct i2c_client *client,
-			struct st_fw_head *fw_head, u8 *path)
+				struct st_fw_head *fw_head, u8 *path)
 {
 	s32 ret = 0;
 	s32 i = 0;
 	s32 fw_checksum = 0;
-	u16 temp;
-	const struct firmware *fw = NULL;
-
-	ret = request_firmware(&fw, GOODIX_CONFIG_FILE_NAME, &client->dev);
-	if (ret < 0) {
-		dev_info(&client->dev, "Cannot get config file - %s (%d)\n",
-						GOODIX_CONFIG_FILE_NAME, ret);
+	u8 buf[FW_HEAD_LENGTH];
+	struct filename name = {.name = path};
+
+	got_file_flag = 0x00;
+	if (path) {
+		GTP_DEBUG("Update File path:%s, %d", path, strlen(path));
+		update_msg.file = file_open_name(&name, O_RDONLY, 0);
+		if (IS_ERR(update_msg.file)) {
+			GTP_ERROR("Open update file(%s) error!", path);
+			return FAIL;
+		}
+		got_file_flag = BIN_FILE_READY;
 	} else {
-		dev_dbg(&client->dev,
-			"Update config File: %s", GOODIX_CONFIG_FILE_NAME);
-		ret = gup_update_config(client, fw);
-		if (ret <= 0)
-			dev_err(&client->dev, "Update config failed.");
-		release_firmware(fw);
+#if GTP_AUTO_UPDATE
+#if GTP_HEADER_FW_UPDATE
+		GTP_INFO("Update by default firmware array");
+		update_msg.fw_total_len =
+		    sizeof(gtp_default_FW) - FW_HEAD_LENGTH;
+		if (sizeof(gtp_default_FW) <
+		    (FW_HEAD_LENGTH + FW_SECTION_LENGTH * 4 +
+		     FW_DSP_ISP_LENGTH + FW_DSP_LENGTH + FW_BOOT_LENGTH)) {
+			GTP_ERROR
+			    ("INVALID gtp_default_FW, check gt9xx_firmware.h!");
+			return FAIL;
+		}
+		GTP_DEBUG("Firmware actual size: %d(%dK)",
+			  update_msg.fw_total_len,
+			  update_msg.fw_total_len / 1024);
+		memcpy(fw_head, &gtp_default_FW[0], FW_HEAD_LENGTH);
+
+		/* check firmware legality */
+		fw_checksum = 0;
+		for (i = 0; i < update_msg.fw_total_len; i += 2)
+			fw_checksum +=
+			    (gtp_default_FW[FW_HEAD_LENGTH + i] << 8) +
+			    gtp_default_FW[FW_HEAD_LENGTH + i + 1];
+
+		GTP_DEBUG("firmware checksum:%x", fw_checksum & 0xFFFF);
+		if (fw_checksum & 0xFFFF) {
+			GTP_ERROR("Illegal firmware file.");
+			return FAIL;
+		}
+		got_file_flag = HEADER_FW_READY;
+		return SUCCESS;
+#else
+
+#if GTP_AUTO_UPDATE_CFG
+		gup_search_file(AUTO_SEARCH_BIN | AUTO_SEARCH_CFG);
+		if (got_file_flag & CFG_FILE_READY) {
+			ret = gup_update_config(i2c_connect_client);
+			if (ret <= 0)
+				GTP_ERROR("Update config failed.");
+			_CLOSE_FILE(update_msg.cfg_file);
+			/* waiting config to be stored in FLASH. */
+			msleep(500);
+		}
+#else
+		gup_search_file(AUTO_SEARCH_BIN);
+#endif
+
+		if (!(got_file_flag & BIN_FILE_READY)) {
+			GTP_ERROR("No bin file for fw update");
+			return FAIL;
+		}
+#endif
+
+#else
+		{
+			GTP_ERROR("NULL file for firmware update");
+			return FAIL;
+		}
+#endif
+	}
+
+	update_msg.old_fs = get_fs();
+	set_fs(KERNEL_DS);
+
+	update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_SET);
+	update_msg.fw_total_len =
+	    update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_END);
+	if (update_msg.fw_total_len <
+	    (FW_HEAD_LENGTH + FW_SECTION_LENGTH * 4 + FW_DSP_ISP_LENGTH +
+	     FW_DSP_LENGTH + FW_BOOT_LENGTH)) {
+		GTP_ERROR("INVALID bin file(size: %d), update aborted.",
+			  update_msg.fw_total_len);
+		return FAIL;
 	}
 
-	update_msg.need_free = false;
-	update_msg.fw_len = 0;
+	update_msg.fw_total_len -= FW_HEAD_LENGTH;
 
-	if (gup_check_firmware_name(client, &path))
-		goto load_failed;
+	GTP_DEBUG("Bin firmware actual size: %d(%dK)", update_msg.fw_total_len,
+		  update_msg.fw_total_len / 1024);
 
-	if (gup_get_firmware_file(client, &update_msg, path))
-		goto load_failed;
+	update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_SET);
+	ret =
+	    update_msg.file->f_op->read(update_msg.file, (char *)buf,
+					FW_HEAD_LENGTH,
+					&update_msg.file->f_pos);
+	if (ret < 0) {
+		GTP_ERROR("Read firmware head in update file error.");
+		return FAIL;
+	}
 
-	memcpy(fw_head, update_msg.fw_data, FW_HEAD_LENGTH);
+	memcpy(fw_head, buf, FW_HEAD_LENGTH);
 
 	/* check firmware legality */
 	fw_checksum = 0;
-	for (i = 0; i < FW_SECTION_LENGTH * 4 + FW_DSP_ISP_LENGTH +
-			FW_DSP_LENGTH + FW_BOOT_LENGTH; i += 2) {
-		temp = (update_msg.fw_data[FW_HEAD_LENGTH + i] << 8) +
-			update_msg.fw_data[FW_HEAD_LENGTH + i + 1];
+	for (i = 0; i < update_msg.fw_total_len; i += 2) {
+		u16 temp;
+		ret =
+		    update_msg.file->f_op->read(update_msg.file, (char *)buf, 2,
+						&update_msg.file->f_pos);
+		if (ret < 0) {
+			GTP_ERROR("Read firmware file error.");
+			return FAIL;
+		}
+		temp = (buf[0] << 8) + buf[1];
 		fw_checksum += temp;
 	}
 
-	pr_debug("firmware checksum:%x", fw_checksum & 0xFFFF);
+	GTP_DEBUG("firmware checksum:%x", fw_checksum & 0xFFFF);
 	if (fw_checksum & 0xFFFF) {
-		dev_err(&client->dev, "Illegal firmware file.");
-		goto load_failed;
+		GTP_ERROR("Illegal firmware file.");
+		return FAIL;
 	}
 
 	return SUCCESS;
-
-load_failed:
-	if (update_msg.need_free) {
-		devm_kfree(&client->dev, update_msg.fw_data);
-		update_msg.need_free = false;
-	}
-	return FAIL;
 }
 
-static u8 gup_burn_proc(struct i2c_client *client, u8 *burn_buf, u16 start_addr,
-							u16 total_length)
+static u8 gup_burn_proc(struct i2c_client *client, u8 *burn_buf,
+			u16 start_addr, u16 total_length)
 {
 	s32 ret = 0;
 	u16 burn_addr = start_addr;
 	u16 frame_length = 0;
 	u16 burn_length = 0;
-	u8  wr_buf[PACK_SIZE + GTP_ADDR_LENGTH];
-	u8  rd_buf[PACK_SIZE + GTP_ADDR_LENGTH];
-	u8  retry = 0;
+	u8 wr_buf[PACK_SIZE + GTP_ADDR_LENGTH];
+	u8 rd_buf[PACK_SIZE + GTP_ADDR_LENGTH];
+	u8 retry = 0;
 
-	pr_debug("Begin burn %dk data to addr 0x%x", (total_length / 1024),
-								start_addr);
+	GTP_DEBUG("Begin burn %dk data to addr 0x%x", (total_length / 1024),
+		  start_addr);
 	while (burn_length < total_length) {
-		pr_debug("B/T:%04d/%04d", burn_length, total_length);
-		frame_length = ((total_length - burn_length) > PACK_SIZE)
-				? PACK_SIZE : (total_length - burn_length);
-		wr_buf[0] = (u8)(burn_addr>>8);
+		GTP_DEBUG("B/T:%04d/%04d", burn_length, total_length);
+		frame_length = ((total_length - burn_length) > PACK_SIZE) ?
+				PACK_SIZE : (total_length - burn_length);
+		wr_buf[0] = (u8)(burn_addr >> 8);
 		rd_buf[0] = wr_buf[0];
 		wr_buf[1] = (u8)burn_addr;
 		rd_buf[1] = wr_buf[1];
 		memcpy(&wr_buf[GTP_ADDR_LENGTH], &burn_buf[burn_length],
-								frame_length);
+		       frame_length);
 
 		for (retry = 0; retry < MAX_FRAME_CHECK_TIME; retry++) {
 			ret = gup_i2c_write(client, wr_buf,
 					GTP_ADDR_LENGTH + frame_length);
 			if (ret <= 0) {
-				pr_err("Write frame data i2c error.");
+				GTP_ERROR("Write frame data i2c error.");
 				continue;
 			}
-			ret = gup_i2c_read(client, rd_buf, GTP_ADDR_LENGTH +
-							frame_length);
+			ret = gup_i2c_read(client, rd_buf,
+					GTP_ADDR_LENGTH + frame_length);
 			if (ret <= 0) {
-				pr_err("Read back frame data i2c error.");
+				GTP_ERROR("Read back frame data i2c error.");
 				continue;
 			}
 
-			if (memcmp(&wr_buf[GTP_ADDR_LENGTH],
-				&rd_buf[GTP_ADDR_LENGTH], frame_length)) {
-				pr_err("Check frame data fail,not equal.");
+			if (memcmp
+			    (&wr_buf[GTP_ADDR_LENGTH], &rd_buf[GTP_ADDR_LENGTH],
+			     frame_length)) {
+				GTP_ERROR("Check frame data fail,not equal.");
+				GTP_DEBUG("write array:");
+				GTP_DEBUG_ARRAY(&wr_buf[GTP_ADDR_LENGTH],
+						frame_length);
+				GTP_DEBUG("read array:");
+				GTP_DEBUG_ARRAY(&rd_buf[GTP_ADDR_LENGTH],
+						frame_length);
 				continue;
 			} else {
+				/* GTP_DEBUG("Check frame data success."); */
 				break;
 			}
 		}
 		if (retry >= MAX_FRAME_CHECK_TIME) {
-			pr_err("Burn frame data time out,exit.");
+			GTP_ERROR("Burn frame data time out,exit.");
 			return FAIL;
 		}
 		burn_length += frame_length;
@@ -805,116 +982,144 @@ static u8 gup_burn_proc(struct i2c_client *client, u8 *burn_buf, u16 start_addr,
 	return SUCCESS;
 }
 
-static u8 gup_load_section_file(u8 *buf, u16 offset, u16 length)
+static u8 gup_load_section_file(u8 *buf, u32 offset, u16 length, u8 set_or_end)
 {
-	if (!update_msg.fw_data ||
-		update_msg.fw_len < FW_HEAD_LENGTH + offset + length) {
-		pr_err(
-			"<<-GTP->> cannot load section data. fw_len=%d read end=%d\n",
-			update_msg.fw_len ,
-			FW_HEAD_LENGTH + offset + length);
-		return FAIL;
+#if (GTP_AUTO_UPDATE && GTP_HEADER_FW_UPDATE)
+	if (got_file_flag == HEADER_FW_READY) {
+		if (SEEK_SET == set_or_end)
+			memcpy(buf, &gtp_default_FW[FW_HEAD_LENGTH + offset],
+			       length);
+		else
+			memcpy(buf,
+			       &gtp_default_FW[update_msg.fw_total_len +
+					       FW_HEAD_LENGTH - offset],
+			       length);
+		return SUCCESS;
 	}
-	memcpy(buf, &update_msg.fw_data[FW_HEAD_LENGTH + offset], length);
+#endif
+	{
+		s32 ret = 0;
 
-	return SUCCESS;
+		if ((update_msg.file == NULL) || IS_ERR(update_msg.file)) {
+			GTP_ERROR
+			    ("cannot find update file,load section file fail.");
+			return FAIL;
+		}
+
+		if (SEEK_SET == set_or_end)
+			update_msg.file->f_pos = FW_HEAD_LENGTH + offset;
+		else
+			update_msg.file->f_pos =
+			    update_msg.fw_total_len + FW_HEAD_LENGTH - offset;
+
+		ret =
+		    update_msg.file->f_op->read(update_msg.file, (char *)buf,
+						length,
+						&update_msg.file->f_pos);
+		if (ret < 0) {
+			GTP_ERROR("Read update file fail.");
+			return FAIL;
+		}
+
+		return SUCCESS;
+	}
 }
 
 static u8 gup_recall_check(struct i2c_client *client, u8 *chk_src,
-					u16 start_rd_addr, u16 chk_length)
+			   u16 start_rd_addr, u16 chk_length)
 {
-	u8  rd_buf[PACK_SIZE + GTP_ADDR_LENGTH];
+	u8 rd_buf[PACK_SIZE + GTP_ADDR_LENGTH];
 	s32 ret = 0;
 	u16 recall_addr = start_rd_addr;
 	u16 recall_length = 0;
 	u16 frame_length = 0;
 
 	while (recall_length < chk_length) {
-		frame_length = ((chk_length - recall_length) > PACK_SIZE)
-				? PACK_SIZE : (chk_length - recall_length);
+		frame_length = ((chk_length - recall_length) > PACK_SIZE) ?
+				PACK_SIZE : (chk_length - recall_length);
 		ret = gup_get_ic_msg(client, recall_addr, rd_buf, frame_length);
 		if (ret <= 0) {
-			pr_err("recall i2c error,exit");
+			GTP_ERROR("recall i2c error,exit");
 			return FAIL;
 		}
 
-		if (memcmp(&rd_buf[GTP_ADDR_LENGTH], &chk_src[recall_length],
-			frame_length)) {
-			pr_err("Recall frame data fail,not equal.");
+		if (memcmp
+		    (&rd_buf[GTP_ADDR_LENGTH], &chk_src[recall_length],
+		     frame_length)) {
+			GTP_ERROR("Recall frame data fail,not equal.");
+			GTP_DEBUG("chk_src array:");
+			GTP_DEBUG_ARRAY(&chk_src[recall_length], frame_length);
+			GTP_DEBUG("recall array:");
+			GTP_DEBUG_ARRAY(&rd_buf[GTP_ADDR_LENGTH], frame_length);
 			return FAIL;
 		}
 
 		recall_length += frame_length;
 		recall_addr += frame_length;
 	}
-	pr_debug("Recall check %dk firmware success.", (chk_length/1024));
+	GTP_DEBUG("Recall check %dk firmware success.", (chk_length / 1024));
 
 	return SUCCESS;
 }
 
 static u8 gup_burn_fw_section(struct i2c_client *client, u8 *fw_section,
-					u16 start_addr, u8 bank_cmd)
+			      u16 start_addr, u8 bank_cmd)
 {
 	s32 ret = 0;
-	u8  rd_buf[5];
+	u8 rd_buf[5];
 
 	/* step1:hold ss51 & dsp */
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
 	if (ret <= 0) {
-		pr_err("hold ss51 & dsp fail.");
+		GTP_ERROR("[burn_fw_section]hold ss51 & dsp fail.");
 		return FAIL;
 	}
-
-	 /* step2:set scramble */
+	/* step2:set scramble */
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
 	if (ret <= 0) {
-		pr_err("set scramble fail.");
+		GTP_ERROR("[burn_fw_section]set scramble fail.");
 		return FAIL;
 	}
-
 	/* step3:select bank */
 	ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK,
-						(bank_cmd >> 4)&0x0F);
+				(bank_cmd >> 4) & 0x0F);
 	if (ret <= 0) {
-		pr_err("select bank %d fail.",
-					(bank_cmd >> 4)&0x0F);
+		GTP_ERROR("[burn_fw_section]select bank %d fail.",
+			  (bank_cmd >> 4) & 0x0F);
 		return FAIL;
 	}
-
 	/* step4:enable accessing code */
 	ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x01);
 	if (ret <= 0) {
-		pr_err("enable accessing code fail.");
+		GTP_ERROR("[burn_fw_section]enable accessing code fail.");
 		return FAIL;
 	}
-
 	/* step5:burn 8k fw section */
 	ret = gup_burn_proc(client, fw_section, start_addr, FW_SECTION_LENGTH);
-	if (ret == FAIL)  {
-		pr_err("burn fw_section fail.");
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_section]burn fw_section fail.");
 		return FAIL;
 	}
-
 	/* step6:hold ss51 & release dsp */
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);
 	if (ret <= 0) {
-		pr_err("hold ss51 & release dsp fail.");
+		GTP_ERROR("[burn_fw_section]hold ss51 & release dsp fail.");
 		return FAIL;
 	}
 	/* must delay */
 	msleep(20);
 
 	/* step7:send burn cmd to move data to flash from sram */
-	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, bank_cmd&0x0f);
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, bank_cmd & 0x0f);
 	if (ret <= 0) {
-		pr_err("send burn cmd fail.");
+		GTP_ERROR("[burn_fw_section]send burn cmd fail.");
 		return FAIL;
 	}
-	pr_debug("Wait for the burn is complete.");
+	GTP_DEBUG("[burn_fw_section]Wait for the burn is complete......");
 	do {
 		ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
 		if (ret <= 0) {
-			pr_err("Get burn state fail");
+			GTP_ERROR("[burn_fw_section]Get burn state fail");
 			return FAIL;
 		}
 		msleep(20);
@@ -922,32 +1127,30 @@ static u8 gup_burn_fw_section(struct i2c_client *client, u8 *fw_section,
 
 	/* step8:select bank */
 	ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK,
-							(bank_cmd >> 4)&0x0F);
+				(bank_cmd >> 4) & 0x0F);
 	if (ret <= 0) {
-		pr_err("select bank %d fail.",
-							(bank_cmd >> 4)&0x0F);
+		GTP_ERROR("[burn_fw_section]select bank %d fail.",
+			  (bank_cmd >> 4) & 0x0F);
 		return FAIL;
 	}
-
 	/* step9:enable accessing code */
 	ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x01);
 	if (ret <= 0) {
-		pr_err("enable accessing code fail.");
+		GTP_ERROR("[burn_fw_section]enable accessing code fail.");
 		return FAIL;
 	}
-
 	/* step10:recall 8k fw section */
-	ret = gup_recall_check(client, fw_section, start_addr,
-							FW_SECTION_LENGTH);
-	if (ret == FAIL) {
-		pr_err("recall check 8k firmware fail.");
+	ret = gup_recall_check(client, fw_section,
+				start_addr, FW_SECTION_LENGTH);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_section]recall check %dk firmware fail.",
+			  FW_SECTION_LENGTH / 1024);
 		return FAIL;
 	}
-
 	/* step11:disable accessing code */
 	ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x00);
 	if (ret <= 0) {
-		pr_err("disable accessing code fail.");
+		GTP_ERROR("[burn_fw_section]disable accessing code fail.");
 		return FAIL;
 	}
 
@@ -958,489 +1161,940 @@ static u8 gup_burn_dsp_isp(struct i2c_client *client)
 {
 	s32 ret = 0;
 	u8 *fw_dsp_isp = NULL;
-	u8  retry = 0;
+	u8 retry = 0;
 
-	pr_debug("Begin burn dsp isp.");
+	GTP_INFO("[burn_dsp_isp]Begin burn dsp isp---->>");
 
 	/* step1:alloc memory */
-	pr_debug("step1:alloc memory");
+	GTP_DEBUG("[burn_dsp_isp]step1:alloc memory");
 	while (retry++ < 5) {
-		fw_dsp_isp = devm_kzalloc(&client->dev, FW_DSP_ISP_LENGTH,
-								GFP_KERNEL);
-		if (fw_dsp_isp == NULL) {
+		fw_dsp_isp = kzalloc(FW_DSP_ISP_LENGTH, GFP_KERNEL);
+		if (fw_dsp_isp == NULL)
 			continue;
-		} else {
-			pr_info("Alloc %dk byte memory success.",
-					(FW_DSP_ISP_LENGTH/1024));
+		else {
+			GTP_INFO("[burn_dsp_isp]Alloc %dk byte memory success.",
+				 (FW_DSP_ISP_LENGTH / 1024));
 			break;
 		}
 	}
-	if (retry == 5) {
-		pr_err("Alloc memory fail,exit.");
+	if (retry >= 5) {
+		GTP_ERROR("[burn_dsp_isp]Alloc memory fail,exit.");
 		return FAIL;
 	}
-
 	/* step2:load dsp isp file data */
-	pr_debug("step2:load dsp isp file data");
-	ret = gup_load_section_file(fw_dsp_isp, (4 * FW_SECTION_LENGTH +
-		FW_DSP_LENGTH + FW_BOOT_LENGTH), FW_DSP_ISP_LENGTH);
-	if (ret == FAIL) {
-		pr_err("load firmware dsp_isp fail.");
-		return FAIL;
+	GTP_DEBUG("[burn_dsp_isp]step2:load dsp isp file data");
+	ret = gup_load_section_file(fw_dsp_isp, FW_DSP_ISP_LENGTH,
+				FW_DSP_ISP_LENGTH, SEEK_END);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_dsp_isp]load firmware dsp_isp fail.");
+		goto exit_burn_dsp_isp;
 	}
-
 	/* step3:disable wdt,clear cache enable */
-	pr_debug("step3:disable wdt,clear cache enable");
+	GTP_DEBUG("[burn_dsp_isp]step3:disable wdt,clear cache enable");
 	ret = gup_set_ic_msg(client, _bRW_MISCTL__TMR0_EN, 0x00);
 	if (ret <= 0) {
-		pr_err("disable wdt fail.");
-		return FAIL;
+		GTP_ERROR("[burn_dsp_isp]disable wdt fail.");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
 	}
 	ret = gup_set_ic_msg(client, _bRW_MISCTL__CACHE_EN, 0x00);
 	if (ret <= 0) {
-		pr_err("clear cache enable fail.");
-		return FAIL;
+		GTP_ERROR("[burn_dsp_isp]clear cache enable fail.");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
 	}
-
 	/* step4:hold ss51 & dsp */
-	pr_debug("step4:hold ss51 & dsp");
+	GTP_DEBUG("[burn_dsp_isp]step4:hold ss51 & dsp");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
 	if (ret <= 0) {
-		pr_err("hold ss51 & dsp fail.");
-		return FAIL;
+		GTP_ERROR("[burn_dsp_isp]hold ss51 & dsp fail.");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
 	}
-
 	/* step5:set boot from sram */
-	pr_debug("step5:set boot from sram");
+	GTP_DEBUG("[burn_dsp_isp]step5:set boot from sram");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOTCTL_B0_, 0x02);
 	if (ret <= 0) {
-		pr_err("set boot from sram fail.");
-		return FAIL;
+		GTP_ERROR("[burn_dsp_isp]set boot from sram fail.");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
 	}
-
 	/* step6:software reboot */
-	pr_debug("step6:software reboot");
+	GTP_DEBUG("[burn_dsp_isp]step6:software reboot");
 	ret = gup_set_ic_msg(client, _bWO_MISCTL__CPU_SWRST_PULSE, 0x01);
 	if (ret <= 0) {
-		pr_err("software reboot fail.");
-		return FAIL;
+		GTP_ERROR("[burn_dsp_isp]software reboot fail.");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
 	}
-
 	/* step7:select bank2 */
-	pr_debug("step7:select bank2");
+	GTP_DEBUG("[burn_dsp_isp]step7:select bank2");
 	ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x02);
 	if (ret <= 0) {
-		pr_err("select bank2 fail.");
-		return FAIL;
+		GTP_ERROR("[burn_dsp_isp]select bank2 fail.");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
 	}
-
 	/* step8:enable accessing code */
-	pr_debug("step8:enable accessing code");
+	GTP_DEBUG("[burn_dsp_isp]step8:enable accessing code");
 	ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x01);
 	if (ret <= 0) {
-		pr_err("enable accessing code fail.");
-		return FAIL;
+		GTP_ERROR("[burn_dsp_isp]enable accessing code fail.");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
 	}
-
 	/* step9:burn 4k dsp_isp */
-	pr_debug("step9:burn 4k dsp_isp");
+	GTP_DEBUG("[burn_dsp_isp]step9:burn 4k dsp_isp");
 	ret = gup_burn_proc(client, fw_dsp_isp, 0xC000, FW_DSP_ISP_LENGTH);
-	if (ret == FAIL) {
-		pr_err("burn dsp_isp fail.");
-		return FAIL;
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_dsp_isp]burn dsp_isp fail.");
+		goto exit_burn_dsp_isp;
 	}
-
 	/* step10:set scramble */
-	pr_debug("step10:set scramble");
+	GTP_DEBUG("[burn_dsp_isp]step10:set scramble");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
 	if (ret <= 0) {
-		pr_err("set scramble fail.");
-		return FAIL;
+		GTP_ERROR("[burn_dsp_isp]set scramble fail.");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
 	}
+	update_msg.fw_burned_len += FW_DSP_ISP_LENGTH;
+	GTP_DEBUG("[burn_dsp_isp]Burned length:%d", update_msg.fw_burned_len);
+	ret = SUCCESS;
 
-	return SUCCESS;
+exit_burn_dsp_isp:
+	kfree(fw_dsp_isp);
+	return ret;
 }
 
 static u8 gup_burn_fw_ss51(struct i2c_client *client)
 {
 	u8 *fw_ss51 = NULL;
-	u8  retry = 0;
+	u8 retry = 0;
 	s32 ret = 0;
 
-	pr_debug("Begin burn ss51 firmware.");
+	GTP_INFO("[burn_fw_ss51]Begin burn ss51 firmware---->>");
 
 	/* step1:alloc memory */
-	pr_debug("step1:alloc memory");
+	GTP_DEBUG("[burn_fw_ss51]step1:alloc memory");
 	while (retry++ < 5) {
-		fw_ss51 = devm_kzalloc(&client->dev, FW_SECTION_LENGTH,
-							GFP_KERNEL);
-		if (fw_ss51 == NULL) {
+		fw_ss51 = kzalloc(FW_SECTION_LENGTH, GFP_KERNEL);
+		if (fw_ss51 == NULL)
 			continue;
-		} else {
-			pr_info("Alloc %dk byte memory success.",
-						(FW_SECTION_LENGTH/1024));
+		else {
+			GTP_DEBUG
+			    ("[burn_fw_ss51]Alloc %dk byte memory success.",
+			     (FW_SECTION_LENGTH / 1024));
 			break;
 		}
 	}
-	if (retry == 5) {
-		pr_err("Alloc memory fail,exit.");
+	if (retry >= 5) {
+		GTP_ERROR("[burn_fw_ss51]Alloc memory fail,exit.");
 		return FAIL;
 	}
-
 	/* step2:load ss51 firmware section 1 file data */
-	pr_debug("step2:load ss51 firmware section 1 file data");
-	ret = gup_load_section_file(fw_ss51, 0, FW_SECTION_LENGTH);
-	if (ret == FAIL) {
-		pr_err("load ss51 firmware section 1 fail.");
-		return FAIL;
-	}
+	/*
+	GTP_DEBUG("[burn_fw_ss51]step2:load ss51 firmware section 1 file data");
+	ret = gup_load_section_file(fw_ss51, 0, FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+	GTP_ERROR("[burn_fw_ss51]load ss51 firmware section 1 fail.");
+	goto exit_burn_fw_ss51;
+	} */
+
+	GTP_INFO("[burn_fw_ss51]Reset first 8K of ss51 to 0xFF.");
+	GTP_DEBUG("[burn_fw_ss51]step2: reset bank0 0xC000~0xD000");
+	memset(fw_ss51, 0xFF, FW_SECTION_LENGTH);
 
 	/* step3:clear control flag */
-	pr_debug("step3:clear control flag");
+	GTP_DEBUG("[burn_fw_ss51]step3:clear control flag");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x00);
 	if (ret <= 0) {
-		pr_err("clear control flag fail.");
-		return FAIL;
+		GTP_ERROR("[burn_fw_ss51]clear control flag fail.");
+		ret = FAIL;
+		goto exit_burn_fw_ss51;
 	}
-
 	/* step4:burn ss51 firmware section 1 */
-	pr_debug("step4:burn ss51 firmware section 1");
+	GTP_DEBUG("[burn_fw_ss51]step4:burn ss51 firmware section 1");
 	ret = gup_burn_fw_section(client, fw_ss51, 0xC000, 0x01);
-	if (ret == FAIL) {
-		pr_err("burn ss51 firmware section 1 fail.");
-		return FAIL;
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_ss51]burn ss51 firmware section 1 fail.");
+		goto exit_burn_fw_ss51;
 	}
-
 	/* step5:load ss51 firmware section 2 file data */
-	pr_debug("step5:load ss51 firmware section 2 file data");
+	GTP_DEBUG("[burn_fw_ss51]step5:load ss51 firmware section 2 file data");
 	ret = gup_load_section_file(fw_ss51, FW_SECTION_LENGTH,
-							FW_SECTION_LENGTH);
-	if (ret == FAIL) {
-		pr_err("[burn_fw_ss51]load ss51 firmware section 2 fail.");
-		return FAIL;
+					FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_ss51]load ss51 firmware section 2 fail.");
+		goto exit_burn_fw_ss51;
 	}
-
 	/* step6:burn ss51 firmware section 2 */
-	pr_debug("step6:burn ss51 firmware section 2");
+	GTP_DEBUG("[burn_fw_ss51]step6:burn ss51 firmware section 2");
 	ret = gup_burn_fw_section(client, fw_ss51, 0xE000, 0x02);
-	if (ret == FAIL) {
-		pr_err("burn ss51 firmware section 2 fail.");
-		return FAIL;
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_ss51]burn ss51 firmware section 2 fail.");
+		goto exit_burn_fw_ss51;
 	}
-
 	/* step7:load ss51 firmware section 3 file data */
-	pr_debug("step7:load ss51 firmware section 3 file data");
-	ret = gup_load_section_file(fw_ss51, 2*FW_SECTION_LENGTH,
-							FW_SECTION_LENGTH);
-	if (ret == FAIL) {
-		pr_err("load ss51 firmware section 3 fail.");
-		return FAIL;
+	GTP_DEBUG("[burn_fw_ss51]step7:load ss51 firmware section 3 file data");
+	ret = gup_load_section_file(fw_ss51, 2 * FW_SECTION_LENGTH,
+					FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_ss51]load ss51 firmware section 3 fail.");
+		goto exit_burn_fw_ss51;
 	}
-
 	/* step8:burn ss51 firmware section 3 */
-	pr_debug("step8:burn ss51 firmware section 3");
+	GTP_DEBUG("[burn_fw_ss51]step8:burn ss51 firmware section 3");
 	ret = gup_burn_fw_section(client, fw_ss51, 0xC000, 0x13);
-	if (ret == FAIL) {
-		pr_err("burn ss51 firmware section 3 fail.");
-		return FAIL;
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_ss51]burn ss51 firmware section 3 fail.");
+		goto exit_burn_fw_ss51;
 	}
-
 	/* step9:load ss51 firmware section 4 file data */
-	pr_debug("step9:load ss51 firmware section 4 file data");
-	ret = gup_load_section_file(fw_ss51, 3*FW_SECTION_LENGTH,
-							FW_SECTION_LENGTH);
-	if (ret == FAIL) {
-		pr_err("load ss51 firmware section 4 fail.");
-		return FAIL;
+	GTP_DEBUG("[burn_fw_ss51]step9:load ss51 firmware section 4 file data");
+	ret = gup_load_section_file(fw_ss51, 3 * FW_SECTION_LENGTH,
+					FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_ss51]load ss51 firmware section 4 fail.");
+		goto exit_burn_fw_ss51;
 	}
-
 	/* step10:burn ss51 firmware section 4 */
-	pr_debug("step10:burn ss51 firmware section 4");
+	GTP_DEBUG("[burn_fw_ss51]step10:burn ss51 firmware section 4");
 	ret = gup_burn_fw_section(client, fw_ss51, 0xE000, 0x14);
-	if (ret == FAIL) {
-		pr_err("burn ss51 firmware section 4 fail.");
-		return FAIL;
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_ss51]burn ss51 firmware section 4 fail.");
+		goto exit_burn_fw_ss51;
 	}
 
-	return SUCCESS;
+	update_msg.fw_burned_len += (FW_SECTION_LENGTH * 4);
+	GTP_DEBUG("[burn_fw_ss51]Burned length:%d", update_msg.fw_burned_len);
+	ret = SUCCESS;
+
+exit_burn_fw_ss51:
+	kfree(fw_ss51);
+	return ret;
 }
 
 static u8 gup_burn_fw_dsp(struct i2c_client *client)
 {
 	s32 ret = 0;
 	u8 *fw_dsp = NULL;
-	u8  retry = 0;
-	u8  rd_buf[5];
+	u8 retry = 0;
+	u8 rd_buf[5];
 
-	pr_debug("Begin burn dsp firmware.");
+	GTP_INFO("[burn_fw_dsp]Begin burn dsp firmware---->>");
 	/* step1:alloc memory */
-	pr_debug("step1:alloc memory");
+	GTP_DEBUG("[burn_fw_dsp]step1:alloc memory");
 	while (retry++ < 5) {
-		fw_dsp = devm_kzalloc(&client->dev, FW_DSP_LENGTH,
-							GFP_KERNEL);
-		if (fw_dsp == NULL) {
+		fw_dsp = kzalloc(FW_DSP_LENGTH, GFP_KERNEL);
+		if (fw_dsp == NULL)
 			continue;
-		} else  {
-			pr_info("Alloc %dk byte memory success.",
-					(FW_SECTION_LENGTH/1024));
+		else {
+			GTP_DEBUG("[burn_fw_dsp]Alloc %dk byte memory success.",
+				  (FW_SECTION_LENGTH / 1024));
 			break;
 		}
 	}
-	if (retry == 5) {
-		pr_err("Alloc memory fail,exit.");
+	if (retry >= 5) {
+		GTP_ERROR("[burn_fw_dsp]Alloc memory fail,exit.");
 		return FAIL;
 	}
-
 	/* step2:load firmware dsp */
-	pr_debug("step2:load firmware dsp");
-	ret = gup_load_section_file(fw_dsp, 4*FW_SECTION_LENGTH, FW_DSP_LENGTH);
-	if (ret == FAIL) {
-		pr_err("load firmware dsp fail.");
-		return ret;
+	GTP_DEBUG("[burn_fw_dsp]step2:load firmware dsp");
+	ret = gup_load_section_file(fw_dsp, 4 * FW_SECTION_LENGTH,
+					FW_DSP_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_dsp]load firmware dsp fail.");
+		goto exit_burn_fw_dsp;
 	}
-
 	/* step3:select bank3 */
-	pr_debug("step3:select bank3");
+	GTP_DEBUG("[burn_fw_dsp]step3:select bank3");
 	ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x03);
 	if (ret <= 0) {
-		pr_err("select bank3 fail.");
-		return FAIL;
+		GTP_ERROR("[burn_fw_dsp]select bank3 fail.");
+		ret = FAIL;
+		goto exit_burn_fw_dsp;
 	}
-
-	/* Step4:hold ss51 & dsp */
-	pr_debug("step4:hold ss51 & dsp");
+	/* step4:hold ss51 & dsp */
+	GTP_DEBUG("[burn_fw_dsp]step4:hold ss51 & dsp");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
 	if (ret <= 0) {
-		pr_err("hold ss51 & dsp fail.");
-		return FAIL;
+		GTP_ERROR("[burn_fw_dsp]hold ss51 & dsp fail.");
+		ret = FAIL;
+		goto exit_burn_fw_dsp;
 	}
-
 	/* step5:set scramble */
-	pr_debug("step5:set scramble");
+	GTP_DEBUG("[burn_fw_dsp]step5:set scramble");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
 	if (ret <= 0) {
-		pr_err("set scramble fail.");
-		return FAIL;
+		GTP_ERROR("[burn_fw_dsp]set scramble fail.");
+		ret = FAIL;
+		goto exit_burn_fw_dsp;
 	}
-
 	/* step6:release ss51 & dsp */
-	pr_debug("step6:release ss51 & dsp");
+	GTP_DEBUG("[burn_fw_dsp]step6:release ss51 & dsp");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);
 	if (ret <= 0) {
-		pr_err("release ss51 & dsp fail.");
-		return FAIL;
+		GTP_ERROR("[burn_fw_dsp]release ss51 & dsp fail.");
+		ret = FAIL;
+		goto exit_burn_fw_dsp;
 	}
 	/* must delay */
 	msleep(20);
 
 	/* step7:burn 4k dsp firmware */
-	pr_debug("step7:burn 4k dsp firmware");
+	GTP_DEBUG("[burn_fw_dsp]step7:burn 4k dsp firmware");
 	ret = gup_burn_proc(client, fw_dsp, 0x9000, FW_DSP_LENGTH);
-	if (ret == FAIL) {
-		pr_err("[burn_fw_dsp]burn fw_section fail.");
-		return ret;
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_dsp]burn fw_section fail.");
+		goto exit_burn_fw_dsp;
 	}
-
 	/* step8:send burn cmd to move data to flash from sram */
-	pr_debug("step8:send burn cmd to move data to flash from sram");
+	GTP_DEBUG
+	    ("[burn_fw_dsp]step8: move data to flash from sram");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x05);
 	if (ret <= 0) {
-		pr_err("send burn cmd fail.");
-		return ret;
+		GTP_ERROR("[burn_fw_dsp]send burn cmd fail.");
+		goto exit_burn_fw_dsp;
 	}
-	pr_debug("Wait for the burn is complete.");
+	GTP_DEBUG("[burn_fw_dsp]Wait for the burn is complete......");
 	do {
 		ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
 		if (ret <= 0) {
-			pr_err("Get burn state fail");
-			return ret;
+			GTP_ERROR("[burn_fw_dsp]Get burn state fail");
+			goto exit_burn_fw_dsp;
 		}
 		msleep(20);
 	} while (rd_buf[GTP_ADDR_LENGTH]);
 
 	/* step9:recall check 4k dsp firmware */
-	pr_debug("step9:recall check 4k dsp firmware");
+	GTP_DEBUG("[burn_fw_dsp]step9:recall check 4k dsp firmware");
 	ret = gup_recall_check(client, fw_dsp, 0x9000, FW_DSP_LENGTH);
-	if (ret == FAIL) {
-		pr_err("recall check 4k dsp firmware fail.");
-		return ret;
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_dsp]recall check 4k dsp firmware fail.");
+		goto exit_burn_fw_dsp;
 	}
 
-	return SUCCESS;
+	update_msg.fw_burned_len += FW_DSP_LENGTH;
+	GTP_DEBUG("[burn_fw_dsp]Burned length:%d", update_msg.fw_burned_len);
+	ret = SUCCESS;
+
+exit_burn_fw_dsp:
+	kfree(fw_dsp);
+	return ret;
 }
 
 static u8 gup_burn_fw_boot(struct i2c_client *client)
 {
 	s32 ret = 0;
 	u8 *fw_boot = NULL;
-	u8  retry = 0;
-	u8  rd_buf[5];
+	u8 retry = 0;
+	u8 rd_buf[5];
 
-	pr_debug("Begin burn bootloader firmware.");
+	GTP_INFO("[burn_fw_boot]Begin burn bootloader firmware---->>");
 
 	/* step1:Alloc memory */
-	pr_debug("step1:Alloc memory");
+	GTP_DEBUG("[burn_fw_boot]step1:Alloc memory");
 	while (retry++ < 5) {
-		fw_boot = devm_kzalloc(&client->dev, FW_BOOT_LENGTH,
-							GFP_KERNEL);
-		if (fw_boot == NULL) {
+		fw_boot = kzalloc(FW_BOOT_LENGTH, GFP_KERNEL);
+		if (fw_boot == NULL)
 			continue;
-		} else {
-			pr_info("Alloc %dk byte memory success.",
-						(FW_BOOT_LENGTH/1024));
+		else {
+			GTP_DEBUG
+			    ("[burn_fw_boot]Alloc %dk byte memory success.",
+			     (FW_BOOT_LENGTH / 1024));
 			break;
 		}
 	}
-	if (retry == 5) {
-		pr_err("Alloc memory fail,exit.");
+	if (retry >= 5) {
+		GTP_ERROR("[burn_fw_boot]Alloc memory fail,exit.");
 		return FAIL;
 	}
-
 	/* step2:load firmware bootloader */
-	pr_debug("step2:load firmware bootloader");
-	ret = gup_load_section_file(fw_boot, (4 * FW_SECTION_LENGTH +
-				FW_DSP_LENGTH), FW_BOOT_LENGTH);
-	if (ret == FAIL) {
-		pr_err("load firmware dsp fail.");
-		return ret;
+	GTP_DEBUG("[burn_fw_boot]step2:load firmware bootloader");
+	ret = gup_load_section_file(fw_boot,
+				(4 * FW_SECTION_LENGTH + FW_DSP_LENGTH),
+				FW_BOOT_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_boot]load firmware bootcode fail.");
+		goto exit_burn_fw_boot;
 	}
-
 	/* step3:hold ss51 & dsp */
-	pr_debug("step3:hold ss51 & dsp");
+	GTP_DEBUG("[burn_fw_boot]step3:hold ss51 & dsp");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
 	if (ret <= 0) {
-		pr_err("hold ss51 & dsp fail.");
-		return FAIL;
+		GTP_ERROR("[burn_fw_boot]hold ss51 & dsp fail.");
+		ret = FAIL;
+		goto exit_burn_fw_boot;
 	}
-
 	/* step4:set scramble */
-	pr_debug("step4:set scramble");
+	GTP_DEBUG("[burn_fw_boot]step4:set scramble");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
 	if (ret <= 0) {
-		pr_err("set scramble fail.");
-		return FAIL;
+		GTP_ERROR("[burn_fw_boot]set scramble fail.");
+		ret = FAIL;
+		goto exit_burn_fw_boot;
 	}
-
-	/* step5:release ss51 & dsp */
-	pr_debug("step5:release ss51 & dsp");
+	/* step5:hold ss51 & release dsp */
+	GTP_DEBUG("[burn_fw_boot]step5:hold ss51 & release dsp");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);
 	if (ret <= 0) {
-		pr_err("release ss51 & dsp fail.");
-		return FAIL;
+		GTP_ERROR("[burn_fw_boot]release ss51 & dsp fail.");
+		ret = FAIL;
+		goto exit_burn_fw_boot;
 	}
 	/* must delay */
 	msleep(20);
 
 	/* step6:select bank3 */
-	pr_debug("step6:select bank3");
+	GTP_DEBUG("[burn_fw_boot]step6:select bank3");
 	ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x03);
 	if (ret <= 0) {
-		pr_err("select bank3 fail.");
-		return FAIL;
+		GTP_ERROR("[burn_fw_boot]select bank3 fail.");
+		ret = FAIL;
+		goto exit_burn_fw_boot;
 	}
-
-	/* step7:burn 2k bootloader firmware */
-	pr_debug("step7:burn 2k bootloader firmware");
+	/* step6:burn 2k bootloader firmware */
+	GTP_DEBUG("[burn_fw_boot]step6:burn 2k bootloader firmware");
 	ret = gup_burn_proc(client, fw_boot, 0x9000, FW_BOOT_LENGTH);
-	if (ret == FAIL) {
-		pr_err("burn fw_section fail.");
-		return ret;
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_boot]burn fw_boot fail.");
+		goto exit_burn_fw_boot;
 	}
-
 	/* step7:send burn cmd to move data to flash from sram */
-	pr_debug("step7:send burn cmd to flash data from sram");
+	GTP_DEBUG
+	    ("[burn_fw_boot]step7: move data to flash from sram");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x06);
 	if (ret <= 0) {
-		pr_err("send burn cmd fail.");
-		return ret;
+		GTP_ERROR("[burn_fw_boot]send burn cmd fail.");
+		goto exit_burn_fw_boot;
 	}
-	pr_debug("Wait for the burn is complete.");
+	GTP_DEBUG("[burn_fw_boot]Wait for the burn is complete......");
 	do {
 		ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
 		if (ret <= 0) {
-			pr_err("Get burn state fail");
-			return ret;
+			GTP_ERROR("[burn_fw_boot]Get burn state fail");
+			goto exit_burn_fw_boot;
 		}
 		msleep(20);
 	} while (rd_buf[GTP_ADDR_LENGTH]);
 
 	/* step8:recall check 2k bootloader firmware */
-	pr_debug("step8:recall check 2k bootloader firmware");
+	GTP_DEBUG("[burn_fw_boot]step8:recall check 2k bootloader firmware");
 	ret = gup_recall_check(client, fw_boot, 0x9000, FW_BOOT_LENGTH);
-	if (ret == FAIL) {
-		pr_err("recall check 4k dsp firmware fail.");
-		return ret;
+	if (FAIL == ret) {
+		GTP_ERROR
+		    ("[burn_fw_boot]recall check 2k bootcode firmware fail.");
+		goto exit_burn_fw_boot;
 	}
 
-	/* step9:enable download DSP code  */
-	pr_debug("step9:enable download DSP code ");
-	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x99);
+	update_msg.fw_burned_len += FW_BOOT_LENGTH;
+	GTP_DEBUG("[burn_fw_boot]Burned length:%d", update_msg.fw_burned_len);
+	ret = SUCCESS;
+
+exit_burn_fw_boot:
+	kfree(fw_boot);
+	return ret;
+}
+
+static u8 gup_burn_fw_boot_isp(struct i2c_client *client)
+{
+	s32 ret = 0;
+	u8 *fw_boot_isp = NULL;
+	u8 retry = 0;
+	u8 rd_buf[5];
+
+	if (update_msg.fw_burned_len >= update_msg.fw_total_len) {
+		GTP_DEBUG("No need to upgrade the boot_isp code!");
+		return SUCCESS;
+	}
+	GTP_INFO("[burn_fw_boot_isp]Begin burn boot_isp firmware---->>");
+
+	/* step1:Alloc memory */
+	GTP_DEBUG("[burn_fw_boot_isp]step1:Alloc memory");
+	while (retry++ < 5) {
+		fw_boot_isp = kzalloc(FW_BOOT_ISP_LENGTH, GFP_KERNEL);
+		if (fw_boot_isp == NULL)
+			continue;
+		else {
+			GTP_DEBUG
+			    ("[burn_fw_boot_isp]Alloc %dk byte memory success.",
+			     (FW_BOOT_ISP_LENGTH / 1024));
+			break;
+		}
+	}
+	if (retry >= 5) {
+		GTP_ERROR("[burn_fw_boot_isp]Alloc memory fail,exit.");
+		return FAIL;
+	}
+	/* step2:load firmware bootloader */
+	GTP_DEBUG("[burn_fw_boot_isp]step2:load firmware bootloader isp");
+	ret = gup_load_section_file(fw_boot_isp,
+			(update_msg.fw_burned_len - FW_DSP_ISP_LENGTH),
+			FW_BOOT_ISP_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_boot_isp]load firmware boot_isp fail.");
+		goto exit_burn_fw_boot_isp;
+	}
+	/* step3:hold ss51 & dsp */
+	GTP_DEBUG("[burn_fw_boot_isp]step3:hold ss51 & dsp");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
+	if (ret <= 0) {
+		GTP_ERROR("[burn_fw_boot_isp]hold ss51 & dsp fail.");
+		ret = FAIL;
+		goto exit_burn_fw_boot_isp;
+	}
+	/* step4:set scramble */
+	GTP_DEBUG("[burn_fw_boot_isp]step4:set scramble");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
+	if (ret <= 0) {
+		GTP_ERROR("[burn_fw_boot_isp]set scramble fail.");
+		ret = FAIL;
+		goto exit_burn_fw_boot_isp;
+	}
+	/* step5:hold ss51 & release dsp */
+	GTP_DEBUG("[burn_fw_boot_isp]step5:hold ss51 & release dsp");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);
+	if (ret <= 0) {
+		GTP_ERROR("[burn_fw_boot_isp]release ss51 & dsp fail.");
+		ret = FAIL;
+		goto exit_burn_fw_boot_isp;
+	}
+	/* must delay */
+	msleep(20);
+
+	/* step6:select bank3 */
+	GTP_DEBUG("[burn_fw_boot_isp]step6:select bank3");
+	ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x03);
+	if (ret <= 0) {
+		GTP_ERROR("[burn_fw_boot_isp]select bank3 fail.");
+		ret = FAIL;
+		goto exit_burn_fw_boot_isp;
+	}
+	/* step7:burn 2k bootload_isp firmware */
+	GTP_DEBUG("[burn_fw_boot_isp]step7:burn 2k bootloader firmware");
+	ret = gup_burn_proc(client, fw_boot_isp, 0x9000, FW_BOOT_ISP_LENGTH);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_boot_isp]burn fw_section fail.");
+		goto exit_burn_fw_boot_isp;
+	}
+	/* step7:send burn cmd to move data to flash from sram */
+	GTP_DEBUG("[burn_fw_boot_isp]step8: move data to flash from sram");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x07);
+	if (ret <= 0) {
+		GTP_ERROR("[burn_fw_boot_isp]send burn cmd fail.");
+		goto exit_burn_fw_boot_isp;
+	}
+	GTP_DEBUG("[burn_fw_boot_isp]Wait for the burn is complete......");
+	do {
+		ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
+		if (ret <= 0) {
+			GTP_ERROR("[burn_fw_boot_isp]Get burn state fail");
+			goto exit_burn_fw_boot_isp;
+		}
+		msleep(20);
+	} while (rd_buf[GTP_ADDR_LENGTH]);
+
+	/* step8:recall check 2k bootload_isp firmware */
+	GTP_DEBUG
+	    ("[burn_fw_boot_isp]step9:recall check 2k bootloader firmware");
+	ret = gup_recall_check(client, fw_boot_isp, 0x9000, FW_BOOT_ISP_LENGTH);
+	if (FAIL == ret) {
+		GTP_ERROR
+		    ("[burn_fw_boot_isp]check bootcode_isp firmware fail.");
+		goto exit_burn_fw_boot_isp;
+	}
+
+	update_msg.fw_burned_len += FW_BOOT_ISP_LENGTH;
+	GTP_DEBUG("[burn_fw_boot_isp]Burned length:%d",
+		  update_msg.fw_burned_len);
+	ret = SUCCESS;
+
+exit_burn_fw_boot_isp:
+	kfree(fw_boot_isp);
+	return ret;
+}
+
+static u8 gup_burn_fw_link(struct i2c_client *client)
+{
+	s32 ret = 0;
+	u8 *fw_link = NULL;
+	u8 retry = 0;
+	u32 offset;
+
+	if (update_msg.fw_burned_len >= update_msg.fw_total_len) {
+		GTP_DEBUG("No need to upgrade the link code!");
+		return SUCCESS;
+	}
+	GTP_INFO("[burn_fw_link]Begin burn link firmware---->>");
+
+	/* step1:Alloc memory */
+	GTP_DEBUG("[burn_fw_link]step1:Alloc memory");
+	while (retry++ < 5) {
+		fw_link = kzalloc(FW_SECTION_LENGTH, GFP_KERNEL);
+		if (fw_link == NULL)
+			continue;
+		else {
+			GTP_DEBUG
+			    ("[burn_fw_link]Alloc %dk byte memory success.",
+			    (FW_SECTION_LENGTH / 1024));
+			break;
+		}
+	}
+	if (retry >= 5) {
+		GTP_ERROR("[burn_fw_link]Alloc memory fail,exit.");
+		return FAIL;
+	}
+	/* step2:load firmware link section 1 */
+	GTP_DEBUG("[burn_fw_link]step2:load firmware link section 1");
+	offset = update_msg.fw_burned_len - FW_DSP_ISP_LENGTH;
+	ret = gup_load_section_file(fw_link, offset,
+					FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_link]load firmware link section 1 fail.");
+		goto exit_burn_fw_link;
+	}
+	/* step3:burn link firmware section 1 */
+	GTP_DEBUG("[burn_fw_link]step3:burn link firmware section 1");
+	ret = gup_burn_fw_gwake_section(client, fw_link, 0x9000,
+					FW_SECTION_LENGTH, 0x38);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_link]burn link firmware section 1 fail.");
+		goto exit_burn_fw_link;
+	}
+	/* step4:load link firmware section 2 file data */
+	GTP_DEBUG("[burn_fw_link]step4:load link firmware section 2 file data");
+	offset += FW_SECTION_LENGTH;
+	ret = gup_load_section_file(fw_link, offset,
+				FW_GLINK_LENGTH - FW_SECTION_LENGTH,
+				SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_link]load link firmware section 2 fail.");
+		goto exit_burn_fw_link;
+	}
+	/* step5:burn link firmware section 2 */
+	GTP_DEBUG("[burn_fw_link]step4:burn link firmware section 2");
+	ret = gup_burn_fw_gwake_section(client, fw_link, 0x9000,
+					FW_GLINK_LENGTH - FW_SECTION_LENGTH,
+					0x39);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_link]burn link firmware section 2 fail.");
+		goto exit_burn_fw_link;
+	}
+
+	update_msg.fw_burned_len += FW_GLINK_LENGTH;
+	GTP_DEBUG("[burn_fw_link]Burned length:%d", update_msg.fw_burned_len);
+	ret = SUCCESS;
+
+exit_burn_fw_link:
+	kfree(fw_link);
+	return ret;
+}
+
+static u8 gup_burn_fw_gwake_section(struct i2c_client *client, u8 *fw_section,
+				    u16 start_addr, u32 len, u8 bank_cmd)
+{
+	s32 ret = 0;
+	u8 rd_buf[5];
+
+	/* step1:hold ss51 & dsp */
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
+	if (ret <= 0) {
+		GTP_ERROR("[burn_fw_app_section]hold ss51 & dsp fail.");
+		return FAIL;
+	}
+	/* step2:set scramble */
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
+	if (ret <= 0) {
+		GTP_ERROR("[burn_fw_app_section]set scramble fail.");
+		return FAIL;
+	}
+	/* step3:hold ss51 & release dsp */
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);
 	if (ret <= 0) {
-		pr_err("enable download DSP code fail.");
+		GTP_ERROR("[burn_fw_app_section]hold ss51 & release dsp fail.");
 		return FAIL;
 	}
+	/* must delay */
+	msleep(20);
 
-	/* step10:release ss51 & hold dsp */
-	pr_debug("step10:release ss51 & hold dsp");
-	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x08);
+	/* step4:select bank */
+	ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK,
+				(bank_cmd >> 4) & 0x0F);
+	if (ret <= 0) {
+		GTP_ERROR("[burn_fw_section]select bank %d fail.",
+			  (bank_cmd >> 4) & 0x0F);
+		return FAIL;
+	}
+	/* step5:burn fw section */
+	ret = gup_burn_proc(client, fw_section, start_addr, len);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_app_section]burn fw_section fail.");
+		return FAIL;
+	}
+	/* step6:send burn cmd to move data to flash from sram */
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, bank_cmd & 0x0F);
 	if (ret <= 0) {
-		pr_err("release ss51 & hold dsp fail.");
+		GTP_ERROR("[burn_fw_app_section]send burn cmd fail.");
+		return FAIL;
+	}
+	GTP_DEBUG("[burn_fw_section]Wait for the burn is complete......");
+	do {
+		ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
+		if (ret <= 0) {
+			GTP_ERROR("[burn_fw_app_section]Get burn state fail");
+			return FAIL;
+		}
+		msleep(20);
+	} while (rd_buf[GTP_ADDR_LENGTH]);
+
+	/* step7:recall fw section */
+	ret = gup_recall_check(client, fw_section, start_addr, len);
+	if (FAIL == ret) {
+		GTP_ERROR
+		    ("[burn_fw_app_section]recall check %dk firmware fail.",
+		     len / 1024);
 		return FAIL;
 	}
 
 	return SUCCESS;
 }
 
-s32 gup_update_proc(void *dir)
+static u8 gup_burn_fw_gwake(struct i2c_client *client)
 {
+	u8 *fw_gwake = NULL;
+	u8 retry = 0;
 	s32 ret = 0;
+	u16 start_index;
+
+	if (update_msg.fw_burned_len >= update_msg.fw_total_len) {
+		GTP_DEBUG("No need to upgrade the gwake code!");
+		return SUCCESS;
+	}
+	start_index = update_msg.fw_burned_len - FW_DSP_ISP_LENGTH;
+	GTP_INFO("[burn_fw_gwake]Begin burn gwake firmware---->>");
+
+	/* step1:alloc memory */
+	GTP_DEBUG("[burn_fw_gwake]step1:alloc memory");
+	while (retry++ < 5) {
+		fw_gwake = kzalloc(FW_SECTION_LENGTH, GFP_KERNEL);
+		if (fw_gwake == NULL)
+			continue;
+		else {
+			GTP_DEBUG
+			    ("[burn_fw_gwake]Alloc %dk byte memory success.",
+			     (FW_SECTION_LENGTH / 1024));
+			break;
+		}
+	}
+	if (retry >= 5) {
+		GTP_ERROR("[burn_fw_gwake]Alloc memory fail,exit.");
+		return FAIL;
+	}
+	/* step2:load app_code firmware section 1 file data */
+	GTP_DEBUG
+	    ("[burn_fw_gwake]step2:load app_code firmware section 1 file data");
+	ret = gup_load_section_file(fw_gwake, start_index,
+					FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR
+		    ("[burn_fw_gwake]load app_code firmware section 1 fail.");
+		goto exit_burn_fw_gwake;
+	}
+	/* step3:burn app_code firmware section 1 */
+	GTP_DEBUG("[burn_fw_gwake]step3:burn app_code firmware section 1");
+	ret = gup_burn_fw_gwake_section(client, fw_gwake, 0x9000,
+					FW_SECTION_LENGTH, 0x3A);
+	if (FAIL == ret) {
+		GTP_ERROR
+		    ("[burn_fw_gwake]burn app_code firmware section 1 fail.");
+		goto exit_burn_fw_gwake;
+	}
+	/* step5:load app_code firmware section 2 file data */
+	GTP_DEBUG
+	    ("[burn_fw_gwake]step5:load app_code firmware section 2 file data");
+	ret = gup_load_section_file(fw_gwake, start_index + FW_SECTION_LENGTH,
+						FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR
+		    ("[burn_fw_gwake]load app_code firmware section 2 fail.");
+		goto exit_burn_fw_gwake;
+	}
+	/* step6:burn app_code firmware section 2 */
+	GTP_DEBUG("[burn_fw_gwake]step6:burn app_code firmware section 2");
+	ret = gup_burn_fw_gwake_section(client, fw_gwake, 0x9000,
+					FW_SECTION_LENGTH, 0x3B);
+	if (FAIL == ret) {
+		GTP_ERROR
+		    ("[burn_fw_gwake]burn app_code firmware section 2 fail.");
+		goto exit_burn_fw_gwake;
+	}
+	/* step7:load app_code firmware section 3 file data */
+	GTP_DEBUG
+	    ("[burn_fw_gwake]step7:load app_code firmware section 3 file data");
+	ret = gup_load_section_file(fw_gwake, start_index
+					+ 2 * FW_SECTION_LENGTH,
+					FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR
+		    ("[burn_fw_gwake]load app_code firmware section 3 fail.");
+		goto exit_burn_fw_gwake;
+	}
+	/* step8:burn app_code firmware section 3 */
+	GTP_DEBUG("[burn_fw_gwake]step8:burn app_code firmware section 3");
+	ret = gup_burn_fw_gwake_section(client, fw_gwake, 0x9000,
+					FW_SECTION_LENGTH, 0x3C);
+	if (FAIL == ret) {
+		GTP_ERROR
+		    ("[burn_fw_gwake]burn app_code firmware section 3 fail.");
+		goto exit_burn_fw_gwake;
+	}
+	/* step9:load app_code firmware section 4 file data */
+	GTP_DEBUG
+	    ("[burn_fw_gwake]step9:load app_code firmware section 4 file data");
+	ret = gup_load_section_file(fw_gwake, start_index
+					+ 3 * FW_SECTION_LENGTH,
+					FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR
+		    ("[burn_fw_gwake]load app_code firmware section 4 fail.");
+		goto exit_burn_fw_gwake;
+	}
+	/* step10:burn app_code firmware section 4 */
+	GTP_DEBUG("[burn_fw_gwake]step10:burn app_code firmware section 4");
+	ret = gup_burn_fw_gwake_section(client, fw_gwake, 0x9000,
+					FW_SECTION_LENGTH, 0x3D);
+	if (FAIL == ret) {
+		GTP_ERROR
+		    ("[burn_fw_gwake]burn app_code firmware section 4 fail.");
+		goto exit_burn_fw_gwake;
+	}
+
+	update_msg.fw_burned_len += FW_GWAKE_LENGTH;
+	GTP_DEBUG("[burn_fw_gwake]Burned length:%d", update_msg.fw_burned_len);
+	ret = SUCCESS;
+
+exit_burn_fw_gwake:
+	kfree(fw_gwake);
+	return ret;
+}
+
+static u8 gup_burn_fw_finish(struct i2c_client *client)
+{
+	u8 *fw_ss51 = NULL;
 	u8 retry = 0;
-	struct st_fw_head fw_head;
-	struct goodix_ts_data *ts = NULL;
+	s32 ret = 0;
+
+	GTP_INFO("[burn_fw_finish]burn first 8K of ss51 and finish update.");
+	/* step1:alloc memory */
+	GTP_DEBUG("[burn_fw_finish]step1:alloc memory");
+	while (retry++ < 5) {
+		fw_ss51 = kzalloc(FW_SECTION_LENGTH, GFP_KERNEL);
+		if (fw_ss51 == NULL)
+			continue;
+		else {
+			GTP_DEBUG
+			    ("[burn_fw_finish]Alloc %dk byte memory success.",
+			     (FW_SECTION_LENGTH / 1024));
+			break;
+		}
+	}
+	if (retry >= 5) {
+		GTP_ERROR("[burn_fw_finish]Alloc memory fail,exit.");
+		return FAIL;
+	}
 
-	pr_debug("Begin update.");
+	GTP_DEBUG("[burn_fw_finish]step2: burn ss51 first 8K.");
+	ret = gup_load_section_file(fw_ss51, 0, FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_finish]load ss51 firmware section 1 fail.");
+		goto exit_burn_fw_finish;
+	}
 
-	if (!i2c_connect_client) {
-		pr_err("No i2c connect client for %s\n", __func__);
-		return -EIO;
+	GTP_DEBUG("[burn_fw_finish]step3:clear control flag");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x00);
+	if (ret <= 0) {
+		GTP_ERROR("[burn_fw_finish]clear control flag fail.");
+		goto exit_burn_fw_finish;
 	}
 
-	show_len = 1;
-	total_len = 100;
+	GTP_DEBUG("[burn_fw_finish]step4:burn ss51 firmware section 1");
+	ret = gup_burn_fw_section(client, fw_ss51, 0xC000, 0x01);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_finish]burn ss51 firmware section 1 fail.");
+		goto exit_burn_fw_finish;
+	}
+	/* step11:enable download DSP code */
+	GTP_DEBUG("[burn_fw_finish]step5:enable download DSP code ");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x99);
+	if (ret <= 0) {
+		GTP_ERROR("[burn_fw_finish]enable download DSP code fail.");
+		goto exit_burn_fw_finish;
+	}
+	/* step12:release ss51 & hold dsp */
+	GTP_DEBUG("[burn_fw_finish]step6:release ss51 & hold dsp");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x08);
+	if (ret <= 0) {
+		GTP_ERROR("[burn_fw_finish]release ss51 & hold dsp fail.");
+		goto exit_burn_fw_finish;
+	}
+
+	kfree(fw_ss51);
+	return SUCCESS;
+
+exit_burn_fw_finish:
+	kfree(fw_ss51);
+	return FAIL;
+}
+
+s32 gup_update_proc(void *dir)
+{
+	s32 ret = 0;
+	s32 update_ret = FAIL;
+	u8 retry = 0;
+	struct st_fw_head fw_head;
+	struct goodix_ts_data *ts = NULL;
+
+	GTP_DEBUG("[update_proc]Begin update ......");
 
 	ts = i2c_get_clientdata(i2c_connect_client);
 
+#if GTP_AUTO_UPDATE
 	if (searching_file) {
-		/* exit .bin update file searching  */
-		searching_file = 0;
-		pr_info("Exiting searching .bin update file.");
-		/* wait for auto update quitted completely */
-		while ((show_len != 200) && (show_len != 100))
+		u8 timeout = 0;
+		searching_file = 0;	/* exit .bin update file searching */
+		GTP_INFO("Exiting searching .bin update file...");
+		while ((show_len != 200) && (show_len != 100)
+			&& (timeout++ < 100))
 			msleep(100);
 	}
+#endif
 
-	ret = gup_check_update_file(i2c_connect_client, &fw_head, (u8 *)dir);
-	if (ret == FAIL) {
-		pr_err("check update file fail.");
+	show_len = 1;
+	total_len = 100;
+
+#if GTP_COMPATIBLE_MODE
+	if (CHIP_TYPE_GT9F == ts->chip_type)
+		return gup_fw_download_proc(dir, GTP_FL_FW_BURN);
+#endif
+
+	update_msg.file = NULL;
+	ret = gup_check_update_file(i2c_connect_client, &fw_head, (u8 *) dir);
+	if (FAIL == ret) {
+		GTP_ERROR("[update_proc]check update file fail.");
 		goto file_fail;
 	}
 
-	/* gtp_reset_guitar(i2c_connect_client, 20); */
 	ret = gup_get_ic_fw_msg(i2c_connect_client);
-	if (ret == FAIL) {
-		pr_err("get ic message fail.");
+	if (FAIL == ret) {
+		GTP_ERROR("[update_proc]get ic message fail.");
 		goto file_fail;
 	}
 
-	if (ts->force_update) {
-		dev_dbg(&ts->client->dev, "Enter force update.");
-	} else {
-		ret = gup_enter_update_judge(ts->client, &fw_head);
-		if (ret == FAIL) {
-			dev_err(&ts->client->dev,
-					"Check *.bin file fail.");
-			goto file_fail;
-		}
+	ret = gup_enter_update_judge(&fw_head);
+	if (FAIL == ret) {
+		GTP_ERROR("[update_proc]Check *.bin file fail.");
+		goto file_fail;
 	}
 
 	ts->enter_update = 1;
@@ -1449,104 +2103,1097 @@ s32 gup_update_proc(void *dir)
 	gtp_esd_switch(ts->client, SWITCH_OFF);
 #endif
 	ret = gup_enter_update_mode(i2c_connect_client);
-	if (ret == FAIL) {
-		pr_err("enter update mode fail.");
+	if (FAIL == ret) {
+		GTP_ERROR("[update_proc]enter update mode fail.");
 		goto update_fail;
 	}
 
 	while (retry++ < 5) {
 		show_len = 10;
 		total_len = 100;
+		update_msg.fw_burned_len = 0;
 		ret = gup_burn_dsp_isp(i2c_connect_client);
-		if (ret == FAIL) {
-			pr_err("burn dsp isp fail.");
+		if (FAIL == ret) {
+			GTP_ERROR("[update_proc]burn dsp isp fail.");
 			continue;
 		}
 
-		show_len += 10;
+		show_len = 20;
 		ret = gup_burn_fw_ss51(i2c_connect_client);
-		if (ret == FAIL) {
-			pr_err("burn ss51 firmware fail.");
+		if (FAIL == ret) {
+			GTP_ERROR("[update_proc]burn ss51 firmware fail.");
 			continue;
 		}
 
-		show_len += 40;
+		show_len = 30;
 		ret = gup_burn_fw_dsp(i2c_connect_client);
-		if (ret == FAIL) {
-			pr_err("burn dsp firmware fail.");
+		if (FAIL == ret) {
+			GTP_ERROR("[update_proc]burn dsp firmware fail.");
 			continue;
 		}
 
-		show_len += 20;
+		show_len = 40;
 		ret = gup_burn_fw_boot(i2c_connect_client);
-		if (ret == FAIL) {
-			pr_err("burn bootloader fw fail.");
+		if (FAIL == ret) {
+			GTP_ERROR
+			    ("[update_proc]burn bootloader firmware fail.");
 			continue;
 		}
-		show_len += 10;
-		pr_info("UPDATE SUCCESS.");
+		show_len = 50;
+
+		ret = gup_burn_fw_boot_isp(i2c_connect_client);
+		if (FAIL == ret) {
+			GTP_ERROR("[update_proc]burn boot_isp firmware fail.");
+			continue;
+		}
+
+		show_len = 60;
+		ret = gup_burn_fw_link(i2c_connect_client);
+		if (FAIL == ret) {
+			GTP_ERROR("[update_proc]burn link firmware fail.");
+			continue;
+		}
+
+		show_len = 70;
+		ret = gup_burn_fw_gwake(i2c_connect_client);
+		if (FAIL == ret) {
+			GTP_ERROR("[update_proc]burn app_code firmware fail.");
+			continue;
+		}
+		show_len = 80;
+
+		ret = gup_burn_fw_finish(i2c_connect_client);
+		if (FAIL == ret) {
+			GTP_ERROR("[update_proc]burn finish fail.");
+			continue;
+		}
+		show_len = 90;
+		GTP_INFO("[update_proc]UPDATE SUCCESS.");
+		retry = 0;
 		break;
 	}
+
 	if (retry >= 5) {
-		pr_err("retry timeout,UPDATE FAIL.");
-		goto update_fail;
-	}
+		GTP_ERROR("[update_proc]retry timeout,UPDATE FAIL.");
+		update_ret = FAIL;
+	} else
+		update_ret = SUCCESS;
 
-	pr_debug("leave update mode.");
-	gup_leave_update_mode(i2c_connect_client);
+update_fail:
+	GTP_DEBUG("[update_proc]leave update mode.");
+	gup_leave_update_mode();
 
 	msleep(100);
 
-	if (ts->fw_error) {
-		pr_info("firmware error auto update, resent config!");
-		gup_init_panel(ts);
+	if (SUCCESS == update_ret) {
+		if (ts->fw_error) {
+			GTP_INFO("firmware error auto update, resent config!");
+			gup_init_panel(ts);
+		} else {
+			GTP_DEBUG("[update_proc]send config.");
+			ret = gtp_send_cfg(i2c_connect_client);
+			if (ret < 0)
+				GTP_ERROR("[update_proc]send config fail.");
+			else
+				msleep(100);
+		}
 	}
-	show_len = 100;
-	total_len = 100;
 	ts->enter_update = 0;
 	gtp_irq_enable(ts);
 
 #if GTP_ESD_PROTECT
 	gtp_esd_switch(ts->client, SWITCH_ON);
 #endif
-	if (update_msg.need_free) {
-		devm_kfree(&ts->client->dev, update_msg.fw_data);
-		update_msg.need_free = false;
-	}
-
-	return SUCCESS;
 
-update_fail:
-	ts->enter_update = 0;
-	gtp_irq_enable(ts);
-
-#if GTP_ESD_PROTECT
-	gtp_esd_switch(ts->client, SWITCH_ON);
+file_fail:
+	if (update_msg.file && !IS_ERR(update_msg.file)) {
+		if (update_msg.old_fs)
+			set_fs(update_msg.old_fs);
+		filp_close(update_msg.file, NULL);
+	}
+#if (GTP_AUTO_UPDATE && GTP_AUTO_UPDATE_CFG && GTP_HEADER_FW_UPDATE)
+	if (NULL == dir) {
+		gup_search_file(AUTO_SEARCH_CFG);
+		if (got_file_flag & CFG_FILE_READY) {
+			ret = gup_update_config(i2c_connect_client);
+			if (ret <= 0)
+				GTP_ERROR("Update config failed.");
+			_CLOSE_FILE(update_msg.cfg_file);
+			msleep(500);
+		}
+	}
 #endif
 
-file_fail:
-	show_len = 200;
 	total_len = 100;
-	if (update_msg.need_free) {
-		devm_kfree(&ts->client->dev, update_msg.fw_data);
-		update_msg.need_free = false;
+	if (SUCCESS == update_ret) {
+		show_len = 100;
+		return SUCCESS;
+	} else {
+		show_len = 200;
+		return FAIL;
 	}
-	return FAIL;
 }
 
-static void gup_update_work(struct work_struct *work)
+#if GTP_AUTO_UPDATE
+u8 gup_init_update_proc(struct goodix_ts_data *ts)
 {
-	if (gup_update_proc(NULL) == FAIL)
-		pr_err("Goodix update work fail!\n");
+	struct task_struct *thread = NULL;
+
+	GTP_INFO("Ready to run update thread.");
+
+#if GTP_COMPATIBLE_MODE
+	if (CHIP_TYPE_GT9F == ts->chip_type)
+		thread = kthread_run(gup_update_proc, "update", "fl update");
+	else
+#endif
+		thread = kthread_run(gup_update_proc,
+					(void *)NULL, "guitar_update");
+	if (IS_ERR(thread)) {
+		GTP_ERROR("Failed to create update thread.\n");
+		return -EINVAL;
+	}
+
+	return 0;
 }
+#endif
 
-u8 gup_init_update_proc(struct goodix_ts_data *ts)
+/************************** For GT9XXF Start ***********************/
+#define FW_DOWNLOAD_LENGTH           0x4000
+#define FW_SS51_SECTION_LEN          0x2000	/* 4 section, each 8k */
+#define FL_PACK_SIZE                 250
+#define GUP_FW_CHK_SIZE              FL_PACK_SIZE
+
+#define FL_UPDATE_PATH              "/data/_fl_update_.bin"
+#define FL_UPDATE_PATH_SD           "/sdcard/_fl_update_.bin"
+/* for clk cal */
+#define PULSE_LENGTH      (200)
+#define INIT_CLK_DAC      (50)
+#define MAX_CLK_DAC       (120)
+#define CLK_AVG_TIME      (1)
+#define MILLION           1000000
+
+#define _wRW_MISCTL__RG_DMY                       0x4282
+#define _bRW_MISCTL__RG_OSC_CALIB                 0x4268
+#define _fRW_MISCTL__GIO0                         0x41e9
+#define _fRW_MISCTL__GIO1                         0x41ed
+#define _fRW_MISCTL__GIO2                         0x41f1
+#define _fRW_MISCTL__GIO3                         0x41f5
+#define _fRW_MISCTL__GIO4                         0x41f9
+#define _fRW_MISCTL__GIO5                         0x41fd
+#define _fRW_MISCTL__GIO6                         0x4201
+#define _fRW_MISCTL__GIO7                         0x4205
+#define _fRW_MISCTL__GIO8                         0x4209
+#define _fRW_MISCTL__GIO9                         0x420d
+#define _fRW_MISCTL__MEA                          0x41a0
+#define _bRW_MISCTL__MEA_MODE                     0x41a1
+#define _wRW_MISCTL__MEA_MAX_NUM                  0x41a4
+#define _dRO_MISCTL__MEA_VAL                      0x41b0
+#define _bRW_MISCTL__MEA_SRCSEL                   0x41a3
+#define _bRO_MISCTL__MEA_RDY                      0x41a8
+#define _rRW_MISCTL__ANA_RXADC_B0_                0x4250
+#define _bRW_MISCTL__RG_LDO_A18_PWD               0x426f
+#define _bRW_MISCTL__RG_BG_PWD                    0x426a
+#define _bRW_MISCTL__RG_CLKGEN_PWD                0x4269
+#define _fRW_MISCTL__RG_RXADC_PWD                 0x426a
+#define _bRW_MISCTL__OSC_CK_SEL                   0x4030
+#define _rRW_MISCTL_RG_DMY83                      0x4283
+#define _rRW_MISCTL__GIO1CTL_B2_                  0x41ee
+#define _rRW_MISCTL__GIO1CTL_B1_                  0x41ed
+
+#if GTP_COMPATIBLE_MODE
+
+u8 i2c_opr_buf[GTP_ADDR_LENGTH + FL_PACK_SIZE] = {0};
+u8 chk_cmp_buf[FL_PACK_SIZE] = {0};
+
+static u8 gup_download_fw_dsp(struct i2c_client *client, u8 dwn_mode);
+static s32 gup_burn_fw_proc(struct i2c_client *client, u16 start_addr,
+			    s32 start_index, s32 burn_len);
+static s32 gup_check_and_repair(struct i2c_client *client, u16 start_addr,
+				s32 start_index, s32 chk_len);
+
+u8 gup_check_fs_mounted(char *path_name)
 {
-	dev_dbg(&ts->client->dev, "Ready to run update work.");
+	struct path root_path;
+	struct path path;
+	int err;
 
-	INIT_DELAYED_WORK(&ts->goodix_update_work, gup_update_work);
-	schedule_delayed_work(&ts->goodix_update_work,
-		msecs_to_jiffies(3000));
+	err = kern_path("/", LOOKUP_FOLLOW, &root_path);
+	if (err) {
+		GTP_DEBUG("\"/\" NOT Mounted: %d", err);
+		return FAIL;
+	}
 
-	return 0;
+	err = kern_path(path_name, LOOKUP_FOLLOW, &path);
+	if (err) {
+		GTP_DEBUG("%s NOT Mounted: %d", path_name, err);
+		return FAIL;
+	}
+
+	path_put(&path);
+	return SUCCESS;
 }
+
+s32 i2c_write_bytes(struct i2c_client *client, u16 addr, u8 *buf, s32 len)
+{
+	s32 ret = 0;
+	s32 write_bytes = 0;
+	s32 retry = 0;
+	u8 *tx_buf = buf;
+
+	while (len > 0) {
+		i2c_opr_buf[0] = (u8)(addr >> 8);
+		i2c_opr_buf[1] = (u8)(addr & 0xFF);
+		if (len > FL_PACK_SIZE)
+			write_bytes = FL_PACK_SIZE;
+		else
+			write_bytes = len;
+		memcpy(i2c_opr_buf + 2, tx_buf, write_bytes);
+		for (retry = 0; retry < 5; ++retry) {
+			ret = gup_i2c_write(client, i2c_opr_buf,
+					write_bytes + GTP_ADDR_LENGTH);
+			if (ret == 1)
+				break;
+		}
+		if (retry >= 5) {
+			GTP_ERROR
+			    ("retry timeout, I2C write 0x%04X %d bytes failed!",
+			     addr, write_bytes);
+			return ret;
+		}
+		addr += write_bytes;
+		len -= write_bytes;
+		tx_buf += write_bytes;
+	}
+
+	return ret;
+}
+
+s32 i2c_read_bytes(struct i2c_client *client, u16 addr, u8 *buf, s32 len)
+{
+	s32 ret = 0;
+	s32 read_bytes = 0;
+	s32 retry = 0;
+	u8 *tx_buf = buf;
+
+	while (len > 0) {
+		i2c_opr_buf[0] = (u8)(addr >> 8);
+		i2c_opr_buf[1] = (u8)(addr & 0xFF);
+		if (len > FL_PACK_SIZE)
+			read_bytes = FL_PACK_SIZE;
+		else
+			read_bytes = len;
+		for (retry = 0; retry < 5; ++retry) {
+			ret = gup_i2c_read(client, i2c_opr_buf,
+					read_bytes + GTP_ADDR_LENGTH);
+			if (ret == 2)
+				break;
+		}
+		if (retry >= 5) {
+			GTP_ERROR
+			    ("retry timeout, I2C read 0x%04X %d bytes failed!",
+			    addr, read_bytes);
+			return ret;
+		}
+		memcpy(tx_buf, i2c_opr_buf + 2, read_bytes);
+		addr += read_bytes;
+		len -= read_bytes;
+		tx_buf += read_bytes;
+	}
+	return ret;
+}
+
+/* main clock calibration
+  * bit: 0~7, val: 0/1
+ */
+static void gup_bit_write(s32 addr, s32 bit, s32 val)
+{
+	u8 buf;
+	i2c_read_bytes(i2c_connect_client, addr, &buf, 1);
+	buf = (buf & (~((u8)1 << bit))) | ((u8)val << bit);
+	i2c_write_bytes(i2c_connect_client, addr, &buf, 1);
+}
+
+static void gup_clk_count_init(s32 bCh, s32 bCNT)
+{
+	u8 buf;
+
+	gup_bit_write(_fRW_MISCTL__MEA, 0, 0);
+	gup_bit_write(_fRW_MISCTL__MEA, 1, 1);
+	buf = 0;
+	i2c_write_bytes(i2c_connect_client, _bRW_MISCTL__MEA_MODE, &buf, 1);
+	buf = 8 + bCh;
+	i2c_write_bytes(i2c_connect_client, _bRW_MISCTL__MEA_SRCSEL, &buf, 1);
+	buf = bCNT;
+	i2c_write_bytes(i2c_connect_client, _wRW_MISCTL__MEA_MAX_NUM, &buf, 1);
+	gup_bit_write(_fRW_MISCTL__MEA, 1, 0);
+	gup_bit_write(_fRW_MISCTL__MEA, 0, 1);
+}
+
+static u32 gup_clk_count_get(void)
+{
+	s32 ready = 0;
+	s32 temp;
+	s8 buf[4];
+
+	while ((ready == 0)) {
+		i2c_read_bytes(i2c_connect_client,
+				_bRO_MISCTL__MEA_RDY, buf, 1);
+		ready = buf[0];
+	}
+
+	msleep(50);
+
+	gup_bit_write(_fRW_MISCTL__MEA, 0, 0);
+	i2c_read_bytes(i2c_connect_client, _dRO_MISCTL__MEA_VAL, buf, 4);
+	GTP_DEBUG("Clk_count 0: %2X", buf[0]);
+	GTP_DEBUG("Clk_count 1: %2X", buf[1]);
+	GTP_DEBUG("Clk_count 2: %2X", buf[2]);
+	GTP_DEBUG("Clk_count 3: %2X", buf[3]);
+
+	temp = (s32)buf[0] + ((s32)buf[1] << 8) +
+		((s32)buf[2] << 16) + ((s32)buf[3] << 24);
+	GTP_INFO("Clk_count : %d", temp);
+	return temp;
+}
+
+static u8 gup_clk_dac_setting(int dac)
+{
+	s8 buf1, buf2;
+
+	i2c_read_bytes(i2c_connect_client, _wRW_MISCTL__RG_DMY, &buf1, 1);
+	i2c_read_bytes(i2c_connect_client, _bRW_MISCTL__RG_OSC_CALIB, &buf2, 1);
+
+	buf1 = (buf1 & 0xFFCF) | ((dac & 0x03) << 4);
+	buf2 = (dac >> 2) & 0x3f;
+
+	i2c_write_bytes(i2c_connect_client, _wRW_MISCTL__RG_DMY, &buf1, 1);
+	i2c_write_bytes(i2c_connect_client,
+			_bRW_MISCTL__RG_OSC_CALIB, &buf2, 1);
+
+	return 0;
+}
+
+static u8 gup_clk_calibration_pin_select(s32 bCh)
+{
+	s32 i2c_addr;
+
+	switch (bCh) {
+	case 0:
+		i2c_addr = _fRW_MISCTL__GIO0;
+		break;
+
+	case 1:
+		i2c_addr = _fRW_MISCTL__GIO1;
+		break;
+
+	case 2:
+		i2c_addr = _fRW_MISCTL__GIO2;
+		break;
+
+	case 3:
+		i2c_addr = _fRW_MISCTL__GIO3;
+		break;
+
+	case 4:
+		i2c_addr = _fRW_MISCTL__GIO4;
+		break;
+
+	case 5:
+		i2c_addr = _fRW_MISCTL__GIO5;
+		break;
+
+	case 6:
+		i2c_addr = _fRW_MISCTL__GIO6;
+		break;
+
+	case 7:
+		i2c_addr = _fRW_MISCTL__GIO7;
+		break;
+
+	case 8:
+		i2c_addr = _fRW_MISCTL__GIO8;
+		break;
+
+	case 9:
+		i2c_addr = _fRW_MISCTL__GIO9;
+		break;
+
+	default:
+		break;
+	}
+
+	gup_bit_write(i2c_addr, 1, 0);
+
+	return 0;
+}
+
+static void gup_sys_clk_init(void)
+{
+	u8 buf;
+
+	gup_bit_write(_rRW_MISCTL__ANA_RXADC_B0_, 5, 0);
+	buf = 0;
+	i2c_write_bytes(i2c_connect_client,
+			_bRW_MISCTL__RG_LDO_A18_PWD, &buf, 1);
+	buf = 0;
+	i2c_write_bytes(i2c_connect_client, _bRW_MISCTL__RG_BG_PWD, &buf, 1);
+	buf = 0;
+	i2c_write_bytes(i2c_connect_client,
+			_bRW_MISCTL__RG_CLKGEN_PWD, &buf, 1);
+	gup_bit_write(_rRW_MISCTL__ANA_RXADC_B0_, 0, 0);
+	gup_bit_write(_rRW_MISCTL__ANA_RXADC_B0_, 1, 0);
+	buf = 1;
+	i2c_write_bytes(i2c_connect_client, _bRW_MISCTL__OSC_CK_SEL, &buf, 1);
+}
+
+s32 gup_clk_calibration(void)
+{
+	u8 buf;
+	s32 i;
+	struct timeval start, end;
+	s32 count;
+	s32 count_ref;
+	s32 sec;
+	s32 usec;
+	struct goodix_ts_data *ts = i2c_get_clientdata(i2c_connect_client);
+
+	buf = 0x0C;
+	i2c_write_bytes(i2c_connect_client, _rRW_MISCTL__SWRST_B0_, &buf, 1);
+
+	gup_bit_write(_rRW_MISCTL_RG_DMY83, 7, 0);
+
+	gup_bit_write(_rRW_MISCTL__GIO1CTL_B2_, 0, 0);
+
+	gup_bit_write(_rRW_MISCTL__GIO1CTL_B1_, 1, 0);
+
+	GTP_INFO("CLK calibration GO");
+	gup_sys_clk_init();
+	/* use GIO1 to do the calibration */
+	gup_clk_calibration_pin_select(1);
+
+	gpio_direction_output(ts->pdata->irq_gpio, 0);
+
+	for (i = INIT_CLK_DAC; i < MAX_CLK_DAC; i++) {
+		GTP_INFO("CLK calibration DAC %d", i);
+
+		if (ts->gtp_is_suspend) {
+			/* 80; if sleeping while calibrating main clock,
+			  * set it default 72
+			  */
+			i = 72;
+			break;
+		}
+
+		gup_clk_dac_setting(i);
+		gup_clk_count_init(1, CLK_AVG_TIME);
+
+		gpio_direction_output(ts->pdata->irq_gpio, 0);
+
+		do_gettimeofday(&start);
+		gpio_direction_output(ts->pdata->irq_gpio, 1);
+
+		msleep(20);
+		gpio_direction_output(ts->pdata->irq_gpio, 0);
+		msleep(20);
+
+		do_gettimeofday(&end);
+		gpio_direction_output(ts->pdata->irq_gpio, 1);
+
+		count = gup_clk_count_get();
+		msleep(20);
+		gpio_direction_output(ts->pdata->irq_gpio, 0);
+
+		usec = end.tv_usec - start.tv_usec;
+		sec = end.tv_sec - start.tv_sec;
+		count_ref = 60 * (usec + sec * MILLION);
+
+		GTP_DEBUG("== time %d, %d, %d", sec, usec, count_ref);
+
+		if (count > count_ref) {
+			GTP_DEBUG("== count_diff %d", count - count_ref);
+			break;
+		}
+	}
+
+	gtp_reset_guitar(i2c_connect_client, 20);
+
+	gpio_direction_input(ts->pdata->irq_gpio);
+	return i;
+}
+
+static s32 gup_hold_ss51_dsp(struct i2c_client *client)
+{
+	s32 ret = -1;
+	s32 retry = 0;
+	u8 rd_buf[3];
+
+	while (retry++ < 200) {
+		/* step4:Hold ss51 & dsp */
+		ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
+		if (ret <= 0) {
+			GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
+			continue;
+		}
+		/* step5:Confirm hold */
+		ret = gup_get_ic_msg(client, _rRW_MISCTL__SWRST_B0_, rd_buf, 1);
+		if (ret <= 0) {
+			GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
+			continue;
+		}
+		if (0x0C == rd_buf[GTP_ADDR_LENGTH]) {
+			GTP_DEBUG
+			    ("[enter_update_mode]Hold ss51 & dsp SUCCESS");
+			break;
+		}
+		GTP_DEBUG("Hold ss51 & dsp confirm 0x4180 failed,value:%d",
+			  rd_buf[GTP_ADDR_LENGTH]);
+	}
+	if (retry >= 200) {
+		GTP_ERROR("Enter update Hold ss51 failed.");
+		return FAIL;
+	}
+	/* DSP_CK and DSP_ALU_CK PowerOn */
+	ret = gup_set_ic_msg(client, 0x4010, 0x00);
+	if (ret <= 0) {
+		GTP_ERROR
+		    ("[enter_update_mode]DSP_CK and DSP_ALU_CK PowerOn fail.");
+		return FAIL;
+	}
+	/* disable wdt */
+	ret = gup_set_ic_msg(client, _bRW_MISCTL__TMR0_EN, 0x00);
+	if (ret <= 0) {
+		GTP_ERROR("[enter_update_mode]disable wdt fail.");
+		return FAIL;
+	}
+	/* clear cache enable */
+	ret = gup_set_ic_msg(client, _bRW_MISCTL__CACHE_EN, 0x00);
+	if (ret <= 0) {
+		GTP_ERROR("[enter_update_mode]clear cache enable fail.");
+		return FAIL;
+	}
+	/* set boot from sram */
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOTCTL_B0_, 0x02);
+	if (ret <= 0) {
+		GTP_ERROR("[enter_update_mode]set boot from sram fail.");
+		return FAIL;
+	}
+	/* software reboot */
+	ret = gup_set_ic_msg(client, _bWO_MISCTL__CPU_SWRST_PULSE, 0x01);
+	if (ret <= 0) {
+		GTP_ERROR("[enter_update_mode]software reboot fail.");
+		return FAIL;
+	}
+
+	return SUCCESS;
+}
+
+static s32 gup_enter_update_mode_fl(struct i2c_client *client)
+{
+	s32 ret = -1;
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+	/* step1:RST output low last at least 2ms */
+	gpio_direction_output(ts->pdata->reset_gpio, 0);
+	msleep(20);
+
+	/* step2:select I2C slave addr,INT:0--0xBA;1--0x28. */
+	gpio_direction_output(ts->pdata->irq_gpio, (client->addr == 0x14));
+	msleep(20);
+
+	/* step3:RST output high reset guitar */
+	gpio_direction_output(ts->pdata->reset_gpio, 1);
+
+	msleep(20);
+
+	/* select addr & hold ss51_dsp */
+	ret = gup_hold_ss51_dsp(client);
+	if (ret <= 0) {
+		GTP_ERROR("[enter_update_mode]hold ss51 & dsp failed.");
+		return FAIL;
+	}
+	/* clear control flag */
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x00);
+	if (ret <= 0) {
+		GTP_ERROR("[enter_update_mode]clear control flag fail.");
+		return FAIL;
+	}
+	/* set scramble */
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
+	if (ret <= 0) {
+		GTP_ERROR("[enter_update_mode]set scramble fail.");
+		return FAIL;
+	}
+	/* enable accessing code */
+	ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x01);
+	if (ret <= 0) {
+		GTP_ERROR("[enter_update_mode]enable accessing code fail.");
+		return FAIL;
+	}
+
+	return SUCCESS;
+}
+
+static u8 gup_download_fw_dsp(struct i2c_client *client, u8 dwn_mode)
+{
+	s32 ret = 0;
+
+	/* step1:select bank2 */
+	GTP_DEBUG("[download_fw_dsp]step1:select bank2");
+	ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x02);
+	if (ret == FAIL) {
+		GTP_ERROR("select bank 2 fail");
+		return FAIL;
+	}
+
+	if (GTP_FL_FW_BURN == dwn_mode) {
+		GTP_INFO("[download_fw_dsp]Begin download dsp fw---->>");
+
+		if (ret <= 0) {
+			GTP_ERROR("[download_fw_dsp]select bank2 fail.");
+			return FAIL;
+		}
+		GTP_DEBUG("burn fw dsp");
+		/* write the second ban */
+		ret = gup_burn_fw_proc(client, 0xC000,
+				2 * FW_DOWNLOAD_LENGTH, FW_DSP_LENGTH);
+		if (FAIL == ret) {
+			GTP_ERROR("[download_fw_dsp]download FW dsp fail.");
+			return FAIL;
+		}
+		GTP_INFO("check firmware dsp");
+		ret = gup_check_and_repair(client, 0xC000,
+				2 * FW_DOWNLOAD_LENGTH, FW_DSP_LENGTH);
+		if (FAIL == ret) {
+			GTP_ERROR("check fw dsp failed!");
+			return FAIL;
+		}
+	} else if (GTP_FL_ESD_RECOVERY == dwn_mode) {
+		GTP_INFO("[download_fw_dsp]Begin esd check dsp fw---->>");
+		/*GTP_INFO("esd recovery: check fw dsp");
+		ret = gup_check_and_repair(client, 0xC000,
+				2 * FW_DOWNLOAD_LENGTH, FW_DSP_LENGTH);
+		if (FAIL == ret)
+		*/
+		{
+			GTP_INFO("esd recovery redownload firmware dsp code");
+			ret = gup_burn_fw_proc(client, 0xC000,
+						2 * FW_DOWNLOAD_LENGTH,
+						FW_DSP_LENGTH);
+			if (FAIL == ret) {
+				GTP_ERROR("redownload fw dsp failed!");
+				return FAIL;
+			}
+		}
+	} else {
+		GTP_INFO("check firmware dsp");
+		ret = gup_check_and_repair(client, 0xC000,
+					2 * FW_DOWNLOAD_LENGTH,
+					FW_DSP_LENGTH);
+		if (FAIL == ret) {
+			GTP_ERROR("check fw dsp failed!");
+			return FAIL;
+		}
+	}
+	return SUCCESS;
+}
+
+static s32 gup_burn_fw_proc(struct i2c_client *client, u16 start_addr,
+			    s32 start_index, s32 burn_len)
+{
+	s32 ret = 0;
+
+	GTP_DEBUG("burn firmware: 0x%04X, %d bytes, start_index: 0x%04X",
+		  start_addr, burn_len, start_index);
+
+	ret = i2c_write_bytes(client, start_addr,
+			(u8 *)&gtp_default_FW_fl[FW_HEAD_LENGTH + start_index],
+			burn_len);
+	if (ret < 0) {
+		GTP_ERROR("burn 0x%04X, %d bytes failed!", start_addr,
+			  burn_len);
+		return FAIL;
+	}
+	return SUCCESS;
+}
+
+static s32 gup_check_and_repair(struct i2c_client *client, u16 start_addr,
+				s32 start_index, s32 chk_len)
+{
+	s32 ret = 0;
+	s32 cmp_len = 0;
+	u16 cmp_addr = start_addr;
+	s32 i = 0;
+	s32 chked_times = 0;
+	u8 chk_fail = 0;
+
+	GTP_DEBUG("check firmware: start 0x%04X, %d bytes", start_addr,
+		  chk_len);
+	while ((chk_len > 0) && (chked_times < GTP_CHK_FW_MAX)) {
+		if (chk_len >= GUP_FW_CHK_SIZE)
+			cmp_len = GUP_FW_CHK_SIZE;
+		else
+			cmp_len = chk_len;
+		ret = i2c_read_bytes(client, cmp_addr, chk_cmp_buf, cmp_len);
+		if (ret < 0) {
+			chk_fail = 1;
+			break;
+		}
+		for (i = 0; i < cmp_len; ++i) {
+			if (chk_cmp_buf[i] !=
+			    gtp_default_FW_fl[FW_HEAD_LENGTH + start_index +
+					      i]) {
+				chk_fail = 1;
+				i2c_write_bytes(client, cmp_addr + i,
+						&gtp_default_FW_fl
+						[FW_HEAD_LENGTH + start_index +
+						 i], cmp_len - i);
+				GTP_ERROR
+				    ("Check failed index: %d(%d != %d)",
+				    i, chk_cmp_buf[i],
+				    gtp_default_FW_fl[FW_HEAD_LENGTH +
+						       start_index + i]);
+				break;
+			}
+		}
+		if (chk_fail == 1) {
+			chk_fail = 0;
+			chked_times++;
+		} else {
+			cmp_addr += cmp_len;
+			start_index += cmp_len;
+			chk_len -= cmp_len;
+		}
+	}
+	if (chk_len > 0) {
+		GTP_ERROR
+		    ("cmp_addr: 0x%04X, start_index: 0x%02X, chk_len: 0x%04X",
+		    cmp_addr, start_index, chk_len);
+		return FAIL;
+	}
+	return SUCCESS;
+}
+
+static u8 gup_download_fw_ss51(struct i2c_client *client, u8 dwn_mode)
+{
+	s32 section = 0;
+	s32 ret = 0;
+	s32 start_index = 0;
+	u8 bank = 0;
+	u16 burn_addr = 0xC000;
+
+	if (GTP_FL_FW_BURN == dwn_mode)
+		GTP_INFO("download firmware ss51");
+	else
+		GTP_INFO("check firmware ss51");
+	for (section = 1; section <= 4; section += 2) {
+		switch (section) {
+		case 1:
+			bank = 0x00;
+			burn_addr = (section - 1) * FW_SS51_SECTION_LEN
+								+ 0xC000;
+			break;
+		case 3:
+			bank = 0x01;
+			burn_addr = (section - 3) * FW_SS51_SECTION_LEN
+								+ 0xC000;
+			break;
+		}
+		start_index = (section - 1) * FW_SS51_SECTION_LEN;
+
+		GTP_DEBUG("download firmware ss51: select bank%d", bank);
+		ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, bank);
+		if (GTP_FL_FW_BURN == dwn_mode) {
+			GTP_INFO("download firmware ss51 section%d & %d",
+				 section, section + 1);
+			ret = gup_burn_fw_proc(client, burn_addr, start_index,
+						2 * FW_SS51_SECTION_LEN);
+			if (ret == FAIL) {
+				GTP_ERROR
+				    ("download fw ss51 section%d & %d failed!",
+				     section, section + 1);
+				return FAIL;
+			}
+			GTP_INFO("check firmware ss51 section%d & %d", section,
+				 section + 1);
+			ret = gup_check_and_repair(client, burn_addr,
+					start_index, 2 * FW_SS51_SECTION_LEN);
+			if (ret == FAIL) {
+				GTP_ERROR("check ss51 section%d & %d failed!",
+					  section, section + 1);
+				return FAIL;
+			}
+		} else if (GTP_FL_ESD_RECOVERY == dwn_mode) {
+			/*GTP_INFO("esd recovery check ss51 section%d & %d",
+						section, section + 1);
+			ret = gup_check_and_repair(client, burn_addr,
+					start_index, FW_SS51_SECTION_LEN);
+			if (ret == FAIL)
+			*/
+			{
+				GTP_INFO
+				    ("esd redownload ss51 section%d & %d",
+				     section, section + 1);
+				ret = gup_burn_fw_proc(client, burn_addr,
+						start_index,
+						2 * FW_SS51_SECTION_LEN);
+				if (ret == FAIL) {
+					GTP_ERROR
+					    ("download ss51 section%d failed!",
+					    section);
+					return FAIL;
+				}
+			}
+		} else {
+			GTP_INFO("check firmware ss51 section%d & %d", section,
+				 section + 1);
+			ret = gup_check_and_repair(client, burn_addr,
+					start_index, 2 * FW_SS51_SECTION_LEN);
+			if (ret == FAIL) {
+				GTP_ERROR("check ss51 section%d & %d failed!",
+					  section, section + 1);
+				return FAIL;
+			}
+		}
+	}
+
+	return SUCCESS;
+}
+
+static s32 gup_prepare_fl_fw(char *path, struct st_fw_head *fw_head)
+{
+	s32 ret = 0;
+	s32 i = 0;
+	s32 timeout = 0;
+	struct filename name = {.name = FL_UPDATE_PATH};
+	struct goodix_ts_data *ts = i2c_get_clientdata(i2c_connect_client);
+
+	if (!memcmp(path, "update", 6)) {
+		GTP_INFO("Search for GT9XXF firmware file to update");
+
+		searching_file = 1;
+		for (i = 0; i < GUP_SEARCH_FILE_TIMES; ++i) {
+			if (0 == searching_file) {
+				GTP_INFO
+				    ("Force terminate auto update for GT9XXF");
+				return FAIL;
+			}
+			GTP_DEBUG("Search for %s, %s for fw update.(%d/%d)",
+				  FL_UPDATE_PATH, FL_UPDATE_PATH_SD, i + 1,
+				  GUP_SEARCH_FILE_TIMES);
+			update_msg.file = file_open_name(&name, O_RDONLY, 0);
+			if (IS_ERR(update_msg.file)) {
+				name.name = FL_UPDATE_PATH_SD;
+				update_msg.file =
+					file_open_name(&name, O_RDONLY, 0);
+				if (IS_ERR(update_msg.file)) {
+					msleep(3000);
+					continue;
+				} else {
+					path = FL_UPDATE_PATH_SD;
+					break;
+				}
+			} else {
+				path = FL_UPDATE_PATH;
+				break;
+			}
+		}
+		searching_file = 0;
+		if (i == 50) {
+			GTP_INFO("Search timeout, update aborted");
+			return FAIL;
+		} else {
+			GTP_INFO("GT9XXF firmware file %s found!", path);
+			_CLOSE_FILE(update_msg.file);
+		}
+		while (ts->rqst_processing && (timeout++ < 5)) {
+			GTP_DEBUG
+			    ("request processing, waiting for accomplishment");
+			msleep(1000);
+		}
+	}
+	GTP_INFO("Firmware update file path: %s", path);
+
+	name.name = path;
+	update_msg.file = file_open_name(&name, O_RDONLY, 0);
+	if (IS_ERR(update_msg.file)) {
+		GTP_ERROR("Open update file(%s) error!", path);
+		return FAIL;
+	}
+
+	update_msg.old_fs = get_fs();
+	set_fs(KERNEL_DS);
+
+	update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_SET);
+	update_msg.fw_total_len =
+	    update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_END);
+
+	update_msg.force_update = 0xBE;	/* GT9XXF ignore the 0xBE */
+	if (update_msg.fw_total_len != sizeof(gtp_default_FW_fl)) {
+		GTP_ERROR
+		    ("fw size error: default size: %d(%dK), file size: %d(%dK)",
+		     sizeof(gtp_default_FW_fl),
+		     sizeof(gtp_default_FW_fl) / 1024, update_msg.fw_total_len,
+		     update_msg.fw_total_len / 1024);
+		set_fs(update_msg.old_fs);
+		_CLOSE_FILE(update_msg.file);
+		return FAIL;
+	}
+
+	update_msg.fw_total_len -= FW_HEAD_LENGTH;
+	GTP_DEBUG("Fimrware size: %d(%dK)", update_msg.fw_total_len,
+		  update_msg.fw_total_len / 1024);
+
+	update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_SET);
+	ret = update_msg.file->f_op->read(update_msg.file,
+					(char *)gtp_default_FW_fl,
+					update_msg.fw_total_len +
+					FW_HEAD_LENGTH,
+					&update_msg.file->f_pos);
+	set_fs(update_msg.old_fs);
+	_CLOSE_FILE(update_msg.file);
+
+	if (ret < 0) {
+		GTP_ERROR("read %s failed, err-code: %d", path, ret);
+		return FAIL;
+	}
+	return SUCCESS;
+}
+
+static u8 gup_check_update_file_fl(struct i2c_client *client,
+				   struct st_fw_head *fw_head, char *path)
+{
+	s32 ret = 0;
+	s32 i = 0;
+	s32 fw_checksum = 0;
+
+	if (NULL != path) {
+		ret = gup_prepare_fl_fw(path, fw_head);
+		if (FAIL == ret)
+			return FAIL;
+	}
+
+	memcpy(fw_head, gtp_default_FW_fl, FW_HEAD_LENGTH);
+	GTP_INFO("FILE HARDWARE INFO: %02x%02x%02x%02x", fw_head->hw_info[0],
+		 fw_head->hw_info[1], fw_head->hw_info[2], fw_head->hw_info[3]);
+	GTP_INFO("FILE PID: %s", fw_head->pid);
+	fw_head->vid =
+	    ((fw_head->vid & 0xFF00) >> 8) + ((fw_head->vid & 0x00FF) << 8);
+	GTP_INFO("FILE VID: %04x", fw_head->vid);
+
+	/* check firmware legality */
+	fw_checksum = 0;
+	for (i = FW_HEAD_LENGTH; i < (FW_HEAD_LENGTH + update_msg.fw_total_len);
+	     i += 2)
+		fw_checksum +=
+		    (gtp_default_FW_fl[i] << 8) + gtp_default_FW_fl[i + 1];
+	ret = SUCCESS;
+
+	GTP_DEBUG("firmware checksum: %x", fw_checksum & 0xFFFF);
+	if (fw_checksum & 0xFFFF) {
+		GTP_ERROR("Illegal firmware file.");
+		ret = FAIL;
+	}
+
+	return ret;
+}
+
+s32 gup_fw_download_proc(void *dir, u8 dwn_mode)
+{
+	s32 ret = 0;
+	u8 retry = 0;
+	struct st_fw_head fw_head;
+	struct goodix_ts_data *ts;
+
+	ts = i2c_get_clientdata(i2c_connect_client);
+	if (NULL == dir) {
+		if (GTP_FL_FW_BURN == dwn_mode)	/* GT9XXF firmware burn mode */
+			GTP_INFO("[fw_download_proc]Begin fw download ...");
+		else if (GTP_FL_ESD_RECOVERY == dwn_mode)
+			GTP_INFO
+			    ("[fw_download_proc]Begin fw esd recovery check");
+		else
+			GTP_INFO
+			    ("[fw_download_proc]Being fw repair check...");
+	} else
+		GTP_INFO("[fw_download_proc]Begin firmware update by bin file");
+
+	total_len = 100;
+	show_len = 0;
+
+	ret = gup_check_update_file_fl(i2c_connect_client,
+					&fw_head, (char *)dir);
+	show_len = 10;
+	if (FAIL == ret) {
+		GTP_ERROR("[fw_download_proc]check update file fail.");
+		goto file_fail;
+	}
+
+	if (!memcmp(fw_head.pid, "950", 3)) {
+		ts->is_950 = 1;
+		GTP_DEBUG("GT9XXF Ic Type: gt950");
+	} else
+		ts->is_950 = 0;
+
+	if (NULL != dir) {
+		gtp_irq_disable(ts);
+#if GTP_ESD_PROTECT
+		gtp_esd_switch(ts->client, SWITCH_OFF);
+#endif
+	}
+
+	ret = gup_enter_update_mode_fl(i2c_connect_client);
+	show_len = 20;
+	if (FAIL == ret) {
+		GTP_ERROR("[fw_download_proc]enter update mode fail.");
+		goto download_fail;
+	}
+
+	while (retry++ < 5) {
+		ret = gup_download_fw_ss51(i2c_connect_client, dwn_mode);
+		show_len = 60;
+		if (FAIL == ret) {
+			GTP_ERROR("[fw_download_proc]burn ss51 firmware fail.");
+			continue;
+		}
+
+		ret = gup_download_fw_dsp(i2c_connect_client, dwn_mode);
+		show_len = 80;
+		if (FAIL == ret) {
+			GTP_ERROR("[fw_download_proc]burn dsp firmware fail.");
+			continue;
+		}
+
+		GTP_INFO("[fw_download_proc]UPDATE SUCCESS.");
+		break;
+	}
+
+	if (retry >= 5) {
+		GTP_ERROR("[fw_download_proc]retry timeout,UPDATE FAIL.");
+		goto download_fail;
+	}
+
+	if (NULL != dir) {
+		gtp_irq_enable(ts);
+		gtp_fw_startup(ts->client);
+#if GTP_ESD_PROTECT
+		gtp_esd_switch(ts->client, SWITCH_ON);
+#endif
+	}
+	show_len = 100;
+	return SUCCESS;
+
+download_fail:
+	if (NULL != dir) {
+		gtp_irq_enable(ts);
+		gtp_fw_startup(ts->client);
+#if GTP_ESD_PROTECT
+		gtp_esd_switch(ts->client, SWITCH_ON);
+#endif
+	}
+file_fail:
+	show_len = 200;
+	return FAIL;
+}
+#endif
+
+/**************** For GT9XXF End ********************/
-- 
1.9.1

