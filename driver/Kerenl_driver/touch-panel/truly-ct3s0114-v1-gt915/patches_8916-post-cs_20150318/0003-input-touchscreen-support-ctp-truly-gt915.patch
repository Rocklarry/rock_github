From dbee43e5b24c5daadb485c4e10a9d9a8dff9c51f Mon Sep 17 00:00:00 2001
From: Li Zhanchao <lizc1023@thundersoft.com>
Date: Wed, 18 Mar 2015 10:03:18 +0800
Subject: [PATCH 3/3] input:touchscreen: support ctp truly gt915

Add CTP TRULY@CT3S0114-V1@GT915 driver

Change-Id: I14adc5918f8a960804512fdd2c1daa6f8c8997e0
Signed-off-by: Li Zhanchao <lizc1023@thundersoft.com>
---
 drivers/input/touchscreen/gt9xx/goodix_tool.c    |  624 ++--
 drivers/input/touchscreen/gt9xx/gt9xx.c          | 3625 ++++++++++++++-------
 drivers/input/touchscreen/gt9xx/gt9xx.h          |  414 ++-
 drivers/input/touchscreen/gt9xx/gt9xx_firmware.h | 3715 ++++++++++++++++++++++
 drivers/input/touchscreen/gt9xx/gt9xx_update.c   | 3247 ++++++++++++++-----
 5 files changed, 9213 insertions(+), 2412 deletions(-)
 create mode 100644 drivers/input/touchscreen/gt9xx/gt9xx_firmware.h

diff --git a/drivers/input/touchscreen/gt9xx/goodix_tool.c b/drivers/input/touchscreen/gt9xx/goodix_tool.c
index 8e202fc..5df17ea 100644
--- a/drivers/input/touchscreen/gt9xx/goodix_tool.c
+++ b/drivers/input/touchscreen/gt9xx/goodix_tool.c
@@ -1,7 +1,6 @@
 /* drivers/input/touchscreen/goodix_tool.c
  *
  * 2010 - 2012 Goodix Technology.
- * Copyright (c) 2013, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,140 +13,130 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * General Public License for more details.
  *
- * Version:1.6
+ * Version:2.2
  *        V1.0:2012/05/01,create file.
  *        V1.2:2012/06/08,modify some warning.
  *        V1.4:2012/08/28,modified to support GT9XX
  *        V1.6:new proc name
+ *        V2.2: compatible with Linux 3.10, 2014/01/14
  */
 
 #include "gt9xx.h"
-#include <linux/mutex.h>
-#include <linux/proc_fs.h>
-#include <linux/debugfs.h>
 
 #define DATA_LENGTH_UINT    512
 #define CMD_HEAD_LENGTH     (sizeof(struct st_cmd_head) - sizeof(u8 *))
-static char procname[20] = {0};
+static char procname[20] = { 0 };
 
+#pragma pack(1)
 struct st_cmd_head {
-	u8  wr;		/* write read flag 0:R 1:W 2:PID 3: */
-	u8  flag;	/* 0:no need flag/int 1: need flag  2:need int */
-	u8 flag_addr[2];/* flag address */
-	u8  flag_val;	/* flag val */
-	u8  flag_relation; /* flag_val:flag 0:not equal 1:equal 2:> 3:< */
-	u16 circle;	/* polling cycle */
-	u8  times;	/* plling times */
-	u8  retry;	/* I2C retry times */
-	u16 delay;	/* delay befor read or after write */
-	u16 data_len;	/* data length */
-	u8  addr_len;	/* address length */
-	u8  addr[2];	/* address */
-	u8  res[3];	/* reserved */
-	u8  *data;	/* data pointer */
-} __packed;
-
-static struct st_cmd_head cmd_head;
+	u8 wr;			/* write read flag£¬0:R  1:W  2:PID 3: */
+	u8 flag;		/* 0:no need flag 1: need flag 2:need int */
+	u8 flag_addr[2];	/* flag address */
+	u8 flag_val;		/* flag val */
+	u8 flag_relation;	/* flag_val:flag 0:not equal 1:equal 2:> 3:< */
+	u16 circle;		/* polling cycle */
+	u8 times;		/* plling times */
+	u8 retry;		/* I2C retry times */
+	u16 delay;		/* delay befor read or after write */
+	u16 data_len;		/* data length */
+	u8 addr_len;		/* address length */
+	u8 addr[2];		/* address */
+	u8 res[3];		/* reserved */
+	u8 *data;		/* data pointer */
+};
+#pragma pack()
+struct st_cmd_head cmd_head;
 
 static struct i2c_client *gt_client;
 
 static struct proc_dir_entry *goodix_proc_entry;
 
-static struct mutex lock;
+static ssize_t goodix_tool_read(struct file *, char __user *, size_t, loff_t *);
+static ssize_t goodix_tool_write(struct file *, const char __user *, size_t,
+				 loff_t *);
+static const struct file_operations tool_ops = {
+	.owner = THIS_MODULE,
+	.read = goodix_tool_read,
+	.write = goodix_tool_write,
+};
 
-static s32 (*tool_i2c_read)(u8 *, u16);
-static s32 (*tool_i2c_write)(u8 *, u16);
+static s32(*tool_i2c_read) (u8 *, u16);
+static s32(*tool_i2c_write) (u8 *, u16);
 
-s32 data_length;
-s8 ic_type[16] = {0};
+s32 DATA_LENGTH;
+s8 IC_TYPE[16] = "GT9XX";
 
 static void tool_set_proc_name(char *procname)
 {
-	char *months[12] = {"Jan", "Feb", "Mar", "Apr", "May",
-	"Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
-	char date[20] = {0};
-	char month[4] = {0};
+	char *months[12] = { "Jan", "Feb", "Mar", "Apr", "May",
+		"Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
+	};
+	char date[20] = { 0 };
+	char month[4] = { 0 };
 	int i = 0, n_month = 1, n_day = 0, n_year = 0;
-	snprintf(date, 20, "%s", __DATE__);
 
-	/* pr_debug("compile date: %s", date); */
+	snprintf(date, 20, "%s", __DATE__);
 
 	sscanf(date, "%s %d %d", month, &n_day, &n_year);
 
 	for (i = 0; i < 12; ++i) {
 		if (!memcmp(months[i], month, 3)) {
-			n_month = i+1;
+			n_month = i + 1;
 			break;
 		}
 	}
 
 	snprintf(procname, 20, "gmnode%04d%02d%02d", n_year, n_month, n_day);
-	/* pr_debug("procname = %s", procname); */
 }
 
 static s32 tool_i2c_read_no_extra(u8 *buf, u16 len)
 {
 	s32 ret = -1;
-	u8 i = 0;
-	struct i2c_msg msgs[2] = {
-		{
-			.flags = !I2C_M_RD,
-			.addr  = gt_client->addr,
-			.len   = cmd_head.addr_len,
-			.buf   = &buf[0],
-		},
-		{
-			.flags = I2C_M_RD,
-			.addr  = gt_client->addr,
-			.len   = len,
-			.buf   = &buf[GTP_ADDR_LENGTH],
-		},
-	};
+	s32 i = 0;
+	struct i2c_msg msgs[2];
+
+	msgs[0].flags = !I2C_M_RD;
+	msgs[0].addr = gt_client->addr;
+	msgs[0].len = cmd_head.addr_len;
+	msgs[0].buf = &buf[0];
+
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].addr = gt_client->addr;
+	msgs[1].len = len;
+	msgs[1].buf = &buf[GTP_ADDR_LENGTH];
 
 	for (i = 0; i < cmd_head.retry; i++) {
 		ret = i2c_transfer(gt_client->adapter, msgs, 2);
 		if (ret > 0)
 			break;
 	}
-
-	if (i == cmd_head.retry) {
-		dev_err(&gt_client->dev, "I2C read retry limit over.\n");
-		ret = -EIO;
-	}
-
 	return ret;
 }
 
 static s32 tool_i2c_write_no_extra(u8 *buf, u16 len)
 {
 	s32 ret = -1;
-	u8 i = 0;
-	struct i2c_msg msg = {
-		.flags = !I2C_M_RD,
-		.addr  = gt_client->addr,
-		.len   = len,
-		.buf   = buf,
-	};
+	s32 i = 0;
+	struct i2c_msg msg;
+
+	msg.flags = !I2C_M_RD;
+	msg.addr = gt_client->addr;
+	msg.len = len;
+	msg.buf = buf;
 
 	for (i = 0; i < cmd_head.retry; i++) {
 		ret = i2c_transfer(gt_client->adapter, &msg, 1);
 		if (ret > 0)
 			break;
 	}
-
-	if (i == cmd_head.retry) {
-		dev_err(&gt_client->dev, "I2C write retry limit over.\n");
-		ret = -EIO;
-	}
-
 	return ret;
 }
 
 static s32 tool_i2c_read_with_extra(u8 *buf, u16 len)
 {
 	s32 ret = -1;
-	u8 pre[2] = {0x0f, 0xff};
-	u8 end[2] = {0x80, 0x00};
+	u8 pre[2] = { 0x0f, 0xff };
+	u8 end[2] = { 0x80, 0x00 };
 
 	tool_i2c_write_no_extra(pre, 2);
 	ret = tool_i2c_read_no_extra(buf, len);
@@ -159,8 +148,8 @@ static s32 tool_i2c_read_with_extra(u8 *buf, u16 len)
 static s32 tool_i2c_write_with_extra(u8 *buf, u16 len)
 {
 	s32 ret = -1;
-	u8 pre[2] = {0x0f, 0xff};
-	u8 end[2] = {0x80, 0x00};
+	u8 pre[2] = { 0x0f, 0xff };
+	u8 end[2] = { 0x80, 0x00 };
 
 	tool_i2c_write_no_extra(pre, 2);
 	ret = tool_i2c_write_no_extra(buf, len);
@@ -171,17 +160,17 @@ static s32 tool_i2c_write_with_extra(u8 *buf, u16 len)
 
 static void register_i2c_func(void)
 {
-	if (strcmp(ic_type, "GT8110") && strcmp(ic_type, "GT8105")
-	&& strcmp(ic_type, "GT801") && strcmp(ic_type, "GT800")
-	&& strcmp(ic_type, "GT801PLUS") && strcmp(ic_type, "GT811")
-	&& strcmp(ic_type, "GTxxx")) {
+	if (strncmp(IC_TYPE, "GT8110", 6) && strncmp(IC_TYPE, "GT8105", 6)
+	    && strncmp(IC_TYPE, "GT801", 5) && strncmp(IC_TYPE, "GT800", 5)
+	    && strncmp(IC_TYPE, "GT801PLUS", 9) && strncmp(IC_TYPE, "GT811", 5)
+	    && strncmp(IC_TYPE, "GTxxx", 5) && strncmp(IC_TYPE, "GT9XX", 5)) {
 		tool_i2c_read = tool_i2c_read_with_extra;
 		tool_i2c_write = tool_i2c_write_with_extra;
-		pr_debug("I2C function: with pre and end cmd!");
+		GTP_DEBUG("I2C function: with pre and end cmd!");
 	} else {
 		tool_i2c_read = tool_i2c_read_no_extra;
 		tool_i2c_write = tool_i2c_write_no_extra;
-		pr_info("I2C function: without pre and end cmd!");
+		GTP_INFO("I2C function: without pre and end cmd!");
 	}
 }
 
@@ -189,14 +178,55 @@ static void unregister_i2c_func(void)
 {
 	tool_i2c_read = NULL;
 	tool_i2c_write = NULL;
-	pr_info("I2C function: unregister i2c transfer function!");
+	GTP_INFO("I2C function: unregister i2c transfer function!");
+}
+
+s32 init_wr_node(struct i2c_client *client)
+{
+	s32 i;
+
+	gt_client = client;
+	memset(&cmd_head, 0, sizeof(cmd_head));
+	cmd_head.data = NULL;
+
+	i = 5;
+	while ((!cmd_head.data) && i) {
+		cmd_head.data = kzalloc(i * DATA_LENGTH_UINT, GFP_KERNEL);
+		if (NULL != cmd_head.data)
+			break;
+		i--;
+	}
+	if (i) {
+		DATA_LENGTH = i * DATA_LENGTH_UINT + GTP_ADDR_LENGTH;
+		GTP_INFO("Applied memory size:%d.", DATA_LENGTH);
+	} else {
+		GTP_ERROR("Apply for memory failed.");
+		return FAIL;
+	}
+
+	cmd_head.addr_len = 2;
+	cmd_head.retry = 5;
+
+	register_i2c_func();
+
+	tool_set_proc_name(procname);
+
+	goodix_proc_entry = proc_create(procname, 0666, NULL, &tool_ops);
+	if (goodix_proc_entry == NULL) {
+		GTP_ERROR("Couldn't create proc entry!");
+		return FAIL;
+	}
+	GTP_INFO("Create proc entry success!");
+
+	return SUCCESS;
 }
 
 void uninit_wr_node(void)
 {
+	kfree(cmd_head.data);
 	cmd_head.data = NULL;
 	unregister_i2c_func();
-	proc_remove(goodix_proc_entry);
+	remove_proc_entry(procname, NULL);
 }
 
 static u8 relation(u8 src, u8 dst, u8 rlt)
@@ -204,15 +234,14 @@ static u8 relation(u8 src, u8 dst, u8 rlt)
 	u8 ret = 0;
 
 	switch (rlt) {
-
 	case 0:
 		ret = (src != dst) ? true : false;
 		break;
 
 	case 1:
 		ret = (src == dst) ? true : false;
-		pr_debug("equal:src:0x%02x   dst:0x%02x  ret:%d.",
-					src, dst, (s32)ret);
+		GTP_DEBUG("equal:src:0x%02x   dst:0x%02x   ret:%d.", src, dst,
+			  (s32) ret);
 		break;
 
 	case 2:
@@ -256,14 +285,15 @@ static u8 comfirm(void)
 
 	for (i = 0; i < cmd_head.times; i++) {
 		if (tool_i2c_read(buf, 1) <= 0) {
-			dev_err(&gt_client->dev, "Read flag data failed!");
+			GTP_ERROR("Read flag data failed!");
 			return FAIL;
 		}
-		if (true == relation(buf[GTP_ADDR_LENGTH], cmd_head.flag_val,
-						cmd_head.flag_relation)) {
-			pr_debug("value at flag addr:0x%02x.",
-						buf[GTP_ADDR_LENGTH]);
-			pr_debug("flag value:0x%02x.", cmd_head.flag_val);
+		if (true ==
+		    relation(buf[GTP_ADDR_LENGTH], cmd_head.flag_val,
+			     cmd_head.flag_relation)) {
+			GTP_DEBUG("value at flag addr:0x%02x.",
+				  buf[GTP_ADDR_LENGTH]);
+			GTP_DEBUG("flag value:0x%02x.", cmd_head.flag_val);
 			break;
 		}
 
@@ -271,330 +301,244 @@ static u8 comfirm(void)
 	}
 
 	if (i >= cmd_head.times) {
-		dev_err(&gt_client->dev, "Didn't get the flag to continue!");
+		GTP_ERROR("Didn't get the flag to continue!");
 		return FAIL;
 	}
 
 	return SUCCESS;
 }
 
-#ifdef CONFIG_GT9XX_TOUCHPANEL_UPDATE
-static s32 fill_update_info(char __user *user_buf,
-				    size_t count, loff_t *ppos)
-{
-	u8 buf[4];
-
-	buf[0] = show_len >> 8;
-	buf[1] = show_len & 0xff;
-	buf[2] = total_len >> 8;
-	buf[3] = total_len & 0xff;
-	return simple_read_from_buffer(user_buf, count, ppos,
-			buf, sizeof(buf));
-}
-#else
-static s32 fill_update_info(char __user *user_buf,
-				    size_t count, loff_t *ppos)
-{
-	return -ENODEV;
-}
-#endif
-
-/********************************************************
+/*******************************************************
 Function:
     Goodix tool write function.
-nput:
+Input:
   standard proc write function param.
 Output:
     Return write length.
 ********************************************************/
-static s32 goodix_tool_write(struct file *filp, const char __user *userbuf,
-						size_t count, loff_t *ppos)
+ssize_t goodix_tool_write(struct file *filp, const char __user *buff,
+			  size_t len, loff_t *off)
 {
 	s32 ret = 0;
 
-	mutex_lock(&lock);
-	ret = copy_from_user(&cmd_head, userbuf, CMD_HEAD_LENGTH);
-	if (ret) {
-		dev_err(&gt_client->dev, "copy_from_user failed.");
-		ret = -EACCES;
-		goto exit;
-	}
+	GTP_DEBUG_FUNC();
+	GTP_DEBUG_ARRAY((u8 *) buff, len);
 
-	dev_dbg(&gt_client->dev, "wr:0x%02x, flag:0x%02x, flag addr:0x%02x%02x, flag val:0x%02x, flag rel:0x%02x, circle:%d, times:%d, retry:%d, delay:%d, data len:%d, addr len:%d, addr:0x%02x%02x, write len: %d.",
-		cmd_head.wr, cmd_head.flag, cmd_head.flag_addr[0],
-		cmd_head.flag_addr[1], cmd_head.flag_val,
-		cmd_head.flag_relation,	(s32)cmd_head.circle,
-		(s32)cmd_head.times, (s32)cmd_head.retry, (s32)cmd_head.delay,
-		(s32)cmd_head.data_len, (s32)cmd_head.addr_len,
-		cmd_head.addr[0], cmd_head.addr[1], (s32)count);
-
-	if (cmd_head.data_len > (data_length - GTP_ADDR_LENGTH)) {
-		dev_err(&gt_client->dev, "data len %d > data buff %d, rejected!\n",
-			cmd_head.data_len, (data_length - GTP_ADDR_LENGTH));
-		ret = -EINVAL;
-		goto exit;
-	}
-	if (cmd_head.addr_len > GTP_ADDR_LENGTH) {
-		dev_err(&gt_client->dev, "addr len %d > data buff %d, rejected!\n",
-			cmd_head.addr_len, GTP_ADDR_LENGTH);
-		ret = -EINVAL;
-		goto exit;
+	ret = copy_from_user(&cmd_head, buff, CMD_HEAD_LENGTH);
+	if (ret) {
+		GTP_ERROR("copy_from_user failed.");
+		return -EPERM;
 	}
 
-	if (cmd_head.wr == GTP_RW_WRITE) {
-		ret = copy_from_user(&cmd_head.data[GTP_ADDR_LENGTH],
-				&userbuf[CMD_HEAD_LENGTH], cmd_head.data_len);
+	GTP_DEBUG("[Operation]wr: %02X", cmd_head.wr);
+	GTP_DEBUG
+	    ("[Flag]flag: %02X, addr: %02X%02X, value: %02X, relation: %02X",
+	     cmd_head.flag, cmd_head.flag_addr[0], cmd_head.flag_addr[1],
+	     cmd_head.flag_val, cmd_head.flag_relation);
+	GTP_DEBUG("[Retry]circle: %d, times: %d, retry: %d, delay: %d",
+		  (s32) cmd_head.circle, (s32) cmd_head.times,
+		  (s32) cmd_head.retry, (s32) cmd_head.delay);
+	GTP_DEBUG
+	    ("[Data]data len: %d, addr len: %d, addr: %02X%02X",
+	     (s32) cmd_head.data_len, (s32) cmd_head.addr_len,
+	     cmd_head.addr[0], cmd_head.addr[1]);
+	GTP_DEBUG
+	    ("[Data]buffer len: %d, data[0]: %02X",
+	     (s32) len, buff[CMD_HEAD_LENGTH]);
+
+	if (1 == cmd_head.wr) {
+		ret =
+		    copy_from_user(&cmd_head.data[GTP_ADDR_LENGTH],
+				   &buff[CMD_HEAD_LENGTH], cmd_head.data_len);
 		if (ret) {
-			dev_err(&gt_client->dev, "copy_from_user failed.");
-			goto exit;
+			GTP_ERROR("copy_from_user failed.");
+			return -EPERM;
 		}
-
 		memcpy(&cmd_head.data[GTP_ADDR_LENGTH - cmd_head.addr_len],
-					cmd_head.addr, cmd_head.addr_len);
+		       cmd_head.addr, cmd_head.addr_len);
 
-		if (cmd_head.flag == GTP_NEED_FLAG) {
-			if (comfirm() ==  FAIL) {
-				dev_err(&gt_client->dev, "Comfirm fail!");
-				ret = -EINVAL;
-				goto exit;
+		GTP_DEBUG_ARRAY(cmd_head.data,
+				cmd_head.data_len + cmd_head.addr_len);
+		GTP_DEBUG_ARRAY((u8 *)&buff[CMD_HEAD_LENGTH],
+				cmd_head.data_len);
+
+		if (1 == cmd_head.flag) {
+			if (FAIL == comfirm()) {
+				GTP_ERROR("[WRITE]Comfirm fail!");
+				return -EPERM;
 			}
-		} else if (cmd_head.flag == GTP_NEED_INTERRUPT) {
+		} else if (2 == cmd_head.flag) {
 			/* Need interrupt! */
 		}
-		if (tool_i2c_write(
-		&cmd_head.data[GTP_ADDR_LENGTH - cmd_head.addr_len],
-		cmd_head.data_len + cmd_head.addr_len) <= 0) {
-			dev_err(&gt_client->dev, "Write data failed!");
-			ret = -EIO;
-			goto exit;
+		if (tool_i2c_write
+		    (&cmd_head.data[GTP_ADDR_LENGTH - cmd_head.addr_len],
+		     cmd_head.data_len + cmd_head.addr_len) <= 0) {
+			GTP_ERROR("[WRITE]Write data failed!");
+			return -EPERM;
 		}
 
+		GTP_DEBUG_ARRAY(&cmd_head.
+				data[GTP_ADDR_LENGTH - cmd_head.addr_len],
+				cmd_head.data_len + cmd_head.addr_len);
 		if (cmd_head.delay)
 			msleep(cmd_head.delay);
-
-		ret = cmd_head.data_len + CMD_HEAD_LENGTH;
-		goto exit;
-	} else if (cmd_head.wr == GTP_RW_WRITE_IC_TYPE) {  /* Write ic type */
-		ret = copy_from_user(&cmd_head.data[0],
-				&userbuf[CMD_HEAD_LENGTH],
-				cmd_head.data_len);
+	} else if (3 == cmd_head.wr) {
+		ret =
+		    copy_from_user(&cmd_head.data[0], &buff[CMD_HEAD_LENGTH],
+				   cmd_head.data_len);
 		if (ret) {
-			dev_err(&gt_client->dev, "copy_from_user failed.");
-			goto exit;
+			GTP_ERROR("copy_from_user failed.");
+			return -EPERM;
 		}
-
-		if (cmd_head.data_len > sizeof(ic_type)) {
-			dev_err(&gt_client->dev,
-				"data len %d > data buff %d, rejected!\n",
-				cmd_head.data_len, sizeof(ic_type));
-			ret = -EINVAL;
-			goto exit;
-		}
-		memcpy(ic_type, cmd_head.data, cmd_head.data_len);
+		memcpy(IC_TYPE, cmd_head.data, cmd_head.data_len);
 
 		register_i2c_func();
-
-		ret = cmd_head.data_len + CMD_HEAD_LENGTH;
-		goto exit;
-	} else if (cmd_head.wr == GTP_RW_NO_WRITE) {
-		ret = cmd_head.data_len + CMD_HEAD_LENGTH;
-		goto exit;
-	} else if (cmd_head.wr == GTP_RW_DISABLE_IRQ) { /* disable irq! */
+	} else if (5 == cmd_head.wr) {
+		/* memcpy(IC_TYPE, cmd_head.data, cmd_head.data_len); */
+	} else if (7 == cmd_head.wr) {	/*disable irq! */
 		gtp_irq_disable(i2c_get_clientdata(gt_client));
-
-		#if GTP_ESD_PROTECT
+#if GTP_ESD_PROTECT
 		gtp_esd_switch(gt_client, SWITCH_OFF);
-		#endif
-		ret = CMD_HEAD_LENGTH;
-		goto exit;
-	} else if (cmd_head.wr == GTP_RW_ENABLE_IRQ) { /* enable irq! */
+#endif
+	} else if (9 == cmd_head.wr) {	/*enable irq! */
 		gtp_irq_enable(i2c_get_clientdata(gt_client));
-
-		#if GTP_ESD_PROTECT
+#if GTP_ESD_PROTECT
 		gtp_esd_switch(gt_client, SWITCH_ON);
-		#endif
-		ret = CMD_HEAD_LENGTH;
-		goto exit;
-	} else if (cmd_head.wr == GTP_RW_CHECK_RAWDIFF_MODE) {
+#endif
+	} else if (17 == cmd_head.wr) {
 		struct goodix_ts_data *ts = i2c_get_clientdata(gt_client);
-		ret = copy_from_user(&cmd_head.data[GTP_ADDR_LENGTH],
-				&userbuf[CMD_HEAD_LENGTH], cmd_head.data_len);
+		ret =
+		    copy_from_user(&cmd_head.data[GTP_ADDR_LENGTH],
+				   &buff[CMD_HEAD_LENGTH], cmd_head.data_len);
 		if (ret) {
-			pr_debug("copy_from_user failed.");
-			goto exit;
+			GTP_DEBUG("copy_from_user failed.");
+			return -EPERM;
 		}
 		if (cmd_head.data[GTP_ADDR_LENGTH]) {
-			pr_debug("gtp enter rawdiff.");
+			GTP_INFO("gtp enter rawdiff.");
 			ts->gtp_rawdiff_mode = true;
 		} else {
 			ts->gtp_rawdiff_mode = false;
-			pr_debug("gtp leave rawdiff.");
-		}
-		ret = CMD_HEAD_LENGTH;
-		goto exit;
-	} else if (cmd_head.wr == GTP_RW_ENTER_UPDATE_MODE) {
-		/* Enter update mode! */
-		if (gup_enter_update_mode(gt_client) ==  FAIL) {
-			ret = -EBUSY;
-			goto exit;
+			GTP_INFO("gtp leave rawdiff.");
 		}
-	} else if (cmd_head.wr == GTP_RW_LEAVE_UPDATE_MODE) {
-		/* Leave update mode! */
-		gup_leave_update_mode(gt_client);
-	} else if (cmd_head.wr == GTP_RW_UPDATE_FW) {
-		/* Update firmware! */
+	}
+#ifdef UPDATE_FUNCTIONS
+	else if (11 == cmd_head.wr) {	/*Enter update mode! */
+		if (FAIL == gup_enter_update_mode(gt_client))
+			return -EPERM;
+	} else if (13 == cmd_head.wr)	/* Leave update mode! */
+		gup_leave_update_mode();
+	else if (15 == cmd_head.wr) {	/* Update firmware! */
 		show_len = 0;
 		total_len = 0;
-		if (cmd_head.data_len + 1 > data_length) {
-			dev_err(&gt_client->dev, "data len %d > data buff %d, rejected!\n",
-			cmd_head.data_len + 1, data_length);
-			ret = -EINVAL;
-			goto exit;
-		}
 		memset(cmd_head.data, 0, cmd_head.data_len + 1);
-		memcpy(cmd_head.data, &userbuf[CMD_HEAD_LENGTH],
-					cmd_head.data_len);
+		memcpy(cmd_head.data, &buff[CMD_HEAD_LENGTH],
+		       cmd_head.data_len);
 
-		if (gup_update_proc((void *)cmd_head.data) == FAIL) {
-			ret = -EBUSY;
-			goto exit;
-		}
+		if (FAIL == gup_update_proc((void *)cmd_head.data))
+			return -EPERM;
 	}
-	ret = CMD_HEAD_LENGTH;
+#endif
 
-exit:
-	mutex_unlock(&lock);
-	return ret;
+	return len;
 }
 
 /*******************************************************
 Function:
     Goodix tool read function.
 Input:
-  standard seq file read function param.
+  standard proc read function param.
 Output:
     Return read length.
 ********************************************************/
-static s32 goodix_tool_read(struct file *file, char __user *user_buf,
-					size_t count, loff_t *ppos)
+ssize_t goodix_tool_read(struct file *file, char __user *page, size_t size,
+			 loff_t *ppos)
 {
-	u16 data_len = 0;
-	s32 ret;
-	u8 buf[32];
+	s32 ret = 0;
+
+	GTP_DEBUG_FUNC();
 
-	mutex_lock(&lock);
-	if (cmd_head.wr & 0x1) {
-		dev_err(&gt_client->dev, "command head wrong\n");
-		ret = -EINVAL;
-		goto exit;
+	if (*ppos) {		/* ADB call again */
+		/*GTP_DEBUG("[HEAD]wr: %d", cmd_head.wr);
+		GTP_DEBUG("[PARAM]size: %d, *ppos: %d", size, (int)*ppos);
+		GTP_DEBUG("[TOOL_READ]ADB call again, return it.");
+		*/
+		return 0;
 	}
 
-	switch (cmd_head.wr) {
-	case GTP_RW_READ:
-		if (cmd_head.flag == GTP_NEED_FLAG) {
-			if (comfirm() == FAIL) {
-				dev_err(&gt_client->dev, "Comfirm fail!");
-				ret = -EINVAL;
-				goto exit;
+	if (cmd_head.wr % 2)
+		return -EPERM;
+	else if (!cmd_head.wr) {
+		u16 len = 0;
+		s16 data_len = 0;
+		u16 loc = 0;
+
+		if (1 == cmd_head.flag) {
+			if (FAIL == comfirm()) {
+				GTP_ERROR("[READ]Comfirm fail!");
+				return -EPERM;
 			}
-		} else if (cmd_head.flag == GTP_NEED_INTERRUPT) {
+		} else if (2 == cmd_head.flag) {
 			/* Need interrupt! */
 		}
 
 		memcpy(cmd_head.data, cmd_head.addr, cmd_head.addr_len);
 
-		pr_debug("[CMD HEAD DATA] ADDR:0x%02x%02x.", cmd_head.data[0],
-							cmd_head.data[1]);
-		pr_debug("[CMD HEAD ADDR] ADDR:0x%02x%02x.", cmd_head.addr[0],
-							cmd_head.addr[1]);
+		GTP_DEBUG("[CMD HEAD DATA] ADDR:0x%02x%02x.", cmd_head.data[0],
+			  cmd_head.data[1]);
+		GTP_DEBUG("[CMD HEAD ADDR] ADDR:0x%02x%02x.", cmd_head.addr[0],
+			  cmd_head.addr[1]);
 
 		if (cmd_head.delay)
 			msleep(cmd_head.delay);
 
 		data_len = cmd_head.data_len;
-		if (data_len <= 0 || (data_len > data_length)) {
-			dev_err(&gt_client->dev, "Invalid data length %d\n",
-				data_len);
-			ret = -EINVAL;
-			goto exit;
-		}
-		if (data_len > count)
-			data_len = count;
-
-		if (tool_i2c_read(cmd_head.data, data_len) <= 0) {
-			dev_err(&gt_client->dev, "Read data failed!\n");
-			ret = -EIO;
-			goto exit;
+		while (data_len > 0) {
+			if (data_len > DATA_LENGTH)
+				len = DATA_LENGTH;
+			else
+				len = data_len;
+			data_len -= len;
+
+			if (tool_i2c_read(cmd_head.data, len) <= 0) {
+				GTP_ERROR("[READ]Read data failed!");
+				return -EPERM;
+			}
+			ret =
+			    simple_read_from_buffer(&page[loc], size, ppos,
+						    &cmd_head.
+						    data[GTP_ADDR_LENGTH], len);
+			if (ret < 0)
+				return ret;
+			loc += len;
+
+			GTP_DEBUG_ARRAY(&cmd_head.data[GTP_ADDR_LENGTH], len);
+			GTP_DEBUG_ARRAY(page, len);
 		}
-		ret = simple_read_from_buffer(user_buf, count, ppos,
-			&cmd_head.data[GTP_ADDR_LENGTH], data_len);
-		break;
-	case GTP_RW_FILL_INFO:
-		ret = fill_update_info(user_buf, count, ppos);
-		break;
-	case GTP_RW_READ_VERSION:
-		/* Read driver version */
-		data_len = scnprintf(buf, sizeof(buf), "%s\n",
-			GTP_DRIVER_VERSION);
-		ret = simple_read_from_buffer(user_buf, count, ppos,
-			buf, data_len);
-		break;
-	default:
-		ret = -EINVAL;
-		break;
+		return cmd_head.data_len;
+	} else if (2 == cmd_head.wr) {
+		ret =
+		    simple_read_from_buffer(page, size, ppos, IC_TYPE,
+					    sizeof(IC_TYPE));
+		return ret;
+	} else if (4 == cmd_head.wr) {
+		u8 progress_buf[4];
+		progress_buf[0] = show_len >> 8;
+		progress_buf[1] = show_len & 0xff;
+		progress_buf[2] = total_len >> 8;
+		progress_buf[3] = total_len & 0xff;
+
+		ret =
+		    simple_read_from_buffer(page, size, ppos, progress_buf, 4);
+		return ret;
+	} else if (6 == cmd_head.wr) {
+		/* Read error code! */
+	} else if (8 == cmd_head.wr) {
+		ret =
+		    simple_read_from_buffer(page, size, ppos,
+					    GTP_DRIVER_VERSION,
+					    strlen(GTP_DRIVER_VERSION));
+		return ret;
 	}
-
-exit:
-	mutex_unlock(&lock);
-	return ret;
-}
-
-static const struct file_operations goodix_proc_fops = {
-	.write = goodix_tool_write,
-	.read = goodix_tool_read,
-	.open = simple_open,
-	.owner = THIS_MODULE,
-};
-
-s32 init_wr_node(struct i2c_client *client)
-{
-	u8 i;
-
-	gt_client = client;
-	memset(&cmd_head, 0, sizeof(cmd_head));
-	cmd_head.data = NULL;
-
-	i = GTP_I2C_RETRY_5;
-	while ((!cmd_head.data) && i) {
-		cmd_head.data = devm_kzalloc(&client->dev,
-				i * DATA_LENGTH_UINT, GFP_KERNEL);
-		if (cmd_head.data)
-			break;
-		i--;
-	}
-	if (i) {
-		data_length = i * DATA_LENGTH_UINT;
-		dev_dbg(&client->dev, "Applied memory size:%d.", data_length);
-	} else {
-		dev_err(&client->dev, "Apply for memory failed.");
-		return FAIL;
-	}
-
-	cmd_head.addr_len = 2;
-	cmd_head.retry = GTP_I2C_RETRY_5;
-
-	register_i2c_func();
-
-	mutex_init(&lock);
-	tool_set_proc_name(procname);
-	goodix_proc_entry = proc_create(procname,
-			S_IWUSR | S_IWGRP | S_IRUSR | S_IRGRP,
-			goodix_proc_entry,
-			&goodix_proc_fops);
-	if (goodix_proc_entry == NULL) {
-		dev_err(&client->dev, "Couldn't create proc entry!");
-		return FAIL;
-	}
-
-	return SUCCESS;
+	return -EPERM;
 }
diff --git a/drivers/input/touchscreen/gt9xx/gt9xx.c b/drivers/input/touchscreen/gt9xx/gt9xx.c
index 46dfeed..2ea1cc9 100644
--- a/drivers/input/touchscreen/gt9xx/gt9xx.c
+++ b/drivers/input/touchscreen/gt9xx/gt9xx.c
@@ -1,10 +1,5 @@
 /* drivers/input/touchscreen/gt9xx.c
  *
- * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
- *
- * Linux Foundation chooses to take subject only to the GPLv2 license
- * terms, and distributes only under these terms.
- *
  * 2010 - 2013 Goodix Technology.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -18,15 +13,15 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * General Public License for more details.
  *
- * Version: 1.8
+ * Version: 2.2
  * Authors: andrew@goodix.com, meta@goodix.com
- * Release Date: 2013/04/25
+ * Release Date: 2014/01/14
  * Revision record:
  *      V1.0:
  *          first Release. By Andrew, 2012/08/31
  *      V1.2:
  *          modify gtp_reset_guitar,slot report,tracking_id & 0x0F.
- *                  By Andrew, 2012/10/15
+ *	By Andrew, 2012/10/15
  *      V1.4:
  *          modify gt9xx_update.c. By Andrew, 2012/12/12
  *      V1.6:
@@ -39,26 +34,33 @@
  *      V1.8:
  *          1. pen/stylus identification
  *          2. read double check & fixed config support
- *          2. new esd & slide wakeup optimization
+ *          3. new esd & slide wakeup optimization
  *                  By Meta, 2013/06/08
+ *      V2.0:
+ *          1. compatible with GT9XXF
+ *          2. send config after resume
+ *                  By Meta, 2013/08/06
+ *      V2.2:
+ *          1. gt9xx_config for debug
+ *          2. gesture wakeup
+ *          3. pen separate input device, active-pen button support
+ *          4. coordinates & keys optimization
+ *                  By Meta, 2014/01/14
  */
 
+#include <linux/irq.h>
 #include <linux/regulator/consumer.h>
+#include <linux/of_gpio.h>
 #include "gt9xx.h"
 
-#include <linux/of_gpio.h>
-#include <linux/irq.h>
-#include <linux/module.h>
+#if GTP_ICS_SLOT_REPORT
 #include <linux/input/mt.h>
-#include <linux/debugfs.h>
+#endif
 
-#define GOODIX_DEV_NAME	"Goodix-CTP"
-#define CFG_MAX_TOUCH_POINTS	5
+static const char *goodix_ts_name = "goodix-ts";
+static struct workqueue_struct *goodix_wq;
+struct i2c_client *i2c_connect_client;
 #define GOODIX_COORDS_ARR_SIZE	4
-#define MAX_BUTTONS		4
-
-#define CFG_GROUP_LEN(p_cfg_grp)  (sizeof(p_cfg_grp) / sizeof(p_cfg_grp[0]))
-
 #define GOODIX_VTG_MIN_UV	2600000
 #define GOODIX_VTG_MAX_UV	3300000
 #define GOODIX_I2C_VTG_MIN_UV	1800000
@@ -67,20 +69,39 @@
 #define GOODIX_VDD_LOAD_MAX_UA	10000
 #define GOODIX_VIO_LOAD_MIN_UA	0
 #define GOODIX_VIO_LOAD_MAX_UA	10000
+#ifdef FEATURE_QRD8X26_UNISCOPE_MODIFY
+#define GPIO_VDD_2_8V          56
+#endif
+#define MAX_BUTTONS		4
+#define PROP_NAME_SIZE		24
 
-#define RESET_DELAY_T3_US	200	/* T3: > 100us */
-#define RESET_DELAY_T4		20	/* T4: > 5ms */
+u8 config[GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH] = {
+		GTP_REG_CONFIG_DATA >> 8, GTP_REG_CONFIG_DATA & 0xff};
 
-#define PHY_BUF_SIZE		32
-#define PROP_NAME_SIZE		24
+#if GTP_HAVE_TOUCH_KEY
+static const u16 touch_key_array[] = GTP_KEY_TAB;
+#define GTP_MAX_KEY_NUM  (sizeof(touch_key_array) / sizeof(touch_key_array[0]))
+#if GTP_DEBUG_ON
+static const int key_codes[] = { KEY_HOMEPAGE, KEY_BACK, KEY_MENU, KEY_SEARCH };
+static const char *const key_names[] = {
+	"Key_Home", "Key_Back", "Key_Menu", "Key_Search"};
+#endif
+#endif
 
-#define GTP_MAX_TOUCH		5
-#define GTP_ESD_CHECK_CIRCLE_MS	2000
+static s8 gtp_i2c_test(struct i2c_client *client);
+static void gtp_int_sync(struct goodix_ts_data *ts, s32 ms);
 
-static void gtp_int_sync(struct goodix_ts_data *ts, int ms);
-static int gtp_i2c_test(struct i2c_client *client);
-static int goodix_power_off(struct goodix_ts_data *ts);
-static int goodix_power_on(struct goodix_ts_data *ts);
+static ssize_t gt91xx_config_read_proc(struct file *, char __user *, size_t,
+				       loff_t *);
+static ssize_t gt91xx_config_write_proc(struct file *, const char __user *,
+					size_t, loff_t *);
+
+static struct proc_dir_entry *gt91xx_config_proc;
+static const struct file_operations config_proc_ops = {
+	.owner = THIS_MODULE,
+	.read = gt91xx_config_read_proc,
+	.write = gt91xx_config_write_proc,
+};
 
 #if defined(CONFIG_FB)
 static int fb_notifier_callback(struct notifier_block *self,
@@ -95,220 +116,253 @@ static void goodix_ts_late_resume(struct early_suspend *h);
 #if GTP_ESD_PROTECT
 static struct delayed_work gtp_esd_check_work;
 static struct workqueue_struct *gtp_esd_check_workqueue;
-static void gtp_esd_check_func(struct work_struct *work);
-static int gtp_init_ext_watchdog(struct i2c_client *client);
+static void gtp_esd_check_func(struct work_struct *);
+static s32 gtp_init_ext_watchdog(struct i2c_client *client);
+#endif
+
+/*********** For GT9XXF Start **********/
+#if GTP_COMPATIBLE_MODE
+static s32 gtp_esd_recovery(struct i2c_client *client);
+static s32 gtp_main_clk_proc(struct goodix_ts_data *ts);
+static s32 gtp_bak_ref_proc(struct goodix_ts_data *ts, u8 mode);
 #endif
+/********** For GT9XXF End **********/
 
-enum doze {
+#if GTP_GESTURE_WAKEUP
+enum {
 	DOZE_DISABLED = 0,
 	DOZE_ENABLED = 1,
 	DOZE_WAKEUP = 2,
-};
-static enum doze doze_status = DOZE_DISABLED;
+} DOZE_T;
+static DOZE_T doze_status = DOZE_DISABLED;
 static s8 gtp_enter_doze(struct goodix_ts_data *ts);
+#endif
 
-bool init_done;
-static u8 chip_gt9xxs;  /* true if ic is gt9xxs, like gt915s */
 u8 grp_cfg_version;
-struct i2c_client  *i2c_connect_client;
 
 #define GTP_DEBUGFS_DIR			"ts_debug"
 #define GTP_DEBUGFS_FILE_SUSPEND	"suspend"
 #define GTP_DEBUGFS_FILE_DATA		"data"
 #define GTP_DEBUGFS_FILE_ADDR		"addr"
+#define GTP_DEBUGFS_FILE_DUMP_INFO	"dump_info"
+
+#define GOODIX_INFO_MAX_LEN 512
+#define GOODIX_STORE_TS_INFO(buf, name, max_tch, product_id, fw_vkey_support) \
+				snprintf(buf, GOODIX_INFO_MAX_LEN, \
+				"controller\t= goodix\n" \
+				"name\t\t= %s\n" \
+				"max_touches\t= %d\n" \
+				"product\t= %s\n" \
+				"fw_vkey_support\t= %s\n" \
+				, name, \
+				max_tch, product_id, \
+				fw_vkey_support)
 
 /*******************************************************
 Function:
-	Read data from the i2c slave device.
+    Read data from the i2c slave device.
 Input:
-	client:     i2c device.
-	buf[0~1]:   read start address.
-	buf[2~len-1]:   read data buffer.
-	len:    GTP_ADDR_LENGTH + read bytes count
+    client:     i2c device.
+    buf[0~1]:   read start address.
+    buf[2~len-1]:   read data buffer.
+    len:    GTP_ADDR_LENGTH + read bytes count
 Output:
-	numbers of i2c_msgs to transfer:
-		2: succeed, otherwise: failed
+    numbers of i2c_msgs to transfer:
+      2: succeed, otherwise: failed
 *********************************************************/
-int gtp_i2c_read(struct i2c_client *client, u8 *buf, int len)
+s32 gtp_i2c_read(struct i2c_client *client, u8 *buf, s32 len)
 {
-	struct goodix_ts_data *ts = i2c_get_clientdata(client);
-	int ret = -EIO;
-	u8 retries;
-	struct i2c_msg msgs[2] = {
-		{
-			.flags	= !I2C_M_RD,
-			.addr	= client->addr,
-			.len	= GTP_ADDR_LENGTH,
-			.buf	= &buf[0],
-		},
-		{
-			.flags	= I2C_M_RD,
-			.addr	= client->addr,
-			.len	= len - GTP_ADDR_LENGTH,
-			.buf	= &buf[GTP_ADDR_LENGTH],
-		},
-	};
+	struct i2c_msg msgs[2];
+	s32 ret = -1;
+	s32 retries = 0;
+
+	GTP_DEBUG_FUNC();
 
-	for (retries = 0; retries < GTP_I2C_RETRY_5; retries++) {
+	msgs[0].flags = !I2C_M_RD;
+	msgs[0].addr = client->addr;
+	msgs[0].len = GTP_ADDR_LENGTH;
+	msgs[0].buf = &buf[0];
+
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].addr = client->addr;
+	msgs[1].len = len - GTP_ADDR_LENGTH;
+	msgs[1].buf = &buf[GTP_ADDR_LENGTH];
+
+	while (retries < 5) {
 		ret = i2c_transfer(client->adapter, msgs, 2);
 		if (ret == 2)
 			break;
-		dev_err(&client->dev, "I2C retry: %d\n", retries + 1);
+		retries++;
 	}
-	if (retries == GTP_I2C_RETRY_5) {
-		if (ts->pdata->slide_wakeup)
-			/* reset chip would quit doze mode */
-			if (DOZE_ENABLED == doze_status)
-				return ret;
+	if ((retries >= 5)) {
+#if GTP_COMPATIBLE_MODE
+		struct goodix_ts_data *ts = i2c_get_clientdata(client);
+#endif
 
-		if (init_done)
-			gtp_reset_guitar(ts, 10);
+#if GTP_GESTURE_WAKEUP
+		/* reset chip would quit doze mode */
+		if (DOZE_ENABLED == doze_status)
+			return ret;
+#endif
+		GTP_ERROR
+		    ("I2C Read: 0x%04X, %d bytes failed, errcode: %d!",
+		     (((u16) (buf[0] << 8)) | buf[1]), len - 2, ret);
+#if GTP_COMPATIBLE_MODE
+		if (CHIP_TYPE_GT9F == ts->chip_type)
+			gtp_recovery_reset(client);
 		else
-			dev_warn(&client->dev,
-				"gtp_reset_guitar exit init_done=%d:\n",
-				init_done);
+#endif
+			gtp_reset_guitar(client, 10);
 	}
 	return ret;
 }
 
 /*******************************************************
 Function:
-	Write data to the i2c slave device.
+    Write data to the i2c slave device.
 Input:
-	client:     i2c device.
-	buf[0~1]:   write start address.
-	buf[2~len-1]:   data buffer
-	len:    GTP_ADDR_LENGTH + write bytes count
+    client:     i2c device.
+    buf[0~1]:   write start address.
+    buf[2~len-1]:   data buffer
+    len:    GTP_ADDR_LENGTH + write bytes count
 Output:
-	numbers of i2c_msgs to transfer:
-	1: succeed, otherwise: failed
+    numbers of i2c_msgs to transfer:
+    1: succeed, otherwise: failed
 *********************************************************/
-int gtp_i2c_write(struct i2c_client *client, u8 *buf, int len)
+s32 gtp_i2c_write(struct i2c_client *client, u8 *buf, s32 len)
 {
-	struct goodix_ts_data *ts = i2c_get_clientdata(client);
-	int ret = -EIO;
-	u8 retries;
-	struct i2c_msg msg = {
-		.flags = !I2C_M_RD,
-		.addr = client->addr,
-		.len = len,
-		.buf = buf,
-	};
+	struct i2c_msg msg;
+	s32 ret = -1;
+	s32 retries = 0;
+
+	GTP_DEBUG_FUNC();
 
-	for (retries = 0; retries < GTP_I2C_RETRY_5; retries++) {
+	msg.flags = !I2C_M_RD;
+	msg.addr = client->addr;
+	msg.len = len;
+	msg.buf = buf;
+
+	while (retries < 5) {
 		ret = i2c_transfer(client->adapter, &msg, 1);
 		if (ret == 1)
 			break;
-		dev_err(&client->dev, "I2C retry: %d\n", retries + 1);
+		retries++;
 	}
-	if ((retries == GTP_I2C_RETRY_5)) {
-		if (ts->pdata->slide_wakeup)
-			if (DOZE_ENABLED == doze_status)
-				return ret;
+	if ((retries >= 5)) {
+#if GTP_COMPATIBLE_MODE
+		struct goodix_ts_data *ts = i2c_get_clientdata(client);
+#endif
 
-		if (init_done)
-			gtp_reset_guitar(ts, 10);
+#if GTP_GESTURE_WAKEUP
+		if (DOZE_ENABLED == doze_status)
+			return ret;
+#endif
+		GTP_ERROR
+		    ("I2C Write: 0x%04X, %d bytes failed, errcode: %d!",
+		     (((u16) (buf[0] << 8)) | buf[1]), len - 2, ret);
+#if GTP_COMPATIBLE_MODE
+		if (CHIP_TYPE_GT9F == ts->chip_type)
+			gtp_recovery_reset(client);
 		else
-			dev_warn(&client->dev,
-				"gtp_reset_guitar exit init_done=%d:\n",
-				init_done);
+#endif
+			gtp_reset_guitar(client, 10);
 	}
 	return ret;
 }
 
 /*******************************************************
 Function:
-	i2c read twice, compare the results
+    i2c read twice, compare the results
 Input:
-	client:  i2c device
-	addr:    operate address
-	rxbuf:   read data to store, if compare successful
-	len:     bytes to read
+    client:  i2c device
+    addr:    operate address
+    rxbuf:   read data to store, if compare successful
+    len:     bytes to read
 Output:
-	FAIL:    read failed
-	SUCCESS: read successful
+    FAIL:    read failed
+    SUCCESS: read successful
 *********************************************************/
-int gtp_i2c_read_dbl_check(struct i2c_client *client,
-			u16 addr, u8 *rxbuf, int len)
+s32 gtp_i2c_read_dbl_check(struct i2c_client *client, u16 addr, u8 *rxbuf,
+			   int len)
 {
-	u8 buf[16] = {0};
-	u8 confirm_buf[16] = {0};
+	u8 buf[16] = { 0 };
+	u8 confirm_buf[16] = { 0 };
 	u8 retry = 0;
 
-	while (retry++ < GTP_I2C_RETRY_3) {
+	while (retry++ < 3) {
 		memset(buf, 0xAA, 16);
-		buf[0] = (u8)(addr >> 8);
-		buf[1] = (u8)(addr & 0xFF);
+		buf[0] = (u8) (addr >> 8);
+		buf[1] = (u8) (addr & 0xFF);
 		gtp_i2c_read(client, buf, len + 2);
 
 		memset(confirm_buf, 0xAB, 16);
-		confirm_buf[0] = (u8)(addr >> 8);
-		confirm_buf[1] = (u8)(addr & 0xFF);
+		confirm_buf[0] = (u8) (addr >> 8);
+		confirm_buf[1] = (u8) (addr & 0xFF);
 		gtp_i2c_read(client, confirm_buf, len + 2);
 
-		if (!memcmp(buf, confirm_buf, len + 2))
-			break;
-	}
-	if (retry < GTP_I2C_RETRY_3) {
-		memcpy(rxbuf, confirm_buf + 2, len);
-		return SUCCESS;
-	} else {
-		dev_err(&client->dev,
-			"i2c read 0x%04X, %d bytes, double check failed!",
-			addr, len);
-		return FAIL;
+		if (!memcmp(buf, confirm_buf, len + 2)) {
+			memcpy(rxbuf, confirm_buf + 2, len);
+			return SUCCESS;
+		}
 	}
+	GTP_ERROR("I2C read 0x%04X, %d bytes, double check failed!", addr, len);
+	return FAIL;
 }
 
 /*******************************************************
 Function:
-	Send config data.
+    Send config.
 Input:
-	client: i2c device.
+    client: i2c device.
 Output:
-	result of i2c write operation.
-	> 0: succeed, otherwise: failed
+    result of i2c write operation.
+    1: succeed, otherwise: failed
 *********************************************************/
-int gtp_send_cfg(struct goodix_ts_data *ts)
+s32 gtp_send_cfg(struct i2c_client *client)
 {
-	int ret = 0;
-	int retry;
+	s32 ret = 2;
 
-	if (ts->pdata->driver_send_cfg) {
-		if (ts->fixed_cfg) {
-			dev_dbg(&ts->client->dev,
-				"Ic fixed config, no config sent!");
-			ret = 2;
-		} else {
-			for (retry = 0; retry < GTP_I2C_RETRY_5; retry++) {
-				ret = gtp_i2c_write(ts->client,
-					ts->config_data,
-					GTP_CONFIG_MAX_LENGTH +
-						GTP_ADDR_LENGTH);
-				if (ret > 0)
-					break;
-			}
-		}
+#if GTP_DRIVER_SEND_CFG
+	s32 retry = 0;
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+	if (ts->fixed_cfg) {
+		GTP_INFO("Ic fixed config, no config sent!");
+		return 0;
+	} else if (ts->pnl_init_error) {
+		GTP_INFO("Error occured in init_panel, no config sent");
+		return 0;
 	}
 
+	GTP_INFO("Driver send config.");
+	for (retry = 0; retry < 5; retry++) {
+		ret =
+		    gtp_i2c_write(client, config,
+				  GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH);
+		if (ret > 0)
+			break;
+	}
+#endif
 	return ret;
 }
 
 /*******************************************************
 Function:
-	Disable irq function
+    Disable irq function
 Input:
-	ts: goodix i2c_client private data
+    ts: goodix i2c_client private data
 Output:
-	None.
+    None.
 *********************************************************/
 void gtp_irq_disable(struct goodix_ts_data *ts)
 {
 	unsigned long irqflags;
 
+	GTP_DEBUG_FUNC();
+
 	spin_lock_irqsave(&ts->irq_lock, irqflags);
-	if (!ts->irq_is_disabled) {
-		ts->irq_is_disabled = true;
+	if (!ts->irq_is_disable) {
+		ts->irq_is_disable = 1;
 		disable_irq_nosync(ts->client->irq);
 	}
 	spin_unlock_irqrestore(&ts->irq_lock, irqflags);
@@ -316,86 +370,195 @@ void gtp_irq_disable(struct goodix_ts_data *ts)
 
 /*******************************************************
 Function:
-	Enable irq function
+    Enable irq function
 Input:
-	ts: goodix i2c_client private data
+    ts: goodix i2c_client private data
 Output:
-	None.
+    None.
 *********************************************************/
 void gtp_irq_enable(struct goodix_ts_data *ts)
 {
 	unsigned long irqflags = 0;
 
+	GTP_DEBUG_FUNC();
+
 	spin_lock_irqsave(&ts->irq_lock, irqflags);
-	if (ts->irq_is_disabled) {
+	if (ts->irq_is_disable) {
 		enable_irq(ts->client->irq);
-		ts->irq_is_disabled = false;
+		ts->irq_is_disable = 0;
 	}
 	spin_unlock_irqrestore(&ts->irq_lock, irqflags);
 }
 
 /*******************************************************
 Function:
-	Report touch point event
+    Report touch point event
 Input:
-	ts: goodix i2c_client private data
-	id: trackId
-	x:  input x coordinate
-	y:  input y coordinate
-	w:  input pressure
+    ts: goodix i2c_client private data
+    id: trackId
+    x:  input x coordinate
+    y:  input y coordinate
+    w:  input pressure
 Output:
-	None.
+    None.
 *********************************************************/
-static void gtp_touch_down(struct goodix_ts_data *ts, int id, int x, int y,
-		int w)
+static void gtp_touch_down(struct goodix_ts_data *ts, s32 id, s32 x, s32 y,
+			   s32 w)
 {
-	if (ts->pdata->change_x2y)
-		swap(x, y);
+#if GTP_CHANGE_X2Y
+	GTP_SWAP(x, y);
+#endif
 
+#if GTP_ICS_SLOT_REPORT
 	input_mt_slot(ts->input_dev, id);
-	input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, true);
+	input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, id);
+	input_report_abs(ts->input_dev, ABS_MT_POSITION_X, x);
+	input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, y);
+	input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, w);
+	input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, w);
+#else
+	input_report_key(ts->input_dev, BTN_TOUCH, 1);
 	input_report_abs(ts->input_dev, ABS_MT_POSITION_X, x);
 	input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, y);
 	input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, w);
 	input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, w);
+	input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, id);
+	input_mt_sync(ts->input_dev);
+#endif
+
+	GTP_DEBUG("ID:%d, X:%d, Y:%d, W:%d", id, x, y, w);
 }
 
 /*******************************************************
 Function:
-	Report touch release event
+    Report touch release event
 Input:
-	ts: goodix i2c_client private data
+    ts: goodix i2c_client private data
 Output:
-	None.
+    None.
 *********************************************************/
-static void gtp_touch_up(struct goodix_ts_data *ts, int id)
+static void gtp_touch_up(struct goodix_ts_data *ts, s32 id)
 {
+#if GTP_ICS_SLOT_REPORT
 	input_mt_slot(ts->input_dev, id);
-	input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, false);
+	input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, -1);
+	GTP_DEBUG("Touch id[%2d] release!", id);
+#else
+	input_report_key(ts->input_dev, BTN_TOUCH, 0);
+#endif
+}
+
+#if GTP_WITH_PEN
+static void gtp_pen_init(struct goodix_ts_data *ts)
+{
+	s32 ret = 0;
+
+	GTP_INFO("Request input device for pen/stylus.");
+
+	ts->pen_dev = input_allocate_device();
+	if (ts->pen_dev == NULL) {
+		GTP_ERROR("Failed to allocate input device for pen/stylus.");
+		return;
+	}
+
+	ts->pen_dev->evbit[0] =
+	    BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+
+#if GTP_ICS_SLOT_REPORT
+	input_mt_init_slots(ts->pen_dev, 16);
+#else
+	ts->pen_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+#endif
+
+	set_bit(BTN_TOOL_PEN, ts->pen_dev->keybit);
+	set_bit(INPUT_PROP_DIRECT, ts->pen_dev->propbit);
+
+#if GTP_PEN_HAVE_BUTTON
+	input_set_capability(ts->pen_dev, EV_KEY, BTN_STYLUS);
+	input_set_capability(ts->pen_dev, EV_KEY, BTN_STYLUS2);
+#endif
+
+	input_set_abs_params(ts->pen_dev, ABS_MT_POSITION_X, 0, ts->abs_x_max,
+			     0, 0);
+	input_set_abs_params(ts->pen_dev, ABS_MT_POSITION_Y, 0, ts->abs_y_max,
+			     0, 0);
+	input_set_abs_params(ts->pen_dev, ABS_MT_PRESSURE, 0, 255, 0, 0);
+	input_set_abs_params(ts->pen_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(ts->pen_dev, ABS_MT_TRACKING_ID, 0, 255, 0, 0);
+
+	ts->pen_dev->name = "goodix-pen";
+	ts->pen_dev->id.bustype = BUS_I2C;
+
+	ret = input_register_device(ts->pen_dev);
+	if (ret)
+		GTP_ERROR("Register %s input device failed", ts->pen_dev->name);
+}
+
+static void gtp_pen_down(s32 x, s32 y, s32 w, s32 id)
+{
+	struct goodix_ts_data *ts = i2c_get_clientdata(i2c_connect_client);
+
+#if GTP_CHANGE_X2Y
+	GTP_SWAP(x, y);
+#endif
+
+	input_report_key(ts->pen_dev, BTN_TOOL_PEN, 1);
+#if GTP_ICS_SLOT_REPORT
+	input_mt_slot(ts->pen_dev, id);
+	input_report_abs(ts->pen_dev, ABS_MT_TRACKING_ID, id);
+	input_report_abs(ts->pen_dev, ABS_MT_POSITION_X, x);
+	input_report_abs(ts->pen_dev, ABS_MT_POSITION_Y, y);
+	input_report_abs(ts->pen_dev, ABS_MT_PRESSURE, w);
+	input_report_abs(ts->pen_dev, ABS_MT_TOUCH_MAJOR, w);
+#else
+	input_report_key(ts->pen_dev, BTN_TOUCH, 1);
+	input_report_abs(ts->pen_dev, ABS_MT_POSITION_X, x);
+	input_report_abs(ts->pen_dev, ABS_MT_POSITION_Y, y);
+	input_report_abs(ts->pen_dev, ABS_MT_PRESSURE, w);
+	input_report_abs(ts->pen_dev, ABS_MT_TOUCH_MAJOR, w);
+	input_report_abs(ts->pen_dev, ABS_MT_TRACKING_ID, id);
+	input_mt_sync(ts->pen_dev);
+#endif
+	GTP_DEBUG("(%d)(%d, %d)[%d]", id, x, y, w);
 }
 
+static void gtp_pen_up(s32 id)
+{
+	struct goodix_ts_data *ts = i2c_get_clientdata(i2c_connect_client);
+
+	input_report_key(ts->pen_dev, BTN_TOOL_PEN, 0);
 
+#if GTP_ICS_SLOT_REPORT
+	input_mt_slot(ts->pen_dev, id);
+	input_report_abs(ts->pen_dev, ABS_MT_TRACKING_ID, -1);
+#else
+	input_report_key(ts->pen_dev, BTN_TOUCH, 0);
+#endif
+}
+#endif
 
 /*******************************************************
 Function:
-	Goodix touchscreen work function
+    Goodix touchscreen work function
 Input:
-	work: work struct of goodix_workqueue
+    work: work struct of goodix_workqueue
 Output:
-	None.
+    None.
 *********************************************************/
 static void goodix_ts_work_func(struct work_struct *work)
 {
-	u8 end_cmd[3] = { GTP_READ_COOR_ADDR >> 8,
-			GTP_READ_COOR_ADDR & 0xFF, 0};
+	u8 end_cmd[3] = {
+		GTP_READ_COOR_ADDR >> 8, GTP_READ_COOR_ADDR & 0xFF, 0 };
 	u8 point_data[2 + 1 + 8 * GTP_MAX_TOUCH + 1] = {
-			GTP_READ_COOR_ADDR >> 8,
-			GTP_READ_COOR_ADDR & 0xFF};
+		GTP_READ_COOR_ADDR >> 8, GTP_READ_COOR_ADDR & 0xFF };
 	u8 touch_num = 0;
 	u8 finger = 0;
 	static u16 pre_touch;
 	static u8 pre_key;
+#if GTP_WITH_PEN
+	u8 pen_active = 0;
 	static u8 pre_pen;
+#endif
 	u8 key_value = 0;
 	u8 *coor_data = NULL;
 	s32 input_x = 0;
@@ -403,78 +566,176 @@ static void goodix_ts_work_func(struct work_struct *work)
 	s32 input_w = 0;
 	s32 id = 0;
 	s32 i = 0;
-	int ret = -1;
+	s32 ret = -1;
 	struct goodix_ts_data *ts = NULL;
-	u8 doze_buf[3] = {0x81, 0x4B};
 
+#if GTP_COMPATIBLE_MODE
+	u8 rqst_buf[3] = { 0x80, 0x43 };	/* for GT9XXF */
+#endif
+
+#if GTP_GESTURE_WAKEUP
+	u8 doze_buf[3] = { 0x81, 0x4B };
+#endif
+
+	GTP_DEBUG_FUNC();
 	ts = container_of(work, struct goodix_ts_data, work);
-#ifdef CONFIG_GT9XX_TOUCHPANEL_UPDATE
 	if (ts->enter_update)
 		return;
-#endif
 
-	if (ts->pdata->slide_wakeup) {
-		if (DOZE_ENABLED == doze_status) {
-			ret = gtp_i2c_read(ts->client, doze_buf, 3);
-			if (ret > 0) {
-				if (doze_buf[2] == 0xAA) {
-					dev_dbg(&ts->client->dev,
-						"Slide(0xAA) To Light up the screen!");
-					doze_status = DOZE_WAKEUP;
-					input_report_key(
-						ts->input_dev, KEY_POWER, 1);
-					input_sync(ts->input_dev);
-					input_report_key(
-						ts->input_dev, KEY_POWER, 0);
-					input_sync(ts->input_dev);
-					/* clear 0x814B */
-					doze_buf[2] = 0x00;
-					gtp_i2c_write(ts->client, doze_buf, 3);
-				} else if (doze_buf[2] == 0xBB) {
-					dev_dbg(&ts->client->dev,
-						"Slide(0xBB) To Light up the screen!");
-					doze_status = DOZE_WAKEUP;
-					input_report_key(ts->input_dev,
-								KEY_POWER, 1);
-					input_sync(ts->input_dev);
-					input_report_key(ts->input_dev,
-								KEY_POWER, 0);
-					input_sync(ts->input_dev);
-					/* clear 0x814B*/
-					doze_buf[2] = 0x00;
-					gtp_i2c_write(ts->client, doze_buf, 3);
-				} else if (0xC0 == (doze_buf[2] & 0xC0)) {
-					dev_dbg(&ts->client->dev,
-						"double click to light up the screen!");
-					doze_status = DOZE_WAKEUP;
-					input_report_key(ts->input_dev,
-								KEY_POWER, 1);
-					input_sync(ts->input_dev);
-					input_report_key(ts->input_dev,
-								KEY_POWER, 0);
-					input_sync(ts->input_dev);
-					/* clear 0x814B */
-					doze_buf[2] = 0x00;
-					gtp_i2c_write(ts->client, doze_buf, 3);
-				} else {
-					gtp_enter_doze(ts);
-				}
+#if GTP_GESTURE_WAKEUP
+	if (DOZE_ENABLED == doze_status) {
+		ret = gtp_i2c_read(i2c_connect_client, doze_buf, 3);
+		GTP_DEBUG("0x814B = 0x%02X", doze_buf[2]);
+		if (ret > 0) {
+			if ((doze_buf[2] == 'a') || (doze_buf[2] == 'b')
+				|| (doze_buf[2] == 'c') || (doze_buf[2] == 'd')
+				|| (doze_buf[2] == 'e') || (doze_buf[2] == 'g')
+				|| (doze_buf[2] == 'h') || (doze_buf[2] == 'm')
+				|| (doze_buf[2] == 'o') || (doze_buf[2] == 'q')
+				|| (doze_buf[2] == 's') || (doze_buf[2] == 'v')
+				|| (doze_buf[2] == 'w') || (doze_buf[2] == 'y')
+				|| (doze_buf[2] == 'z') || (doze_buf[2] == 0x5E)
+			    ) {
+				if (doze_buf[2] != 0x5E)
+					GTP_INFO("Wakeup by gesture(%c), ",
+					     doze_buf[2]);
+				else
+					GTP_INFO("Wakeup by gesture(^), ");
+				GTP_INFO("light up the screen!");
+				doze_status = DOZE_WAKEUP;
+				input_report_key(ts->input_dev, KEY_POWER, 1);
+				input_sync(ts->input_dev);
+				input_report_key(ts->input_dev, KEY_POWER, 0);
+				input_sync(ts->input_dev);
+				/* clear 0x814B */
+				doze_buf[2] = 0x00;
+				gtp_i2c_write(i2c_connect_client, doze_buf, 3);
+			} else if ((doze_buf[2] == 0xAA)
+				   || (doze_buf[2] == 0xBB)
+				   || (doze_buf[2] == 0xAB)
+				   || (doze_buf[2] == 0xBA)) {
+				char *direction[4] = {
+					"Right", "Down", "Up", "Left" };
+				u8 type =
+				    ((doze_buf[2] & 0x0F) - 0x0A) +
+				    (((doze_buf[2] >> 4) & 0x0F) - 0x0A) * 2;
+
+				GTP_INFO("%s slide to light up the screen!",
+					 direction[type]);
+				doze_status = DOZE_WAKEUP;
+				input_report_key(ts->input_dev, KEY_POWER, 1);
+				input_sync(ts->input_dev);
+				input_report_key(ts->input_dev, KEY_POWER, 0);
+				input_sync(ts->input_dev);
+				/* clear 0x814B */
+				doze_buf[2] = 0x00;
+				gtp_i2c_write(i2c_connect_client, doze_buf, 3);
+			} else if (0xCC == doze_buf[2]) {
+				GTP_INFO
+				    ("Double click to light up the screen!");
+				doze_status = DOZE_WAKEUP;
+				input_report_key(ts->input_dev, KEY_POWER, 1);
+				input_sync(ts->input_dev);
+				input_report_key(ts->input_dev, KEY_POWER, 0);
+				input_sync(ts->input_dev);
+				/* clear 0x814B */
+				doze_buf[2] = 0x00;
+				gtp_i2c_write(i2c_connect_client, doze_buf, 3);
+			} else {
+				/* clear 0x814B */
+				doze_buf[2] = 0x00;
+				gtp_i2c_write(i2c_connect_client, doze_buf, 3);
+				gtp_enter_doze(ts);
 			}
-			if (ts->use_irq)
-				gtp_irq_enable(ts);
-
-			return;
 		}
+		if (ts->use_irq)
+			gtp_irq_enable(ts);
+		return;
 	}
+#endif
 
 	ret = gtp_i2c_read(ts->client, point_data, 12);
 	if (ret < 0) {
-		dev_err(&ts->client->dev,
-				"I2C transfer error. errno:%d\n ", ret);
-		goto exit_work_func;
+		GTP_ERROR("I2C transfer error. errno:%d\n ", ret);
+		if (ts->use_irq)
+			gtp_irq_enable(ts);
+		return;
 	}
 
 	finger = point_data[GTP_ADDR_LENGTH];
+
+#if GTP_COMPATIBLE_MODE
+	/* GT9XXF */
+	if ((finger == 0x00) && (CHIP_TYPE_GT9F == ts->chip_type)) {
+		ret = gtp_i2c_read(ts->client, rqst_buf, 3);
+		if (ret < 0) {
+			GTP_ERROR("Read request status error!");
+			goto exit_work_func;
+		}
+
+		switch (rqst_buf[2]) {
+		case GTP_RQST_CONFIG:
+			GTP_INFO("Request for config.");
+			ret = gtp_send_cfg(ts->client);
+			if (ret < 0)
+				GTP_ERROR("Request for config unresponded!");
+			else {
+				rqst_buf[2] = GTP_RQST_RESPONDED;
+				gtp_i2c_write(ts->client, rqst_buf, 3);
+				GTP_INFO("Request for config responded!");
+			}
+			break;
+
+		case GTP_RQST_BAK_REF:
+			GTP_INFO("Request for backup reference.");
+			ts->rqst_processing = 1;
+			ret = gtp_bak_ref_proc(ts, GTP_BAK_REF_SEND);
+			if (SUCCESS == ret) {
+				rqst_buf[2] = GTP_RQST_RESPONDED;
+				gtp_i2c_write(ts->client, rqst_buf, 3);
+				ts->rqst_processing = 0;
+				GTP_INFO
+				    ("Request for backup reference responded!");
+			} else
+				GTP_ERROR
+				    ("Requeet for backup reference unresponed");
+			break;
+
+		case GTP_RQST_RESET:
+			GTP_INFO("Request for reset.");
+			gtp_recovery_reset(ts->client);
+			break;
+
+		case GTP_RQST_MAIN_CLOCK:
+			GTP_INFO("Request for main clock.");
+			ts->rqst_processing = 1;
+			ret = gtp_main_clk_proc(ts);
+			if (FAIL == ret)
+				GTP_ERROR
+				    ("Request for main clock unresponded!");
+			else {
+				GTP_INFO("Request for main clock responded!");
+				rqst_buf[2] = GTP_RQST_RESPONDED;
+				gtp_i2c_write(ts->client, rqst_buf, 3);
+				ts->rqst_processing = 0;
+				ts->clk_chk_fs_times = 0;
+			}
+			break;
+
+		default:
+			GTP_INFO("Undefined request: 0x%02X", rqst_buf[2]);
+			rqst_buf[2] = GTP_RQST_RESPONDED;
+			gtp_i2c_write(ts->client, rqst_buf, 3);
+			break;
+		}
+	}
+#endif
+	if (finger == 0x00) {
+		if (ts->use_irq)
+			gtp_irq_enable(ts);
+		return;
+	}
+
 	if ((finger & 0x80) == 0)
 		goto exit_work_func;
 
@@ -483,150 +744,265 @@ static void goodix_ts_work_func(struct work_struct *work)
 		goto exit_work_func;
 
 	if (touch_num > 1) {
-		u8 buf[8 * GTP_MAX_TOUCH] = { (GTP_READ_COOR_ADDR + 10) >> 8,
-				(GTP_READ_COOR_ADDR + 10) & 0xff };
-
-		ret = gtp_i2c_read(ts->client, buf,
-				2 + 8 * (touch_num - 1));
+		u8 buf[8 * GTP_MAX_TOUCH] = {
+			(GTP_READ_COOR_ADDR + 10) >> 8,
+			(GTP_READ_COOR_ADDR + 10) & 0xff };
+		ret = gtp_i2c_read(ts->client, buf, 2 + 8 * (touch_num - 1));
 		memcpy(&point_data[12], &buf[2], 8 * (touch_num - 1));
 	}
-
-
+#if (GTP_HAVE_TOUCH_KEY || GTP_PEN_HAVE_BUTTON)
 	key_value = point_data[3 + 8 * touch_num];
 
 	if (key_value || pre_key) {
-		for (i = 0; i < ts->pdata->num_button; i++) {
-			input_report_key(ts->input_dev,
-				ts->pdata->button_map[i],
-				key_value & (0x01<<i));
+#if GTP_PEN_HAVE_BUTTON
+		if (key_value == 0x40) {
+			GTP_DEBUG("BTN_STYLUS & BTN_STYLUS2 Down.");
+			input_report_key(ts->pen_dev, BTN_STYLUS, 1);
+			input_report_key(ts->pen_dev, BTN_STYLUS2, 1);
+			pen_active = 1;
+		} else if (key_value == 0x10) {
+			GTP_DEBUG("BTN_STYLUS Down, BTN_STYLUS2 Up.");
+			input_report_key(ts->pen_dev, BTN_STYLUS, 1);
+			input_report_key(ts->pen_dev, BTN_STYLUS2, 0);
+			pen_active = 1;
+		} else if (key_value == 0x20) {
+			GTP_DEBUG("BTN_STYLUS Up, BTN_STYLUS2 Down.");
+			input_report_key(ts->pen_dev, BTN_STYLUS, 0);
+			input_report_key(ts->pen_dev, BTN_STYLUS2, 1);
+			pen_active = 1;
+		} else {
+			GTP_DEBUG("BTN_STYLUS & BTN_STYLUS2 Up.");
+			input_report_key(ts->pen_dev, BTN_STYLUS, 0);
+			input_report_key(ts->pen_dev, BTN_STYLUS2, 0);
+			if ((pre_key == 0x40) || (pre_key == 0x20) ||
+			    (pre_key == 0x10))
+				pen_active = 1;
 		}
-		touch_num = 0;
-		pre_touch = 0;
-	}
-
-	pre_key = key_value;
+		if (pen_active) {
+			touch_num = 0;	/* shield pen point */
+			/*pre_touch = 0; */
+		}
+#endif
 
-	if (ts->pdata->with_pen) {
-		if (pre_pen && (touch_num == 0)) {
-			dev_dbg(&ts->client->dev, "Pen touch UP(Slot)!");
-			input_report_key(ts->input_dev, BTN_TOOL_PEN, 0);
-			input_mt_slot(ts->input_dev, 5);
-			input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, -1);
-			pre_pen = 0;
+#if GTP_HAVE_TOUCH_KEY
+		if (!pre_touch) {
+			for (i = 0; i < GTP_MAX_KEY_NUM; i++) {
+#if GTP_DEBUG_ON
+				for (ret = 0; ret < 4; ++ret) {
+					if (key_codes[ret] ==
+					    touch_key_array[i]) {
+						GTP_DEBUG("Key: %s %s",
+							  key_names[ret],
+							  (key_value &
+							   (0x01 << i)) ? "Down"
+							  : "Up");
+						break;
+					}
+				}
+#endif
+				input_report_key(ts->input_dev,
+						 touch_key_array[i],
+						 key_value & (0x01 << i));
+			}
+			touch_num = 0;	/* shield fingers */
 		}
+#endif
 	}
+#endif
+	pre_key = key_value;
+
+	GTP_DEBUG("pre_touch:%02x, finger:%02x.", pre_touch, finger);
 
+#if GTP_ICS_SLOT_REPORT
+
+#if GTP_WITH_PEN
+	if (pre_pen && (touch_num == 0)) {
+		GTP_DEBUG("Pen touch UP(Slot)!");
+		gtp_pen_up(0);
+		pen_active = 1;
+		pre_pen = 0;
+	}
+#endif
 	if (pre_touch || touch_num) {
 		s32 pos = 0;
 		u16 touch_index = 0;
-
+		u8 report_num = 0;
 		coor_data = &point_data[3];
+
 		if (touch_num) {
 			id = coor_data[pos] & 0x0F;
-			if (ts->pdata->with_pen) {
-				id = coor_data[pos];
-				if (id == 128) {
-					dev_dbg(&ts->client->dev,
-							"Pen touch DOWN(Slot)!");
-					input_x  = coor_data[pos + 1]
-						| (coor_data[pos + 2] << 8);
-					input_y  = coor_data[pos + 3]
-						| (coor_data[pos + 4] << 8);
-					input_w  = coor_data[pos + 5]
-						| (coor_data[pos + 6] << 8);
-
-					input_report_key(ts->input_dev,
-						BTN_TOOL_PEN, 1);
-					input_mt_slot(ts->input_dev, 5);
-					input_report_abs(ts->input_dev,
-						ABS_MT_TRACKING_ID, 5);
-					input_report_abs(ts->input_dev,
-						ABS_MT_POSITION_X, input_x);
-					input_report_abs(ts->input_dev,
-						ABS_MT_POSITION_Y, input_y);
-					input_report_abs(ts->input_dev,
-						ABS_MT_TOUCH_MAJOR, input_w);
-					dev_dbg(&ts->client->dev,
-						"Pen/Stylus: (%d, %d)[%d]",
-						input_x, input_y, input_w);
-					pre_pen = 1;
-					pre_touch = 0;
-				}
+
+#if GTP_WITH_PEN
+			id = coor_data[pos];
+			if ((id & 0x80)) {
+				GTP_DEBUG("Pen touch DOWN(Slot)!");
+				input_x =
+				    coor_data[pos +
+					      1] | (coor_data[pos + 2] << 8);
+				input_y =
+				    coor_data[pos +
+					      3] | (coor_data[pos + 4] << 8);
+				input_w =
+				    coor_data[pos +
+					      5] | (coor_data[pos + 6] << 8);
+
+				gtp_pen_down(input_x, input_y, input_w, 0);
+				pre_pen = 1;
+				pre_touch = 0;
+				pen_active = 1;
 			}
+#endif
 
-			touch_index |= (0x01<<id);
+			touch_index |= (0x01 << id);
 		}
 
+		GTP_DEBUG("id = %d,touch_index = 0x%x, pre_touch = 0x%x\n", id,
+			  touch_index, pre_touch);
 		for (i = 0; i < GTP_MAX_TOUCH; i++) {
-			if (ts->pdata->with_pen)
-				if (pre_pen == 1)
-					break;
-
-			if (touch_index & (0x01<<i)) {
-				input_x = coor_data[pos + 1] |
-						coor_data[pos + 2] << 8;
-				input_y = coor_data[pos + 3] |
-						coor_data[pos + 4] << 8;
-				input_w = coor_data[pos + 5] |
-						coor_data[pos + 6] << 8;
+#if GTP_WITH_PEN
+			if (pre_pen == 1)
+				break;
+#endif
 
-				gtp_touch_down(ts, id,
-						input_x, input_y, input_w);
+			if ((touch_index & (0x01 << i))) {
+				input_x =
+				    coor_data[pos +
+					      1] | (coor_data[pos + 2] << 8);
+				input_y =
+				    coor_data[pos +
+					      3] | (coor_data[pos + 4] << 8);
+				input_w =
+				    coor_data[pos +
+					      5] | (coor_data[pos + 6] << 8);
+
+				gtp_touch_down(ts, id, input_x, input_y,
+					       input_w);
 				pre_touch |= 0x01 << i;
 
-				pos += 8;
-				id = coor_data[pos] & 0x0F;
-				touch_index |= (0x01<<id);
+				report_num++;
+				if (report_num < touch_num) {
+					pos += 8;
+					id = coor_data[pos] & 0x0F;
+					touch_index |= (0x01 << id);
+				}
 			} else {
 				gtp_touch_up(ts, i);
 				pre_touch &= ~(0x01 << i);
 			}
 		}
 	}
-	input_sync(ts->input_dev);
+#else
+
+	if (touch_num) {
+		for (i = 0; i < touch_num; i++) {
+			coor_data = &point_data[i * 8 + 3];
+
+			id = coor_data[0] & 0x0F;
+			input_x = coor_data[1] | (coor_data[2] << 8);
+			input_y = coor_data[3] | (coor_data[4] << 8);
+			input_w = coor_data[5] | (coor_data[6] << 8);
+
+#if GTP_WITH_PEN
+			id = coor_data[0];
+			if (id & 0x80) {
+				GTP_DEBUG("Pen touch DOWN!");
+				gtp_pen_down(input_x, input_y, input_w, 0);
+				pre_pen = 1;
+				pen_active = 1;
+				break;
+			} else
+#endif
+				gtp_touch_down(ts, id, input_x, input_y,
+					       input_w);
+		}
+	} else if (pre_touch) {
+#if GTP_WITH_PEN
+		if (pre_pen == 1) {
+			GTP_DEBUG("Pen touch UP!");
+			gtp_pen_up(0);
+			pre_pen = 0;
+			pen_active = 1;
+		} else
+#endif
+		{
+			GTP_DEBUG("Touch Release!");
+			gtp_touch_up(ts, 0);
+		}
+	}
+
+	pre_touch = touch_num;
+#endif
+
+#if GTP_WITH_PEN
+	if (pen_active) {
+		pen_active = 0;
+		input_sync(ts->pen_dev);
+	} else
+#endif
+		input_sync(ts->input_dev);
 
 exit_work_func:
 	if (!ts->gtp_rawdiff_mode) {
 		ret = gtp_i2c_write(ts->client, end_cmd, 3);
 		if (ret < 0)
-			dev_warn(&ts->client->dev, "I2C write end_cmd error!\n");
-
+			GTP_INFO("I2C write end_cmd error!");
 	}
 	if (ts->use_irq)
 		gtp_irq_enable(ts);
+}
 
-	return;
+/*******************************************************
+Function:
+    Timer interrupt service routine for polling mode.
+Input:
+    timer: timer struct pointer
+Output:
+    Timer work mode.
+    HRTIMER_NORESTART: no restart mode
+*********************************************************/
+static enum hrtimer_restart goodix_ts_timer_handler(struct hrtimer *timer)
+{
+	struct goodix_ts_data *ts =
+	    container_of(timer, struct goodix_ts_data, timer);
+
+	GTP_DEBUG_FUNC();
+
+	queue_work(goodix_wq, &ts->work);
+	hrtimer_start(&ts->timer, ktime_set(0, (GTP_POLL_TIME + 6) * 1000000),
+		      HRTIMER_MODE_REL);
+	return HRTIMER_NORESTART;
 }
 
 /*******************************************************
 Function:
-	External interrupt service routine for interrupt mode.
+    External interrupt service routine for interrupt mode.
 Input:
-	irq:  interrupt number.
-	dev_id: private data pointer
+    irq:  interrupt number.
+    dev_id: private data pointer
 Output:
-	Handle Result.
-	IRQ_HANDLED: interrupt handled successfully
+    Handle Result.
+    IRQ_HANDLED: interrupt handled successfully
 *********************************************************/
 static irqreturn_t goodix_ts_irq_handler(int irq, void *dev_id)
 {
 	struct goodix_ts_data *ts = dev_id;
 
+	GTP_DEBUG_FUNC();
 	gtp_irq_disable(ts);
-
-	queue_work(ts->goodix_wq, &ts->work);
+	queue_work(goodix_wq, &ts->work);
 
 	return IRQ_HANDLED;
 }
+
 /*******************************************************
 Function:
-	Synchronization.
+    Synchronization.
 Input:
-	ms: synchronization time in millisecond.
+    ms: synchronization time in millisecond.
 Output:
-	None.
+    None.
 *******************************************************/
-void gtp_int_sync(struct goodix_ts_data *ts, int ms)
+static void gtp_int_sync(struct goodix_ts_data *ts, s32 ms)
 {
 	gpio_direction_output(ts->pdata->irq_gpio, 0);
 	msleep(ms);
@@ -635,66 +1011,71 @@ void gtp_int_sync(struct goodix_ts_data *ts, int ms)
 
 /*******************************************************
 Function:
-	Reset chip.
+    Reset chip.
 Input:
-	ms: reset time in millisecond, must >10ms
+    ms: reset time in millisecond
 Output:
-	None.
+    None.
 *******************************************************/
-void gtp_reset_guitar(struct goodix_ts_data *ts, int ms)
+void gtp_reset_guitar(struct i2c_client *client, s32 ms)
 {
-	/* This reset sequence will selcet I2C slave address */
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+	GTP_DEBUG_FUNC();
+	GTP_INFO("Guitar reset");
+	/* begin select I2C slave addr */
 	gpio_direction_output(ts->pdata->reset_gpio, 0);
+	/* T2: > 10ms */
 	msleep(ms);
+	/* HIGH: 0x28/0x29, LOW: 0xBA/0xBB */
+	gpio_direction_output(ts->pdata->irq_gpio, client->addr == 0x14);
 
-	if (ts->client->addr == GTP_I2C_ADDRESS_HIGH)
-		gpio_direction_output(ts->pdata->irq_gpio, 1);
-	else
-		gpio_direction_output(ts->pdata->irq_gpio, 0);
-
-	usleep(RESET_DELAY_T3_US);
+	/* T3: > 100us */
+	msleep(20);
 	gpio_direction_output(ts->pdata->reset_gpio, 1);
-	msleep(RESET_DELAY_T4);
 
+	/* T4: > 5ms */
+	msleep(20);
 	gpio_direction_input(ts->pdata->reset_gpio);
+	/* end select I2C slave addr */
 
-	gtp_int_sync(ts, 50);
+#if GTP_COMPATIBLE_MODE
+	if (CHIP_TYPE_GT9F == ts->chip_type)
+		return;
+#endif
 
+	gtp_int_sync(ts, 50);
 #if GTP_ESD_PROTECT
-	gtp_init_ext_watchdog(ts->client);
+	gtp_init_ext_watchdog(client);
 #endif
 }
 
-#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_FB)
+#if GTP_GESTURE_WAKEUP
 /*******************************************************
 Function:
-	Enter doze mode for sliding wakeup.
+    Enter doze mode for sliding wakeup.
 Input:
-	ts: goodix tp private data
+    ts: goodix tp private data
 Output:
-	1: succeed, otherwise failed
+    1: succeed, otherwise failed
 *******************************************************/
 static s8 gtp_enter_doze(struct goodix_ts_data *ts)
 {
-	int ret = -1;
+	s8 ret = -1;
 	s8 retry = 0;
 	u8 i2c_control_buf[3] = {
-		(u8)(GTP_REG_SLEEP >> 8),
-		(u8)GTP_REG_SLEEP, 8};
+		(u8) (GTP_REG_SLEEP >> 8), (u8) GTP_REG_SLEEP, 8 };
 
-	if (ts->pdata->dbl_clk_wakeup)
-		i2c_control_buf[2] = 0x09;
-
-	gtp_irq_disable(ts);
+	GTP_DEBUG_FUNC();
 
-	while (retry++ < GTP_I2C_RETRY_3) {
+	GTP_DEBUG("Entering gesture mode.");
+	while (retry++ < 5) {
 		i2c_control_buf[0] = 0x80;
 		i2c_control_buf[1] = 0x46;
 		ret = gtp_i2c_write(ts->client, i2c_control_buf, 3);
 		if (ret < 0) {
-			dev_err(&ts->client->dev,
-				"failed to set doze flag into 0x8046, %d",
-				retry);
+			GTP_DEBUG("failed to set doze flag into 0x8046, %d",
+				  retry);
 			continue;
 		}
 		i2c_control_buf[0] = 0x80;
@@ -702,584 +1083,1162 @@ static s8 gtp_enter_doze(struct goodix_ts_data *ts)
 		ret = gtp_i2c_write(ts->client, i2c_control_buf, 3);
 		if (ret > 0) {
 			doze_status = DOZE_ENABLED;
-			dev_dbg(&ts->client->dev,
-				"GTP has been working in doze mode!");
-			gtp_irq_enable(ts);
+			GTP_INFO("Gesture mode enabled.");
 			return ret;
 		}
 		msleep(20);
 	}
-	dev_err(&ts->client->dev, "GTP send doze cmd failed.\n");
-	gtp_irq_enable(ts);
+	GTP_ERROR("GTP send gesture cmd failed.");
 	return ret;
 }
-/**
- * gtp_enter_sleep - Enter sleep mode
- * @ts: driver private data
- *
- * Returns zero on success, else an error.
- */
-static u8 gtp_enter_sleep(struct goodix_ts_data *ts)
-{
-	int ret = -1;
-	s8 retry = 0;
-	u8 i2c_control_buf[3] = {
-		(u8)(GTP_REG_SLEEP >> 8),
-		(u8)GTP_REG_SLEEP, 5};
+#else
+/*******************************************************
+Function:
+    Enter sleep mode.
+Input:
+    ts: private data.
+Output:
+    Executive outcomes.
+       1: succeed, otherwise failed.
+*******************************************************/
+static s8 gtp_enter_sleep(struct goodix_ts_data *ts)
+{
+	s8 ret = -1;
+	s8 retry = 0;
+	u8 i2c_control_buf[3] = {
+		(u8) (GTP_REG_SLEEP >> 8), (u8) GTP_REG_SLEEP, 5 };
 
-	ret = gpio_direction_output(ts->pdata->irq_gpio, 0);
-	if (ret)
-		dev_err(&ts->client->dev,
-			"GTP sleep: Cannot reconfig gpio %d.\n",
-			ts->pdata->irq_gpio);
-	if (ts->pdata->enable_power_off) {
-		ret = gpio_direction_output(ts->pdata->reset_gpio, 0);
-		if (ret)
-			dev_err(&ts->client->dev,
-				"GTP sleep: Cannot reconfig gpio %d.\n",
-				ts->pdata->reset_gpio);
-		ret = goodix_power_off(ts);
-		if (ret) {
-			dev_err(&ts->client->dev, "GTP power off failed.\n");
-			return ret;
+#if GTP_COMPATIBLE_MODE
+	u8 status_buf[3] = { 0x80, 0x44 };
+#endif
+
+	GTP_DEBUG_FUNC();
+
+#if GTP_COMPATIBLE_MODE
+	if (CHIP_TYPE_GT9F == ts->chip_type) {
+		/* GT9XXF: host interact with ic */
+		ret = gtp_i2c_read(ts->client, status_buf, 3);
+		if (ret < 0)
+			GTP_ERROR("failed to get backup-reference status");
+
+		if (status_buf[2] & 0x80) {
+			ret = gtp_bak_ref_proc(ts, GTP_BAK_REF_STORE);
+			if (FAIL == ret)
+				GTP_ERROR("failed to store bak_ref");
 		}
-		return 0;
-	} else {
-		usleep(5000);
-		while (retry++ < GTP_I2C_RETRY_5) {
-			ret = gtp_i2c_write(ts->client, i2c_control_buf, 3);
-			if (ret == 1) {
-				dev_dbg(&ts->client->dev, "GTP enter sleep!");
-				return 0;
-			}
-			msleep(20);
+	}
+#endif
+
+	gpio_direction_output(ts->pdata->irq_gpio, 0);
+	msleep(20);
+
+	while (retry++ < 5) {
+		ret = gtp_i2c_write(ts->client, i2c_control_buf, 3);
+		if (ret > 0) {
+			GTP_INFO("GTP enter sleep!");
+			return ret;
 		}
-		dev_err(&ts->client->dev, "GTP send sleep cmd failed.\n");
-		return ret;
+		msleep(20);
 	}
+	GTP_ERROR("GTP send sleep cmd failed.");
+	return ret;
 }
+#endif
 
 /*******************************************************
 Function:
-	Wakeup from sleep.
+    Wakeup from sleep.
 Input:
-	ts: private data.
+    ts: private data.
 Output:
-	Executive outcomes.
-	>0: succeed, otherwise: failed.
+    Executive outcomes.
+    0: succeed, otherwise: failed.
 *******************************************************/
 static s8 gtp_wakeup_sleep(struct goodix_ts_data *ts)
 {
 	u8 retry = 0;
 	s8 ret = -1;
 
-	if (ts->pdata->enable_power_off) {
-		ret = gpio_direction_output(ts->pdata->irq_gpio, 0);
-		if (ret)
-			dev_err(&ts->client->dev,
-				"GTP wakeup: Cannot reconfig gpio %d.\n",
-				ts->pdata->irq_gpio);
-		ret = gpio_direction_output(ts->pdata->reset_gpio, 0);
-		if (ret)
-			dev_err(&ts->client->dev,
-				"GTP wakeup: Cannot reconfig gpio %d.\n",
-				ts->pdata->reset_gpio);
-		ret = goodix_power_on(ts);
-		if (ret) {
-			dev_err(&ts->client->dev, "GTP power on failed.\n");
-			return 0;
-		}
+	GTP_DEBUG_FUNC();
 
-		gtp_reset_guitar(ts, 20);
+#if GTP_COMPATIBLE_MODE
+	if (CHIP_TYPE_GT9F == ts->chip_type) {
+		u8 opr_buf[3] = { 0x41, 0x80 };
 
-		ret = gtp_send_cfg(ts);
-		if (ret <= 0) {
-			dev_err(&ts->client->dev,
-				"GTP wakeup sleep failed.\n");
-			return ret;
-		}
+		gpio_direction_output(ts->pdata->irq_gpio, 1);
+		msleep(20);
 
-		dev_dbg(&ts->client->dev,
-				"Wakeup sleep send config success.");
-	} else {
-err_retry:
-		if (ts->pdata->slide_wakeup) { /* wakeup not by slide */
-			if (DOZE_WAKEUP != doze_status)
-				gtp_reset_guitar(ts, 10);
-			else
-				/* wakeup by slide */
-				doze_status = DOZE_DISABLED;
-		} else {
-			if (chip_gt9xxs == 1) {
-				gtp_reset_guitar(ts, 10);
-			} else {
-				ret = gpio_direction_output(
-						ts->pdata->irq_gpio, 1);
-				usleep(5000);
+		for (retry = 0; retry < 10; ++retry) {
+			/* hold ss51 & dsp */
+			opr_buf[2] = 0x0C;
+			ret = gtp_i2c_write(ts->client, opr_buf, 3);
+			if (FAIL == ret) {
+				GTP_ERROR("failed to hold ss51 & dsp!");
+				continue;
 			}
+			opr_buf[2] = 0x00;
+			ret = gtp_i2c_read(ts->client, opr_buf, 3);
+			if (FAIL == ret) {
+				GTP_ERROR("failed to get ss51 & dsp status!");
+				continue;
+			}
+			if (0x0C != opr_buf[2]) {
+				GTP_DEBUG("ss51 & dsp not been hold, %d",
+					  retry + 1);
+				continue;
+			}
+			GTP_DEBUG("ss51 & dsp confirmed hold");
+
+			ret = gtp_fw_startup(ts->client);
+			if (FAIL == ret) {
+				GTP_ERROR
+				    ("startup GT9XXF failed, process recovery");
+				gtp_esd_recovery(ts->client);
+			}
+			break;
 		}
+		if (retry >= 10) {
+			GTP_ERROR("failed to wakeup, processing esd recovery");
+			gtp_esd_recovery(ts->client);
+		} else
+			GTP_INFO("GT9XXF gtp wakeup success");
+		return ret;
+	}
+#endif
+
+#if GTP_POWER_CTRL_SLEEP
+	while (retry++ < 5) {
+		gtp_reset_guitar(ts->client, ts->pdata->soft_rst_dly);
+		GTP_INFO("GTP wakeup sleep.");
+		return 1;
+	}
+#else
+	while (retry++ < 10) {
+#if GTP_GESTURE_WAKEUP
+		if (DOZE_WAKEUP != doze_status)
+			GTP_INFO("Powerkey wakeup.");
+		else
+			GTP_INFO("Gesture wakeup.");
+		doze_status = DOZE_DISABLED;
+		gtp_irq_disable(ts);
+		gtp_reset_guitar(ts->client, 10);
+		gtp_irq_enable(ts);
+
+#else
+		gpio_direction_output(ts->pdata->irq_gpio, 1);
+		msleep(20);
+#endif
+
 		ret = gtp_i2c_test(ts->client);
-		if (ret == 2) {
-			dev_dbg(&ts->client->dev, "GTP wakeup sleep.");
-			if (!ts->pdata->slide_wakeup) {
-				if (chip_gt9xxs == 0) {
-					gtp_int_sync(ts, 25);
-					msleep(20);
+		if (ret > 0) {
+			GTP_INFO("GTP wakeup sleep.");
+
+#if (!GTP_GESTURE_WAKEUP)
+			gtp_int_sync(ts, 25);
 #if GTP_ESD_PROTECT
-					gtp_init_ext_watchdog(ts->client);
+			gtp_init_ext_watchdog(ts->client);
+#endif
 #endif
-				}
-			}
 			return ret;
 		}
-		gtp_reset_guitar(ts, 20);
-		if (retry++ < GTP_I2C_RETRY_10)
-			goto err_retry;
-		dev_err(&ts->client->dev, "GTP wakeup sleep failed.\n");
+		gtp_reset_guitar(ts->client, ts->pdata->soft_rst_dly);
 	}
+#endif
+
+	GTP_ERROR("GTP wakeup sleep failed.");
 	return ret;
 }
-#endif /* !CONFIG_HAS_EARLYSUSPEND && !CONFIG_FB*/
+
+#if GTP_DRIVER_SEND_CFG
+static s32 gtp_get_info(struct goodix_ts_data *ts)
+{
+	u8 opr_buf[6] = { 0 };
+	s32 ret = 0;
+
+	ts->abs_x_max = GTP_MAX_WIDTH;
+	ts->abs_y_max = GTP_MAX_HEIGHT;
+	ts->int_trigger_type = GTP_INT_TRIGGER;
+
+	opr_buf[0] = (u8) ((GTP_REG_CONFIG_DATA + 1) >> 8);
+	opr_buf[1] = (u8) ((GTP_REG_CONFIG_DATA + 1) & 0xFF);
+
+	ret = gtp_i2c_read(ts->client, opr_buf, 6);
+	if (ret < 0)
+		return FAIL;
+
+	ts->abs_x_max = (opr_buf[3] << 8) + opr_buf[2];
+	ts->abs_y_max = (opr_buf[5] << 8) + opr_buf[4];
+
+	opr_buf[0] = (u8) ((GTP_REG_CONFIG_DATA + 6) >> 8);
+	opr_buf[1] = (u8) ((GTP_REG_CONFIG_DATA + 6) & 0xFF);
+
+	ret = gtp_i2c_read(ts->client, opr_buf, 3);
+	if (ret < 0)
+		return FAIL;
+
+	ts->int_trigger_type = opr_buf[2] & 0x03;
+	GTP_INFO("X_MAX = %d, Y_MAX = %d, TRIGGER = 0x%02x",
+		 ts->abs_x_max, ts->abs_y_max, ts->int_trigger_type);
+
+	return SUCCESS;
+}
+#endif
 
 /*******************************************************
 Function:
-	Initialize gtp.
+    Initialize gtp.
 Input:
-	ts: goodix private data
+    ts: goodix private data
 Output:
-	Executive outcomes.
-	> =0: succeed, otherwise: failed
+    Executive outcomes.
+    0: succeed, otherwise: failed
 *******************************************************/
-static int gtp_init_panel(struct goodix_ts_data *ts)
+static s32 gtp_init_panel(struct goodix_ts_data *ts)
 {
-	struct i2c_client *client = ts->client;
-	unsigned char *config_data = NULL;
-	int ret = -EIO;
-	int i;
+	s32 ret = -1;
+
+#if GTP_DRIVER_SEND_CFG
+	s32 i = 0;
 	u8 check_sum = 0;
-	u8 opr_buf[16];
+	u8 opr_buf[16] = { 0 };
 	u8 sensor_id = 0;
 
-	if (ts->pdata->driver_send_cfg) {
-		for (i = 0; i < GOODIX_MAX_CFG_GROUP; i++)
-			dev_dbg(&client->dev, "Config Groups(%d) Lengths: %d",
-				i, ts->pdata->config_data_len[i]);
+	u8 cfg_info_group1[] = CTP_CFG_GROUP1;
+	u8 cfg_info_group2[] = CTP_CFG_GROUP2;
+	u8 cfg_info_group3[] = CTP_CFG_GROUP3;
+	u8 cfg_info_group4[] = CTP_CFG_GROUP4;
+	u8 cfg_info_group5[] = CTP_CFG_GROUP5;
+	u8 cfg_info_group6[] = CTP_CFG_GROUP6;
+	u8 *send_cfg_buf[] = {
+		cfg_info_group1, cfg_info_group2, cfg_info_group3,
+		cfg_info_group4, cfg_info_group5, cfg_info_group6
+	};
+	u8 cfg_info_len[] = { CFG_GROUP_LEN(cfg_info_group1),
+		CFG_GROUP_LEN(cfg_info_group2),
+		CFG_GROUP_LEN(cfg_info_group3),
+		CFG_GROUP_LEN(cfg_info_group4),
+		CFG_GROUP_LEN(cfg_info_group5),
+		CFG_GROUP_LEN(cfg_info_group6)
+	};
+
+	GTP_DEBUG_FUNC();
+	GTP_DEBUG("Config Groups\' Lengths: %d, %d, %d, %d, %d, %d",
+		  cfg_info_len[0], cfg_info_len[1], cfg_info_len[2],
+		  cfg_info_len[3], cfg_info_len[4], cfg_info_len[5]);
 
+#if GTP_COMPATIBLE_MODE
+	if (CHIP_TYPE_GT9F == ts->chip_type)
+		ts->fw_error = 0;
+	else
+#endif
+	{
 		ret = gtp_i2c_read_dbl_check(ts->client, 0x41E4, opr_buf, 1);
 		if (SUCCESS == ret) {
 			if (opr_buf[0] != 0xBE) {
 				ts->fw_error = 1;
-				dev_err(&client->dev,
-					"Firmware error, no config sent!");
+				GTP_ERROR("Firmware error, no config sent!");
 				return -EINVAL;
 			}
 		}
+	}
 
-		for (i = 1; i < GOODIX_MAX_CFG_GROUP; i++) {
-			if (ts->pdata->config_data_len[i])
-				break;
-		}
-
-		if (i == GOODIX_MAX_CFG_GROUP) {
-			sensor_id = 0;
-		} else {
-			ret = gtp_i2c_read_dbl_check(ts->client,
+	if ((!cfg_info_len[1]) && (!cfg_info_len[2]) &&
+	    (!cfg_info_len[3]) && (!cfg_info_len[4]) && (!cfg_info_len[5]))
+		sensor_id = 0;
+	else {
+#if GTP_COMPATIBLE_MODE
+		msleep(50);
+#endif
+		ret = gtp_i2c_read_dbl_check(ts->client,
 					GTP_REG_SENSOR_ID, &sensor_id, 1);
-			if (SUCCESS == ret) {
-				if (sensor_id >= GOODIX_MAX_CFG_GROUP) {
-					dev_err(&client->dev,
-						"Invalid sensor_id(0x%02X), No Config Sent!",
-						sensor_id);
-					return -EINVAL;
-				}
-			} else {
-				dev_err(&client->dev,
-					"Failed to get sensor_id, No config sent!");
+		if (SUCCESS == ret) {
+			if (sensor_id >= 0x06) {
+				GTP_ERROR
+				    ("Invalid id(0x%02X), No Config Sent!",
+				     sensor_id);
+				ts->pnl_init_error = 1;
 				return -EINVAL;
 			}
-		}
-
-		dev_info(&client->dev, "Sensor ID selected: %d", sensor_id);
-
-		if (ts->pdata->config_data_len[sensor_id] <
-			GTP_CONFIG_MIN_LENGTH ||
-			!ts->pdata->config_data[sensor_id]) {
-			dev_err(&client->dev,
-					"Sensor_ID(%d) matches with NULL or invalid config group!\n",
-					sensor_id);
+		} else {
+			GTP_ERROR("Failed to get sensor_id, No config sent!");
+			ts->pnl_init_error = 1;
 			return -EINVAL;
 		}
+		GTP_INFO("Sensor_ID: %d", sensor_id);
+	}
+	ts->gtp_cfg_len = cfg_info_len[sensor_id];
+	GTP_INFO("CTP_CONFIG_GROUP%d used, config length: %d", sensor_id + 1,
+		 ts->gtp_cfg_len);
 
-		ret = gtp_i2c_read_dbl_check(ts->client, GTP_REG_CONFIG_DATA,
-			&opr_buf[0], 1);
+	if (ts->gtp_cfg_len < GTP_CONFIG_MIN_LENGTH) {
+		GTP_ERROR
+		    ("Config Group%d is INVALID CONFIG GROUP(Len: %d)!",
+		     sensor_id + 1, ts->gtp_cfg_len);
+		ts->pnl_init_error = 1;
+		return -EINVAL;
+	}
+#if GTP_COMPATIBLE_MODE
+	if (CHIP_TYPE_GT9F == ts->chip_type)
+		ts->fixed_cfg = 0;
+	else
+#endif
+	{
+		ret =
+		    gtp_i2c_read_dbl_check(ts->client, GTP_REG_CONFIG_DATA,
+					   &opr_buf[0], 1);
 		if (ret == SUCCESS) {
+			GTP_DEBUG
+			    ("CFG_GROUP%d Config Version: %d, 0x%02X",
+			     sensor_id + 1, send_cfg_buf[sensor_id][0],
+			     send_cfg_buf[sensor_id][0]);
+			GTP_DEBUG
+			    ("IC Config Version: %d, 0x%02X",
+			     opr_buf[0], opr_buf[0]);
+
 			if (opr_buf[0] < 90) {
 				/* backup group config version */
-				grp_cfg_version =
-				ts->pdata->
-					config_data[sensor_id][GTP_ADDR_LENGTH];
-				ts->pdata->
-					config_data[sensor_id][GTP_ADDR_LENGTH]
-						= 0x00;
+				grp_cfg_version = send_cfg_buf[sensor_id][0];
+				send_cfg_buf[sensor_id][0] = 0x00;
 				ts->fixed_cfg = 0;
 			} else {
 				/* treated as fixed config, not send config */
-				dev_warn(&client->dev,
-					"Ic fixed config with config version(%d, 0x%02X)",
-					opr_buf[0], opr_buf[0]);
+				GTP_INFO
+				    ("Ic with config version (%d, 0x%02X)",
+				     opr_buf[0], opr_buf[0]);
 				ts->fixed_cfg = 1;
+				gtp_get_info(ts);
+				return 0;
 			}
 		} else {
-			dev_err(&client->dev,
-				"Failed to get ic config version!No config sent!");
+			GTP_ERROR
+			    ("Failed to get ic config version!No config sent!");
 			return -EINVAL;
 		}
+	}
 
-		config_data = ts->pdata->config_data[sensor_id];
-		ts->config_data = ts->pdata->config_data[sensor_id];
-		ts->gtp_cfg_len = ts->pdata->config_data_len[sensor_id];
+	memset(&config[GTP_ADDR_LENGTH], 0, GTP_CONFIG_MAX_LENGTH);
+	memcpy(&config[GTP_ADDR_LENGTH], send_cfg_buf[sensor_id],
+	       ts->gtp_cfg_len);
 
 #if GTP_CUSTOM_CFG
-		config_data[RESOLUTION_LOC] =
-		(unsigned char)(GTP_MAX_WIDTH && 0xFF);
-		config_data[RESOLUTION_LOC + 1] =
-		(unsigned char)(GTP_MAX_WIDTH >> 8);
-		config_data[RESOLUTION_LOC + 2] =
-		(unsigned char)(GTP_MAX_HEIGHT && 0xFF);
-		config_data[RESOLUTION_LOC + 3] =
-		(unsigned char)(GTP_MAX_HEIGHT >> 8);
-
-		if (GTP_INT_TRIGGER == 0)
-			config_data[TRIGGER_LOC] &= 0xfe;
-		else if (GTP_INT_TRIGGER == 1)
-			config_data[TRIGGER_LOC] |= 0x01;
-#endif  /* !GTP_CUSTOM_CFG */
+	config[RESOLUTION_LOC] = (u8) GTP_MAX_WIDTH;
+	config[RESOLUTION_LOC + 1] = (u8) (GTP_MAX_WIDTH >> 8);
+	config[RESOLUTION_LOC + 2] = (u8) GTP_MAX_HEIGHT;
+	config[RESOLUTION_LOC + 3] = (u8) (GTP_MAX_HEIGHT >> 8);
+
+	if (GTP_INT_TRIGGER == 0)	/* RISING */
+		config[TRIGGER_LOC] &= 0xfe;
+	else if (GTP_INT_TRIGGER == 1)	/* FALLING */
+		config[TRIGGER_LOC] |= 0x01;
+#endif /* GTP_CUSTOM_CFG */
+
+	check_sum = 0;
+	for (i = GTP_ADDR_LENGTH; i < ts->gtp_cfg_len; i++)
+		check_sum += config[i];
+	config[ts->gtp_cfg_len] = (~check_sum) + 1;
+
+#else /* driver not send config */
+
+	ts->gtp_cfg_len = GTP_CONFIG_MAX_LENGTH;
+	ret = gtp_i2c_read(ts->client, config,
+			ts->gtp_cfg_len + GTP_ADDR_LENGTH);
+	if (ret < 0) {
+		GTP_ERROR
+		    ("Read Config Fail, Use Default Resolution & INT Trigger!");
+		ts->abs_x_max = GTP_MAX_WIDTH;
+		ts->abs_y_max = GTP_MAX_HEIGHT;
+		ts->int_trigger_type = GTP_INT_TRIGGER;
+	}
+#endif /* GTP_DRIVER_SEND_CFG */
 
+	if ((ts->abs_x_max == 0) && (ts->abs_y_max == 0)) {
+		ts->abs_x_max =
+		    (config[RESOLUTION_LOC + 1] << 8) + config[RESOLUTION_LOC];
+		ts->abs_y_max =
+		    (config[RESOLUTION_LOC + 3] << 8) + config[RESOLUTION_LOC +
+							       2];
+		ts->int_trigger_type = (config[TRIGGER_LOC]) & 0x03;
+	}
+#if GTP_COMPATIBLE_MODE
+	if (CHIP_TYPE_GT9F == ts->chip_type) {
+		u8 sensor_num = 0;
+		u8 driver_num = 0;
+		u8 have_key = 0;
+
+		have_key =
+		    (config[GTP_REG_HAVE_KEY - GTP_REG_CONFIG_DATA + 2] & 0x01);
+
+		if (1 == ts->is_950) {
+			driver_num =
+			    config[GTP_REG_MATRIX_DRVNUM - GTP_REG_CONFIG_DATA +
+				   2];
+			sensor_num =
+			    config[GTP_REG_MATRIX_SENNUM - GTP_REG_CONFIG_DATA +
+				   2];
+			if (have_key)
+				driver_num--;
+			ts->bak_ref_len =
+			    (driver_num * (sensor_num - 1) + 2) * 2 * 6;
+		} else {
+			driver_num =
+			    (config[CFG_LOC_DRVA_NUM] & 0x1F) +
+			    (config[CFG_LOC_DRVB_NUM] & 0x1F);
+			if (have_key)
+				driver_num--;
+			sensor_num =
+			    (config[CFG_LOC_SENS_NUM] & 0x0F) +
+			    ((config[CFG_LOC_SENS_NUM] >> 4) & 0x0F);
+			ts->bak_ref_len =
+			    (driver_num * (sensor_num - 2) + 2) * 2;
+		}
+
+		GTP_INFO
+		    ("%d * %d(key: %d), X_MAX: %d, Y_MAX: %d, TRIGGER: 0x%02x",
+		     driver_num, sensor_num, have_key, ts->abs_x_max,
+		     ts->abs_y_max, ts->int_trigger_type);
+		return 0;
+	} else
+#endif
+	{
+#if GTP_DRIVER_SEND_CFG
+		ret = gtp_send_cfg(ts->client);
+		if (ret < 0)
+			GTP_ERROR("Send config error.");
+		/* set config version to CTP_CFG_GROUP
+		  * for resume to send config
+		  */
+		config[GTP_ADDR_LENGTH] = grp_cfg_version;
 		check_sum = 0;
 		for (i = GTP_ADDR_LENGTH; i < ts->gtp_cfg_len; i++)
-			check_sum += config_data[i];
+			check_sum += config[i];
+		config[ts->gtp_cfg_len] = (~check_sum) + 1;
+#endif
+		GTP_INFO("X_MAX: %d, Y_MAX: %d, TRIGGER: 0x%02x", ts->abs_x_max,
+			 ts->abs_y_max, ts->int_trigger_type);
+	}
 
-		config_data[ts->gtp_cfg_len] = (~check_sum) + 1;
+	msleep(20);
+	return 0;
+}
 
-	} else { /* DRIVER NOT SEND CONFIG */
-		ts->gtp_cfg_len = GTP_CONFIG_MAX_LENGTH;
-		ret = gtp_i2c_read(ts->client, config_data,
-			ts->gtp_cfg_len + GTP_ADDR_LENGTH);
-		if (ret < 0) {
-			dev_err(&client->dev,
-				"Read Config Failed, Using DEFAULT Resolution & INT Trigger!\n");
-			ts->abs_x_max = GTP_MAX_WIDTH;
-			ts->abs_y_max = GTP_MAX_HEIGHT;
-			ts->int_trigger_type = GTP_INT_TRIGGER;
-		}
-	} /* !DRIVER NOT SEND CONFIG */
+static ssize_t gt91xx_config_read_proc(struct file *file, char __user *page,
+				       size_t size, loff_t *ppos)
+{
+	char *ptr = page;
+	char temp_data[GTP_CONFIG_MAX_LENGTH + 2] = { 0x80, 0x47 };
+	int i;
 
-	if ((ts->abs_x_max == 0) && (ts->abs_y_max == 0)) {
-		ts->abs_x_max = (config_data[RESOLUTION_LOC + 1] << 8)
-				+ config_data[RESOLUTION_LOC];
-		ts->abs_y_max = (config_data[RESOLUTION_LOC + 3] << 8)
-				+ config_data[RESOLUTION_LOC + 2];
-		ts->int_trigger_type = (config_data[TRIGGER_LOC]) & 0x03;
+	if (*ppos)
+		return 0;
+
+	ptr += snprintf(ptr, 36, "==== GT9XX config init value====\n");
+	for (i = 0; i < GTP_CONFIG_MAX_LENGTH; i++) {
+		ptr += snprintf(ptr, 4, "0x%02X ", config[i + 2]);
+		if (i % 8 == 7)
+			ptr += snprintf(ptr, 4, "\n");
+	}
+
+	ptr += snprintf(ptr, 4, "\n");
+	ptr += snprintf(ptr, 36, "==== GT9XX config real value====\n");
+	gtp_i2c_read(i2c_connect_client, temp_data, GTP_CONFIG_MAX_LENGTH + 2);
+	for (i = 0; i < GTP_CONFIG_MAX_LENGTH; i++) {
+		ptr += snprintf(ptr, 4, "0x%02X ", temp_data[i + 2]);
+		if (i % 8 == 7)
+			ptr += snprintf(ptr, 4, "\n");
 	}
-	ret = gtp_send_cfg(ts);
+	*ppos += ptr - page;
+	return (ssize_t)(ptr - page);
+}
+
+static ssize_t gt91xx_config_write_proc(struct file *filp,
+					const char __user *buffer,
+					size_t count, loff_t *off)
+{
+	s32 ret = 0;
+
+	GTP_DEBUG("write count %d\n", count);
+
+	if (count > GTP_CONFIG_MAX_LENGTH) {
+		GTP_ERROR("size not match [%d:%d]\n", GTP_CONFIG_MAX_LENGTH,
+			  count);
+		return -EFAULT;
+	}
+
+	if (copy_from_user(&config[2], buffer, count)) {
+		GTP_ERROR("copy from user fail\n");
+		return -EFAULT;
+	}
+
+	ret = gtp_send_cfg(i2c_connect_client);
 	if (ret < 0)
-		dev_err(&client->dev, "%s: Send config error.\n", __func__);
+		GTP_ERROR("send config failed.");
 
-	msleep(20);
-	return ret;
+	return count;
 }
 
 /*******************************************************
 Function:
-	Read firmware version
+    Read chip version.
 Input:
-	client:  i2c device
-	version: buffer to keep ic firmware version
+    client:  i2c device
+    version: buffer to keep ic firmware version
 Output:
-	read operation return.
-	0: succeed, otherwise: failed
+    read operation return.
+    2: succeed, otherwise: failed
 *******************************************************/
-static int gtp_read_fw_version(struct i2c_client *client, u16 *version)
+s32 gtp_read_version(struct i2c_client *client, u16 *version)
 {
-	int ret = 0;
-	u8 buf[GTP_FW_VERSION_BUFFER_MAXSIZE] = {
-		GTP_REG_FW_VERSION >> 8, GTP_REG_FW_VERSION & 0xff };
+	s32 ret = -1;
+	u8 buf[8] = { GTP_REG_VERSION >> 8, GTP_REG_VERSION & 0xff };
+
+	GTP_DEBUG_FUNC();
 
 	ret = gtp_i2c_read(client, buf, sizeof(buf));
 	if (ret < 0) {
-		dev_err(&client->dev, "GTP read version failed.\n");
-		return -EIO;
+		GTP_ERROR("GTP read version failed");
+		return ret;
 	}
 
 	if (version)
-		*version = (buf[3] << 8) | buf[2];
+		*version = (buf[7] << 8) | buf[6];
+
+	if (buf[5] == 0x00)
+		GTP_INFO("IC Version: %c%c%c_%02x%02x", buf[2], buf[3], buf[4],
+			 buf[7], buf[6]);
+	else
+		GTP_INFO("IC Version: %c%c%c%c_%02x%02x", buf[2], buf[3],
+			 buf[4], buf[5], buf[7], buf[6]);
 
 	return ret;
 }
+
 /*******************************************************
 Function:
-	Read and check chip id.
+    I2c test Function.
 Input:
-	client:  i2c device
+    client:i2c client.
 Output:
-	read operation return.
-	0: succeed, otherwise: failed
+    Executive outcomes.
+    2: succeed, otherwise failed.
 *******************************************************/
-static int gtp_check_product_id(struct i2c_client *client)
+static s8 gtp_i2c_test(struct i2c_client *client)
 {
-	int ret = 0;
-	char product_id[GTP_PRODUCT_ID_MAXSIZE];
-	struct goodix_ts_data *ts = i2c_get_clientdata(client);
-	/* 04 bytes are used for the Product-id in the register space.*/
-	u8 buf[GTP_PRODUCT_ID_BUFFER_MAXSIZE] =	{
-		GTP_REG_PRODUCT_ID >> 8, GTP_REG_PRODUCT_ID & 0xff };
+	u8 test[3] = { GTP_REG_CONFIG_DATA >> 8, GTP_REG_CONFIG_DATA & 0xff };
+	u8 retry = 0;
+	s8 ret = -1;
 
-	ret = gtp_i2c_read(client, buf, sizeof(buf));
-	if (ret < 0) {
-		dev_err(&client->dev, "GTP read product_id failed.\n");
-		return -EIO;
+	GTP_DEBUG_FUNC();
+
+	while (retry++ < 5) {
+		ret = gtp_i2c_read(client, test, 3);
+		if (ret > 0)
+			return ret;
+		GTP_ERROR("GTP i2c test failed time %d.", retry);
+		msleep(20);
 	}
+	return ret;
+}
+
+/*******************************************************
+Function:
+    Request gpio(INT & RST) ports.
+Input:
+    ts: private data.
+Output:
+    Executive outcomes.
+    >= 0: succeed, < 0: failed
+*******************************************************/
+static s8 gtp_request_io_port(struct goodix_ts_data *ts)
+{
+	s32 ret = 0;
+
+	GTP_DEBUG_FUNC();
 
-	if (buf[5] == 0x00) {
-		/* copy (GTP_PRODUCT_ID_MAXSIZE - 1) from buffer. Ex: 915 */
-		strlcpy(product_id, &buf[2], GTP_PRODUCT_ID_MAXSIZE - 1);
+#ifndef FEATURE_QRD8X26_UNISCOPE_MODIFY
+	ret = gpio_request(ts->pdata->irq_gpio, "GTP_INT_IRQ");
+	if (ret < 0) {
+		GTP_ERROR("Failed to request GPIO:%d, ERRNO:%d",
+			  (s32) ts->pdata->irq_gpio, ret);
+		ret = -ENODEV;
 	} else {
-		if (buf[5] == 'S' || buf[5] == 's')
-			chip_gt9xxs = 1;
-		/* copy GTP_PRODUCT_ID_MAXSIZE from buffer. Ex: 915s */
-		strlcpy(product_id, &buf[2], GTP_PRODUCT_ID_MAXSIZE);
+		ret = gpio_direction_input(ts->pdata->irq_gpio);
+		if (ret < 0)
+			gpio_free(ts->pdata->irq_gpio);
+		ts->client->irq = gpio_to_irq(ts->pdata->irq_gpio);
 	}
 
-	dev_info(&client->dev, "Goodix Product ID = %s\n", product_id);
+	ret = gpio_request(ts->pdata->reset_gpio, "GTP_RST_PORT");
+	if (ret < 0) {
+		GTP_ERROR("Failed to request GPIO:%d, ERRNO:%d",
+			  (s32) ts->pdata->reset_gpio, ret);
+		ret = -ENODEV;
+	}
+#endif
+	ret = gpio_direction_input(ts->pdata->reset_gpio);
+	if (ret < 0)
+		gpio_free(ts->pdata->reset_gpio);
 
-	ret = strcmp(product_id, ts->pdata->product_id);
-	if (ret != 0)
-		return -EINVAL;
+	gtp_reset_guitar(ts->client, 20);
 
 	return ret;
 }
 
 /*******************************************************
 Function:
-	I2c test Function.
+    Request interrupt.
 Input:
-	client:i2c client.
+    ts: private data.
 Output:
-	Executive outcomes.
-	2: succeed, otherwise failed.
+    Executive outcomes.
+    0: succeed, -1: failed.
 *******************************************************/
-static int gtp_i2c_test(struct i2c_client *client)
+static s8 gtp_request_irq(struct goodix_ts_data *ts)
 {
-	u8 buf[3] = { GTP_REG_CONFIG_DATA >> 8, GTP_REG_CONFIG_DATA & 0xff };
-	int retry = GTP_I2C_RETRY_5;
-	int ret = -EIO;
+	s32 ret = -1;
+	const u8 irq_table[] = GTP_IRQ_TAB;
 
-	while (retry--) {
-		ret = gtp_i2c_read(client, buf, 3);
-		if (ret > 0)
-			return ret;
-		dev_err(&client->dev, "GTP i2c test failed time %d.\n", retry);
-		msleep(20);
+	GTP_DEBUG_FUNC();
+	GTP_DEBUG("INT trigger type:%x", ts->int_trigger_type);
+	GTP_DEBUG("ts->client->irq:%d", ts->client->irq);
+
+	ret = request_irq(ts->client->irq, goodix_ts_irq_handler,
+			  irq_table[ts->int_trigger_type],
+			  ts->client->name, ts);
+	if (ret) {
+		GTP_ERROR("Request IRQ failed!ERRNO:%d.", ret);
+		gpio_direction_input(ts->pdata->irq_gpio);
+		gpio_free(ts->pdata->irq_gpio);
+
+		hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		ts->timer.function = goodix_ts_timer_handler;
+		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+		return ret;
+	} else {
+		gtp_irq_disable(ts);
+		ts->use_irq = 1;
+		return 0;
 	}
-	return ret;
 }
 
 /*******************************************************
 Function:
-	Request gpio(INT & RST) ports.
+    Request input device Function.
 Input:
-	ts: private data.
+    ts:private data.
 Output:
-	Executive outcomes.
-	= 0: succeed, != 0: failed
+    Executive outcomes.
+    0: succeed, otherwise: failed.
 *******************************************************/
-static int gtp_request_io_port(struct goodix_ts_data *ts)
+static s8 gtp_request_input_dev(struct goodix_ts_data *ts)
 {
-	struct i2c_client *client = ts->client;
-	struct goodix_ts_platform_data *pdata = ts->pdata;
-	int ret;
+	s8 ret = -1;
+	s8 phys[32];
+#if GTP_HAVE_TOUCH_KEY
+	u8 index = 0;
+#endif
 
-	if (gpio_is_valid(pdata->irq_gpio)) {
-		ret = gpio_request(pdata->irq_gpio, "goodix_ts_irq_gpio");
-		if (ret) {
-			dev_err(&client->dev, "Unable to request irq gpio [%d]\n",
-				pdata->irq_gpio);
-			goto err_pwr_off;
+	GTP_DEBUG_FUNC();
+
+	ts->input_dev = input_allocate_device();
+	if (ts->input_dev == NULL) {
+		GTP_ERROR("Failed to allocate input device.");
+		return -ENOMEM;
+	}
+
+	ts->input_dev->evbit[0] =
+	    BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+#if GTP_ICS_SLOT_REPORT
+	input_mt_init_slots(ts->input_dev, 16, 0);
+#else
+	ts->input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+#endif
+	__set_bit(INPUT_PROP_DIRECT, ts->input_dev->propbit);
+
+#if GTP_HAVE_TOUCH_KEY
+	for (index = 0; index < GTP_MAX_KEY_NUM; index++)
+		input_set_capability(ts->input_dev, EV_KEY,
+				     touch_key_array[index]);
+#endif
+
+#if GTP_GESTURE_WAKEUP
+	input_set_capability(ts->input_dev, EV_KEY, KEY_POWER);
+#endif
+
+#if GTP_CHANGE_X2Y
+	GTP_SWAP(ts->abs_x_max, ts->abs_y_max);
+#endif
+
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, ts->abs_x_max,
+			     0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, ts->abs_y_max,
+			     0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_TRACKING_ID, 0, 255, 0, 0);
+
+	snprintf(phys, 32, "input/ts");
+	ts->input_dev->name = goodix_ts_name;
+	ts->input_dev->phys = phys;
+	ts->input_dev->id.bustype = BUS_I2C;
+	ts->input_dev->id.vendor = 0xDEAD;
+	ts->input_dev->id.product = 0xBEEF;
+	ts->input_dev->id.version = 10427;
+
+	ret = input_register_device(ts->input_dev);
+	if (ret) {
+		GTP_ERROR("Register %s input device failed",
+			  ts->input_dev->name);
+		return -ENODEV;
+	}
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	ts->early_suspend.suspend = goodix_ts_early_suspend;
+	ts->early_suspend.resume = goodix_ts_late_resume;
+	register_early_suspend(&ts->early_suspend);
+#endif
+
+#if GTP_WITH_PEN
+	gtp_pen_init(ts);
+#endif
+
+	return 0;
+}
+
+/************** For GT9XXF Start *************/
+#if GTP_COMPATIBLE_MODE
+s32 gtp_fw_startup(struct i2c_client *client)
+{
+	u8 opr_buf[4];
+	s32 ret = 0;
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+	/* init sw WDT */
+	opr_buf[0] = 0xAA;
+	ret = i2c_write_bytes(client, 0x8041, opr_buf, 1);
+	if (ret < 0)
+		return FAIL;
+
+	/* release SS51 & DSP */
+	opr_buf[0] = 0x00;
+	ret = i2c_write_bytes(client, 0x4180, opr_buf, 1);
+	if (ret < 0)
+		return FAIL;
+
+	/* int sync */
+	gtp_int_sync(ts, 25);
+
+	/* check fw run status */
+	ret = i2c_read_bytes(client, 0x8041, opr_buf, 1);
+	if (ret < 0)
+		return FAIL;
+
+	if (0xAA == opr_buf[0]) {
+		GTP_ERROR("IC works abnormally,startup failed.");
+		return FAIL;
+	}
+
+	GTP_INFO("IC works normally, Startup success.");
+	opr_buf[0] = 0xAA;
+	i2c_write_bytes(client, 0x8041, opr_buf, 1);
+	return SUCCESS;
+}
+
+static s32 gtp_esd_recovery(struct i2c_client *client)
+{
+	s32 retry = 0;
+	s32 ret = 0;
+	struct goodix_ts_data *ts;
+
+	ts = i2c_get_clientdata(client);
+
+	gtp_irq_disable(ts);
+
+	GTP_INFO("GT9XXF esd recovery mode");
+	for (retry = 0; retry < 5; retry++) {
+		ret = gup_fw_download_proc(NULL, GTP_FL_ESD_RECOVERY);
+		if (FAIL == ret) {
+			GTP_ERROR("esd recovery failed %d", retry + 1);
+			continue;
 		}
-		ret = gpio_direction_input(pdata->irq_gpio);
-		if (ret) {
-			dev_err(&client->dev, "Unable to set direction for irq gpio [%d]\n",
-				pdata->irq_gpio);
-			goto err_free_irq_gpio;
+		ret = gtp_fw_startup(ts->client);
+		if (FAIL == ret) {
+			GTP_ERROR("GT9XXF start up failed %d", retry + 1);
+			continue;
 		}
-	} else {
-		dev_err(&client->dev, "Invalid irq gpio [%d]!\n",
-			pdata->irq_gpio);
-		ret = -EINVAL;
-		goto err_pwr_off;
+		break;
 	}
+	gtp_irq_enable(ts);
 
-	if (gpio_is_valid(pdata->reset_gpio)) {
-		ret = gpio_request(pdata->reset_gpio, "goodix_ts_reset_gpio");
-		if (ret) {
-			dev_err(&client->dev, "Unable to request reset gpio [%d]\n",
-				pdata->reset_gpio);
-			goto err_free_irq_gpio;
-		}
+	if (retry >= 5) {
+		GTP_ERROR("failed to esd recovery");
+		return FAIL;
+	}
 
-		ret = gpio_direction_output(pdata->reset_gpio, 0);
-		if (ret) {
-			dev_err(&client->dev, "Unable to set direction for reset gpio [%d]\n",
-				pdata->reset_gpio);
-			goto err_free_reset_gpio;
+	GTP_INFO("Esd recovery successful");
+	return SUCCESS;
+}
+
+void gtp_recovery_reset(struct i2c_client *client)
+{
+#if GTP_ESD_PROTECT
+	gtp_esd_switch(client, SWITCH_OFF);
+#endif
+	GTP_DEBUG_FUNC();
+
+	gtp_esd_recovery(client);
+
+#if GTP_ESD_PROTECT
+	gtp_esd_switch(client, SWITCH_ON);
+#endif
+}
+
+static s32 gtp_bak_ref_proc(struct goodix_ts_data *ts, u8 mode)
+{
+	s32 ret = 0;
+	s32 i = 0;
+	s32 j = 0;
+	u16 ref_sum = 0;
+	u16 learn_cnt = 0;
+	u16 chksum = 0;
+	s32 ref_seg_len = 0;
+	s32 ref_grps = 0;
+	struct file *ref_filp = NULL;
+	u8 *p_bak_ref;
+	struct filename name;
+
+	ret = gup_check_fs_mounted("/data");
+	if (FAIL == ret) {
+		ts->ref_chk_fs_times++;
+		GTP_DEBUG("Ref check /data times/MAX_TIMES: %d / %d",
+			  ts->ref_chk_fs_times, GTP_CHK_FS_MNT_MAX);
+		if (ts->ref_chk_fs_times < GTP_CHK_FS_MNT_MAX) {
+			msleep(50);
+			GTP_INFO("/data not mounted.");
+			return FAIL;
 		}
+		GTP_INFO("check /data mount timeout...");
+	} else
+		GTP_INFO("/data mounted!!!(%d/%d)", ts->ref_chk_fs_times,
+			 GTP_CHK_FS_MNT_MAX);
+
+	p_bak_ref = kzalloc(ts->bak_ref_len, GFP_KERNEL);
+	if (NULL == p_bak_ref) {
+		GTP_ERROR("Allocate memory for p_bak_ref failed!");
+		return FAIL;
+	}
+
+	if (ts->is_950) {
+		ref_seg_len = ts->bak_ref_len / 6;
+		ref_grps = 6;
 	} else {
-		dev_err(&client->dev, "Invalid irq gpio [%d]!\n",
-			pdata->reset_gpio);
-		ret = -EINVAL;
-		goto err_free_irq_gpio;
-	}
-	/* IRQ GPIO is an input signal, but we are setting it to output
-	  * direction and pulling it down, to comply with power up timing
-	  * requirements, mentioned in power up timing section of device
-	  * datasheet.
-	  */
-	ret = gpio_direction_output(pdata->irq_gpio, 0);
-	if (ret)
-		dev_warn(&client->dev,
-			"pull down interrupt gpio failed\n");
-	ret = gpio_direction_output(pdata->reset_gpio, 0);
-	if (ret)
-		dev_warn(&client->dev,
-			"pull down reset gpio failed\n");
+		ref_seg_len = ts->bak_ref_len;
+		ref_grps = 1;
+	}
 
-	return ret;
+	name.name = GTP_BAK_REF_PATH;
+	ref_filp = file_open_name(&name, O_RDWR | O_CREAT, 0666);
+	if (IS_ERR(ref_filp)) {
+		GTP_ERROR("Failed to open/create %s.", GTP_BAK_REF_PATH);
+		if (GTP_BAK_REF_SEND == mode)
+			goto bak_ref_default;
+		else
+			goto bak_ref_exit;
+	}
 
-err_free_reset_gpio:
-	if (gpio_is_valid(pdata->reset_gpio))
-		gpio_free(pdata->reset_gpio);
-err_free_irq_gpio:
-	if (gpio_is_valid(pdata->irq_gpio))
-		gpio_free(pdata->irq_gpio);
-err_pwr_off:
+	switch (mode) {
+	case GTP_BAK_REF_SEND:
+		GTP_INFO("Send backup-reference");
+		ref_filp->f_op->llseek(ref_filp, 0, SEEK_SET);
+		ret =
+		    ref_filp->f_op->read(ref_filp, (char *)p_bak_ref,
+					 ts->bak_ref_len, &ref_filp->f_pos);
+		if (ret < 0) {
+			GTP_ERROR("failed to read bak_ref info from file");
+			goto bak_ref_default;
+		}
+		for (j = 0; j < ref_grps; ++j) {
+			ref_sum = 0;
+			for (i = 0; i < (ref_seg_len); i += 2)
+				ref_sum +=
+				    (p_bak_ref[i + j * ref_seg_len] << 8) +
+				    p_bak_ref[i + 1 + j * ref_seg_len];
+			learn_cnt =
+			    (p_bak_ref[j * ref_seg_len + ref_seg_len - 4] << 8)
+			    + (p_bak_ref[j * ref_seg_len + ref_seg_len - 3]);
+			chksum =
+			    (p_bak_ref[j * ref_seg_len + ref_seg_len - 2] << 8)
+			    + (p_bak_ref[j * ref_seg_len + ref_seg_len - 1]);
+			GTP_DEBUG("learn count = %d", learn_cnt);
+			GTP_DEBUG("chksum = %d", chksum);
+			GTP_DEBUG("ref_sum = 0x%04X", ref_sum & 0xFFFF);
+
+			if (1 != ref_sum) {
+				GTP_INFO
+				    ("wrong chksum for bak_ref, reset to 0x00");
+				memset(&p_bak_ref[j * ref_seg_len], 0,
+				       ref_seg_len);
+				p_bak_ref[ref_seg_len + j * ref_seg_len - 1] =
+				    0x01;
+			} else {
+				if (j == (ref_grps - 1))
+					GTP_INFO
+					    ("backup-reference data in %s used",
+					     GTP_BAK_REF_PATH);
+			}
+		}
+		ret =
+		    i2c_write_bytes(ts->client, GTP_REG_BAK_REF, p_bak_ref,
+				    ts->bak_ref_len);
+		if (FAIL == ret) {
+			GTP_ERROR("send bak_ref failed: iic comm error");
+			goto bak_ref_exit;
+		}
+		break;
+
+	case GTP_BAK_REF_STORE:
+		GTP_INFO("Store backup-reference");
+		ret =
+		    i2c_read_bytes(ts->client, GTP_REG_BAK_REF, p_bak_ref,
+				   ts->bak_ref_len);
+		if (ret < 0) {
+			GTP_ERROR("read bak_ref info failed, send default");
+			goto bak_ref_default;
+		}
+		ref_filp->f_op->llseek(ref_filp, 0, SEEK_SET);
+		ref_filp->f_op->write(ref_filp, (char *)p_bak_ref,
+				      ts->bak_ref_len, &ref_filp->f_pos);
+		break;
+
+	default:
+		GTP_ERROR("invalid backup-reference request");
+		break;
+	}
+	ret = SUCCESS;
+	goto bak_ref_exit;
+
+bak_ref_default:
+	for (j = 0; j < ref_grps; ++j) {
+		memset(&p_bak_ref[j * ref_seg_len], 0, ref_seg_len);
+		p_bak_ref[j * ref_seg_len + ref_seg_len - 1] = 0x01;
+	}
+	ret =
+	    i2c_write_bytes(ts->client, GTP_REG_BAK_REF, p_bak_ref,
+			    ts->bak_ref_len);
+	if (!IS_ERR(ref_filp)) {
+		GTP_INFO("write backup-reference data into %s",
+			 GTP_BAK_REF_PATH);
+		ref_filp->f_op->llseek(ref_filp, 0, SEEK_SET);
+		ref_filp->f_op->write(ref_filp, (char *)p_bak_ref,
+				      ts->bak_ref_len, &ref_filp->f_pos);
+	}
+	if (ret == FAIL)
+		GTP_ERROR("failed to load the default backup reference");
+
+bak_ref_exit:
+	kfree(p_bak_ref);
+	if (ref_filp && !IS_ERR(ref_filp))
+		filp_close(ref_filp, NULL);
 	return ret;
 }
 
-/*******************************************************
-Function:
-	Request interrupt.
-Input:
-	ts: private data.
-Output:
-	Executive outcomes.
-	0: succeed, -1: failed.
-*******************************************************/
-static int gtp_request_irq(struct goodix_ts_data *ts)
+static s32 gtp_verify_main_clk(u8 *p_main_clk)
 {
-	int ret = 0;
-	const u8 irq_table[] = GTP_IRQ_TAB;
+	u8 chksum = 0;
+	u8 main_clock = p_main_clk[0];
+	s32 i = 0;
 
-	ret = request_threaded_irq(ts->client->irq, NULL,
-			goodix_ts_irq_handler,
-			irq_table[ts->int_trigger_type],
-			ts->client->name, ts);
-	if (ret) {
-		ts->use_irq = false;
-		return ret;
-	} else {
-		gtp_irq_disable(ts);
-		ts->use_irq = true;
-		return ret;
+	if (main_clock < 50 || main_clock > 120)
+		return FAIL;
+
+	for (i = 0; i < 5; ++i) {
+		if (main_clock != p_main_clk[i])
+			return FAIL;
+		chksum += p_main_clk[i];
+	}
+	chksum += p_main_clk[5];
+	if ((chksum) == 0)
+		return SUCCESS;
+	return FAIL;
+}
+
+static s32 gtp_main_clk_proc(struct goodix_ts_data *ts)
+{
+	s32 ret = 0;
+	s32 i = 0;
+	s32 clk_chksum = 0;
+	struct file *clk_filp = NULL;
+	u8 p_main_clk[6] = { 0 };
+	struct filename name;
+
+	ret = gup_check_fs_mounted("/data");
+	if (FAIL == ret) {
+		ts->clk_chk_fs_times++;
+		GTP_DEBUG("Clock check /data times/MAX_TIMES: %d / %d",
+			  ts->clk_chk_fs_times, GTP_CHK_FS_MNT_MAX);
+		if (ts->clk_chk_fs_times < GTP_CHK_FS_MNT_MAX) {
+			msleep(50);
+			GTP_INFO("/data not mounted.");
+			return FAIL;
+		}
+		GTP_INFO("Check /data mount timeout!");
+	} else
+		GTP_INFO("/data mounted!!!(%d/%d)", ts->clk_chk_fs_times,
+			 GTP_CHK_FS_MNT_MAX);
+
+	name.name = GTP_MAIN_CLK_PATH;
+	clk_filp = file_open_name(&name, O_RDWR | O_CREAT, 0666);
+	if (IS_ERR(clk_filp))
+		GTP_ERROR("%s is unavailable, calculate main clock",
+			  GTP_MAIN_CLK_PATH);
+	else {
+		clk_filp->f_op->llseek(clk_filp, 0, SEEK_SET);
+		clk_filp->f_op->read(clk_filp, (char *)p_main_clk, 6,
+				     &clk_filp->f_pos);
+
+		ret = gtp_verify_main_clk(p_main_clk);
+		if (FAIL == ret) {
+			/* recalculate main clock
+			  * & rewrite main clock data to file
+			  */
+			GTP_ERROR
+			    ("main clock data in %s is wrong,",
+			     GTP_MAIN_CLK_PATH);
+		} else {
+			GTP_INFO
+			    ("main clock data in %s used, main clock freq: %d",
+			     GTP_MAIN_CLK_PATH, p_main_clk[0]);
+			filp_close(clk_filp, NULL);
+			goto update_main_clk;
+		}
+	}
+
+#if GTP_ESD_PROTECT
+	gtp_esd_switch(ts->client, SWITCH_OFF);
+#endif
+	ret = gup_clk_calibration();
+	gtp_esd_recovery(ts->client);
+
+#if GTP_ESD_PROTECT
+	gtp_esd_switch(ts->client, SWITCH_ON);
+#endif
+
+	GTP_INFO("calibrate main clock: %d", ret);
+	if (ret < 50 || ret > 120) {
+		GTP_ERROR("wrong main clock: %d", ret);
+		goto exit_main_clk;
+	}
+
+	for (i = 0; i < 5; ++i) {
+		p_main_clk[i] = ret;
+		clk_chksum += p_main_clk[i];
+	}
+	p_main_clk[5] = 0 - clk_chksum;
+
+	if (!IS_ERR(clk_filp)) {
+		GTP_DEBUG("write main clock data into %s", GTP_MAIN_CLK_PATH);
+		clk_filp->f_op->llseek(clk_filp, 0, SEEK_SET);
+		clk_filp->f_op->write(clk_filp, (char *)p_main_clk, 6,
+				      &clk_filp->f_pos);
+		filp_close(clk_filp, NULL);
+	}
+
+update_main_clk:
+	ret = i2c_write_bytes(ts->client, GTP_REG_MAIN_CLK, p_main_clk, 6);
+	if (FAIL == ret) {
+		GTP_ERROR("update main clock failed!");
+		return FAIL;
 	}
+	return SUCCESS;
+
+exit_main_clk:
+	if (!IS_ERR(clk_filp))
+		filp_close(clk_filp, NULL);
+	return FAIL;
 }
 
-/*******************************************************
-Function:
-	Request input device Function.
-Input:
-	ts:private data.
-Output:
-	Executive outcomes.
-	0: succeed, otherwise: failed.
-*******************************************************/
-static int gtp_request_input_dev(struct goodix_ts_data *ts)
+static s32 gtp_gt9xxf_init(struct i2c_client *client)
 {
-	int ret;
-	char phys[PHY_BUF_SIZE];
-	int index = 0;
+	s32 ret = 0;
 
-	ts->input_dev = input_allocate_device();
-	if (ts->input_dev == NULL) {
-		dev_err(&ts->client->dev,
-				"Failed to allocate input device.\n");
-		return -ENOMEM;
-	}
+	ret = gup_fw_download_proc(NULL, GTP_FL_FW_BURN);
+	if (FAIL == ret)
+		return FAIL;
 
-	ts->input_dev->evbit[0] =
-		BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) ;
-	set_bit(BTN_TOOL_FINGER, ts->input_dev->keybit);
-	__set_bit(INPUT_PROP_DIRECT, ts->input_dev->propbit);
-	/* in case of "out of memory" */
-	input_mt_init_slots(ts->input_dev, 10, 0);
+	ret = gtp_fw_startup(client);
+	if (FAIL == ret)
+		return FAIL;
 
-	if (ts->pdata->have_touch_key) {
-		for (index = 0; index < ts->pdata->num_button; index++) {
-			input_set_capability(ts->input_dev,
-				EV_KEY, ts->pdata->button_map[index]);
-		}
-	}
+	return SUCCESS;
+}
+
+static void gtp_get_chip_type(struct goodix_ts_data *ts)
+{
+	u8 opr_buf[10] = { 0x00 };
+	s32 ret = 0;
 
-	if (ts->pdata->slide_wakeup)
-		input_set_capability(ts->input_dev, EV_KEY, KEY_POWER);
+	msleep(20);
 
-	if (ts->pdata->with_pen) {  /* pen support */
-		__set_bit(BTN_TOOL_PEN, ts->input_dev->keybit);
-		__set_bit(INPUT_PROP_DIRECT, ts->input_dev->propbit);
-		__set_bit(INPUT_PROP_POINTER, ts->input_dev->propbit);
+	ret =
+	    gtp_i2c_read_dbl_check(ts->client, GTP_REG_CHIP_TYPE, opr_buf, 10);
+	if (FAIL == ret) {
+		GTP_ERROR("Failed to get chip-type");
+		ts->chip_type = CHIP_TYPE_GT9;
+		return;
 	}
 
-	if (ts->pdata->change_x2y)
-		swap(ts->abs_x_max, ts->abs_y_max);
+	if (!memcmp(opr_buf, "GOODIX_GT9", 10))
+		ts->chip_type = CHIP_TYPE_GT9;
+	else	/* GT9XXF */
+		ts->chip_type = CHIP_TYPE_GT9F;
+	GTP_INFO("Chip Type: %s",
+		 (ts->chip_type ==
+		  CHIP_TYPE_GT9) ? "GOODIX_GT9" : "GOODIX_GT9F");
+}
+#endif
 
-	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X,
-				0, ts->abs_x_max, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y,
-				0, ts->abs_y_max, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR,
-				0, 255, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR,
-				0, 255, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_TRACKING_ID,
-				0, 255, 0, 0);
+static int goodix_ts_get_dt_coords(struct device *dev, char *name,
+				   struct goodix_ts_platform_data *pdata)
+{
+	struct property *prop;
+	struct device_node *np = dev->of_node;
+	int rc;
+	u32 coords[GOODIX_COORDS_ARR_SIZE];
 
-	snprintf(phys, PHY_BUF_SIZE, "input/ts");
-	ts->input_dev->name = GOODIX_DEV_NAME;
-	ts->input_dev->phys = phys;
-	ts->input_dev->id.bustype = BUS_I2C;
-	ts->input_dev->id.vendor = 0xDEAD;
-	ts->input_dev->id.product = 0xBEEF;
-	ts->input_dev->id.version = 10427;
+	prop = of_find_property(np, name, NULL);
+	if (!prop)
+		return -EINVAL;
+	if (!prop->value)
+		return -ENODATA;
 
-	ret = input_register_device(ts->input_dev);
-	if (ret) {
-		dev_err(&ts->client->dev,
-				"Register %s input device failed.\n",
-				ts->input_dev->name);
-		goto exit_free_inputdev;
+	rc = of_property_read_u32_array(np, name, coords,
+					GOODIX_COORDS_ARR_SIZE);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read %s\n", name);
+		return rc;
 	}
 
-	return 0;
+	if (!strcmp(name, "goodix,panel-coords")) {
+		pdata->panel_minx = coords[0];
+		pdata->panel_miny = coords[1];
+		pdata->panel_maxx = coords[2];
+		pdata->panel_maxy = coords[3];
+	} else if (!strcmp(name, "goodix,display-coords")) {
+		pdata->x_min = coords[0];
+		pdata->y_min = coords[1];
+		pdata->x_max = coords[2];
+		pdata->y_max = coords[3];
+	} else {
+		dev_err(dev, "unsupported property %s\n", name);
+		return -EINVAL;
+	}
 
-exit_free_inputdev:
-	input_free_device(ts->input_dev);
-	ts->input_dev = NULL;
-	return ret;
+	return 0;
 }
 
 static int reg_set_optimum_mode_check(struct regulator *reg, int load_uA)
 {
 	return (regulator_count_voltages(reg) > 0) ?
-		regulator_set_optimum_mode(reg, load_uA) : 0;
+	    regulator_set_optimum_mode(reg, load_uA) : 0;
 }
 
 /**
@@ -1291,39 +2250,38 @@ static int reg_set_optimum_mode_check(struct regulator *reg, int load_uA)
 static int goodix_power_on(struct goodix_ts_data *ts)
 {
 	int ret;
+#ifdef FEATURE_QRD8X26_UNISCOPE_MODIFY
+	int err = 0;
+#endif
 
 	if (ts->power_on) {
-		dev_info(&ts->client->dev,
-				"Device already power on\n");
+		dev_info(&ts->client->dev, "Device already power on\n");
 		return 0;
 	}
-
-	if (!IS_ERR(ts->avdd)) {
-		ret = reg_set_optimum_mode_check(ts->avdd,
-			GOODIX_VDD_LOAD_MAX_UA);
-		if (ret < 0) {
-			dev_err(&ts->client->dev,
-				"Regulator avdd set_opt failed rc=%d\n", ret);
-			goto err_set_opt_avdd;
-		}
-		ret = regulator_enable(ts->avdd);
-		if (ret) {
+#ifdef FEATURE_QRD8X26_UNISCOPE_MODIFY
+	/* VDD 2.8V Power on */
+	if (gpio_is_valid(GPIO_VDD_2_8V)) {
+		err = gpio_direction_output(GPIO_VDD_2_8V, 1);
+		if (err) {
 			dev_err(&ts->client->dev,
-				"Regulator avdd enable failed ret=%d\n", ret);
-			goto err_enable_avdd;
+				"set_direction for CTP 2.8V gpio failed\n");
+			goto free_vdd_gpio;
 		}
 	}
 
+	msleep(20);
+#endif
+
 	if (!IS_ERR(ts->vdd)) {
 		ret = regulator_set_voltage(ts->vdd, GOODIX_VTG_MIN_UV,
-					   GOODIX_VTG_MAX_UV);
+					    GOODIX_VTG_MAX_UV);
 		if (ret) {
 			dev_err(&ts->client->dev,
 				"Regulator set_vtg failed vdd ret=%d\n", ret);
 			goto err_set_vtg_vdd;
 		}
 		ret = reg_set_optimum_mode_check(ts->vdd,
-			GOODIX_VDD_LOAD_MAX_UA);
+						 GOODIX_VDD_LOAD_MAX_UA);
 		if (ret < 0) {
 			dev_err(&ts->client->dev,
 				"Regulator vdd set_opt failed rc=%d\n", ret);
@@ -1339,7 +2297,7 @@ static int goodix_power_on(struct goodix_ts_data *ts)
 
 	if (!IS_ERR(ts->vcc_i2c)) {
 		ret = regulator_set_voltage(ts->vcc_i2c, GOODIX_I2C_VTG_MIN_UV,
-					   GOODIX_I2C_VTG_MAX_UV);
+					    GOODIX_I2C_VTG_MAX_UV);
 		if (ret) {
 			dev_err(&ts->client->dev,
 				"Regulator set_vtg failed vcc_i2c ret=%d\n",
@@ -1347,7 +2305,7 @@ static int goodix_power_on(struct goodix_ts_data *ts)
 			goto err_set_vtg_vcc_i2c;
 		}
 		ret = reg_set_optimum_mode_check(ts->vcc_i2c,
-			GOODIX_VIO_LOAD_MAX_UA);
+						 GOODIX_VIO_LOAD_MAX_UA);
 		if (ret < 0) {
 			dev_err(&ts->client->dev,
 				"Regulator vcc_i2c set_opt failed rc=%d\n",
@@ -1361,7 +2319,7 @@ static int goodix_power_on(struct goodix_ts_data *ts)
 				ret);
 			regulator_disable(ts->vdd);
 			goto err_enable_vcc_i2c;
-			}
+		}
 	}
 
 	ts->power_on = true;
@@ -1379,11 +2337,12 @@ err_set_opt_vdd:
 	if (!IS_ERR(ts->vdd))
 		regulator_set_voltage(ts->vdd, 0, GOODIX_VTG_MAX_UV);
 err_set_vtg_vdd:
-	if (!IS_ERR(ts->avdd))
-		regulator_disable(ts->avdd);
-err_enable_avdd:
-err_set_opt_avdd:
 	ts->power_on = false;
+#ifdef FEATURE_QRD8X26_UNISCOPE_MODIFY
+free_vdd_gpio:
+	if (gpio_is_valid(GPIO_VDD_2_8V))
+		gpio_free(GPIO_VDD_2_8V);
+#endif
 	return ret;
 }
 
@@ -1396,16 +2355,25 @@ err_set_opt_avdd:
 static int goodix_power_off(struct goodix_ts_data *ts)
 {
 	int ret;
+#ifdef FEATURE_QRD8X26_UNISCOPE_MODIFY
+	int err = 0;
+#endif
 
 	if (!ts->power_on) {
-		dev_info(&ts->client->dev,
-				"Device already power off\n");
+		dev_info(&ts->client->dev, "Device already power off\n");
 		return 0;
 	}
+#ifdef FEATURE_QRD8X26_UNISCOPE_MODIFY
+	err = gpio_direction_output(GPIO_VDD_2_8V, 0);
+	if (err) {
+		dev_err(&ts->client->dev,
+			"set_direction for CTP 2.8V gpio failed\n");
+	}
+#endif
 
 	if (!IS_ERR(ts->vcc_i2c)) {
 		ret = regulator_set_voltage(ts->vcc_i2c, 0,
-			GOODIX_I2C_VTG_MAX_UV);
+					    GOODIX_I2C_VTG_MAX_UV);
 		if (ret < 0)
 			dev_err(&ts->client->dev,
 				"Regulator vcc_i2c set_vtg failed ret=%d\n",
@@ -1428,13 +2396,6 @@ static int goodix_power_off(struct goodix_ts_data *ts)
 				"Regulator vdd disable failed ret=%d\n", ret);
 	}
 
-	if (!IS_ERR(ts->avdd)) {
-		ret = regulator_disable(ts->avdd);
-		if (ret)
-			dev_err(&ts->client->dev,
-				"Regulator avdd disable failed ret=%d\n", ret);
-	}
-
 	ts->power_on = false;
 	return 0;
 }
@@ -1448,28 +2409,68 @@ static int goodix_power_off(struct goodix_ts_data *ts)
 static int goodix_power_init(struct goodix_ts_data *ts)
 {
 	int ret;
-
-	ts->avdd = regulator_get(&ts->client->dev, "avdd");
-	if (IS_ERR(ts->avdd)) {
-		ret = PTR_ERR(ts->avdd);
-		dev_info(&ts->client->dev,
-			"Regulator get failed avdd ret=%d\n", ret);
-	}
+#ifdef FEATURE_QRD8X26_UNISCOPE_MODIFY
+	int err = 0;
+#endif
 
 	ts->vdd = regulator_get(&ts->client->dev, "vdd");
 	if (IS_ERR(ts->vdd)) {
 		ret = PTR_ERR(ts->vdd);
 		dev_info(&ts->client->dev,
-			"Regulator get failed vdd ret=%d\n", ret);
+			 "Regulator get failed vdd ret=%d\n", ret);
 	}
 
 	ts->vcc_i2c = regulator_get(&ts->client->dev, "vcc-i2c");
 	if (IS_ERR(ts->vcc_i2c)) {
 		ret = PTR_ERR(ts->vcc_i2c);
 		dev_info(&ts->client->dev,
-			"Regulator get failed vcc_i2c ret=%d\n", ret);
+			 "Regulator get failed vcc_i2c ret=%d\n", ret);
+	}
+#ifdef FEATURE_QRD8X26_UNISCOPE_MODIFY
+	if (regulator_count_voltages(ts->vcc_i2c) > 0) {
+		err = regulator_set_voltage(ts->vcc_i2c, GOODIX_I2C_VTG_MIN_UV,
+					    GOODIX_I2C_VTG_MIN_UV);
+		if (err) {
+			dev_err(&ts->client->desv,
+				"Regulator set_vtg failed vcc_i2c rc=%d\n",
+				err);
+			goto err_set_vtg_vcc_i2c;
+		}
+	}
+
+	err = gpio_request(GPIO_VDD_2_8V, "CTP 2.8V");
+	if (err)
+		dev_err(&ts->client->dev, "CTP 2.8V request failed");
+
+	/* request GTP GPIO --Timing 2014-2-14 */
+	ret = gpio_request(ts->pdata->irq_gpio, "GTP_INT_IRQ");
+	if (ret < 0) {
+		GTP_ERROR("Failed to request GPIO:%d, ERRNO:%d",
+			  (s32) ts->pdata->irq_gpio, ret);
+		ret = -ENODEV;
+	} else {
+		ret = gpio_direction_input(ts->pdata->irq_gpio);
+		if (ret < 0)
+			gpio_free(ts->pdata->irq_gpio);
+		ts->client->irq = gpio_to_irq(ts->pdata->irq_gpio);
+	}
+
+	ret = gpio_request(ts->pdata->reset_gpio, "GTP_RST_PORT");
+	if (ret < 0) {
+		GTP_ERROR("Failed to request GPIO:%d, ERRNO:%d",
+			  (s32) ts->pdata->reset_gpio, ret);
+		ret = -ENODEV;
 	}
+	/* RST and INT output low for poweron timing  --Timing 2014-2-14 */
+	err = gpio_direction_output(ts->pdata->irq_gpio, 0);
+	err = gpio_direction_output(ts->pdata->reset_gpio, 0);
+	err = gpio_direction_output(GPIO_VDD_2_8V, 0);
+	msleep(200);
 
+err_set_vtg_vcc_i2c:
+	if (!IS_ERR(ts->vdd))
+		regulator_disable(ts->vdd);
+#endif
 	return 0;
 }
 
@@ -1483,11 +2484,10 @@ static int goodix_power_deinit(struct goodix_ts_data *ts)
 {
 	regulator_put(ts->vdd);
 	regulator_put(ts->vcc_i2c);
-	regulator_put(ts->avdd);
-
 	return 0;
 }
 
+/************* For GT9XXF End ************/
 static ssize_t gtp_fw_name_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
@@ -1495,15 +2495,15 @@ static ssize_t gtp_fw_name_show(struct device *dev,
 
 	if (!strlen(ts->fw_name))
 		return snprintf(buf, GTP_FW_NAME_MAXSIZE - 1,
-			"No fw name has been given.");
+				"No fw name has been given.");
 	else
 		return snprintf(buf, GTP_FW_NAME_MAXSIZE - 1,
-			"%s\n", ts->fw_name);
+				"%s\n", ts->fw_name);
 }
 
 static ssize_t gtp_fw_name_store(struct device *dev,
-				struct device_attribute *attr,
-				const char *buf, size_t size)
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
 {
 	struct goodix_ts_data *ts = dev_get_drvdata(dev);
 
@@ -1513,22 +2513,22 @@ static ssize_t gtp_fw_name_store(struct device *dev,
 	}
 
 	strlcpy(ts->fw_name, buf, size);
-	if (ts->fw_name[size-1] == '\n')
-		ts->fw_name[size-1] = '\0';
+	if (ts->fw_name[size - 1] == '\n')
+		ts->fw_name[size - 1] = '\0';
 
 	return size;
 }
 
 static ssize_t gtp_fw_upgrade_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
+				   struct device_attribute *attr, char *buf)
 {
 	struct goodix_ts_data *ts = dev_get_drvdata(dev);
 	return snprintf(buf, 2, "%d\n", ts->fw_loading);
 }
 
 static ssize_t gtp_fw_upgrade_store(struct device *dev,
-				struct device_attribute *attr,
-				const char *buf, size_t size)
+				    struct device_attribute *attr,
+				    const char *buf, size_t size)
 {
 	struct goodix_ts_data *ts = dev_get_drvdata(dev);
 	unsigned int val;
@@ -1554,7 +2554,7 @@ static ssize_t gtp_fw_upgrade_store(struct device *dev,
 			ret = gup_update_proc(NULL);
 			if (ret == FAIL)
 				dev_err(&ts->client->dev,
-						"Fail to update GTP firmware.\n");
+					"Fail to update GTP firmware.\n");
 		}
 		ts->fw_loading = false;
 		enable_irq(ts->client->irq);
@@ -1565,8 +2565,8 @@ static ssize_t gtp_fw_upgrade_store(struct device *dev,
 }
 
 static ssize_t gtp_force_fw_upgrade_store(struct device *dev,
-				struct device_attribute *attr,
-				const char *buf, size_t size)
+					  struct device_attribute *attr,
+					  const char *buf, size_t size)
 {
 	struct goodix_ts_data *ts = dev_get_drvdata(dev);
 	unsigned int val;
@@ -1593,7 +2593,7 @@ static ssize_t gtp_force_fw_upgrade_store(struct device *dev,
 			ret = gup_update_proc(NULL);
 			if (ret == FAIL)
 				dev_err(&ts->client->dev,
-				"Fail to force update GTP firmware.\n");
+					"Fail to force update GTP firmware.\n");
 		}
 		ts->force_update = false;
 		ts->fw_loading = false;
@@ -1604,20 +2604,127 @@ static ssize_t gtp_force_fw_upgrade_store(struct device *dev,
 	return size;
 }
 
+static ssize_t goodix_enable_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct goodix_ts_data *ts = dev_get_drvdata(dev);
+	if (ts->gtp_is_suspend) {
+		dev_info(&ts->client->dev, "Already in suspend state\n");
+		return snprintf(buf, 4, "%s\n", "0");
+	}
+	return snprintf(buf, 4, "%s\n", ts->enable ? "1" : "0");
+}
+
+static ssize_t goodix_enable_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	struct goodix_ts_data *ts = dev_get_drvdata(dev);
+	unsigned long val;
+	int rc, ret, i;
+
+	if (size > 2)
+		return -EINVAL;
+
+	if (ts->gtp_is_suspend) {
+		dev_info(&ts->client->dev, "Already in suspend state\n");
+		goto no_operation;
+	}
+
+	rc = kstrtoul(buf, 10, &val);
+	if (rc != 0)
+		return rc;
+
+	if (val) {
+		ret = gtp_wakeup_sleep(ts);
+
+#if GTP_GESTURE_WAKEUP
+		doze_status = DOZE_DISABLED;
+#endif
+
+		if (ret <= 0)
+			dev_err(&ts->client->dev, "GTP resume failed.\n");
+
+		if (ts->use_irq)
+			gtp_irq_enable(ts);
+		else
+			hrtimer_start(&ts->timer, ktime_set(1, 0),
+				      HRTIMER_MODE_REL);
+
+#if GTP_ESD_PROTECT
+		ts->gtp_is_suspend = 0;
+		gtp_esd_switch(ts->client, SWITCH_ON);
+#endif
+		ts->enable = true;
+	} else {
+#if GTP_ESD_PROTECT
+		ts->gtp_is_suspend = 1;
+		gtp_esd_switch(ts->client, SWITCH_OFF);
+#endif
+
+#if GTP_GESTURE_WAKEUP
+		ret = gtp_enter_doze(ts);
+#else
+		if (ts->use_irq)
+			gtp_irq_disable(ts);
+		else
+			hrtimer_cancel(&ts->timer);
+
+		for (i = 0; i < GTP_MAX_TOUCH; i++)
+			gtp_touch_up(ts, i);
+
+		input_sync(ts->input_dev);
+
+		ret = gtp_enter_sleep(ts);
+#endif
+		if (ret <= 0)
+			dev_err(&ts->client->dev,
+				"GTP early suspend failed.\n");
+		/* to avoid waking up while not sleeping,
+		 * delay 48 + 10ms to ensure reliability
+		 */
+		msleep(58);
+		ts->enable = false;
+	}
+
+no_operation:
+	return size;
+}
+
+static ssize_t goodix_mt_protocol_type_show(struct device *dev,
+					    struct device_attribute *attr,
+					    char *buf)
+{
+	return snprintf(buf, 16, "%s\n", "MT Protocal B");
+}
+
+static ssize_t goodix_ts_info_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct goodix_ts_data *data = dev_get_drvdata(dev);
+	return snprintf(buf, GOODIX_INFO_MAX_LEN, "%s\n", data->ts_info);
+}
+
 static DEVICE_ATTR(fw_name, (S_IRUGO | S_IWUSR | S_IWGRP),
-			gtp_fw_name_show,
-			gtp_fw_name_store);
-static DEVICE_ATTR(fw_upgrade, (S_IRUGO | S_IWUSR | S_IWGRP),
-			gtp_fw_upgrade_show,
-			gtp_fw_upgrade_store);
-static DEVICE_ATTR(force_fw_upgrade, (S_IRUGO | S_IWUSR | S_IWGRP),
-			gtp_fw_upgrade_show,
-			gtp_force_fw_upgrade_store);
+		   gtp_fw_name_show, gtp_fw_name_store);
+static DEVICE_ATTR(update_fw, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   gtp_fw_upgrade_show, gtp_fw_upgrade_store);
+static DEVICE_ATTR(force_update_fw, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   gtp_fw_upgrade_show, gtp_force_fw_upgrade_store);
+static DEVICE_ATTR(enable, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   goodix_enable_show, goodix_enable_store);
+static DEVICE_ATTR(mt_protocol_type, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   goodix_mt_protocol_type_show, NULL);
+static DEVICE_ATTR(ts_info, (S_IRUGO | S_IWUSR | S_IWGRP),
+		   goodix_ts_info_show, NULL);
 
 static struct attribute *gtp_attrs[] = {
 	&dev_attr_fw_name.attr,
-	&dev_attr_fw_upgrade.attr,
-	&dev_attr_force_fw_upgrade.attr,
+	&dev_attr_update_fw.attr,
+	&dev_attr_force_update_fw.attr,
+	&dev_attr_enable.attr,
+	&dev_attr_mt_protocol_type.attr,
+	&dev_attr_ts_info.attr,
 	NULL
 };
 
@@ -1652,7 +2759,7 @@ static int gtp_debug_data_get(void *_data, u64 *val)
 {
 	struct goodix_ts_data *ts = _data;
 	int ret;
-	u8 buf[3] = {0};
+	u8 buf[3] = { 0 };
 
 	mutex_lock(&ts->input_dev->mutex);
 	buf[0] = ts->addr >> 8;
@@ -1673,7 +2780,7 @@ static int gtp_debug_data_get(void *_data, u64 *val)
 }
 
 DEFINE_SIMPLE_ATTRIBUTE(debug_data_fops, gtp_debug_data_get,
-				gtp_debug_data_set, "%llx\n");
+			gtp_debug_data_set, "%llx\n");
 
 static int gtp_debug_addr_set(void *_data, u64 val)
 {
@@ -1681,7 +2788,7 @@ static int gtp_debug_addr_set(void *_data, u64 val)
 
 	if (gtp_debug_addr_is_valid(val)) {
 		mutex_lock(&ts->input_dev->mutex);
-			ts->addr = val;
+		ts->addr = val;
 		mutex_unlock(&ts->input_dev->mutex);
 	}
 
@@ -1701,7 +2808,7 @@ static int gtp_debug_addr_get(void *_data, u64 *val)
 }
 
 DEFINE_SIMPLE_ATTRIBUTE(debug_addr_fops, gtp_debug_addr_get,
-				gtp_debug_addr_set, "%llx\n");
+			gtp_debug_addr_set, "%llx\n");
 
 static int gtp_debug_suspend_set(void *_data, u64 val)
 {
@@ -1731,81 +2838,69 @@ static int gtp_debug_suspend_get(void *_data, u64 *val)
 DEFINE_SIMPLE_ATTRIBUTE(debug_suspend_fops, gtp_debug_suspend_get,
 			gtp_debug_suspend_set, "%lld\n");
 
+static int goodix_debug_dump_info(struct seq_file *m, void *v)
+{
+	struct goodix_ts_data *data = m->private;
+
+	seq_printf(m, "%s\n", data->ts_info);
+
+	return 0;
+}
+
+static int debugfs_dump_info_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, goodix_debug_dump_info, inode->i_private);
+}
+
+static const struct file_operations debug_dump_info_fops = {
+	.owner = THIS_MODULE,
+	.open = debugfs_dump_info_open,
+	.read = seq_read,
+	.release = single_release,
+};
+
 static int gtp_debugfs_init(struct goodix_ts_data *data)
 {
 	data->debug_base = debugfs_create_dir(GTP_DEBUGFS_DIR, NULL);
-
 	if (IS_ERR_OR_NULL(data->debug_base)) {
 		dev_err(&data->client->dev, "Failed to create debugfs dir.\n");
-			return -EINVAL;
+		return -EINVAL;
 	}
 
 	if ((IS_ERR_OR_NULL(debugfs_create_file(GTP_DEBUGFS_FILE_SUSPEND,
-					S_IWUSR | S_IWGRP | S_IRUSR | S_IRGRP,
-					data->debug_base,
-					data,
-					&debug_suspend_fops)))) {
+						S_IWUSR | S_IWGRP | S_IRUSR |
+						S_IRGRP, data->debug_base, data,
+						&debug_suspend_fops)))) {
 		dev_err(&data->client->dev, "Failed to create suspend file.\n");
 		debugfs_remove_recursive(data->debug_base);
 		return -EINVAL;
 	}
 
 	if ((IS_ERR_OR_NULL(debugfs_create_file(GTP_DEBUGFS_FILE_DATA,
-					S_IWUSR | S_IWGRP | S_IRUSR | S_IRGRP,
-					data->debug_base,
-					data,
-					&debug_data_fops)))) {
+						S_IWUSR | S_IWGRP | S_IRUSR |
+						S_IRGRP, data->debug_base, data,
+						&debug_data_fops)))) {
 		dev_err(&data->client->dev, "Failed to create data file.\n");
 		debugfs_remove_recursive(data->debug_base);
 		return -EINVAL;
 	}
 
 	if ((IS_ERR_OR_NULL(debugfs_create_file(GTP_DEBUGFS_FILE_ADDR,
-					S_IWUSR | S_IWGRP | S_IRUSR | S_IRGRP,
-					data->debug_base,
-					data,
-					&debug_addr_fops)))) {
+						S_IWUSR | S_IWGRP | S_IRUSR |
+						S_IRGRP, data->debug_base, data,
+						&debug_addr_fops)))) {
 		dev_err(&data->client->dev, "Failed to create addr file.\n");
 		debugfs_remove_recursive(data->debug_base);
 		return -EINVAL;
 	}
 
-	return 0;
-}
-
-static int goodix_ts_get_dt_coords(struct device *dev, char *name,
-				struct goodix_ts_platform_data *pdata)
-{
-	struct property *prop;
-	struct device_node *np = dev->of_node;
-	int rc;
-	u32 coords[GOODIX_COORDS_ARR_SIZE];
-
-	prop = of_find_property(np, name, NULL);
-	if (!prop)
-		return -EINVAL;
-	if (!prop->value)
-		return -ENODATA;
-
-	rc = of_property_read_u32_array(np, name, coords,
-		GOODIX_COORDS_ARR_SIZE);
-	if (rc && (rc != -EINVAL)) {
-		dev_err(dev, "Unable to read %s\n", name);
-		return rc;
-	}
-
-	if (!strcmp(name, "goodix,panel-coords")) {
-		pdata->panel_minx = coords[0];
-		pdata->panel_miny = coords[1];
-		pdata->panel_maxx = coords[2];
-		pdata->panel_maxy = coords[3];
-	} else if (!strcmp(name, "goodix,display-coords")) {
-		pdata->x_min = coords[0];
-		pdata->y_min = coords[1];
-		pdata->x_max = coords[2];
-		pdata->y_max = coords[3];
-	} else {
-		dev_err(dev, "unsupported property %s\n", name);
+	if ((IS_ERR_OR_NULL(debugfs_create_file(GTP_DEBUGFS_FILE_DUMP_INFO,
+						S_IWUSR | S_IWGRP | S_IRUSR |
+						S_IRGRP, data->debug_base, data,
+						&debug_dump_info_fops)))) {
+		dev_err(&data->client->dev,
+			"Failed to create dump info file.\n");
+		debugfs_remove_recursive(data->debug_base);
 		return -EINVAL;
 	}
 
@@ -1813,7 +2908,7 @@ static int goodix_ts_get_dt_coords(struct device *dev, char *name,
 }
 
 static int goodix_parse_dt(struct device *dev,
-			struct goodix_ts_platform_data *pdata)
+			   struct goodix_ts_platform_data *pdata)
 {
 	int rc;
 	struct device_node *np = dev->of_node;
@@ -1823,6 +2918,7 @@ static int goodix_parse_dt(struct device *dev,
 	char prop_name[PROP_NAME_SIZE];
 	int i, read_cfg_num;
 
+	pdata->name = "goodix";
 	rc = goodix_ts_get_dt_coords(dev, "goodix,panel-coords", pdata);
 	if (rc && (rc != -EINVAL))
 		return rc;
@@ -1831,53 +2927,49 @@ static int goodix_parse_dt(struct device *dev,
 	if (rc)
 		return rc;
 
-	pdata->i2c_pull_up = of_property_read_bool(np,
-						"goodix,i2c-pull-up");
+	pdata->i2c_pull_up = of_property_read_bool(np, "goodix,i2c-pull-up");
 
-	pdata->force_update = of_property_read_bool(np,
-						"goodix,force-update");
+	pdata->no_force_update = of_property_read_bool(np,
+						       "goodix,no-force-update");
 
 	pdata->enable_power_off = of_property_read_bool(np,
-						"goodix,enable-power-off");
-
-	pdata->have_touch_key = of_property_read_bool(np,
-						"goodix,have-touch-key");
-
-	pdata->driver_send_cfg = of_property_read_bool(np,
-						"goodix,driver-send-cfg");
-
-	pdata->change_x2y = of_property_read_bool(np,
-						"goodix,change-x2y");
-
-	pdata->with_pen = of_property_read_bool(np,
-						"goodix,with-pen");
-
-	pdata->slide_wakeup = of_property_read_bool(np,
-						"goodix,slide-wakeup");
-
-	pdata->dbl_clk_wakeup = of_property_read_bool(np,
-						"goodix,dbl_clk_wakeup");
-
+							"goodix,enable-power-off");
+	pdata->fw_vkey_support = of_property_read_bool(np,
+						       "goodix,fw-vkey-support");
 	/* reset, irq gpio info */
 	pdata->reset_gpio = of_get_named_gpio_flags(np, "reset-gpios",
-				0, &pdata->reset_gpio_flags);
+						    0,
+						    &pdata->reset_gpio_flags);
 	if (pdata->reset_gpio < 0)
 		return pdata->reset_gpio;
 
 	pdata->irq_gpio = of_get_named_gpio_flags(np, "interrupt-gpios",
-				0, &pdata->irq_gpio_flags);
+						  0, &pdata->irq_gpio_flags);
 	if (pdata->irq_gpio < 0)
 		return pdata->irq_gpio;
 
 	rc = of_property_read_string(np, "goodix,product-id",
-						&pdata->product_id);
+				     &pdata->product_id);
 	if (rc && (rc != -EINVAL)) {
 		dev_err(dev, "Failed to parse product_id.");
 		return -EINVAL;
 	}
 
-	rc = of_property_read_string(np, "goodix,fw_name",
-						&pdata->fw_name);
+	rc = of_property_read_u32(np, "goodix,num_max_touches",
+				  &pdata->num_max_touches);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Failed to parse num_max_touches.");
+		return -EINVAL;
+	}
+
+	rc = of_property_read_u32(np, "goodix,soft_rst_dly",
+				  &pdata->soft_rst_dly);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Failed to parse soft reset delay.");
+		return -EINVAL;
+	}
+
+	rc = of_property_read_string(np, "goodix,fw_name", &pdata->fw_name);
 	if (rc && (rc != -EINVAL)) {
 		dev_err(dev, "Failed to parse firmware name.\n");
 		return -EINVAL;
@@ -1890,30 +2982,28 @@ static int goodix_parse_dt(struct device *dev,
 			return -EINVAL;
 
 		rc = of_property_read_u32_array(np,
-			"goodix,button-map", button_map,
-			num_buttons);
+						"goodix,button-map", button_map,
+						num_buttons);
 		if (rc) {
 			dev_err(dev, "Unable to read key codes\n");
 			return rc;
 		}
-		pdata->num_button = num_buttons;
-		memcpy(pdata->button_map, button_map,
-			pdata->num_button * sizeof(u32));
 	}
 
 	read_cfg_num = 0;
 	for (i = 0; i < GOODIX_MAX_CFG_GROUP; i++) {
 		snprintf(prop_name, sizeof(prop_name), "goodix,cfg-data%d", i);
 		prop = of_find_property(np, prop_name,
-			&pdata->config_data_len[i]);
+					&pdata->config_data_len[i]);
 		if (!prop || !prop->value) {
 			pdata->config_data_len[i] = 0;
 			pdata->config_data[i] = NULL;
 			continue;
 		}
 		pdata->config_data[i] = devm_kzalloc(dev,
-				GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH,
-				GFP_KERNEL);
+						     GTP_CONFIG_MAX_LENGTH +
+						     GTP_ADDR_LENGTH,
+						     GFP_KERNEL);
 		if (!pdata->config_data[i]) {
 			dev_err(dev,
 				"Not enough memory for panel config data %d\n",
@@ -1923,37 +3013,45 @@ static int goodix_parse_dt(struct device *dev,
 		pdata->config_data[i][0] = GTP_REG_CONFIG_DATA >> 8;
 		pdata->config_data[i][1] = GTP_REG_CONFIG_DATA & 0xff;
 		memcpy(&pdata->config_data[i][GTP_ADDR_LENGTH],
-				prop->value, pdata->config_data_len[i]);
+		       prop->value, pdata->config_data_len[i]);
 		read_cfg_num++;
 	}
-	dev_dbg(dev, "%d config data read from device tree.\n", read_cfg_num);
+	dev_info(dev, "%d config data read from device tree.\n", read_cfg_num);
 
 	return 0;
 }
 
 /*******************************************************
 Function:
-	I2c probe.
+    I2c probe.
 Input:
-	client: i2c device struct.
-	id: device id.
+    client: i2c device struct.
+    id: device id.
 Output:
-	Executive outcomes.
-	0: succeed.
+    Executive outcomes.
+    0: succeed.
 *******************************************************/
-
 static int goodix_ts_probe(struct i2c_client *client,
 			   const struct i2c_device_id *id)
 {
+	s32 ret = -1;
 	struct goodix_ts_platform_data *pdata;
 	struct goodix_ts_data *ts;
 	u16 version_info;
-	int ret;
 
+	GTP_DEBUG_FUNC();
+
+	/* do NOT remove these logs */
+	GTP_INFO("GTP Driver Version: %s", GTP_DRIVER_VERSION);
+	GTP_INFO("GTP Driver Built@%s, %s", __TIME__, __DATE__);
+	GTP_INFO("GTP I2C Address: 0x%02x", client->addr);
+
+	i2c_connect_client = client;
 	dev_dbg(&client->dev, "GTP I2C Address: 0x%02x\n", client->addr);
 	if (client->dev.of_node) {
 		pdata = devm_kzalloc(&client->dev,
-			sizeof(struct goodix_ts_platform_data), GFP_KERNEL);
+				     sizeof(struct goodix_ts_platform_data),
+				     GFP_KERNEL);
 		if (!pdata) {
 			dev_err(&client->dev,
 				"GTP Failed to allocate memory for pdata\n");
@@ -1963,103 +3061,110 @@ static int goodix_ts_probe(struct i2c_client *client,
 		ret = goodix_parse_dt(&client->dev, pdata);
 		if (ret)
 			return ret;
-	} else {
+	} else
 		pdata = client->dev.platform_data;
-	}
 
 	if (!pdata) {
 		dev_err(&client->dev, "GTP invalid pdata\n");
 		return -EINVAL;
 	}
 
-	i2c_connect_client = client;
-
 	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
-		dev_err(&client->dev, "GTP I2C not supported\n");
+		GTP_ERROR("I2C check functionality failed.");
 		return -ENODEV;
 	}
 
-	ts = devm_kzalloc(&client->dev, sizeof(*ts), GFP_KERNEL);
-	if (!ts) {
-		dev_err(&client->dev, "GTP not enough memory for ts\n");
+	ts = kzalloc(sizeof(*ts), GFP_KERNEL);
+	if (ts == NULL) {
+		GTP_ERROR("Alloc GFP_KERNEL memory failed.");
 		return -ENOMEM;
 	}
 
 	memset(ts, 0, sizeof(*ts));
+	INIT_WORK(&ts->work, goodix_ts_work_func);
 	ts->client = client;
 	ts->pdata = pdata;
-	/* For 2.6.39 & later use spin_lock_init(&ts->irq_lock)
-	 * For 2.6.39 & before, use ts->irq_lock = SPIN_LOCK_UNLOCKED
-	 */
 	spin_lock_init(&ts->irq_lock);
+	mutex_init(&ts->lock);
+#if GTP_ESD_PROTECT
+	ts->clk_tick_cnt = 2 * HZ;
+	GTP_DEBUG("Clock ticks for an esd cycle: %d", ts->clk_tick_cnt);
+	spin_lock_init(&ts->esd_lock);
+#endif
 	i2c_set_clientdata(client, ts);
+
 	ts->gtp_rawdiff_mode = 0;
-	ts->power_on = false;
 
-	ret = gtp_request_io_port(ts);
-	if (ret) {
-		dev_err(&client->dev, "GTP request IO port failed.\n");
+	ts->ts_info =
+	    devm_kzalloc(&client->dev, GOODIX_INFO_MAX_LEN, GFP_KERNEL);
+	if (!ts->ts_info) {
+		dev_err(&client->dev, "Not enough memory\n");
 		goto exit_free_client_data;
 	}
 
+	GOODIX_STORE_TS_INFO(ts->ts_info, ts->pdata->name,
+			     ts->pdata->num_max_touches, ts->pdata->product_id,
+			     ts->pdata->fw_vkey_support ? "yes" : "no");
+
 	ret = goodix_power_init(ts);
 	if (ret) {
 		dev_err(&client->dev, "GTP power init failed\n");
-		goto exit_free_io_port;
+		goto exit_free_ts_info;
 	}
-
 	ret = goodix_power_on(ts);
 	if (ret) {
 		dev_err(&client->dev, "GTP power on failed\n");
 		goto exit_deinit_power;
 	}
+	ret = gtp_request_io_port(ts);
+	if (ret < 0) {
+		GTP_ERROR("GTP request IO port failed.");
+		kfree(ts);
+		goto exit_power_off;
+	}
 
-	gtp_reset_guitar(ts, 20);
+	gtp_reset_guitar(ts->client, ts->pdata->soft_rst_dly);
 
 	ret = gtp_i2c_test(client);
-	if (ret != 2) {
-		dev_err(&client->dev, "I2C communication ERROR!\n");
+	if (ret < 0) {
+		GTP_ERROR("I2C communication ERROR!");
 		goto exit_power_off;
 	}
 
-	if (pdata->force_update)
-		ts->force_update = true;
+#if GTP_COMPATIBLE_MODE
+	gtp_get_chip_type(ts);
+	if (CHIP_TYPE_GT9F == ts->chip_type) {
+		ret = gtp_gt9xxf_init(ts->client);
+		if (FAIL == ret) {
+			GTP_INFO("Failed to init GT9XXF.");
+			goto exit_power_off;
+		}
+	}
+#endif
 
+	if (!pdata->no_force_update)
+		ts->force_update = true;
 	if (pdata->fw_name)
 		strlcpy(ts->fw_name, pdata->fw_name,
-						strlen(pdata->fw_name) + 1);
+			strlen(pdata->fw_name) + 1);
+
+	ret = gtp_read_version(client, &version_info);
+	if (ret < 0)
+		GTP_ERROR("Read version failed.");
 
-	if (config_enabled(CONFIG_GT9XX_TOUCHPANEL_UPDATE)) {
-		ret = gup_init_update_proc(ts);
-		if (ret < 0) {
-			dev_err(&client->dev,
-					"GTP Create firmware update thread error.\n");
-			goto exit_power_off;
-		}
-	}
 	ret = gtp_init_panel(ts);
 	if (ret < 0) {
-		dev_err(&client->dev, "GTP init panel failed.\n");
+		GTP_ERROR("GTP init panel failed.");
 		ts->abs_x_max = GTP_MAX_WIDTH;
 		ts->abs_y_max = GTP_MAX_HEIGHT;
 		ts->int_trigger_type = GTP_INT_TRIGGER;
 	}
-
-	ret = gtp_request_input_dev(ts);
-	if (ret) {
-		dev_err(&client->dev, "GTP request input dev failed.\n");
-		goto exit_free_inputdev;
-	}
-	input_set_drvdata(ts->input_dev, ts);
-
-	mutex_init(&ts->lock);
 #if defined(CONFIG_FB)
 	ts->fb_notif.notifier_call = fb_notifier_callback;
 	ret = fb_register_client(&ts->fb_notif);
 	if (ret)
 		dev_err(&ts->client->dev,
-			"Unable to register fb_notifier: %d\n",
-			ret);
+			"Unable to register fb_notifier: %d\n", ret);
 #elif defined(CONFIG_HAS_EARLYSUSPEND)
 	ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
 	ts->early_suspend.suspend = goodix_ts_early_suspend;
@@ -2067,30 +3172,44 @@ static int goodix_ts_probe(struct i2c_client *client,
 	register_early_suspend(&ts->early_suspend);
 #endif
 
-	ts->goodix_wq = create_singlethread_workqueue("goodix_wq");
-	INIT_WORK(&ts->work, goodix_ts_work_func);
-
-	ret = gtp_request_irq(ts);
-	if (ret)
-		dev_info(&client->dev, "GTP request irq failed %d.\n", ret);
+	/* Create proc file system */
+	gt91xx_config_proc =
+	    proc_create(GT91XX_CONFIG_PROC_FILE, 0666, NULL, &config_proc_ops);
+	if (gt91xx_config_proc == NULL)
+		GTP_ERROR("create_proc_entry %s failed\n",
+			  GT91XX_CONFIG_PROC_FILE);
 	else
-		dev_info(&client->dev, "GTP works in interrupt mode.\n");
+		GTP_INFO("create proc entry %s success",
+			 GT91XX_CONFIG_PROC_FILE);
 
-	ret = gtp_read_fw_version(client, &version_info);
-	if (ret != 2)
-		dev_err(&client->dev, "GTP firmware version read failed.\n");
+#if GTP_AUTO_UPDATE
+	ret = gup_init_update_proc(ts);
+	if (ret < 0)
+		GTP_ERROR("Create update thread error.");
+#endif
 
-	ret = gtp_check_product_id(client);
-	if (ret != 0) {
-		dev_err(&client->dev, "GTP Product id doesn't match.\n");
-		goto exit_free_irq;
+	ret = gtp_request_input_dev(ts);
+	if (ret < 0) {
+		GTP_ERROR("GTP request input dev failed");
+		goto exit_free_inputdev;
 	}
+
+	ret = gtp_request_irq(ts);
+	if (ret < 0)
+		GTP_INFO("GTP works in polling mode.");
+	else
+		GTP_INFO("GTP works in interrupt mode.");
+
 	if (ts->use_irq)
 		gtp_irq_enable(ts);
 
+	ts->enable = true;
+
 #ifdef CONFIG_GT9XX_TOUCHPANEL_DEBUG
+#if GTP_CREATE_WR_NODE
 	init_wr_node(client);
 #endif
+#endif
 
 #if GTP_ESD_PROTECT
 	gtp_esd_switch(client, SWITCH_ON);
@@ -2104,14 +3223,23 @@ static int goodix_ts_probe(struct i2c_client *client,
 	ret = gtp_debugfs_init(ts);
 	if (ret != 0) {
 		dev_err(&client->dev, "Failed to create debugfs entries, %d\n",
-						ret);
+			ret);
 		goto exit_remove_sysfs;
 	}
 
-	init_done = true;
 	return 0;
+
+exit_remove_sysfs:
+	sysfs_remove_group(&ts->input_dev->dev.kobj, &gtp_attr_grp);
 exit_free_irq:
-	mutex_destroy(&ts->lock);
+	input_unregister_device(ts->input_dev);
+	if (ts->input_dev) {
+		input_free_device(ts->input_dev);
+		ts->input_dev = NULL;
+	}
+	if (ts->use_irq)
+		free_irq(client->irq, ts);
+exit_free_inputdev:
 #if defined(CONFIG_FB)
 	if (fb_unregister_client(&ts->fb_notif))
 		dev_err(&client->dev,
@@ -2119,96 +3247,157 @@ exit_free_irq:
 #elif defined(CONFIG_HAS_EARLYSUSPEND)
 	unregister_early_suspend(&ts->early_suspend);
 #endif
-	if (ts->use_irq)
-		free_irq(client->irq, ts);
-	cancel_work_sync(&ts->work);
-	flush_workqueue(ts->goodix_wq);
-	destroy_workqueue(ts->goodix_wq);
-
-	input_unregister_device(ts->input_dev);
-	if (ts->input_dev) {
-		input_free_device(ts->input_dev);
-		ts->input_dev = NULL;
-	}
-exit_remove_sysfs:
-	sysfs_remove_group(&ts->input_dev->dev.kobj, &gtp_attr_grp);
-exit_free_inputdev:
-	kfree(ts->config_data);
 exit_power_off:
 	goodix_power_off(ts);
 exit_deinit_power:
 	goodix_power_deinit(ts);
-exit_free_io_port:
-	if (gpio_is_valid(pdata->reset_gpio))
-		gpio_free(pdata->reset_gpio);
-	if (gpio_is_valid(pdata->irq_gpio))
-		gpio_free(pdata->irq_gpio);
+exit_free_ts_info:
+	devm_kfree(&client->dev, ts->ts_info);
 exit_free_client_data:
+	mutex_destroy(&ts->lock);
+	cancel_work_sync(&ts->work);
 	i2c_set_clientdata(client, NULL);
+	kfree(ts);
 	return ret;
 }
 
 /*******************************************************
 Function:
-	Goodix touchscreen driver release function.
+    Goodix touchscreen driver release function.
 Input:
-	client: i2c device struct.
+    client: i2c device struct.
 Output:
-	Executive outcomes. 0---succeed.
+    Executive outcomes. 0---succeed.
 *******************************************************/
 static int goodix_ts_remove(struct i2c_client *client)
 {
 	struct goodix_ts_data *ts = i2c_get_clientdata(client);
 
-	sysfs_remove_group(&ts->input_dev->dev.kobj, &gtp_attr_grp);
+	GTP_DEBUG_FUNC();
 
-#if defined(CONFIG_FB)
-	if (fb_unregister_client(&ts->fb_notif))
-		dev_err(&client->dev,
-			"Error occurred while unregistering fb_notifier.\n");
-#elif defined(CONFIG_HAS_EARLYSUSPEND)
+#ifdef CONFIG_HAS_EARLYSUSPEND
 	unregister_early_suspend(&ts->early_suspend);
 #endif
-	mutex_destroy(&ts->lock);
 
 #ifdef CONFIG_GT9XX_TOUCHPANEL_DEBUG
+#if GTP_CREATE_WR_NODE
 	uninit_wr_node();
 #endif
+#endif
 
 #if GTP_ESD_PROTECT
-	cancel_work_sync(gtp_esd_check_workqueue);
-	flush_workqueue(gtp_esd_check_workqueue);
 	destroy_workqueue(gtp_esd_check_workqueue);
 #endif
 
 	if (ts) {
-		if (ts->use_irq)
+		if (ts->use_irq) {
+			gpio_direction_input(ts->pdata->irq_gpio);
+			gpio_free(ts->pdata->irq_gpio);
 			free_irq(client->irq, ts);
-
-		cancel_work_sync(&ts->work);
-		flush_workqueue(ts->goodix_wq);
-		destroy_workqueue(ts->goodix_wq);
-
-		input_unregister_device(ts->input_dev);
-		if (ts->input_dev) {
-			input_free_device(ts->input_dev);
-			ts->input_dev = NULL;
-		}
-
+		} else
+			hrtimer_cancel(&ts->timer);
 		if (gpio_is_valid(ts->pdata->reset_gpio))
 			gpio_free(ts->pdata->reset_gpio);
 		if (gpio_is_valid(ts->pdata->irq_gpio))
 			gpio_free(ts->pdata->irq_gpio);
-
-		goodix_power_off(ts);
-		goodix_power_deinit(ts);
-		i2c_set_clientdata(client, NULL);
 	}
+
+	GTP_INFO("GTP driver removing...");
+	i2c_set_clientdata(client, NULL);
+	input_unregister_device(ts->input_dev);
 	debugfs_remove_recursive(ts->debug_base);
+	kfree(ts);
 
 	return 0;
 }
 
+#ifdef CONFIG_HAS_EARLYSUSPEND
+/*******************************************************
+Function:
+    Early suspend function.
+Input:
+    h: early_suspend struct.
+Output:
+    None.
+*******************************************************/
+static void goodix_ts_early_suspend(struct i2c_client *client,
+				    pm_message_t mesg)
+{
+	struct goodix_ts_data *ts;
+	s8 ret = -1;
+	ts = container_of(client, struct goodix_ts_data, i2c_client);
+
+	GTP_DEBUG_FUNC();
+
+	GTP_INFO("System suspend.");
+
+	ts->gtp_is_suspend = 1;
+#if GTP_ESD_PROTECT
+	gtp_esd_switch(ts->client, SWITCH_OFF);
+#endif
+
+#if GTP_GESTURE_WAKEUP
+	ret = gtp_enter_doze(ts);
+#else
+	if (ts->use_irq)
+		gtp_irq_disable(ts);
+	else
+		hrtimer_cancel(&ts->timer);
+	ret = gtp_enter_sleep(ts);
+#endif
+	if (ret < 0)
+		GTP_ERROR("GTP early suspend failed.");
+	/* to avoid waking up while not sleeping
+	  * delay 48 + 10ms to ensure reliability
+	  */
+	msleep(58);
+}
+
+/*******************************************************
+Function:
+    Late resume function.
+Input:
+    h: early_suspend struct.
+Output:
+    None.
+*******************************************************/
+static void goodix_ts_late_resume(struct i2c_client *client)
+{
+	struct goodix_ts_data *ts;
+	s8 ret = -1;
+	ts = container_of(client, struct goodix_ts_data, i2c_client);
+
+	GTP_DEBUG_FUNC();
+
+	GTP_INFO("System resume.");
+
+	ret = gtp_wakeup_sleep(ts);
+
+#if GTP_GESTURE_WAKEUP
+	doze_status = DOZE_DISABLED;
+#endif
+
+	if (ret < 0)
+		GTP_ERROR("GTP later resume failed.");
+#if (GTP_COMPATIBLE_MODE)
+	if (CHIP_TYPE_GT9F == ts->chip_type) {
+		/* do nothing */
+	} else
+#endif
+		gtp_send_cfg(ts->client);
+
+	if (ts->use_irq)
+		gtp_irq_enable(ts);
+	else
+		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+
+	ts->gtp_is_suspend = 0;
+#if GTP_ESD_PROTECT
+	gtp_esd_switch(ts->client, SWITCH_ON);
+#endif
+}
+#endif
+
 #if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_FB)
 /*******************************************************
 Function:
@@ -2220,8 +3409,10 @@ Output:
 *******************************************************/
 static int goodix_ts_suspend(struct device *dev)
 {
+	int ret = -1;
 	struct goodix_ts_data *ts = dev_get_drvdata(dev);
-	int ret = 0, i;
+
+	GTP_DEBUG_FUNC();
 
 	if (ts->gtp_is_suspend) {
 		dev_dbg(&ts->client->dev, "Already in suspend state.\n");
@@ -2230,38 +3421,36 @@ static int goodix_ts_suspend(struct device *dev)
 
 	mutex_lock(&ts->lock);
 
+	GTP_INFO("System suspend.");
+
 	if (ts->fw_loading) {
 		dev_info(&ts->client->dev,
-			"Fw upgrade in progress, can't go to suspend.");
+			 "Fw upgrade in progress, can't go to suspend.");
 		mutex_unlock(&ts->lock);
 		return 0;
 	}
-
 #if GTP_ESD_PROTECT
 	gtp_esd_switch(ts->client, SWITCH_OFF);
 #endif
 
-	if (ts->pdata->slide_wakeup) {
-		ret = gtp_enter_doze(ts);
-	} else {
-		if (ts->use_irq)
-			gtp_irq_disable(ts);
-
-		for (i = 0; i < GTP_MAX_TOUCH; i++)
-			gtp_touch_up(ts, i);
-
-		input_sync(ts->input_dev);
-
-		ret = gtp_enter_sleep(ts);
-		if (ret < 0)
-			dev_err(&ts->client->dev, "GTP early suspend failed.\n");
-	}
-	/* to avoid waking up while not sleeping,
-	 * delay 48 + 10ms to ensure reliability
-	 */
+#if GTP_GESTURE_WAKEUP
+	ret = gtp_enter_doze(ts);
+#else
+	if (ts->use_irq)
+		gtp_irq_disable(ts);
+	else
+		hrtimer_cancel(&ts->timer);
+	ret = gtp_enter_sleep(ts);
+#endif
+	if (ret < 0)
+		GTP_ERROR("GTP early suspend failed.");
+	/* to avoid waking up while not sleeping
+	  * delay 48 + 10ms to ensure reliability
+	  */
 	msleep(58);
-	mutex_unlock(&ts->lock);
+
 	ts->gtp_is_suspend = 1;
+	mutex_unlock(&ts->lock);
 
 	return ret;
 }
@@ -2276,8 +3465,10 @@ Output:
 *******************************************************/
 static int goodix_ts_resume(struct device *dev)
 {
+	int ret = -1;
 	struct goodix_ts_data *ts = dev_get_drvdata(dev);
-	int ret = 0;
+
+	GTP_DEBUG_FUNC();
 
 	if (!ts->gtp_is_suspend) {
 		dev_dbg(&ts->client->dev, "Already in awake state.\n");
@@ -2285,37 +3476,47 @@ static int goodix_ts_resume(struct device *dev)
 	}
 
 	mutex_lock(&ts->lock);
+
+	GTP_INFO("System resume.");
 	ret = gtp_wakeup_sleep(ts);
 
-	if (ts->pdata->slide_wakeup)
-		doze_status = DOZE_DISABLED;
+#if GTP_GESTURE_WAKEUP
+	doze_status = DOZE_DISABLED;
+#endif
 
-	if (ret <= 0)
-		dev_err(&ts->client->dev, "GTP resume failed.\n");
+	if (ret < 0)
+		GTP_ERROR("GTP later resume failed.");
+#if (GTP_COMPATIBLE_MODE)
+	if (CHIP_TYPE_GT9F == ts->chip_type) {
+		/* do nothing */
+	} else
+#endif
+		gtp_send_cfg(ts->client);
 
 	if (ts->use_irq)
 		gtp_irq_enable(ts);
+	else
+		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
 
+	ts->gtp_is_suspend = 0;
 #if GTP_ESD_PROTECT
 	gtp_esd_switch(ts->client, SWITCH_ON);
 #endif
 	mutex_unlock(&ts->lock);
-	ts->gtp_is_suspend = 0;
-
 	return ret;
 }
 
 #if defined(CONFIG_FB)
 static int fb_notifier_callback(struct notifier_block *self,
-				 unsigned long event, void *data)
+				unsigned long event, void *data)
 {
 	struct fb_event *evdata = data;
 	int *blank;
 	struct goodix_ts_data *ts =
-		container_of(self, struct goodix_ts_data, fb_notif);
+	    container_of(self, struct goodix_ts_data, fb_notif);
 
 	if (evdata && evdata->data && event == FB_EVENT_BLANK &&
-			ts && ts->client) {
+	    ts && ts->client) {
 		blank = evdata->data;
 		if (*blank == FB_BLANK_UNBLANK)
 			goodix_ts_resume(&ts->client->dev);
@@ -2356,139 +3557,221 @@ static void goodix_ts_late_resume(struct early_suspend *h)
 	struct goodix_ts_data *ts;
 
 	ts = container_of(h, struct goodix_ts_data, early_suspend);
-	goodix_ts_late_resume(ts);
+	goodix_ts_resume(&ts->client->dev);
 	return;
 }
 #endif
-#endif /* !CONFIG_HAS_EARLYSUSPEND && !CONFIG_FB*/
+#endif /* !CONFIG_HAS_EARLYSUSPEND && !CONFIG_FB */
 
 #if GTP_ESD_PROTECT
+static s32 gtp_i2c_read_no_rst(struct i2c_client *client, u8 *buf, s32 len)
+{
+	struct i2c_msg msgs[2];
+	s32 ret = -1;
+	s32 retries = 0;
+
+	GTP_DEBUG_FUNC();
+
+	msgs[0].flags = !I2C_M_RD;
+	msgs[0].addr = client->addr;
+	msgs[0].len = GTP_ADDR_LENGTH;
+	msgs[0].buf = &buf[0];
+
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].addr = client->addr;
+	msgs[1].len = len - GTP_ADDR_LENGTH;
+	msgs[1].buf = &buf[GTP_ADDR_LENGTH];
+
+	while (retries < 5) {
+		ret = i2c_transfer(client->adapter, msgs, 2);
+		if (ret == 2)
+			break;
+		retries++;
+	}
+	if ((retries >= 5))
+		GTP_ERROR("I2C Read: 0x%04X, %d bytes failed, errcode: %d!",
+			  (((u16) (buf[0] << 8)) | buf[1]), len - 2, ret);
+	return ret;
+}
+
+static s32 gtp_i2c_write_no_rst(struct i2c_client *client, u8 *buf, s32 len)
+{
+	struct i2c_msg msg;
+	s32 ret = -1;
+	s32 retries = 0;
+
+	GTP_DEBUG_FUNC();
+
+	msg.flags = !I2C_M_RD;
+	msg.addr = client->addr;
+	msg.len = len;
+	msg.buf = buf;
+
+	while (retries < 5) {
+		ret = i2c_transfer(client->adapter, &msg, 1);
+		if (ret == 1)
+			break;
+		retries++;
+	}
+	if ((retries >= 5))
+		GTP_ERROR("I2C Write: 0x%04X, %d bytes failed, errcode: %d!",
+			  (((u16) (buf[0] << 8)) | buf[1]), len - 2, ret);
+	return ret;
+}
+
 /*******************************************************
 Function:
-	switch on & off esd delayed work
+    switch on & off esd delayed work
 Input:
-	client:  i2c device
-	on:	SWITCH_ON / SWITCH_OFF
+    client:  i2c device
+    on:      SWITCH_ON / SWITCH_OFF
 Output:
-	void
+    void
 *********************************************************/
-void gtp_esd_switch(struct i2c_client *client, int on)
+void gtp_esd_switch(struct i2c_client *client, s32 on)
 {
 	struct goodix_ts_data *ts;
 
 	ts = i2c_get_clientdata(client);
+	spin_lock(&ts->esd_lock);
+
 	if (SWITCH_ON == on) {
-		/* switch on esd  */
 		if (!ts->esd_running) {
 			ts->esd_running = 1;
-			dev_dbg(&client->dev, "Esd started\n");
+			spin_unlock(&ts->esd_lock);
+			GTP_INFO("Esd started");
 			queue_delayed_work(gtp_esd_check_workqueue,
-				&gtp_esd_check_work, GTP_ESD_CHECK_CIRCLE);
-		}
+					   &gtp_esd_check_work,
+					   ts->clk_tick_cnt);
+		} else
+			spin_unlock(&ts->esd_lock);
 	} else {
-		/* switch off esd */
 		if (ts->esd_running) {
 			ts->esd_running = 0;
-			dev_dbg(&client->dev, "Esd cancelled\n");
+			spin_unlock(&ts->esd_lock);
+			GTP_INFO("Esd cancelled");
 			cancel_delayed_work_sync(&gtp_esd_check_work);
-		}
+		} else
+			spin_unlock(&ts->esd_lock);
 	}
 }
 
 /*******************************************************
 Function:
-	Initialize external watchdog for esd protect
+    Initialize external watchdog for esd protect
 Input:
-	client:  i2c device.
+    client:  i2c device.
 Output:
-	result of i2c write operation.
-		1: succeed, otherwise: failed
+    result of i2c write operation.
+    1: succeed, otherwise: failed
 *********************************************************/
-static int gtp_init_ext_watchdog(struct i2c_client *client)
+static s32 gtp_init_ext_watchdog(struct i2c_client *client)
 {
-	/* in case of recursively reset by calling gtp_i2c_write*/
-	struct i2c_msg msg;
-	u8 opr_buffer[4] = {0x80, 0x40, 0xAA, 0xAA};
-	int ret;
-	int retries = 0;
-
-	msg.flags = !I2C_M_RD;
-	msg.addr  = client->addr;
-	msg.len   = 4;
-	msg.buf   = opr_buffer;
-
-	while (retries < GTP_I2C_RETRY_5) {
-		ret = i2c_transfer(client->adapter, &msg, 1);
-		if (ret == 1)
-			return 1;
-		retries++;
-	}
-	if (retries == GTP_I2C_RETRY_5)
-		dev_err(&client->dev, "init external watchdog failed!");
-	return 0;
+	u8 opr_buffer[3] = { 0x80, 0x41, 0xAA };
+	GTP_DEBUG("[Esd]Init external watchdog");
+	return gtp_i2c_write_no_rst(client, opr_buffer, 3);
 }
 
 /*******************************************************
 Function:
-	Esd protect function.
-	Added external watchdog by meta, 2013/03/07
+    Esd protect function.
+    External watchdog added by meta, 2013/03/07
 Input:
-	work: delayed work
+    work: delayed work
 Output:
-	None.
+    None.
 *******************************************************/
 static void gtp_esd_check_func(struct work_struct *work)
 {
-	s32 retry;
+	s32 i;
 	s32 ret = -1;
 	struct goodix_ts_data *ts = NULL;
-	u8 test[4] = {0x80, 0x40};
+	u8 esd_buf[5] = { 0x80, 0x40 };
+
+	GTP_DEBUG_FUNC();
 
 	ts = i2c_get_clientdata(i2c_connect_client);
 
 	if (ts->gtp_is_suspend) {
-		dev_dbg(&ts->client->dev, "Esd terminated!\n");
-		ts->esd_running = 0;
+		GTP_INFO("Esd suspended!");
 		return;
 	}
-#ifdef CONFIG_GT9XX_TOUCHPANEL_UPDATE
-	if (ts->enter_update)
-		return;
-#endif
 
-	for (retry = 0; retry < GTP_I2C_RETRY_3; retry++) {
-		ret = gtp_i2c_read(ts->client, test, 4);
+	for (i = 0; i < 3; i++) {
+		ret = gtp_i2c_read_no_rst(ts->client, esd_buf, 4);
 
+		GTP_DEBUG("[Esd]0x8040 = 0x%02X, 0x8041 = 0x%02X", esd_buf[2],
+			  esd_buf[3]);
 		if ((ret < 0)) {
-			/* IC works abnormally..*/
+			/* IIC communication problem */
 			continue;
 		} else {
-			if ((test[2] == 0xAA) || (test[3] != 0xAA)) {
-				/* IC works abnormally..*/
-				retry = GTP_I2C_RETRY_3;
-				break;
+			if ((esd_buf[2] == 0xAA) || (esd_buf[3] != 0xAA)) {
+				/* IC works abnormally.. */
+				u8 chk_buf[4] = { 0x80, 0x40 };
+
+				gtp_i2c_read_no_rst(ts->client, chk_buf, 4);
+
+				GTP_DEBUG
+				    ("[Check]0x8040 = 0x%02X, 0x8041 = 0x%02X",
+				     chk_buf[2], chk_buf[3]);
+
+				if ((chk_buf[2] == 0xAA)
+				    || (chk_buf[3] != 0xAA)) {
+					i = 3;
+					break;
+				} else
+					continue;
 			} else {
-				/* IC works normally, Write 0x8040 0xAA*/
-				test[2] = 0xAA;
-				gtp_i2c_write(ts->client, test, 3);
+				/* IC works normally,
+				  * Write 0x8040 0xAA,
+				  * feed the dog
+				  */
+				esd_buf[2] = 0xAA;
+				gtp_i2c_write_no_rst(ts->client, esd_buf, 3);
 				break;
 			}
 		}
 	}
-	if (retry == GTP_I2C_RETRY_3) {
-		dev_err(&ts->client->dev,
-			"IC Working ABNORMALLY, Resetting Guitar...\n");
-		gtp_reset_guitar(ts, 50);
+	if (i >= 3) {
+#if GTP_COMPATIBLE_MODE
+		if (CHIP_TYPE_GT9F == ts->chip_type) {
+			if (ts->rqst_processing)
+				GTP_INFO("Request processing, no esd recovery");
+			else {
+				GTP_ERROR("IC working abnormally!");
+				esd_buf[0] = 0x42;
+				esd_buf[1] = 0x26;
+				esd_buf[2] = 0x01;
+				esd_buf[3] = 0x01;
+				esd_buf[4] = 0x01;
+				gtp_i2c_write_no_rst(ts->client, esd_buf, 5);
+				msleep(50);
+				gtp_esd_recovery(ts->client);
+			}
+		} else
+#endif
+		{
+			GTP_ERROR
+			    ("IC working abnormally! Process reset guitar.");
+			esd_buf[0] = 0x42;
+			esd_buf[1] = 0x26;
+			esd_buf[2] = 0x01;
+			esd_buf[3] = 0x01;
+			esd_buf[4] = 0x01;
+			gtp_i2c_write_no_rst(ts->client, esd_buf, 5);
+			msleep(50);
+			gtp_reset_guitar(ts->client, 50);
+			msleep(50);
+			gtp_send_cfg(ts->client);
+		}
 	}
 
 	if (!ts->gtp_is_suspend)
-		queue_delayed_work(gtp_esd_check_workqueue,
-			&gtp_esd_check_work, GTP_ESD_CHECK_CIRCLE);
-	else {
-		dev_dbg(&ts->client->dev, "Esd terminated!\n");
-		ts->esd_running = 0;
-	}
-
+		queue_delayed_work(gtp_esd_check_workqueue, &gtp_esd_check_work,
+				   ts->clk_tick_cnt);
+	else
+		GTP_INFO("Esd suspended!");
 	return;
 }
 #endif
@@ -2504,31 +3787,31 @@ static const struct dev_pm_ops goodix_ts_dev_pm_ops = {
 #endif
 
 static const struct i2c_device_id goodix_ts_id[] = {
-	{ GTP_I2C_NAME, 0 },
-	{ }
+	{GTP_I2C_NAME, 0},
+	{}
 };
 
 static struct of_device_id goodix_match_table[] = {
-	{ .compatible = "goodix,gt9xx", },
-	{ },
+	{.compatible = "goodix,gt9xx",},
+	{},
 };
 
 static struct i2c_driver goodix_ts_driver = {
-	.probe      = goodix_ts_probe,
-	.remove     = goodix_ts_remove,
+	.probe = goodix_ts_probe,
+	.remove = goodix_ts_remove,
 #ifdef CONFIG_HAS_EARLYSUSPEND
-	.suspend    = goodix_ts_early_suspend,
-	.resume     = goodix_ts_late_resume,
+	.suspend = goodix_ts_early_suspend,
+	.resume = goodix_ts_late_resume,
 #endif
-	.id_table   = goodix_ts_id,
+	.id_table = goodix_ts_id,
 	.driver = {
-		.name     = GTP_I2C_NAME,
-		.owner    = THIS_MODULE,
-		.of_match_table = goodix_match_table,
+		   .name = GTP_I2C_NAME,
+		   .owner = THIS_MODULE,
+		   .of_match_table = goodix_match_table,
 #if CONFIG_PM
-		.pm = &goodix_ts_dev_pm_ops,
+		   .pm = &goodix_ts_dev_pm_ops,
 #endif
-	},
+		   },
 };
 
 /*******************************************************
@@ -2541,27 +3824,35 @@ Output:
 ********************************************************/
 static int __init goodix_ts_init(void)
 {
-	int ret;
-
+	GTP_DEBUG_FUNC();
+	GTP_INFO("GTP driver installing...");
+	goodix_wq = create_singlethread_workqueue("goodix_wq");
+	if (!goodix_wq) {
+		GTP_ERROR("Creat workqueue failed.");
+		return -ENOMEM;
+	}
 #if GTP_ESD_PROTECT
 	INIT_DELAYED_WORK(&gtp_esd_check_work, gtp_esd_check_func);
 	gtp_esd_check_workqueue = create_workqueue("gtp_esd_check");
 #endif
-	ret = i2c_add_driver(&goodix_ts_driver);
-	return ret;
+	return i2c_add_driver(&goodix_ts_driver);
 }
 
 /*******************************************************
 Function:
-	Driver uninstall function.
+    Driver uninstall function.
 Input:
-	None.
+    None.
 Output:
-	Executive Outcomes. 0---succeed.
+    Executive Outcomes. 0---succeed.
 ********************************************************/
 static void __exit goodix_ts_exit(void)
 {
+	GTP_DEBUG_FUNC();
+	GTP_INFO("GTP driver exited.");
 	i2c_del_driver(&goodix_ts_driver);
+	if (goodix_wq)
+		destroy_workqueue(goodix_wq);
 }
 
 module_init(goodix_ts_init);
diff --git a/drivers/input/touchscreen/gt9xx/gt9xx.h b/drivers/input/touchscreen/gt9xx/gt9xx.h
index 3cedf26..7f4c0ad 100644
--- a/drivers/input/touchscreen/gt9xx/gt9xx.h
+++ b/drivers/input/touchscreen/gt9xx/gt9xx.h
@@ -1,10 +1,5 @@
 /* drivers/input/touchscreen/gt9xx.h
  *
- * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
- *
- * Linux Foundation chooses to take subject only to the GPLv2 license
- * terms, and distributes only under these terms.
- *
  * 2010 - 2013 Goodix Technology.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -24,10 +19,22 @@
 #define _GOODIX_GT9XX_H_
 
 #include <linux/kernel.h>
+#include <linux/hrtimer.h>
 #include <linux/i2c.h>
+#include <linux/irq.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/module.h>
 #include <linux/delay.h>
-#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/proc_fs.h>
+#include <linux/debugfs.h>
+#include <linux/string.h>
 #include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <mach/gpio.h>
 
 #if defined(CONFIG_FB)
 #include <linux/notifier.h>
@@ -36,18 +43,59 @@
 #include <linux/earlysuspend.h>
 #define GOODIX_SUSPEND_LEVEL 1
 #endif
+/***************************PART1:ON/OFF define*******************************/
+#define UPDATE_FUNCTIONS
+
+#define GTP_CUSTOM_CFG        0
+#define GTP_CHANGE_X2Y        0
+#define GTP_DRIVER_SEND_CFG   1
+#define GTP_HAVE_TOUCH_KEY    1
+#define GTP_POWER_CTRL_SLEEP  0
+#define GTP_ICS_SLOT_REPORT   1
+
+#define GTP_AUTO_UPDATE       0	/* auto update fw by .bin file as default */
+#define GTP_HEADER_FW_UPDATE  0	/* auto update fw by gtp_default_FW
+				  * in gt9xx_firmware.h, function together
+				  * with GTP_AUTO_UPDATE
+				  */
+#define GTP_AUTO_UPDATE_CFG   0	/* auto update config by .cfg file,
+				  *function together with GTP_AUTO_UPDATE
+				  */
+
+#define GTP_COMPATIBLE_MODE   0	/* compatible with GT9XXF */
 
-#define MAX_BUTTONS 4
+#define GTP_CREATE_WR_NODE    1
+#define GTP_ESD_PROTECT       0	/* esd protection with a cycle of 2 seconds */
+
+#define GTP_WITH_PEN          0
+#define GTP_PEN_HAVE_BUTTON   0	/* active pen has buttons, function
+				  * together with GTP_WITH_PEN
+				  */
+
+#define GTP_GESTURE_WAKEUP    0	/* gesture wakeup */
+
+#define GTP_DEBUG_ON          0
+#define GTP_DEBUG_ARRAY_ON    0
+#define GTP_DEBUG_FUNC_ON     0
+
+#if GTP_COMPATIBLE_MODE
+enum chip_type_t {
+	CHIP_TYPE_GT9 = 0,
+	CHIP_TYPE_GT9F = 1,
+};
+#endif
 #define GOODIX_MAX_CFG_GROUP	6
 #define GTP_FW_NAME_MAXSIZE	50
-
 struct goodix_ts_platform_data {
 	int irq_gpio;
 	u32 irq_gpio_flags;
 	int reset_gpio;
 	u32 reset_gpio_flags;
+	u32 num_max_touches;
+	u32 soft_rst_dly;
 	const char *product_id;
 	const char *fw_name;
+	char *name;
 	u32 x_max;
 	u32 y_max;
 	u32 x_min;
@@ -56,54 +104,62 @@ struct goodix_ts_platform_data {
 	u32 panel_miny;
 	u32 panel_maxx;
 	u32 panel_maxy;
-	bool force_update;
+	bool no_force_update;
 	bool i2c_pull_up;
 	bool enable_power_off;
+	bool fw_vkey_support;
 	size_t config_data_len[GOODIX_MAX_CFG_GROUP];
 	u8 *config_data[GOODIX_MAX_CFG_GROUP];
-	u32 button_map[MAX_BUTTONS];
-	u8 num_button;
-	bool have_touch_key;
-	bool driver_send_cfg;
-	bool change_x2y;
-	bool with_pen;
-	bool slide_wakeup;
-	bool dbl_clk_wakeup;
 };
 struct goodix_ts_data {
 	spinlock_t irq_lock;
 	struct i2c_client *client;
-	struct input_dev  *input_dev;
+	struct input_dev *input_dev;
 	struct goodix_ts_platform_data *pdata;
 	struct hrtimer timer;
-	struct workqueue_struct *goodix_wq;
-	struct work_struct	work;
-	char fw_name[GTP_FW_NAME_MAXSIZE];
-	struct delayed_work goodix_update_work;
-	s32 irq_is_disabled;
+	struct work_struct work;
+	u8 enable;
+	u16 addr;
+	s32 irq_is_disable;
 	s32 use_irq;
 	u16 abs_x_max;
 	u16 abs_y_max;
-	u16 addr;
-	u8  max_touch_num;
-	u8  int_trigger_type;
-	u8  green_wake_mode;
-	u8  chip_type;
-	u8 *config_data;
-	u8  enter_update;
-	u8  gtp_is_suspend;
-	u8  gtp_rawdiff_mode;
-	u8  gtp_cfg_len;
-	u8  fixed_cfg;
-	u8  esd_running;
-	u8  fw_error;
-	bool power_on;
-	struct mutex lock;
+	u8 max_touch_num;
+	u8 int_trigger_type;
+	u8 green_wake_mode;
+	u8 enter_update;
+	u8 gtp_is_suspend;
+	u8 gtp_rawdiff_mode;
+	u8 gtp_cfg_len;
+	u8 fixed_cfg;
+	u8 fw_error;
+	u8 pnl_init_error;
 	bool fw_loading;
+	char fw_name[GTP_FW_NAME_MAXSIZE];
+	char *ts_info;
 	bool force_update;
-	struct regulator *avdd;
 	struct regulator *vdd;
 	struct regulator *vcc_i2c;
+	bool power_on;
+#if GTP_WITH_PEN
+	struct input_dev *pen_dev;
+#endif
+
+#if GTP_ESD_PROTECT
+	spinlock_t esd_lock;
+	u8 esd_running;
+	s32 clk_tick_cnt;
+#endif
+
+#if GTP_COMPATIBLE_MODE
+	u16 bak_ref_len;
+	s32 ref_chk_fs_times;
+	s32 clk_chk_fs_times;
+	enum chip_type_t chip_type;
+	u8 rqst_processing;
+	u8 is_950;
+#endif
+	struct mutex lock;
 #if defined(CONFIG_FB)
 	struct notifier_block fb_notif;
 #elif defined(CONFIG_HAS_EARLYSUSPEND)
@@ -115,111 +171,223 @@ struct goodix_ts_data {
 extern u16 show_len;
 extern u16 total_len;
 
-/***************************PART1:ON/OFF define*******************************/
-#define GTP_CUSTOM_CFG			0
-#define GTP_ESD_PROTECT			0
+/******************* PART2:TODO define *************************/
+/* STEP_1(REQUIRED): Define Configuration Information Group(s)
+    Sensor_ID Map:
+   sensor_opt1 sensor_opt2 Sensor_ID
+    GND         GND         0
+    VDDIO       GND         1
+    NC          GND         2
+    GND         NC/300K     3
+    VDDIO       NC/300K     4
+    NC          NC/300K     5
+*/
+/* TODO: define your own default or for Sensor_ID == 0 config here. */
+/* The predefined one is just a sample config,
+  * which is not suitable for your tp in most cases.
+  */
+#define CTP_CFG_GROUP1 {\
+	0x41, 0xD0, 0x02, 0x00, 0x05, 0x0A, 0x34, 0x01, 0x01, 0x0B,\
+	0x19, 0x0A, 0x4B, 0x37, 0x03, 0x05, 0x00, 0x00, 0x00, 0x00,\
+	0x00, 0x00, 0x00, 0x16, 0x1A, 0x1E, 0x14, 0x8C, 0x0C, 0x0D,\
+	0x25, 0x24, 0x6A, 0x0D, 0x00, 0x00, 0x00, 0x02, 0x03, 0x1D,\
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x64, 0x32, 0x00, 0x00,\
+	0x00, 0x3C, 0x96, 0x99, 0x05, 0x02, 0x06, 0x00, 0x00, 0x05,\
+	0x0D, 0x27, 0x5D, 0x0F, 0x28, 0xED, 0x10, 0x2B, 0x91, 0x17,\
+	0x25, 0x59, 0x18, 0x2C, 0x00, 0x00, 0x10, 0x38, 0x60, 0x00,\
+	0xF0, 0x40, 0x30, 0xFF, 0xFF, 0x16, 0x00, 0x00, 0x2C, 0x2C,\
+	0x00, 0x01, 0x1E, 0x1E, 0x14, 0x14, 0x00, 0x00, 0x02, 0x00,\
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
+	0x00, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0E, 0x10,\
+	0x12, 0x14, 0x16, 0x18, 0x1A, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\
+	0xFF, 0xFF, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0F,\
+	0x10, 0x12, 0x13, 0x14, 0x16, 0x18, 0x1C, 0x1D, 0x1E, 0x1F,\
+	0x20, 0x21, 0x22, 0x24, 0x26, 0x28, 0xFF, 0xFF, 0xFF, 0xFF,\
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\
+	0xFF, 0xFF, 0xFF, 0xFF, 0x3D, 0x01\
+}
+
+/* TODO: define your config for Sensor_ID == 1 here, if needed */
+#define CTP_CFG_GROUP2 {\
+}
+
+/* TODO: define your config for Sensor_ID == 2 here, if needed */
+#define CTP_CFG_GROUP3 {\
+}
+
+/* TODO: define your config for Sensor_ID == 3 here, if needed */
+#define CTP_CFG_GROUP4 {\
+}
+
+/* TODO: define your config for Sensor_ID == 4 here, if needed */
+#define CTP_CFG_GROUP5 {\
+}
 
-#define GTP_IRQ_TAB            {\
-				IRQ_TYPE_EDGE_RISING,\
-				IRQ_TYPE_EDGE_FALLING,\
-				IRQ_TYPE_LEVEL_LOW,\
-				IRQ_TYPE_LEVEL_HIGH\
-				}
+/* TODO: define your config for Sensor_ID == 5 here, if needed */
+#define CTP_CFG_GROUP6 {\
+}
 
+/* STEP_2(REQUIRED): Customize your I/O ports & I/O operations */
+#define GTP_IRQ_TAB	{\
+	IRQ_TYPE_EDGE_RISING, \
+	IRQ_TYPE_EDGE_FALLING, \
+	IRQ_TYPE_LEVEL_LOW, \
+	IRQ_TYPE_LEVEL_HIGH }
 
-#define GTP_IRQ_TAB_RISING	0
-#define GTP_IRQ_TAB_FALLING	1
+/* STEP_3(optional): Specify your special config info if needed */
 #if GTP_CUSTOM_CFG
-#define GTP_MAX_HEIGHT		800
-#define GTP_MAX_WIDTH		480
-#define GTP_INT_TRIGGER		GTP_IRQ_TAB_RISING
+#define GTP_MAX_HEIGHT   800
+#define GTP_MAX_WIDTH    480
+#define GTP_INT_TRIGGER  0	/* 0: Rising 1: Falling */
 #else
-#define GTP_MAX_HEIGHT		4096
-#define GTP_MAX_WIDTH		4096
-#define GTP_INT_TRIGGER		GTP_IRQ_TAB_FALLING
+#define GTP_MAX_HEIGHT   4096
+#define GTP_MAX_WIDTH    4096
+#define GTP_INT_TRIGGER  1
 #endif
+#define GTP_MAX_TOUCH    5
 
-#define GTP_PRODUCT_ID_MAXSIZE	5
-#define GTP_PRODUCT_ID_BUFFER_MAXSIZE	6
-#define GTP_FW_VERSION_BUFFER_MAXSIZE	4
-#define GTP_MAX_TOUCH		5
-#define GTP_ESD_CHECK_CIRCLE	2000      /* jiffy: ms */
+/* STEP_4(optional): If keys are available and
+  * reported as keys, config your key info here
+  */
+#if GTP_HAVE_TOUCH_KEY
+#define GTP_KEY_TAB  {KEY_MENU, KEY_HOMEPAGE, KEY_BACK}
+#endif
 
 /***************************PART3:OTHER define*********************************/
-#define GTP_DRIVER_VERSION	"V1.8.1<2013/09/01>"
-#define GTP_I2C_NAME		"Goodix-TS"
-#define GTP_POLL_TIME		10     /* jiffy: ms*/
-#define GTP_ADDR_LENGTH		2
-#define GTP_CONFIG_MIN_LENGTH	186
-#define GTP_CONFIG_MAX_LENGTH	240
-#define FAIL			0
-#define SUCCESS			1
-#define SWITCH_OFF		0
-#define SWITCH_ON		1
+#define GTP_DRIVER_VERSION          "V2.2<2014/01/14>"
+#define GTP_I2C_NAME                "Goodix-TS"
+#define GT91XX_CONFIG_PROC_FILE     "gt9xx_config"
+#define GTP_POLL_TIME         10
+#define GTP_ADDR_LENGTH       2
+#define GTP_CONFIG_MIN_LENGTH 186
+#define GTP_CONFIG_MAX_LENGTH 240
+#define FAIL                  0
+#define SUCCESS               1
+#define SWITCH_OFF            0
+#define SWITCH_ON             1
+
+/******************** For GT9XXF Start **********************/
+#define GTP_REG_BAK_REF                 0x99D0
+#define GTP_REG_MAIN_CLK                0x8020
+#define GTP_REG_CHIP_TYPE               0x8000
+#define GTP_REG_HAVE_KEY                0x804E
+#define GTP_REG_MATRIX_DRVNUM           0x8069
+#define GTP_REG_MATRIX_SENNUM           0x806A
+
+#define GTP_FL_FW_BURN              0x00
+#define GTP_FL_ESD_RECOVERY         0x01
+#define GTP_FL_READ_REPAIR          0x02
 
+#define GTP_BAK_REF_SEND                0
+#define GTP_BAK_REF_STORE               1
+#define CFG_LOC_DRVA_NUM                29
+#define CFG_LOC_DRVB_NUM                30
+#define CFG_LOC_SENS_NUM                31
+
+#define GTP_CHK_FW_MAX                  40
+#define GTP_CHK_FS_MNT_MAX              300
+#define GTP_BAK_REF_PATH                "/data/gtp_ref.bin"
+#define GTP_MAIN_CLK_PATH               "/data/gtp_clk.bin"
+#define GTP_RQST_CONFIG                 0x01
+#define GTP_RQST_BAK_REF                0x02
+#define GTP_RQST_RESET                  0x03
+#define GTP_RQST_MAIN_CLOCK             0x04
+#define GTP_RQST_RESPONDED              0x00
+#define GTP_RQST_IDLE                   0xFF
+
+/******************** For GT9XXF End **********************/
 /* Registers define */
-#define GTP_READ_COOR_ADDR	0x814E
-#define GTP_REG_SLEEP		0x8040
-#define GTP_REG_SENSOR_ID	0x814A
-#define GTP_REG_CONFIG_DATA	0x8047
-#define GTP_REG_FW_VERSION	0x8144
-#define GTP_REG_PRODUCT_ID	0x8140
-
-#define GTP_I2C_RETRY_3		3
-#define GTP_I2C_RETRY_5		5
-#define GTP_I2C_RETRY_10	10
-
-#define RESOLUTION_LOC		3
-#define TRIGGER_LOC		8
-
-/* HIGH: 0x28/0x29, LOW: 0xBA/0xBB */
-#define GTP_I2C_ADDRESS_HIGH	0x14
-#define GTP_I2C_ADDRESS_LOW	0x5D
+#define GTP_READ_COOR_ADDR    0x814E
+#define GTP_REG_SLEEP         0x8040
+#define GTP_REG_SENSOR_ID     0x814A
+#define GTP_REG_CONFIG_DATA   0x8047
+#define GTP_REG_VERSION       0x8140
 #define GTP_VALID_ADDR_START	0x8040
 #define GTP_VALID_ADDR_END	0x8177
 
-#define CFG_GROUP_LEN(p_cfg_grp) (sizeof(p_cfg_grp) / sizeof(p_cfg_grp[0]))
-
-/* GTP CM_HEAD RW flags */
-#define GTP_RW_READ			0
-#define GTP_RW_WRITE			1
-#define GTP_RW_READ_IC_TYPE		2
-#define GTP_RW_WRITE_IC_TYPE		3
-#define GTP_RW_FILL_INFO		4
-#define GTP_RW_NO_WRITE			5
-#define GTP_RW_READ_ERROR		6
-#define GTP_RW_DISABLE_IRQ		7
-#define GTP_RW_READ_VERSION		8
-#define GTP_RW_ENABLE_IRQ		9
-#define GTP_RW_ENTER_UPDATE_MODE	11
-#define GTP_RW_LEAVE_UPDATE_MODE	13
-#define GTP_RW_UPDATE_FW		15
-#define GTP_RW_CHECK_RAWDIFF_MODE	17
-
-/* GTP need flag or interrupt */
-#define GTP_NO_NEED			0
-#define GTP_NEED_FLAG			1
-#define GTP_NEED_INTERRUPT		2
+#define RESOLUTION_LOC        3
+#define TRIGGER_LOC           8
+
+#define CFG_GROUP_LEN(p_cfg_grp)  (sizeof(p_cfg_grp) / sizeof(p_cfg_grp[0]))
+/* Log define */
+#define GTP_INFO(fmt, arg...) pr_info("<<-GTP-INFO->> "fmt"\n", ##arg)
+#define GTP_ERROR(fmt, arg...) pr_err("<<-GTP-ERROR->> "fmt"\n", ##arg)
+#define GTP_DEBUG(fmt, arg...) \
+	do {\
+		if (GTP_DEBUG_ON)\
+			pr_debug("<<-GTP-DEBUG->> [%d]"fmt"\n",\
+					__LINE__, ##arg);\
+	} while (0)
+#define GTP_DEBUG_ARRAY(array, num) \
+	do {\
+		s32 i;\
+		u8 *a = array;\
+		if (GTP_DEBUG_ARRAY_ON) {\
+			pr_debug("<<-GTP-DEBUG-ARRAY->>\n");\
+			for (i = 0; i < (num); i++) {\
+				pr_debug("%02x   ", (a)[i]);\
+				if ((i + 1) % 10 == 0) \
+					pr_debug("\n");\
+			} \
+			pr_debug("\n");\
+		} \
+	} while (0)
+#define GTP_DEBUG_FUNC() \
+	do {\
+		if (GTP_DEBUG_FUNC_ON)\
+			pr_debug("<<-GTP-FUNC->> Func:%s@Line:%d\n",\
+					__func__, __LINE__);\
+	} while (0)
+#define GTP_SWAP(x, y) \
+	do {\
+		typeof(x) z = x;\
+		x = y;\
+		y = z;\
+	} while (0)
 
 /*****************************End of Part III********************************/
+extern struct i2c_client *i2c_connect_client;
+extern u8 config[GTP_CONFIG_MAX_LENGTH + GTP_ADDR_LENGTH];
+void gtp_reset_guitar(struct i2c_client *client, s32 ms);
+s32 gtp_send_cfg(struct i2c_client *client);
+s32 gtp_read_version(struct i2c_client *, u16 *);
+s32 gtp_i2c_read_dbl_check(struct i2c_client *, u16, u8 *, int);
 
-void gtp_esd_switch(struct i2c_client *client, int on);
+#ifdef UPDATE_FUNCTIONS
+s32 gup_enter_update_mode(struct i2c_client *client);
+void gup_leave_update_mode(void);
+s32 gup_update_proc(void *dir);
+#endif
 
-int gtp_i2c_read_dbl_check(struct i2c_client *client, u16 addr,
-					u8 *rxbuf, int len);
-int gtp_send_cfg(struct goodix_ts_data *ts);
-void gtp_reset_guitar(struct goodix_ts_data *ts, int ms);
-void gtp_irq_disable(struct goodix_ts_data *ts);
-void gtp_irq_enable(struct goodix_ts_data *ts);
+void gtp_irq_disable(struct goodix_ts_data *);
+void gtp_irq_enable(struct goodix_ts_data *);
+
+#if GTP_ESD_PROTECT
+void gtp_esd_switch(struct i2c_client *, s32);
+#endif
 
 #ifdef CONFIG_GT9XX_TOUCHPANEL_DEBUG
-s32 init_wr_node(struct i2c_client *client);
+#if GTP_CREATE_WR_NODE
+s32 init_wr_node(struct i2c_client *);
 void uninit_wr_node(void);
 #endif
+#endif
+
+#if GTP_AUTO_UPDATE
+extern u8 gup_init_update_proc(struct goodix_ts_data *);
+#endif
+
+#if GTP_COMPATIBLE_MODE
+s32 i2c_read_bytes(struct i2c_client *client, u16 addr, u8 *buf,
+			  s32 len);
+s32 i2c_write_bytes(struct i2c_client *client, u16 addr, u8 *buf,
+			   s32 len);
+s32 gup_clk_calibration(void);
+s32 gup_fw_download_proc(void *dir, u8 dwn_mode);
+u8 gup_check_fs_mounted(char *path_name);
+void gtp_recovery_reset(struct i2c_client *client);
+s32 gtp_fw_startup(struct i2c_client *client);
+#endif
 
-u8 gup_init_update_proc(struct goodix_ts_data *ts);
-s32 gup_enter_update_mode(struct i2c_client *client);
-void gup_leave_update_mode(struct i2c_client *client);
-s32 gup_update_proc(void *dir);
-extern struct i2c_client  *i2c_connect_client;
 #endif /* _GOODIX_GT9XX_H_ */
diff --git a/drivers/input/touchscreen/gt9xx/gt9xx_firmware.h b/drivers/input/touchscreen/gt9xx/gt9xx_firmware.h
new file mode 100644
index 0000000..92a353b
--- /dev/null
+++ b/drivers/input/touchscreen/gt9xx/gt9xx_firmware.h
@@ -0,0 +1,3715 @@
+/* Copyright Statement:
+*This firmware are protected under relevant copyright laws,
+*this information contained
+*herein is confidential and proprietary to Goodix.
+*
+*GOODIX (C) 2013. All rights reserved.
+*
+*WARNING:The GTP_COMPATIBLE_MODE part of this file
+*was generated by the specialized tools,
+*please do not modify it manually!
+*
+*/
+
+#ifndef _GT9XX_FIRMWARE_H_
+#define _GT9XX_FIRMWARE_H_
+
+#if GTP_HEADER_FW_UPDATE
+unsigned char gtp_default_FW[] = {
+	/* TODO:Puts your update firmware data here! */
+};
+#endif
+
+#if GTP_COMPATIBLE_MODE
+unsigned char gtp_default_FW_fl[] = {
+	0x00, 0x90, 0x06, 0x00, 0x39, 0x35, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
+	    0x10, 0x30, 0x80, 0x00, 0x55, 0x40, 0xA4, 0x28,
+	0xB3, 0x26, 0x69, 0xF0, 0x0C, 0xC1, 0x38, 0xA8, 0xD5, 0xA0, 0x88, 0xB0,
+	    0x01, 0x41, 0xF0, 0x90, 0x72, 0xAF, 0x32, 0xE0,
+	0x1D, 0xC9, 0x26, 0xCA, 0x49, 0x8C, 0x01, 0x8D, 0x05, 0x02, 0xA5, 0x49,
+	    0xF3, 0xDD, 0x12, 0x6B, 0x4D, 0x21, 0x39, 0x24,
+	0xEB, 0x96, 0x09, 0x0D, 0x87, 0x03, 0x49, 0x39, 0x72, 0x6F, 0x09, 0x7B,
+	    0x4D, 0x4B, 0xC0, 0x30, 0x04, 0x0F, 0x84, 0xC6,
+	0x62, 0x09, 0x38, 0x63, 0xB3, 0xAE, 0x8F, 0x53, 0x71, 0x87, 0xC7, 0x17,
+	    0x2A, 0xC5, 0x58, 0x22, 0xE8, 0x5C, 0xF0, 0x06,
+	0x50, 0xD5, 0x2A, 0x34, 0xE0, 0x5E, 0xFE, 0x80, 0xF0, 0xE1, 0xED, 0xC4,
+	    0x8C, 0x40, 0x46, 0xAD, 0x02, 0xE9, 0xEE, 0x87,
+	0x67, 0x40, 0x0B, 0xF5, 0x39, 0xD7, 0x37, 0x3C, 0x01, 0x03, 0x90, 0x74,
+	    0x34, 0x6B, 0x97, 0x17, 0x83, 0xCB, 0x80, 0x76,
+	0x34, 0x7C, 0x47, 0xAC, 0x2C, 0x48, 0x35, 0x8E, 0x1B, 0xCC, 0x10, 0xDA,
+	    0x0F, 0x4C, 0x56, 0x72, 0x56, 0x76, 0x9A, 0x3C,
+	0x2F, 0x49, 0xC2, 0x0A, 0xBA, 0x2F, 0x20, 0x3A, 0x55, 0x69, 0xC7, 0x5E,
+	    0xA6, 0x2B, 0x58, 0xA0, 0x0F, 0x08, 0xD9, 0x1D,
+	0x3B, 0x2C, 0x17, 0x7D, 0x2F, 0xB4, 0xEE, 0xD6, 0x5A, 0x6E, 0x5A, 0x19,
+	    0xAF, 0x48, 0x03, 0xB1, 0x78, 0x24, 0x9B, 0x29,
+	0xD9, 0x49, 0x44, 0x0E, 0x5B, 0x0C, 0xC9, 0x2A, 0x87, 0x6E, 0x07, 0xCE,
+	    0x9A, 0x45, 0x18, 0x8A, 0x79, 0xEF, 0xC4, 0x0A,
+	0xA5, 0x77, 0xD3, 0x59, 0x60, 0x74, 0x8E, 0xB4, 0xDF, 0xE6, 0x03, 0x76,
+	    0x4D, 0xFD, 0x18, 0x9A, 0x68, 0x4C, 0x53, 0x2B,
+	0xCE, 0xA5, 0xFB, 0x6B, 0x73, 0x68, 0xAB, 0xEB, 0x4A, 0x44, 0xC1, 0x0B,
+	    0xA6, 0x75, 0x13, 0xDB, 0x0B, 0x97, 0xCF, 0xB5,
+	0xB3, 0x62, 0xE3, 0xFD, 0xB4, 0xEA, 0x63, 0x95, 0x4B, 0xAE, 0x04, 0x80,
+	    0x78, 0xF8, 0x7C, 0x74, 0x38, 0x3F, 0x2C, 0xC0,
+	0xD0, 0x58, 0xCD, 0x2B, 0xD7, 0x6B, 0xDE, 0xB0, 0x26, 0xE9, 0x64, 0xAE,
+	    0xB3, 0x19, 0xE5, 0xC2, 0xEF, 0x34, 0x64, 0x5C,
+	0x01, 0xFA, 0x4F, 0x28, 0x82, 0x11, 0x2D, 0xBB, 0x37, 0x47, 0x64, 0xD3,
+	    0x6E, 0x37, 0xB2, 0x53, 0xC3, 0x72, 0x02, 0x1D,
+	0x24, 0xE6, 0x0B, 0x65, 0xF5, 0x3C, 0x64, 0xC3, 0x6F, 0x36, 0x19, 0x53,
+	    0x73, 0x77, 0x1B, 0xD0, 0x24, 0xEF, 0xFC, 0x14,
+	0x3E, 0xB4, 0x94, 0x1D, 0x8A, 0x4F, 0x6F, 0x54, 0xBE, 0xEB, 0xB4, 0xA2,
+	    0xDC, 0xCA, 0xED, 0xA2, 0xC4, 0x5B, 0x7C, 0x20,
+	0x50, 0xA1, 0x68, 0x8F, 0xD0, 0x84, 0x73, 0x29, 0x62, 0xEB, 0x9C, 0xCE,
+	    0x55, 0x2D, 0xF1, 0x9E, 0x45, 0x50, 0xB5, 0x42,
+	0xEE, 0x79, 0xF2, 0x96, 0x61, 0xB7, 0x2A, 0x95, 0xFB, 0xCB, 0x9D, 0xED,
+	    0x17, 0x51, 0x22, 0x8B, 0x81, 0x71, 0xC6, 0x75,
+	0x72, 0xB3, 0xE6, 0xCD, 0x7C, 0x37, 0x3F, 0xFB, 0xEC, 0x44, 0x9F, 0xCE,
+	    0xFA, 0x5C, 0x79, 0x69, 0x1E, 0x1C, 0x09, 0x7E,
+	0xBB, 0x11, 0x66, 0x9F, 0xF8, 0xF5, 0x93, 0xDE, 0xFB, 0x5D, 0x37, 0xD7,
+	    0xC3, 0x21, 0xE7, 0xCC, 0xF0, 0xB1, 0xBE, 0xFA,
+	0x64, 0x06, 0x1D, 0x4F, 0x7A, 0x7E, 0x51, 0x69, 0x92, 0xB0, 0x8D, 0x7F,
+	    0xBF, 0xB3, 0xBF, 0xF3, 0x7C, 0xF7, 0x11, 0x5F,
+	0x7B, 0x7F, 0x0E, 0xF8, 0x49, 0x3D, 0x7D, 0x93, 0xBA, 0xBC, 0x76, 0x2D,
+	    0x59, 0x28, 0xA4, 0x71, 0xD9, 0x19, 0x1C, 0x6A,
+	0xC0, 0x79, 0x97, 0xC5, 0xC6, 0x72, 0xA8, 0x05, 0x72, 0xC6, 0xC3, 0x9E,
+	    0x90, 0x34, 0xD4, 0x3A, 0x2E, 0x93, 0x9E, 0xEC,
+	0x1F, 0xC1, 0x97, 0xF5, 0x1E, 0x85, 0x68, 0x0F, 0x78, 0x7A, 0x15, 0x26,
+	    0x08, 0xE2, 0x96, 0xEC, 0x1E, 0xC0, 0x7F, 0x00,
+	0x20, 0x24, 0x6B, 0x9F, 0x10, 0x16, 0x20, 0x02, 0x04, 0xC0, 0x14, 0x16,
+	    0xB7, 0xE2, 0x20, 0x62, 0xC4, 0xC6, 0xB4, 0x59,
+	0xF7, 0x3B, 0x28, 0x12, 0x05, 0xC1, 0xC8, 0x14, 0x4B, 0x0C, 0x3C, 0xB5,
+	    0x64, 0x56, 0x88, 0xCF, 0xAA, 0xA3, 0xFA, 0x1C,
+	0x84, 0x82, 0x78, 0xF8, 0x48, 0xC9, 0xED, 0x4B, 0x25, 0x19, 0xC3, 0xDA,
+	    0xD9, 0x99, 0x29, 0x8F, 0x85, 0x83, 0x75, 0xF5,
+	0x93, 0x18, 0x8D, 0xCC, 0x86, 0x30, 0x62, 0xC4, 0x57, 0x64, 0x58, 0xAA,
+	    0xC8, 0xCB, 0x1F, 0x26, 0x1A, 0xBF, 0x29, 0xE8,
+	0xBB, 0x8B, 0xAD, 0xF7, 0xF9, 0xFF, 0x60, 0x57, 0x64, 0xC5, 0xEF, 0xBE,
+	    0x7F, 0xE8, 0xE2, 0xF6, 0x1F, 0x88, 0x3A, 0x10,
+	0x8B, 0xEA, 0xD9, 0x84, 0x44, 0xC6, 0x43, 0x53, 0xB6, 0x84, 0x11, 0x61,
+	    0xAD, 0xDD, 0xB7, 0x01, 0x29, 0xFD, 0x91, 0xD1,
+	0x07, 0x7F, 0x12, 0xBF, 0xF7, 0xEA, 0xB9, 0x8E, 0x2F, 0xDC, 0xCB, 0x88,
+	    0xE4, 0xF3, 0x22, 0x0A, 0x0C, 0xC8, 0x27, 0x8A,
+	0x63, 0x8A, 0x62, 0x59, 0x54, 0x42, 0x75, 0x4C, 0xAB, 0x8D, 0x2A, 0x1A,
+	    0x0D, 0xC9, 0x44, 0xEF, 0xAF, 0x39, 0x8E, 0x5A,
+	0x45, 0x19, 0x80, 0xC5, 0x5B, 0x32, 0x23, 0x96, 0x8C, 0x8A, 0x7C, 0xA2,
+	    0x9A, 0x51, 0xF4, 0xD5, 0x2D, 0xAC, 0x8B, 0xD0,
+	0xE3, 0x38, 0xA5, 0xCD, 0x8D, 0x8B, 0x43, 0x35, 0x1F, 0xA3, 0x94, 0xEB,
+	    0x4C, 0x6A, 0xC5, 0x4D, 0x36, 0x91, 0x5A, 0x9A,
+	0x52, 0x97, 0x71, 0xA8, 0xFF, 0xB7, 0xD2, 0x15, 0xE9, 0xA9, 0xCC, 0x8C,
+	    0xF9, 0xFC, 0xEA, 0x4A, 0xA8, 0x8B, 0x71, 0x3C,
+	0x11, 0xCF, 0x42, 0x4B, 0xEE, 0xD6, 0x3A, 0x67, 0xD2, 0x32, 0xAD, 0xAD,
+	    0x2B, 0x85, 0xF5, 0xA9, 0x1C, 0xAA, 0x4B, 0xBB,
+	0x92, 0x6F, 0x4C, 0x89, 0xE5, 0xDA, 0x4B, 0x9A, 0x2E, 0x70, 0xA1, 0xC2,
+	    0x74, 0x64, 0xE5, 0xFF, 0x97, 0xF2, 0x44, 0x4F,
+	0x5E, 0x50, 0x01, 0x82, 0x4F, 0xB4, 0xA0, 0xE6, 0x24, 0xBB, 0x90, 0xEC,
+	    0xBB, 0xED, 0x3D, 0xC4, 0xF6, 0xD4, 0xAC, 0x92,
+	0x94, 0x1C, 0x6C, 0x72, 0x26, 0xF0, 0x63, 0xFA, 0x1A, 0xF1, 0x31, 0xD4,
+	    0xF7, 0xD5, 0xDA, 0x87, 0xA4, 0xF7, 0x27, 0x7C,
+	0x4B, 0x6D, 0xDE, 0xD4, 0x64, 0x05, 0xBC, 0x45, 0x76, 0xF6, 0xC9, 0xB4,
+	    0x16, 0x1E, 0x05, 0x3F, 0x54, 0xB5, 0xFD, 0xCF,
+	0x76, 0x5E, 0xB0, 0x55, 0x82, 0xD7, 0x72, 0xA0, 0x46, 0xE0, 0xBD, 0xF6,
+	    0x93, 0x6B, 0x7D, 0x66, 0x5D, 0x35, 0x34, 0x22,
+	0x59, 0xB8, 0x94, 0x22, 0x24, 0x64, 0x43, 0xA8, 0xEA, 0xB1, 0x27, 0xF0,
+	    0x1C, 0x32, 0xC6, 0x09, 0x71, 0x7E, 0x1C, 0xB1,
+	0x01, 0x86, 0x09, 0x58, 0xB7, 0x16, 0xAE, 0x54, 0x99, 0xE7, 0x60, 0x63,
+	    0xCC, 0xB5, 0x14, 0xA1, 0x00, 0x67, 0xED, 0xC8,
+	0xD0, 0xAC, 0xA0, 0xD3, 0xE1, 0xEC, 0x7B, 0x84, 0xD2, 0x53, 0xC2, 0xAD,
+	    0x2D, 0xF8, 0x08, 0xDC, 0x9F, 0xDD, 0x56, 0xA8,
+	0x65, 0xD7, 0x69, 0xF6, 0x43, 0xFC, 0x2F, 0x45, 0xCE, 0x9D, 0x06, 0xBB,
+	    0xBA, 0x3B, 0xC1, 0x58, 0x8C, 0xBC, 0xC0, 0x3A,
+	0x0E, 0x0E, 0xDD, 0x89, 0xA4, 0xD5, 0xDF, 0x67, 0x2A, 0xF5, 0x57, 0xA9,
+	    0xE1, 0x51, 0x8D, 0x54, 0xFA, 0x21, 0x3A, 0xE9,
+	0x23, 0xFE, 0x47, 0x93, 0xAF, 0xF4, 0x47, 0x9C, 0x4E, 0xDD, 0xDF, 0xBD,
+	    0xDE, 0xF6, 0x3C, 0xDA, 0x5A, 0x43, 0xF0, 0xA8,
+	0xC1, 0x61, 0xE0, 0x68, 0xEE, 0x95, 0x6A, 0x0C, 0x9E, 0x58, 0x21, 0xB8,
+	    0x6C, 0x6D, 0xB7, 0xEE, 0x9A, 0x12, 0x6C, 0x1C,
+	0xC3, 0xD0, 0x9E, 0xFC, 0x46, 0xF0, 0x47, 0x1D, 0x2C, 0x9A, 0x4B, 0x50,
+	    0xBF, 0x5E, 0x4F, 0x3B, 0xB0, 0xC5, 0x8F, 0x9F,
+	0x15, 0x57, 0x90, 0x22, 0xA3, 0xDD, 0xF8, 0xDD, 0xBB, 0x4B, 0x35, 0x66,
+	    0xDC, 0x7E, 0xD9, 0x9A, 0x5C, 0x7A, 0xFF, 0xE8,
+	0xCA, 0xAD, 0xCD, 0xE3, 0xA1, 0x81, 0xF7, 0x60, 0x0C, 0xBB, 0xE6, 0x46,
+	    0xD2, 0xA7, 0xF0, 0x98, 0xA4, 0x5E, 0xC1, 0x72,
+	0xE6, 0x31, 0x0C, 0x6E, 0x36, 0x46, 0x4C, 0xB2, 0x49, 0x9C, 0x79, 0xE7,
+	    0x90, 0xFF, 0xB9, 0x8C, 0x3F, 0x39, 0x95, 0xA5,
+	0xED, 0x2A, 0x9C, 0xC7, 0x71, 0x9D, 0x08, 0x77, 0x3E, 0xA2, 0x31, 0xEA,
+	    0x70, 0xBC, 0xC6, 0x05, 0xC7, 0xA3, 0xD3, 0xC8,
+	0x72, 0x68, 0xA0, 0x54, 0x80, 0x00, 0x9F, 0x26, 0x51, 0xD4, 0x43, 0x86,
+	    0x44, 0x1D, 0xCE, 0x55, 0xF3, 0x1B, 0xFC, 0x32,
+	0xE8, 0x94, 0xF0, 0xAB, 0xD2, 0xAF, 0x98, 0xBC, 0x38, 0x5E, 0xA6, 0x50,
+	    0x8F, 0x06, 0x91, 0x23, 0x69, 0x77, 0x98, 0x68,
+	0x35, 0x43, 0x9E, 0xE5, 0xE3, 0x46, 0xEB, 0x9E, 0xD4, 0xBD, 0x29, 0x53,
+	    0xB4, 0x0A, 0x4E, 0xBD, 0xD1, 0x68, 0x5E, 0x17,
+	0x38, 0x02, 0x19, 0xF5, 0xD3, 0x25, 0x3A, 0xF3, 0xBD, 0x6B, 0xFD, 0x76,
+	    0x99, 0x25, 0xCD, 0xD4, 0xEA, 0xB3, 0x16, 0xDC,
+	0xA7, 0x67, 0xF1, 0x62, 0x6B, 0xCC, 0xDE, 0x7A, 0xEE, 0x39, 0x7A, 0x3A,
+	    0x08, 0x44, 0x98, 0xBE, 0xBF, 0x71, 0x78, 0x72,
+	0xE8, 0x1B, 0x43, 0x10, 0xD9, 0x31, 0xC9, 0xAD, 0x84, 0xB1, 0xF3, 0x9B,
+	    0xC1, 0x67, 0x6B, 0xAB, 0xEF, 0x04, 0x33, 0xE2,
+	0x1A, 0x26, 0x11, 0x31, 0x6A, 0xC6, 0xE3, 0x4F, 0xEA, 0x39, 0x1B, 0x4F,
+	    0xED, 0x69, 0x7A, 0x0B, 0xD8, 0x8C, 0x97, 0x1A,
+	0x64, 0xC4, 0x91, 0xE0, 0xA6, 0x67, 0x13, 0x5F, 0xEE, 0xF2, 0x32, 0xDE,
+	    0x9B, 0xF6, 0xE2, 0x2A, 0x65, 0x2E, 0xC3, 0x26,
+	0xAE, 0xF1, 0x7B, 0xA1, 0x42, 0xC1, 0x8B, 0x48, 0xF9, 0x8E, 0x73, 0x96,
+	    0xF9, 0xBC, 0x60, 0x10, 0xDC, 0xD5, 0x75, 0x74,
+	0x06, 0xF9, 0xF3, 0x8D, 0xC7, 0x8E, 0x11, 0x3B, 0x96, 0xB0, 0xF4, 0x02,
+	    0x02, 0x54, 0x86, 0x62, 0x8C, 0xED, 0x7C, 0x8C,
+	0xCD, 0x7F, 0x4D, 0x9D, 0xC7, 0xED, 0x6B, 0x9A, 0xD3, 0x32, 0xF4, 0x18,
+	    0x84, 0xB2, 0x71, 0x1C, 0x94, 0xEE, 0x91, 0xD2,
+	0x96, 0x57, 0x6A, 0x44, 0x79, 0x7E, 0x7D, 0xE7, 0xC8, 0xBB, 0xBB, 0xE1,
+	    0x3D, 0x50, 0x14, 0x47, 0x62, 0x56, 0xCE, 0xD8,
+	0x72, 0x7A, 0x17, 0x77, 0x9A, 0xD5, 0x8C, 0xF3, 0x4E, 0x8F, 0x3D, 0xFD,
+	    0x40, 0xEC, 0xFD, 0xF5, 0x4F, 0xFE, 0xAC, 0x68,
+	0xA0, 0x10, 0x04, 0x39, 0x3B, 0x76, 0x44, 0x61, 0x26, 0xFB, 0x94, 0xE4,
+	    0x19, 0x7B, 0x6C, 0xA5, 0x82, 0xAA, 0x96, 0x2B,
+	0x94, 0x33, 0x5E, 0x03, 0x20, 0xE0, 0xCE, 0x0E, 0x98, 0x31, 0x5C, 0xA3,
+	    0x55, 0x10, 0xD9, 0x36, 0x81, 0x57, 0x1F, 0x93,
+	0x19, 0x52, 0x55, 0x96, 0xDC, 0xF3, 0xF6, 0x22, 0x9B, 0xAA, 0x3F, 0x88,
+	    0x12, 0x5B, 0x87, 0xCE, 0x84, 0x15, 0xE3, 0x17,
+	0x91, 0x81, 0xC6, 0x91, 0xA5, 0xC7, 0x3B, 0xD7, 0x4B, 0x38, 0xAD, 0xA0,
+	    0xCF, 0xE5, 0xEE, 0xEA, 0xCC, 0x7E, 0xB5, 0x28,
+	0xCD, 0x7C, 0x7A, 0xBC, 0xCC, 0x36, 0xC0, 0xDA, 0x96, 0x42, 0x98, 0x41,
+	    0x71, 0x3B, 0xB8, 0xB9, 0x98, 0xE5, 0x47, 0x08,
+	0x5B, 0x3C, 0x16, 0x4F, 0x6A, 0x5E, 0xC7, 0xA8, 0x5B, 0x34, 0x77, 0xBE,
+	    0x54, 0x14, 0x3B, 0xE2, 0x1A, 0x87, 0x51, 0xCB,
+	0x4E, 0x4B, 0x04, 0x2A, 0x7B, 0x7F, 0x38, 0xE4, 0x0A, 0x0F, 0x9F, 0xCB,
+	    0xFC, 0x07, 0x8D, 0xD3, 0x8B, 0x47, 0xA8, 0xEB,
+	0x93, 0xC5, 0x2E, 0xDA, 0x42, 0x10, 0x0E, 0x21, 0x03, 0xB0, 0x8B, 0x58,
+	    0x3F, 0x06, 0xA6, 0x0D, 0xD8, 0x3D, 0x40, 0x4D,
+	0xD5, 0xDA, 0x53, 0x2A, 0x5B, 0xC1, 0xC6, 0x0F, 0xEC, 0x85, 0xAF, 0xCA,
+	    0x13, 0xA7, 0x31, 0xF4, 0x07, 0x12, 0x96, 0xD1,
+	0x1C, 0x24, 0x3F, 0xFB, 0x98, 0x52, 0xE1, 0x58, 0x1B, 0xFE, 0x94, 0x5C,
+	    0xA7, 0x3D, 0xD9, 0x82, 0x56, 0xFF, 0x50, 0x94,
+	0x94, 0xCF, 0x48, 0xCE, 0x14, 0xAF, 0x7A, 0x05, 0x87, 0xE6, 0x80, 0x74,
+	    0x26, 0x50, 0x58, 0x81, 0x8C, 0xCE, 0x98, 0xE2,
+	0xF4, 0x6B, 0x33, 0x41, 0x73, 0x1F, 0x1A, 0x45, 0x35, 0x5F, 0x51, 0x21,
+	    0xDF, 0xCF, 0xE8, 0xBD, 0x73, 0xE4, 0x69, 0xF1,
+	0x29, 0x5F, 0x11, 0xE9, 0x85, 0xEE, 0x01, 0x74, 0x07, 0x43, 0x3E, 0x07,
+	    0x9D, 0xF8, 0x68, 0xD2, 0xEF, 0x15, 0xD8, 0x77,
+	0xB7, 0xBF, 0x4E, 0x87, 0x2E, 0xC9, 0x39, 0x01, 0xA1, 0xD4, 0x4E, 0x24,
+	    0xF8, 0x28, 0xB1, 0xCE, 0xB0, 0xC0, 0x42, 0xD7,
+	0xB0, 0x49, 0x54, 0xF3, 0x82, 0x87, 0x86, 0x03, 0xDA, 0x9D, 0xF6, 0xA1,
+	    0x3A, 0xAB, 0xFE, 0x9C, 0x62, 0x76, 0x4D, 0x8F,
+	0xDA, 0x3A, 0xFC, 0x94, 0x59, 0x8D, 0xD1, 0xD5, 0x71, 0x05, 0xAD, 0xA3,
+	    0x66, 0x3F, 0x90, 0x9C, 0x28, 0x8B, 0x5A, 0x8E,
+	0x58, 0xD4, 0x5F, 0x8A, 0x48, 0x78, 0x7A, 0x2F, 0x2F, 0x48, 0x71, 0xC8,
+	    0xF9, 0x17, 0x8A, 0xEA, 0x85, 0x5A, 0x92, 0xE0,
+	0x1B, 0x0B, 0x02, 0xC4, 0xCF, 0xCD, 0xE3, 0xBB, 0xFA, 0x14, 0x79, 0x49,
+	    0xF0, 0x25, 0xCB, 0x6D, 0x63, 0xA4, 0x4B, 0xA9,
+	0x4C, 0xF2, 0xEA, 0x2E, 0x7B, 0x67, 0x9C, 0x1D, 0x0F, 0xEC, 0x8D, 0xF7,
+	    0x8A, 0x76, 0x32, 0x59, 0x36, 0x16, 0xE5, 0xDD,
+	0xA3, 0x6E, 0x64, 0x39, 0x7E, 0x7A, 0x9A, 0x2C, 0x93, 0x2A, 0x0C, 0xBA,
+	    0x71, 0xEC, 0xCD, 0xF1, 0xAF, 0x3A, 0xC8, 0x58,
+	0x43, 0xCF, 0x15, 0xBC, 0x19, 0x44, 0x17, 0x92, 0xDF, 0x00, 0x25, 0x7A,
+	    0x59, 0xC6, 0x6B, 0x5A, 0x88, 0x75, 0x62, 0x8F,
+	0x92, 0x25, 0xC4, 0x9F, 0xC8, 0x15, 0xBB, 0x77, 0x26, 0xA7, 0x33, 0x5B,
+	    0x8C, 0xCF, 0x85, 0xDB, 0xCD, 0xC6, 0x86, 0x93,
+	0xE7, 0x82, 0xC5, 0x40, 0xF1, 0xAD, 0x1A, 0xF3, 0x6D, 0x19, 0x19, 0xDD,
+	    0x47, 0xB0, 0x8B, 0x44, 0xC8, 0xDD, 0xEB, 0xC4,
+	0x5A, 0xB6, 0x32, 0x00, 0xD4, 0x3C, 0x65, 0xE8, 0x92, 0xA1, 0xE3, 0x81,
+	    0x56, 0xB2, 0xDC, 0xB4, 0x09, 0xFC, 0x3D, 0x1A,
+	0x2B, 0x3F, 0x65, 0x02, 0x11, 0xA9, 0xCA, 0xC5, 0x1F, 0x90, 0x36, 0x07,
+	    0xA0, 0xA8, 0x37, 0x01, 0xE5, 0x99, 0x12, 0x71,
+	0x54, 0xB5, 0x07, 0x55, 0xF5, 0x2E, 0xC7, 0x48, 0x77, 0xF7, 0x1A, 0xFA,
+	    0x59, 0x1D, 0x74, 0xD6, 0x91, 0xB2, 0x5E, 0x67,
+	0x68, 0x5E, 0x76, 0x15, 0xF2, 0x59, 0x94, 0xF2, 0x2D, 0xF5, 0x28, 0x53,
+	    0x39, 0x3F, 0x1C, 0xF0, 0x14, 0xD8, 0x58, 0x85,
+	0x0A, 0xFA, 0xBE, 0xC3, 0xA0, 0x0D, 0xC5, 0x27, 0x17, 0x49, 0xF1, 0x0B,
+	    0xFC, 0x99, 0x8D, 0x57, 0x56, 0x59, 0x4B, 0xFE,
+	0xD7, 0x8C, 0x2A, 0x52, 0x31, 0x86, 0x37, 0x4E, 0xD4, 0x06, 0x49, 0x84,
+	    0xD4, 0xF8, 0xE6, 0x62, 0x6A, 0xD5, 0xD4, 0x3F,
+	0x9F, 0xBE, 0xCE, 0x42, 0x2B, 0x9A, 0x25, 0xCC, 0x01, 0xF3, 0x66, 0x93,
+	    0x1E, 0x3B, 0x19, 0xD8, 0x6F, 0xFB, 0xFE, 0xA7,
+	0x5B, 0x74, 0x7F, 0x1E, 0x6B, 0x39, 0xD8, 0xF8, 0x89, 0x6C, 0x87, 0xCB,
+	    0x1F, 0xF6, 0xB0, 0x07, 0xDF, 0x59, 0xB0, 0xCD,
+	0xF2, 0xBC, 0x97, 0x64, 0x44, 0xF2, 0x31, 0x13, 0x3F, 0xBF, 0xA3, 0x51,
+	    0x0C, 0xE0, 0x87, 0xF8, 0xF3, 0x99, 0xE3, 0xB9,
+	0x16, 0xD3, 0x4E, 0xCA, 0xB9, 0x49, 0x8E, 0x8C, 0x05, 0xD3, 0xAC, 0x6E,
+	    0x16, 0x9F, 0x37, 0x4F, 0xC6, 0xEC, 0x69, 0xA0,
+	0x98, 0xAD, 0x78, 0xE8, 0xED, 0x1A, 0xCE, 0x0D, 0xF3, 0x50, 0x66, 0xB8,
+	    0x9A, 0xD1, 0x27, 0x32, 0xE7, 0xA5, 0xF3, 0xD9,
+	0x85, 0xD1, 0x89, 0xE9, 0x1F, 0x7D, 0x97, 0x33, 0xBD, 0x32, 0x50, 0x39,
+	    0x9B, 0x12, 0xB3, 0x19, 0x6D, 0xDB, 0xE4, 0x1D,
+	0xDB, 0xFF, 0xA7, 0xA1, 0xE1, 0xAF, 0xBE, 0xB4, 0x9F, 0x56, 0x6E, 0x90,
+	    0xAB, 0x03, 0xD2, 0xDB, 0xB9, 0xE3, 0x76, 0xBC,
+	0xEA, 0x72, 0x9E, 0x76, 0x71, 0xA8, 0x84, 0xF0, 0x62, 0xEC, 0xC2, 0xEF,
+	    0x39, 0xE2, 0x53, 0x12, 0xAD, 0xC1, 0x89, 0xC0,
+	0x79, 0xE1, 0x2F, 0x85, 0x4D, 0xE4, 0x3D, 0xBA, 0xD3, 0x11, 0x77, 0xA9,
+	    0x6A, 0xB0, 0xF0, 0x73, 0x66, 0x33, 0xC9, 0x21,
+	0x3E, 0xBE, 0xE0, 0x53, 0x6E, 0x21, 0x02, 0x07, 0x0C, 0xAB, 0x00, 0x38,
+	    0x1D, 0x3F, 0x01, 0x5F, 0x78, 0x06, 0x3A, 0xE0,
+	0x02, 0x3A, 0x1A, 0xBA, 0xA6, 0xA4, 0x91, 0x0A, 0x15, 0xB5, 0xA1, 0xB2,
+	    0xE2, 0x3A, 0xF0, 0x16, 0xAE, 0x69, 0x17, 0xB1,
+	0x59, 0xA7, 0x28, 0xC1, 0xD4, 0x6D, 0xD6, 0xB0, 0xC4, 0xC4, 0x11, 0x79,
+	    0xA2, 0xBB, 0x71, 0x61, 0xBE, 0x38, 0xA1, 0xD1,
+	0xD1, 0x78, 0x31, 0x13, 0x74, 0x49, 0xE1, 0x4B, 0xA5, 0x92, 0x5B, 0x56,
+	    0x0E, 0xCA, 0x3A, 0xF3, 0x6B, 0x28, 0xBE, 0xBB,
+	0x65, 0x42, 0x95, 0x97, 0xAF, 0xE3, 0x0A, 0xF0, 0x8E, 0x4B, 0x32, 0x6F,
+	    0x7F, 0x88, 0x61, 0x30, 0xEC, 0xF6, 0x22, 0xB8,
+	0x0D, 0xE1, 0xB4, 0x09, 0x88, 0x0A, 0xDC, 0x08, 0x9E, 0x48, 0x59, 0xAD,
+	    0x94, 0xFA, 0x78, 0x1C, 0xBA, 0x75, 0xC9, 0x26,
+	0x89, 0x0B, 0xB3, 0x2D, 0xFC, 0x34, 0x25, 0x9D, 0xCF, 0xBB, 0xD3, 0x0C,
+	    0x64, 0x29, 0xAE, 0x2F, 0xC8, 0x0D, 0xF9, 0x0E,
+	0xBB, 0x91, 0x6A, 0x83, 0xC9, 0x41, 0x05, 0xE8, 0x0E, 0x1C, 0x28, 0x5F,
+	    0x0A, 0xCD, 0xF2, 0x23, 0x9A, 0x20, 0x03, 0x26,
+	0x4D, 0x8F, 0xE2, 0x82, 0x5D, 0xB4, 0x06, 0x2E, 0xEB, 0x0A, 0xEB, 0x2F,
+	    0x6F, 0x22, 0x2A, 0xED, 0x9E, 0xDF, 0xBB, 0x0F,
+	0x25, 0x60, 0x15, 0xE5, 0x8B, 0xA4, 0x78, 0xF1, 0x67, 0x5C, 0x83, 0x91,
+	    0x4C, 0x0D, 0x17, 0x63, 0xE9, 0x9B, 0x50, 0xC7,
+	0xE2, 0x50, 0x83, 0xFC, 0x33, 0x92, 0xAC, 0x53, 0x4E, 0xFD, 0x95, 0xDB,
+	    0xD7, 0xDD, 0xD3, 0xFC, 0x52, 0x44, 0x9E, 0xE4,
+	0x37, 0x81, 0x85, 0x5A, 0x88, 0x42, 0x00, 0x56, 0x91, 0x8E, 0x4D, 0x14,
+	    0xD7, 0xCE, 0xBB, 0x31, 0xD8, 0x3F, 0xC5, 0x90,
+	0x41, 0xD3, 0xC1, 0xD5, 0xF8, 0xD6, 0x52, 0xBB, 0x9E, 0x01, 0xA1, 0xD2,
+	    0xB7, 0x83, 0xE5, 0xB9, 0x08, 0x60, 0xA3, 0x04,
+	0x4E, 0x28, 0x90, 0x44, 0x7E, 0xA4, 0xFC, 0xBB, 0xB3, 0x39, 0x6C, 0x9B,
+	    0xE3, 0x59, 0x79, 0x9B, 0xEF, 0x28, 0x32, 0x79,
+	0xCA, 0x76, 0xF4, 0x2B, 0xB0, 0x38, 0x74, 0x92, 0x9F, 0xD6, 0xBA, 0x96,
+	    0xC8, 0x6A, 0x3B, 0x69, 0xB2, 0x5B, 0x05, 0xDC,
+	0xD5, 0x38, 0xEE, 0xA3, 0x43, 0xAB, 0x6E, 0xAB, 0x47, 0x15, 0x33, 0x33,
+	    0x43, 0xC2, 0x36, 0x17, 0x12, 0x88, 0x67, 0x0B,
+	0x18, 0x88, 0x87, 0xED, 0x9B, 0x54, 0xC6, 0x61, 0x44, 0xC3, 0x1F, 0x4C,
+	    0x7C, 0x95, 0xEE, 0x58, 0xBF, 0xF9, 0x96, 0x91,
+	0x87, 0x25, 0x3B, 0x61, 0x19, 0x1D, 0xDC, 0x6C, 0xE2, 0x98, 0x44, 0x66,
+	    0x15, 0x46, 0x65, 0x9B, 0xD8, 0x86, 0xF1, 0x74,
+	0x1B, 0x81, 0x55, 0xBD, 0x43, 0x95, 0xC7, 0x43, 0x4D, 0x85, 0x57, 0xB5,
+	    0x9D, 0x77, 0x48, 0x1D, 0xFD, 0xC1, 0x5D, 0x77,
+	0x1C, 0x94, 0xA4, 0x5F, 0x8A, 0x85, 0x5F, 0xA0, 0xB3, 0xE7, 0x3E, 0xF9,
+	    0x14, 0xB3, 0xAE, 0xAE, 0xC9, 0x7E, 0x0F, 0xB6,
+	0x6C, 0xCC, 0xA8, 0xEA, 0x9B, 0xFF, 0x30, 0x74, 0xC2, 0x7E, 0x0E, 0x48,
+	    0x1C, 0xB0, 0x36, 0x9A, 0xD4, 0x53, 0x21, 0x8E,
+	0x88, 0xC2, 0x92, 0xB7, 0xC0, 0x4D, 0x5C, 0x08, 0x89, 0xF0, 0xBE, 0x6D,
+	    0xA8, 0x01, 0xF3, 0x1E, 0x76, 0x73, 0x59, 0x60,
+	0x40, 0xAC, 0xB1, 0x79, 0x52, 0x7C, 0x67, 0x17, 0x68, 0x52, 0x24, 0x79,
+	    0xB9, 0x20, 0x20, 0x02, 0x6F, 0x53, 0x18, 0xFC,
+	0x04, 0xED, 0xB3, 0xCC, 0x54, 0x8D, 0xB7, 0x9D, 0xA3, 0x6B, 0x76, 0xB6,
+	    0x55, 0x23, 0xB3, 0x56, 0x55, 0xD5, 0xF8, 0x2A,
+	0xFA, 0xC9, 0x00, 0x07, 0xF4, 0x60, 0xA5, 0xF2, 0xFA, 0x83, 0xDE, 0xC0,
+	    0x92, 0x12, 0xCC, 0xE4, 0x1E, 0x5F, 0xDA, 0x16,
+	0xB6, 0xFD, 0xF9, 0xE3, 0x52, 0x22, 0xFB, 0x15, 0xA1, 0xE1, 0x6C, 0x29,
+	    0xF7, 0x77, 0x24, 0xDD, 0x70, 0x12, 0xB7, 0x08,
+	0xE7, 0x2B, 0x20, 0x5B, 0x5D, 0xBF, 0x73, 0xAC, 0xB2, 0xD7, 0xA5, 0x21,
+	    0x65, 0xDD, 0x0E, 0xE2, 0x06, 0xC5, 0x28, 0xC6,
+	0xA0, 0xAB, 0x6E, 0xDB, 0x41, 0x15, 0xA9, 0x06, 0xD7, 0x4A, 0xB1, 0x30,
+	    0xA0, 0xEA, 0x09, 0xC3, 0xC6, 0xF8, 0xB1, 0x7E,
+	0x8D, 0xBB, 0x49, 0xF4, 0xEC, 0x4B, 0x65, 0xE5, 0xE4, 0x59, 0xD1, 0xB8,
+	    0x14, 0xAA, 0xEA, 0x9B, 0x40, 0x85, 0x81, 0xFF,
+	0x72, 0x6E, 0xF2, 0xE0, 0xE5, 0xCB, 0x21, 0x77, 0xF5, 0x6B, 0x67, 0x55,
+	    0x24, 0xC5, 0x4D, 0xA6, 0xF9, 0x3B, 0xB6, 0x09,
+	0x27, 0x86, 0xD3, 0x78, 0xEE, 0xB9, 0xC2, 0x32, 0xF0, 0x86, 0x07, 0x0F,
+	    0xFC, 0x68, 0xDB, 0xEB, 0x6F, 0x27, 0xB5, 0x6D,
+	0xFC, 0xB3, 0x21, 0x47, 0x7F, 0x97, 0x48, 0xAB, 0x80, 0x48, 0x19, 0xE8,
+	    0xE3, 0x26, 0x13, 0xE4, 0x10, 0xE9, 0x61, 0xE5,
+	0xB1, 0xD4, 0x22, 0xD5, 0x28, 0xA4, 0x74, 0xEE, 0xBD, 0xC1, 0x1B, 0x8C,
+	    0xBF, 0x93, 0xB0, 0x8E, 0x06, 0x8F, 0xD2, 0xFD,
+	0xFD, 0xE6, 0x6D, 0x68, 0x73, 0xCF, 0x96, 0x1C, 0xBE, 0x10, 0xBA, 0x62,
+	    0xCC, 0x8F, 0xFB, 0x0D, 0x65, 0xA2, 0x9C, 0x38,
+	0xE4, 0xCC, 0x8B, 0x2D, 0x98, 0x1E, 0x7F, 0x5A, 0xFD, 0x80, 0x75, 0x1C,
+	    0xEC, 0xA1, 0x68, 0x45, 0x2E, 0x20, 0xC3, 0x3D,
+	0x6A, 0xA3, 0x39, 0x95, 0x3E, 0xC3, 0x48, 0xD7, 0x23, 0xDC, 0x13, 0x84,
+	    0x22, 0x00, 0xF2, 0xF5, 0x52, 0x31, 0x22, 0x06,
+	0xD7, 0x7D, 0x0F, 0xFC, 0xAD, 0x0D, 0x12, 0xF7, 0xC5, 0x10, 0x40, 0x09,
+	    0x36, 0xF1, 0x8E, 0x4B, 0x21, 0x93, 0x43, 0xC4,
+	0x5B, 0xB3, 0xEB, 0x72, 0x07, 0xD2, 0xDA, 0x78, 0x5D, 0x31, 0xE1, 0x45,
+	    0xB8, 0xD6, 0x9A, 0xD4, 0x9A, 0x83, 0x3C, 0x60,
+	0x21, 0x3E, 0x0A, 0x27, 0x5C, 0x50, 0x3A, 0xEE, 0x0C, 0x90, 0xBE, 0xDF,
+	    0x54, 0x2C, 0x5E, 0x73, 0x54, 0x3B, 0x48, 0x55,
+	0x1B, 0xBC, 0x09, 0x20, 0xC7, 0x96, 0xCE, 0x0B, 0xF6, 0xAB, 0x6F, 0x1C,
+	    0x96, 0x99, 0xBA, 0x52, 0x6F, 0x30, 0x43, 0xB0,
+	0xC6, 0x08, 0x30, 0xE8, 0x45, 0x01, 0x36, 0x2B, 0x73, 0xD4, 0x65, 0xC4,
+	    0xF1, 0x1B, 0x72, 0x00, 0x67, 0xDB, 0x88, 0x0D,
+	0xF0, 0x2F, 0x55, 0xB8, 0x26, 0x9A, 0xFB, 0x73, 0xB1, 0x27, 0x55, 0x91,
+	    0x1A, 0xDB, 0xA8, 0x07, 0x44, 0x56, 0x5E, 0x3A,
+	0x94, 0x2D, 0xF8, 0x6C, 0x38, 0x3D, 0xF6, 0xB6, 0x2D, 0xD2, 0x02, 0xCC,
+	    0xF1, 0x4E, 0xF1, 0x70, 0x12, 0x09, 0xD6, 0x2E,
+	0xD9, 0xFB, 0xEE, 0xBB, 0xAD, 0x74, 0x05, 0xCE, 0xFD, 0xEF, 0x87, 0x71,
+	    0xDB, 0x7D, 0xB5, 0xA7, 0x47, 0x17, 0xB7, 0xBA,
+	0x8E, 0x7A, 0x8C, 0xDF, 0x7C, 0xE5, 0xEF, 0x72, 0xC1, 0x16, 0xAC, 0x4A,
+	    0x54, 0xD2, 0xED, 0x8B, 0x1A, 0xA4, 0xF7, 0xAA,
+	0x14, 0x92, 0xDF, 0x88, 0x8F, 0xE1, 0x45, 0xAC, 0xC1, 0x31, 0x4E, 0x6E,
+	    0x36, 0x17, 0x26, 0x1D, 0xFA, 0x71, 0xC3, 0xA5,
+	0xB2, 0x10, 0x07, 0x5A, 0x6F, 0xE3, 0x46, 0x04, 0xEC, 0xD0, 0xC6, 0x1E,
+	    0x29, 0xBF, 0x4F, 0xA9, 0x52, 0xFD, 0x9C, 0x34,
+	0x49, 0xA5, 0x1F, 0x89, 0x11, 0xD0, 0xA5, 0x58, 0x15, 0x9A, 0x96, 0x30,
+	    0x1C, 0x4A, 0x2F, 0x4F, 0x08, 0xA4, 0x00, 0x39,
+	0x4E, 0x40, 0xF8, 0xA6, 0x72, 0x72, 0xE7, 0xFF, 0xE1, 0xD6, 0xA0, 0x8E,
+	    0x34, 0x6D, 0x22, 0x10, 0x38, 0xEF, 0x28, 0x6A,
+	0xA5, 0x3C, 0xEF, 0x6E, 0x60, 0x05, 0x19, 0xE4, 0x10, 0xF0, 0x66, 0x37,
+	    0xA8, 0x05, 0xCB, 0x0F, 0x2B, 0xB4, 0xFA, 0x46,
+	0x69, 0x31, 0x7E, 0x3B, 0xA4, 0x82, 0xB1, 0x53, 0xA2, 0x25, 0x3C, 0x5A,
+	    0x4D, 0xF7, 0x70, 0x62, 0xB3, 0x8A, 0xF7, 0x13,
+	0x70, 0xA0, 0x0F, 0x0C, 0x2A, 0x07, 0xCA, 0x0A, 0xAB, 0x21, 0x93, 0x7F,
+	    0x7C, 0x89, 0x93, 0x60, 0xE9, 0x89, 0xE2, 0x93,
+	0xCE, 0x05, 0x68, 0x9B, 0x42, 0x29, 0xB1, 0x2A, 0x27, 0x79, 0xF2, 0xC6,
+	    0x13, 0xBA, 0x85, 0x61, 0xA2, 0xFA, 0xFF, 0xD1,
+	0xEE, 0x06, 0x3A, 0xBA, 0x84, 0x84, 0x5D, 0x02, 0x48, 0x99, 0x8A, 0x3F,
+	    0xBD, 0x3E, 0xB1, 0xD7, 0xE8, 0x27, 0xF6, 0x1E,
+	0x16, 0xDA, 0x59, 0x2A, 0xFB, 0x2A, 0xC9, 0x02, 0xB7, 0xEC, 0x39, 0xDD,
+	    0x2E, 0xCE, 0x22, 0x82, 0x0B, 0xA8, 0xA6, 0xFF,
+	0x94, 0x69, 0x28, 0x99, 0xC4, 0xE7, 0x56, 0x4A, 0xD5, 0x15, 0x5F, 0xF4,
+	    0xAB, 0x32, 0x75, 0x3B, 0xB8, 0x32, 0x4D, 0xD0,
+	0x27, 0x04, 0x37, 0x43, 0xC4, 0x36, 0x39, 0xFA, 0xBA, 0xA5, 0xE3, 0xBF,
+	    0xE2, 0x27, 0xB7, 0x0D, 0x4A, 0xCD, 0x74, 0xD2,
+	0x6D, 0xBC, 0x99, 0x6A, 0xE7, 0x49, 0x5D, 0x42, 0x3E, 0x3B, 0xE4, 0x31,
+	    0x6C, 0xB7, 0x4F, 0xAE, 0x78, 0x54, 0xEB, 0x3A,
+	0xB1, 0x13, 0xD0, 0x20, 0xA9, 0x61, 0x2A, 0x70, 0xAA, 0xCD, 0x06, 0x0C,
+	    0x2B, 0xC1, 0xD9, 0xC7, 0xFE, 0x84, 0x4E, 0x58,
+	0x59, 0x15, 0x08, 0xDF, 0x6F, 0x03, 0x5E, 0x97, 0x55, 0x0F, 0xD3, 0xB6,
+	    0x05, 0xA3, 0x53, 0xB5, 0x9A, 0x95, 0x06, 0x9A,
+	0x4E, 0xC3, 0x8C, 0x50, 0xDC, 0x47, 0x6B, 0xB3, 0x62, 0xBE, 0x10, 0x63,
+	    0xE4, 0xF6, 0xCA, 0x0B, 0x49, 0x28, 0x1F, 0xAD,
+	0x85, 0xC0, 0x84, 0x11, 0xAC, 0xB2, 0xD3, 0xE6, 0xC7, 0x55, 0xAC, 0x5B,
+	    0xC1, 0x0F, 0x0D, 0x4F, 0x68, 0x1D, 0x64, 0x96,
+	0xA2, 0x75, 0xF7, 0xB3, 0x90, 0x8E, 0x24, 0x43, 0x03, 0x34, 0x20, 0x11,
+	    0x55, 0x1D, 0xA5, 0xE3, 0x6A, 0x01, 0xBD, 0xA2,
+	0x4F, 0x3F, 0xA1, 0xC3, 0x5F, 0x37, 0x83, 0xC7, 0x0F, 0x40, 0x75, 0xB6,
+	    0x5C, 0x1C, 0x1D, 0x6C, 0xF1, 0x28, 0x25, 0x42,
+	0x8B, 0x12, 0xA7, 0x26, 0x89, 0x8C, 0x1B, 0x47, 0xDF, 0x55, 0x96, 0xC4,
+	    0x95, 0x75, 0x66, 0xC4, 0xE0, 0x50, 0x9C, 0xED,
+	0x52, 0x67, 0x31, 0x97, 0x8E, 0xE3, 0x77, 0x9A, 0xAE, 0xC8, 0xA3, 0xD4,
+	    0xDE, 0xF4, 0x59, 0x34, 0x13, 0x48, 0x53, 0xA3,
+	0xC2, 0x6F, 0xE8, 0xBE, 0x2B, 0x6A, 0x5A, 0x83, 0xA1, 0x36, 0x44, 0x9A,
+	    0x7D, 0xF0, 0xF6, 0xA1, 0x23, 0x08, 0x60, 0xF1,
+	0x31, 0x50, 0x65, 0x0E, 0x56, 0x34, 0x31, 0x66, 0x99, 0x7F, 0x00, 0x3D,
+	    0x60, 0x5B, 0x21, 0xFA, 0xCF, 0x28, 0xA5, 0x10,
+	0x94, 0xEB, 0xAC, 0x3F, 0x08, 0xA7, 0xD5, 0xC6, 0x56, 0x40, 0x0E, 0x0C,
+	    0x20, 0x3F, 0x61, 0x42, 0xCC, 0x26, 0x25, 0xCC,
+	0xF9, 0x66, 0x1B, 0x55, 0x8C, 0x85, 0x3D, 0x72, 0xCB, 0x3A, 0xAC, 0x0C,
+	    0x22, 0x57, 0x3B, 0xDE, 0xC4, 0x8C, 0xD2, 0x11,
+	0xAF, 0x20, 0xAF, 0x02, 0x18, 0x84, 0x1E, 0xDF, 0x52, 0x4B, 0xA1, 0x91,
+	    0x98, 0x7F, 0x03, 0xAF, 0x4B, 0x18, 0x47, 0x3C,
+	0x32, 0x33, 0xAD, 0xCC, 0x83, 0x6D, 0x45, 0x68, 0x53, 0xDD, 0x76, 0x36,
+	    0x87, 0x10, 0xF6, 0x27, 0xC8, 0x7C, 0x20, 0xFE,
+	0x8A, 0xDE, 0xB8, 0x9E, 0x90, 0x19, 0x26, 0xED, 0x41, 0x7A, 0x57, 0xB3,
+	    0x94, 0x98, 0x41, 0x8B, 0x8A, 0xD1, 0x6A, 0x1E,
+	0x7E, 0x1D, 0xB2, 0xFD, 0xC0, 0x10, 0x96, 0xC2, 0x5E, 0xE0, 0xAB, 0xDD,
+	    0x02, 0x6E, 0xE0, 0xCC, 0x7F, 0xC0, 0xA3, 0x6C,
+	0xED, 0x93, 0x1F, 0xE0, 0xB8, 0xAD, 0x48, 0x05, 0xB9, 0xCF, 0xC9, 0x02,
+	    0xBD, 0xE3, 0x6A, 0x49, 0x27, 0xF0, 0xA4, 0x49,
+	0xB2, 0xB1, 0x39, 0x54, 0xE9, 0x3D, 0xAA, 0x0F, 0xBE, 0xA5, 0x07, 0xAA,
+	    0x27, 0xC0, 0x5E, 0x20, 0x35, 0xB9, 0x68, 0x62,
+	0x61, 0x3D, 0xEF, 0xC5, 0x84, 0x67, 0xBD, 0x60, 0xEB, 0xC1, 0x16, 0xF1,
+	    0xB1, 0xA5, 0x41, 0x14, 0x38, 0xCC, 0x83, 0x87,
+	0x7B, 0x4C, 0x7A, 0x40, 0x94, 0xC5, 0xD7, 0x23, 0x65, 0xA4, 0x72, 0x80,
+	    0xEA, 0xCB, 0xA2, 0x21, 0xEF, 0x42, 0xDC, 0x30,
+	0xFC, 0xC4, 0x4C, 0x34, 0xE0, 0xC0, 0x87, 0x01, 0x7B, 0xA9, 0x3C, 0xA6,
+	    0x29, 0x4A, 0x1F, 0x44, 0x27, 0x19, 0x3C, 0x6B,
+	0xB2, 0x09, 0xE1, 0x24, 0x0C, 0x77, 0xA3, 0x94, 0xB4, 0x84, 0xD4, 0x6E,
+	    0x78, 0xDA, 0xD1, 0xA8, 0x76, 0x38, 0x9E, 0x57,
+	0x66, 0x6C, 0xAF, 0xF3, 0xFE, 0x46, 0xA1, 0xFB, 0x8D, 0xEC, 0xD4, 0x09,
+	    0xBD, 0x77, 0xA2, 0xA8, 0xAE, 0x7B, 0x16, 0x5D,
+	0xD8, 0xA9, 0x12, 0x89, 0x37, 0x76, 0x55, 0xE6, 0x1D, 0xE9, 0x3B, 0x5C,
+	    0xB2, 0xD2, 0xDD, 0x40, 0x9F, 0xE9, 0x0B, 0x0D,
+	0x01, 0xEF, 0x17, 0x6D, 0xE7, 0xFA, 0x6A, 0x9E, 0x69, 0x15, 0x1F, 0x4D,
+	    0x27, 0x17, 0x2D, 0x1D, 0x46, 0xCF, 0x6F, 0xED,
+	0x1F, 0x2C, 0x37, 0x5D, 0x3E, 0xDB, 0x2B, 0x0E, 0x7C, 0x6A, 0xB1, 0xB4,
+	    0xB7, 0x3F, 0x9D, 0x6A, 0xFF, 0xAA, 0x0A, 0x6E,
+	0xAE, 0x33, 0x32, 0x0F, 0x0D, 0xD3, 0xFA, 0xA6, 0x8F, 0x76, 0x92, 0x7A,
+	    0xBA, 0x2C, 0xC5, 0x8C, 0x6B, 0x60, 0xF6, 0xDE,
+	0x6D, 0x2D, 0x1C, 0x21, 0xFC, 0x11, 0x95, 0x48, 0x3D, 0xCB, 0x4D, 0x89,
+	    0x29, 0xDE, 0x5F, 0xFC, 0xBC, 0xE4, 0xE5, 0xA2,
+	0x22, 0xCD, 0x14, 0xB9, 0x8D, 0xE2, 0xE7, 0x8A, 0x6C, 0x8F, 0x44, 0x38,
+	    0x1D, 0xAF, 0xB2, 0xA6, 0x4C, 0x01, 0x1B, 0x1D,
+	0xC1, 0x36, 0x8C, 0x4C, 0x74, 0x9D, 0xD5, 0x82, 0xD5, 0x7A, 0xD7, 0xED,
+	    0x4D, 0x9C, 0x78, 0x51, 0xC2, 0x0C, 0xAD, 0x83,
+	0xC4, 0x2E, 0x84, 0x50, 0xD4, 0x7B, 0xDA, 0xF9, 0xCE, 0x9D, 0xA5, 0xA3,
+	    0x4B, 0x3F, 0x98, 0x49, 0xC0, 0x7F, 0x32, 0x96,
+	0x55, 0x53, 0xD2, 0xED, 0x8B, 0x4C, 0x4A, 0xE9, 0xD4, 0xB7, 0x03, 0x9A,
+	    0xCB, 0x0C, 0xC5, 0x48, 0x50, 0x4C, 0x66, 0xB1,
+	0x0B, 0x11, 0xE5, 0xB0, 0x12, 0x31, 0x62, 0x80, 0x06, 0x0B, 0xCF, 0x57,
+	    0xFA, 0x6B, 0x52, 0x30, 0x45, 0xC0, 0xD2, 0x34,
+	0x55, 0x60, 0x88, 0xD6, 0x58, 0xF5, 0xC1, 0x31, 0xA1, 0xFD, 0x77, 0xE9,
+	    0x4D, 0xD2, 0xF7, 0xBB, 0x5D, 0xF2, 0x0B, 0xE5,
+	0x07, 0x55, 0x35, 0x86, 0xA5, 0x29, 0xFD, 0xA8, 0xCF, 0x9A, 0x7D, 0x3F,
+	    0xB2, 0xFA, 0x23, 0x11, 0xE3, 0x52, 0x3D, 0xF5,
+	0xB3, 0xCA, 0x7C, 0xA2, 0x50, 0x37, 0xDF, 0xF4, 0x5D, 0xBC, 0x6D, 0xAA,
+	    0x17, 0xB8, 0x26, 0x44, 0xF1, 0x05, 0x50, 0x9D,
+	0x09, 0x34, 0x75, 0x9E, 0xCD, 0xEA, 0x83, 0x25, 0x98, 0x50, 0x47, 0xC5,
+	    0xE7, 0xC6, 0x87, 0x7B, 0x48, 0x49, 0xC6, 0xAB,
+	0x40, 0x39, 0xF7, 0x3B, 0xF5, 0xB6, 0x52, 0x40, 0x09, 0xAC, 0xBC, 0x6A,
+	    0x0E, 0x0B, 0x98, 0x32, 0xBB, 0xD9, 0x1F, 0x51,
+	0x58, 0x52, 0x84, 0x35, 0x4E, 0x2E, 0x99, 0xB0, 0x00, 0x43, 0x80, 0x6F,
+	    0x2C, 0xF1, 0x08, 0xEC, 0xA6, 0xD3, 0x1A, 0x7D,
+	0x14, 0xF4, 0x5C, 0xEA, 0x1F, 0x32, 0x1A, 0x3D, 0x5C, 0x9D, 0x18, 0x98,
+	    0x9C, 0x20, 0xDE, 0xEF, 0xC2, 0x0C, 0xF7, 0x3A,
+	0x0D, 0xDE, 0x81, 0x6F, 0x9A, 0xB8, 0xD3, 0xCF, 0x17, 0xBD, 0x76, 0x80,
+	    0x82, 0x01, 0xCF, 0xA8, 0x0C, 0x1C, 0x97, 0xFB,
+	0x8C, 0x5C, 0x68, 0x04, 0x06, 0xD0, 0x00, 0x9C, 0x2B, 0xBE, 0xAD, 0x7F,
+	    0x9D, 0x06, 0x41, 0xFB, 0x16, 0xB2, 0x22, 0x11,
+	0x2A, 0x02, 0x44, 0xDA, 0xB1, 0xFF, 0xD3, 0x10, 0x01, 0x01, 0xB1, 0x56,
+	    0xB0, 0x8C, 0xCE, 0x17, 0xE0, 0xEE, 0x58, 0xAC,
+	0x3B, 0x23, 0xF7, 0xFF, 0x86, 0xC0, 0x56, 0x81, 0x86, 0xE8, 0xD0, 0x33,
+	    0x61, 0xED, 0xEE, 0xA1, 0x92, 0x3D, 0x09, 0x93,
+	0x33, 0x43, 0xDB, 0x05, 0x1C, 0x41, 0x48, 0x0E, 0xA7, 0x98, 0x58, 0x48,
+	    0xD7, 0xF1, 0x94, 0x42, 0x06, 0x1F, 0x8A, 0xA6,
+	0xED, 0x22, 0xE7, 0x1C, 0xB6, 0xFD, 0x2F, 0x17, 0x2F, 0xC7, 0x49, 0x36,
+	    0xE8, 0x16, 0x4F, 0x69, 0xF8, 0xE6, 0x47, 0x6F,
+	0x36, 0x43, 0x47, 0x0B, 0x5D, 0xCA, 0x0F, 0x27, 0x69, 0xE5, 0xE1, 0x25,
+	    0x33, 0xAC, 0x91, 0xB5, 0x93, 0x92, 0x8D, 0x22,
+	0xDC, 0xC9, 0xE5, 0x22, 0xF6, 0xA1, 0xA9, 0xE2, 0x60, 0x2A, 0x28, 0xF9,
+	    0x62, 0x98, 0x81, 0xF7, 0x7D, 0x66, 0xC2, 0x9C,
+	0x7F, 0x08, 0x7D, 0x88, 0x0E, 0x3F, 0x12, 0xEF, 0x96, 0xC3, 0x9F, 0xA8,
+	    0x4E, 0xD0, 0x7B, 0x0C, 0x0F, 0xCB, 0x75, 0x9E,
+	0xAB, 0x69, 0x7B, 0xF8, 0x4D, 0x68, 0x5B, 0x41, 0x5F, 0xCB, 0x03, 0x09,
+	    0x88, 0x0C, 0xEB, 0x6F, 0x9E, 0x78, 0x33, 0xC3,
+	0xA1, 0xA9, 0xF3, 0x87, 0xCC, 0x28, 0xD0, 0x19, 0x89, 0x0B, 0x4B, 0x89,
+	    0xFC, 0x8B, 0xDC, 0x4A, 0xFB, 0xBD, 0xBD, 0x4F,
+	0xA5, 0x94, 0x13, 0x3B, 0x73, 0xAA, 0x3B, 0x6B, 0xBB, 0x53, 0xE6, 0x0A,
+	    0xB5, 0x0E, 0xEA, 0x96, 0xF6, 0x61, 0x03, 0x3E,
+	0xF8, 0x1D, 0xB4, 0x1D, 0xB7, 0x20, 0x51, 0x0A, 0xB8, 0xF2, 0x86, 0xF8,
+	    0x20, 0x74, 0x95, 0x09, 0x8C, 0x15, 0xA3, 0xFA,
+	0x2D, 0x23, 0x96, 0x70, 0xCC, 0x84, 0xAC, 0x52, 0xFD, 0xBB, 0xF3, 0xA2,
+	    0x41, 0x1C, 0xB5, 0x19, 0xA8, 0x75, 0x3B, 0xD3,
+	0x8D, 0x0D, 0x60, 0x3F, 0x7A, 0x92, 0xC4, 0x0C, 0x05, 0x0B, 0xFB, 0x00,
+	    0x72, 0x6F, 0xD4, 0x2C, 0x27, 0x4D, 0x60, 0x84,
+	0xD1, 0xA3, 0x6C, 0x92, 0x26, 0x1C, 0x4E, 0xE0, 0xB3, 0xD6, 0xEE, 0x72,
+	    0xC0, 0x13, 0xE2, 0x50, 0x8C, 0xD7, 0xCE, 0x05,
+	0xE6, 0x48, 0xE5, 0x2F, 0xB4, 0x70, 0x3D, 0xC3, 0xE6, 0x00, 0x3A, 0xE2,
+	    0x3A, 0x21, 0x47, 0x8C, 0x4A, 0xD0, 0x76, 0x11,
+	0xA7, 0xF9, 0xDC, 0x4E, 0xE7, 0x01, 0xC8, 0x46, 0xDA, 0x31, 0x7B, 0x5F,
+	    0xDD, 0x89, 0x70, 0xA6, 0xD9, 0x1C, 0x90, 0x86,
+	0x9F, 0x4F, 0xAB, 0xDB, 0x51, 0xA1, 0xE7, 0x10, 0x33, 0x5B, 0x91, 0x18,
+	    0x9E, 0x59, 0xF7, 0x75, 0xF0, 0x6A, 0x4C, 0x5B,
+	0x7B, 0xB5, 0xA6, 0x86, 0xA4, 0x64, 0x71, 0xA7, 0x59, 0x7E, 0xD5, 0xBF,
+	    0x6F, 0x34, 0x4A, 0x61, 0x89, 0x6F, 0xCB, 0xD3,
+	0xE3, 0x5B, 0x09, 0x26, 0xBE, 0x07, 0x3D, 0x46, 0x54, 0x15, 0xF8, 0xF3,
+	    0x67, 0x13, 0x66, 0x8A, 0x8E, 0x15, 0xE6, 0x26,
+	0x7C, 0x7A, 0x19, 0x2A, 0xDA, 0x1A, 0xD5, 0x68, 0x7E, 0x2A, 0xBD, 0x7A,
+	    0x49, 0x19, 0xA8, 0xEE, 0x45, 0x96, 0x4C, 0xFF,
+	0xA3, 0x50, 0xA4, 0x51, 0xF9, 0x26, 0x59, 0x6B, 0xAC, 0x9F, 0x46, 0xF0,
+	    0xBE, 0x98, 0xD7, 0x25, 0x3E, 0xF7, 0x08, 0x29,
+	0xB2, 0xDE, 0x71, 0x35, 0x5C, 0x98, 0x14, 0xE3, 0xDB, 0x1B, 0x17, 0xF8,
+	    0x00, 0xD8, 0xE2, 0x57, 0x74, 0x39, 0x80, 0x8E,
+	0x66, 0x27, 0x7A, 0x49, 0xD1, 0xB4, 0x15, 0x30, 0xE8, 0x58, 0xEE, 0xC8,
+	    0x79, 0x3C, 0xF2, 0x30, 0x6F, 0xC1, 0xB1, 0x26,
+	0xC7, 0x36, 0x5E, 0x7C, 0x39, 0xFC, 0x5E, 0x9B, 0x5F, 0x49, 0x0E, 0xAE,
+	    0x5D, 0x2E, 0xE1, 0x79, 0xF3, 0xB3, 0x27, 0x8B,
+	0x11, 0xC5, 0x69, 0xC9, 0x44, 0xA1, 0xE3, 0x5C, 0x7E, 0x7D, 0x7C, 0xA0,
+	    0xBD, 0xF5, 0xE0, 0x11, 0xEF, 0x83, 0x7F, 0xF3,
+	0x77, 0xF2, 0x20, 0x80, 0xB6, 0xD0, 0xF6, 0x07, 0x33, 0x00, 0x4E, 0x8A,
+	    0xAD, 0x23, 0x0B, 0x96, 0x5C, 0x3F, 0x28, 0x12,
+	0x05, 0x87, 0xD9, 0x02, 0x13, 0xF3, 0x49, 0x2E, 0x43, 0x93, 0xEB, 0xCC,
+	    0xD7, 0xF6, 0xE1, 0x97, 0xF3, 0x82, 0xF3, 0x06,
+	0xF1, 0xA4, 0xD2, 0xD0, 0xAA, 0xC4, 0x8B, 0x9E, 0x2F, 0x6F, 0x58, 0x0F,
+	    0x83, 0x41, 0x36, 0x93, 0xC7, 0x9B, 0xF3, 0x59,
+	0x44, 0xCE, 0x7B, 0xB3, 0xC3, 0xE9, 0x9F, 0x38, 0xCC, 0x67, 0x58, 0xB5,
+	    0x1B, 0xB4, 0xB2, 0x16, 0x7D, 0x9E, 0xD8, 0x04,
+	0x50, 0x86, 0xEE, 0xF2, 0x4B, 0x64, 0x3A, 0x07, 0x97, 0x74, 0x21, 0x66,
+	    0x92, 0xA9, 0x90, 0x14, 0xA4, 0x8B, 0xA1, 0xCE,
+	0x5F, 0x8E, 0x59, 0xB4, 0xD7, 0x02, 0xCD, 0x9D, 0xDE, 0xAB, 0x84, 0xA5,
+	    0x77, 0x59, 0x81, 0xC6, 0x07, 0xE6, 0xA3, 0x4A,
+	0x68, 0xA1, 0xBD, 0x2D, 0xC9, 0xD9, 0x46, 0xEC, 0x22, 0x71, 0xF9, 0x0A,
+	    0x0C, 0x88, 0x62, 0x96, 0x62, 0xEA, 0x0C, 0x9A,
+	0xC1, 0xAA, 0xD2, 0x84, 0x08, 0xAA, 0xEA, 0x8E, 0x7A, 0x89, 0xBA, 0x7C,
+	    0xEA, 0xCC, 0x52, 0x58, 0x4B, 0x9B, 0x9C, 0xBC,
+	0xF3, 0xC8, 0x23, 0x89, 0x3E, 0xC8, 0x62, 0xDB, 0x1E, 0xCD, 0xCC, 0xAF,
+	    0xDA, 0x9D, 0x72, 0x52, 0xDA, 0x48, 0x2B, 0x1B,
+	0x8D, 0xF6, 0x93, 0xE0, 0x7C, 0x34, 0xC4, 0xBF, 0x9F, 0x68, 0x83, 0x02,
+	    0x22, 0xED, 0xCA, 0xDF, 0x35, 0x0F, 0xC2, 0x2E,
+	0xBF, 0x26, 0x0F, 0x85, 0xDB, 0x11, 0xFA, 0x7A, 0x96, 0xC7, 0x2F, 0x3D,
+	    0x21, 0xCF, 0x8A, 0xE9, 0xA8, 0xA0, 0x42, 0x81,
+	0x3C, 0xCD, 0x6A, 0xFC, 0xF1, 0xEC, 0xDF, 0x7A, 0x2F, 0x71, 0x9B, 0x72,
+	    0x75, 0x6D, 0xDA, 0xE9, 0x4E, 0x34, 0x6C, 0x7C,
+	0xF9, 0xE5, 0xAE, 0x00, 0x8E, 0xED, 0x12, 0x78, 0x3E, 0xD0, 0xD4, 0x14,
+	    0x12, 0x8D, 0xC3, 0x85, 0x73, 0xE2, 0x20, 0x71,
+	0x1E, 0x1D, 0xDA, 0xFF, 0xB6, 0x57, 0xD8, 0x31, 0x4D, 0xDA, 0x76, 0x33,
+	    0x77, 0x50, 0x80, 0x01, 0x00, 0x99, 0x18, 0x12,
+	0x23, 0x48, 0xFC, 0x3E, 0x22, 0xD7, 0x39, 0x32, 0x27, 0xBB, 0x5B, 0x33,
+	    0x4D, 0x11, 0x5E, 0x03, 0xA2, 0x78, 0xE4, 0x21,
+	0x0A, 0x0D, 0xEB, 0xDF, 0x74, 0xF6, 0xAD, 0xB2, 0xC9, 0x37, 0x6D, 0x06,
+	    0x7D, 0x67, 0xCB, 0x4D, 0xE3, 0x81, 0x7D, 0x3B,
+	0x88, 0xB1, 0x0D, 0x29, 0xD9, 0x92, 0xEF, 0xD8, 0x4B, 0x40, 0xD8, 0x67,
+	    0xB3, 0xB6, 0x10, 0xC2, 0x8B, 0x40, 0x37, 0xD2,
+	0x21, 0xF7, 0x40, 0xA9, 0xFD, 0xE6, 0x8A, 0x08, 0x92, 0xDA, 0x53, 0xEC,
+	    0xD4, 0x70, 0x45, 0x1F, 0x07, 0x29, 0xBD, 0x43,
+	0xB8, 0x81, 0x1C, 0x08, 0x19, 0xD0, 0x8D, 0xD5, 0x46, 0xF9, 0xD5, 0xAC,
+	    0x94, 0xD7, 0x56, 0x44, 0x8D, 0xBD, 0xC9, 0x8C,
+	0x44, 0x95, 0xEC, 0xA9, 0x2F, 0xF8, 0xED, 0x3B, 0xC5, 0x3B, 0x39, 0x91,
+	    0x1F, 0xBE, 0xD5, 0x28, 0xDE, 0x18, 0xF0, 0xBD,
+	0xA0, 0x61, 0xAE, 0xBB, 0x01, 0x34, 0x64, 0xED, 0x0B, 0x18, 0x16, 0xD8,
+	    0x6B, 0x8B, 0xA4, 0xBF, 0x5E, 0x93, 0xCB, 0x18,
+	0xF3, 0x92, 0xD6, 0x93, 0xBA, 0xE8, 0xF7, 0x27, 0xAB, 0xC7, 0xD7, 0x05,
+	    0x94, 0xF7, 0x7D, 0x88, 0x80, 0x94, 0x97, 0x60,
+	0x54, 0x88, 0xCD, 0x79, 0x4C, 0x99, 0xEF, 0x2A, 0xBD, 0xE0, 0xCD, 0x8D,
+	    0x20, 0x40, 0x68, 0x4C, 0x8C, 0xAE, 0x35, 0x66,
+	0xE1, 0x71, 0xC4, 0xD2, 0x89, 0xBD, 0x98, 0x30, 0x29, 0x0F, 0x4D, 0xA7,
+	    0xD4, 0x64, 0x1D, 0x78, 0xEF, 0xFA, 0xFE, 0xD7,
+	0x82, 0x49, 0xA3, 0x01, 0x15, 0x98, 0xDF, 0x31, 0x12, 0xB3, 0x2F, 0x70,
+	    0x07, 0x27, 0x84, 0xEF, 0xE2, 0x29, 0x24, 0x5F,
+	0xB1, 0x2F, 0xD1, 0x3F, 0xD7, 0xF4, 0x47, 0xBB, 0x97, 0x53, 0x87, 0xED,
+	    0x00, 0x4A, 0x78, 0x24, 0xE1, 0x9C, 0xF8, 0x36,
+	0x60, 0xBF, 0x68, 0xCA, 0xEC, 0x4D, 0xBB, 0xCF, 0xE0, 0x24, 0xB7, 0x2D,
+	    0xFE, 0xDC, 0x9B, 0xEE, 0x85, 0x2E, 0x61, 0x43,
+	0xC5, 0xE3, 0xED, 0x34, 0x4A, 0x36, 0x78, 0xF0, 0x23, 0x12, 0xBC, 0x1B,
+	    0x33, 0xA7, 0x00, 0xC3, 0x09, 0x4D, 0x01, 0x8F,
+	0xD0, 0x4E, 0xDD, 0xEF, 0x70, 0x60, 0xB6, 0x27, 0xE1, 0xBC, 0xB9, 0xD1,
+	    0xC5, 0xE1, 0x99, 0x0C, 0x20, 0x17, 0x7F, 0xCF,
+	0xF9, 0x99, 0xB9, 0x22, 0xF9, 0x75, 0x76, 0x67, 0xE1, 0x4A, 0xB2, 0x64,
+	    0xBB, 0xB5, 0x31, 0x4D, 0xC8, 0x0A, 0xB6, 0xF4,
+	0xEB, 0x54, 0x9A, 0xE3, 0x45, 0x87, 0x34, 0x0B, 0x91, 0x65, 0xA0, 0xBB,
+	    0x33, 0x30, 0x01, 0xE1, 0x9E, 0x2B, 0xF5, 0xA3,
+	0x46, 0x04, 0xB3, 0x64, 0xD3, 0x74, 0xA0, 0x23, 0x5A, 0x78, 0x7E, 0x7C,
+	    0x95, 0x5C, 0x3F, 0xF5, 0x85, 0xE1, 0x62, 0xE7,
+	0xD7, 0x6F, 0x79, 0x76, 0xD2, 0x95, 0x3B, 0x12, 0xBB, 0xAD, 0xB6, 0x4A,
+	    0x7A, 0x47, 0xEA, 0x3E, 0x85, 0xB4, 0xB1, 0x83,
+	0xFE, 0xF9, 0xF2, 0x2E, 0x61, 0xB5, 0x24, 0x3E, 0x71, 0xE6, 0x37, 0xD7,
+	    0x6A, 0x7B, 0x62, 0x49, 0xC0, 0x95, 0xAC, 0x27,
+	0x3B, 0x5E, 0x83, 0x86, 0xC0, 0x48, 0xBC, 0xD7, 0x31, 0x65, 0x65, 0xFB,
+	    0x30, 0x86, 0xDA, 0x2C, 0x3A, 0x94, 0xBB, 0x4A,
+	0x45, 0x18, 0x24, 0x00, 0x26, 0xB6, 0x78, 0x12, 0xBD, 0x81, 0xEE, 0x52,
+	    0x6A, 0xD8, 0x92, 0xFC, 0x80, 0xC1, 0x55, 0x1F,
+	0x78, 0x6D, 0xAD, 0xAB, 0xA8, 0x50, 0x13, 0xD7, 0xCF, 0xFC, 0x74, 0x7F,
+	    0x82, 0x42, 0xFA, 0x7E, 0x4B, 0x05, 0x6A, 0xA2,
+	0xAE, 0x73, 0xD4, 0x72, 0xA6, 0x6C, 0x8F, 0x1B, 0x44, 0x2B, 0x6D, 0x7C,
+	    0xD7, 0x6D, 0xA8, 0x1D, 0x28, 0x32, 0x6C, 0x60,
+	0x16, 0x82, 0x75, 0x7E, 0x5A, 0xE3, 0x8B, 0x75, 0x5B, 0x0F, 0x94, 0xC7,
+	    0xB2, 0xAF, 0x93, 0xDA, 0x5A, 0x3F, 0x2A, 0xA7,
+	0x54, 0xFF, 0x2F, 0x01, 0x87, 0xCD, 0x9C, 0xD6, 0xEA, 0x8C, 0x1C, 0x65,
+	    0x92, 0x21, 0x64, 0x97, 0xD8, 0x37, 0xE7, 0xFF,
+	0x5F, 0x4D, 0x82, 0x52, 0x03, 0x4F, 0xFA, 0xF7, 0xC2, 0xAD, 0xB1, 0xCA,
+	    0x6E, 0xFD, 0x41, 0x5E, 0x01, 0x11, 0x5D, 0xE6,
+	0xB9, 0x54, 0xD3, 0x93, 0xB1, 0xCE, 0x8D, 0x5B, 0x5F, 0x73, 0xDD, 0x62,
+	    0xB9, 0x05, 0x90, 0x3F, 0xD7, 0x77, 0x9A, 0xF9,
+	0x32, 0x76, 0x55, 0x10, 0x6E, 0x32, 0xEF, 0x7A, 0x85, 0xDF, 0x77, 0x75,
+	    0xD0, 0x0B, 0xC4, 0xD0, 0xB3, 0x57, 0x6E, 0xC1,
+	0xE7, 0xFA, 0x1C, 0x55, 0x2C, 0xEA, 0xBE, 0xBA, 0x8C, 0xA9, 0x15, 0xE6,
+	    0x70, 0x66, 0xAD, 0x11, 0xA2, 0x3D, 0xAD, 0xE1,
+	0x1B, 0x47, 0x31, 0xF5, 0x46, 0x88, 0xF3, 0x75, 0x93, 0x3A, 0xFD, 0x82,
+	    0x40, 0xF4, 0x69, 0x97, 0x08, 0xDA, 0x68, 0xFA,
+	0xA5, 0xAE, 0x11, 0x73, 0xCD, 0x5B, 0x52, 0xDB, 0xEC, 0x69, 0xAB, 0x22,
+	    0x79, 0x98, 0xB5, 0x38, 0xC4, 0xBB, 0xA5, 0x39,
+	0xE8, 0x95, 0xCF, 0x4B, 0xE5, 0x44, 0x7F, 0x57, 0x25, 0x67, 0x78, 0xFB,
+	    0x7A, 0x85, 0x7C, 0xD6, 0x96, 0x86, 0x69, 0xAF,
+	0x01, 0x3E, 0xAC, 0x22, 0x0B, 0x47, 0xFF, 0x4A, 0x48, 0x77, 0x2F, 0x38,
+	    0x70, 0x7F, 0x67, 0xCA, 0x4A, 0x3E, 0xA7, 0xCF,
+	0x60, 0x24, 0x47, 0xBE, 0xD1, 0x0C, 0x00, 0x8B, 0xD3, 0xED, 0xF2, 0x1B,
+	    0xE6, 0x1D, 0x43, 0xDD, 0xDB, 0xFD, 0xB1, 0xFC,
+	0xDA, 0xD2, 0x0E, 0x78, 0x9F, 0xBB, 0x05, 0x67, 0x14, 0xFF, 0x8C, 0x4B,
+	    0x90, 0x19, 0xFD, 0x37, 0xBA, 0xD3, 0xA5, 0xCC,
+	0xB9, 0x3C, 0x8A, 0xF8, 0x91, 0x33, 0xE8, 0x1E, 0x7E, 0xF3, 0x4E, 0xA2,
+	    0x4C, 0x0F, 0xC9, 0x9D, 0xA3, 0x8A, 0x84, 0xDB,
+	0xED, 0x64, 0xE7, 0x13, 0x57, 0x72, 0x8B, 0xF9, 0x20, 0x3D, 0x9D, 0x19,
+	    0xB7, 0x25, 0x4E, 0x25, 0xE5, 0x6F, 0x64, 0xD8,
+	0xAD, 0x83, 0x0A, 0x32, 0x82, 0x13, 0xD3, 0x79, 0xC1, 0xAE, 0x70, 0x3B,
+	    0xFC, 0x60, 0x05, 0x93, 0xEA, 0xE3, 0x58, 0xF0,
+	0x27, 0x5F, 0xB2, 0x5C, 0xFE, 0xAD, 0x49, 0x04, 0x65, 0x83, 0xCE, 0x5D,
+	    0xFA, 0x7D, 0xD2, 0x28, 0x26, 0x28, 0x9B, 0xE9,
+	0x2D, 0xAC, 0x99, 0xD9, 0x01, 0xCC, 0x57, 0x32, 0x4F, 0xEB, 0x07, 0x06,
+	    0xA5, 0x99, 0xF3, 0xD4, 0x12, 0xAC, 0xD0, 0x28,
+	0xE5, 0xA1, 0x3C, 0xC6, 0x29, 0x4F, 0x51, 0x32, 0x5B, 0x18, 0x90, 0xA9,
+	    0x36, 0x47, 0x56, 0x75, 0xD6, 0x69, 0x38, 0xD7,
+	0x22, 0x3A, 0x02, 0x12, 0x25, 0xC7, 0x6D, 0x34, 0xA2, 0x2C, 0x5F, 0x64,
+	    0x0F, 0xC9, 0x89, 0x63, 0x3F, 0xD7, 0xC5, 0xD6,
+	0x74, 0x3A, 0xB0, 0xE6, 0x32, 0x26, 0xD9, 0x39, 0xE3, 0xC9, 0x4D, 0x15,
+	    0x28, 0x4A, 0x5A, 0x02, 0xF1, 0x79, 0x1F, 0x11,
+	0xBF, 0x2D, 0x33, 0x5C, 0x68, 0xBF, 0xB0, 0x41, 0xC6, 0x97, 0x22, 0x0F,
+	    0x9F, 0x83, 0x85, 0xB7, 0xEA, 0x24, 0x9A, 0xD0,
+	0xE8, 0x66, 0xC7, 0xD0, 0x79, 0xF2, 0xDC, 0x70, 0xA2, 0x35, 0x0C, 0x5C,
+	    0x3F, 0x7B, 0xC8, 0x27, 0x75, 0x6B, 0x34, 0xE5,
+	0x35, 0x67, 0xA9, 0xC8, 0x2E, 0xC4, 0xF8, 0xE5, 0x28, 0x2E, 0x43, 0x33,
+	    0x68, 0x8A, 0xFA, 0x40, 0xA1, 0x14, 0xA6, 0xB1,
+	0xFB, 0xEE, 0xDA, 0xB0, 0xE3, 0xC0, 0xD6, 0xA8, 0xCA, 0x41, 0x67, 0x5F,
+	    0xFF, 0x6D, 0x03, 0xB9, 0x2B, 0x90, 0x79, 0xCC,
+	0x17, 0xA7, 0x7E, 0xFD, 0xE8, 0xDD, 0xA8, 0xC9, 0x59, 0xCE, 0x98, 0x34,
+	    0x80, 0x71, 0x00, 0x0F, 0xCE, 0x03, 0x97, 0x8D,
+	0xDE, 0x45, 0x4F, 0x9C, 0x5A, 0x63, 0x73, 0x46, 0x72, 0xE3, 0x69, 0xAE,
+	    0xEB, 0x8F, 0x21, 0x7F, 0x41, 0x80, 0xCB, 0x38,
+	0x01, 0x10, 0xC3, 0x7D, 0xC5, 0x46, 0x41, 0xFD, 0xA2, 0x2D, 0x4C, 0x86,
+	    0x67, 0xE0, 0x8E, 0xFC, 0xCB, 0xB1, 0x80, 0xE0,
+	0xFF, 0x2E, 0xA4, 0x8E, 0xDE, 0xF5, 0xC6, 0xBA, 0x81, 0xDE, 0x2B, 0x49,
+	    0x80, 0x92, 0xDE, 0x07, 0xAA, 0x1D, 0xC0, 0xF4,
+	0x30, 0xA4, 0x08, 0x92, 0x60, 0xCE, 0xEB, 0x45, 0xF6, 0x0F, 0x17, 0x09,
+	    0x56, 0x97, 0x16, 0x18, 0x42, 0x0E, 0xAD, 0x1C,
+	0x12, 0xE3, 0x46, 0xCC, 0xDB, 0x4C, 0xDF, 0x34, 0x36, 0x69, 0x71, 0xF9,
+	    0x0E, 0xF6, 0xE2, 0x90, 0x8D, 0xE5, 0x58, 0x7D,
+	0x8D, 0xA9, 0xD8, 0xA9, 0x84, 0xF0, 0xDB, 0xFB, 0xCB, 0x84, 0xB1, 0xB2,
+	    0x63, 0xF8, 0x8C, 0x31, 0x8A, 0x73, 0x9F, 0xE7,
+	0x57, 0x99, 0xBA, 0x7C, 0x1F, 0xC9, 0x4B, 0xCA, 0x6B, 0x70, 0x96, 0x1D,
+	    0xF0, 0xAF, 0xD6, 0x31, 0x0B, 0x6A, 0x2D, 0x3F,
+	0xB7, 0x1A, 0x82, 0x03, 0x40, 0x76, 0xFD, 0x89, 0x35, 0x77, 0xA2, 0x0E,
+	    0x22, 0x17, 0x47, 0x75, 0xCD, 0x8E, 0x0B, 0x9B,
+	0xE8, 0xC4, 0x9D, 0x0B, 0xAD, 0xE4, 0x14, 0x05, 0xD2, 0x14, 0x44, 0xEC,
+	    0xE8, 0xC6, 0xC6, 0x9E, 0xDC, 0x2D, 0x38, 0x31,
+	0x8C, 0xAF, 0x77, 0x58, 0xE0, 0xF6, 0xDC, 0x92, 0x77, 0xB5, 0xCF, 0xD8,
+	    0x4F, 0xCA, 0x63, 0xE5, 0xFE, 0x14, 0xCC, 0x65,
+	0x89, 0x37, 0x95, 0xC4, 0x0A, 0x36, 0x47, 0x89, 0x3C, 0xAF, 0x86, 0x34,
+	    0xFC, 0xAB, 0x1E, 0xEE, 0xDF, 0xD3, 0xB6, 0x6E,
+	0x93, 0xFC, 0x63, 0x6E, 0x44, 0x87, 0xFE, 0xEB, 0x73, 0xFF, 0xD5, 0x3C,
+	    0x3F, 0x60, 0xDA, 0x4C, 0x37, 0xB5, 0x26, 0xFE,
+	0xC6, 0xA2, 0xC0, 0x5E, 0xDC, 0x5D, 0x66, 0xB0, 0x09, 0x8E, 0xDB, 0x20,
+	    0xB8, 0xFD, 0x4F, 0x18, 0xD2, 0x51, 0xF3, 0x6B,
+	0xD8, 0x9E, 0x97, 0xFF, 0x1F, 0xDB, 0x7B, 0x18, 0x56, 0x4E, 0x25, 0x3B,
+	    0x87, 0xAE, 0xEA, 0xBC, 0x1E, 0xBE, 0x3A, 0xF3,
+	0x38, 0x8B, 0x15, 0x77, 0x28, 0x62, 0x05, 0xA4, 0x73, 0x8E, 0xAC, 0x46,
+	    0xA3, 0x05, 0xB0, 0xE3, 0x3D, 0x8B, 0xDC, 0x6E,
+	0xFA, 0x45, 0x8F, 0xB4, 0x6B, 0x1A, 0x58, 0xB8, 0x54, 0x67, 0x49, 0x30,
+	    0xB8, 0x1D, 0x51, 0xA4, 0x6F, 0x60, 0xB6, 0x0D,
+	0xA3, 0x0D, 0xA9, 0xDE, 0xE3, 0x8B, 0x8E, 0x71, 0xB0, 0xA1, 0x32, 0xF7,
+	    0x3D, 0xDE, 0x43, 0xCE, 0x62, 0xC8, 0xA9, 0x21,
+	0xD7, 0xA1, 0x1C, 0x6E, 0x31, 0xB0, 0x7D, 0x79, 0xED, 0x79, 0x28, 0x52,
+	    0x2A, 0x75, 0xEB, 0x14, 0xD2, 0x72, 0x30, 0x54,
+	0xEA, 0x54, 0xB7, 0x3E, 0x61, 0xBA, 0x26, 0x76, 0xA2, 0xC6, 0x4F, 0x3B,
+	    0xAE, 0x19, 0xC3, 0x43, 0xEE, 0xAD, 0x12, 0xBB,
+	0x2B, 0x95, 0x47, 0x03, 0xA2, 0x57, 0x41, 0x5B, 0xA6, 0x93, 0x89, 0xF0,
+	    0xF6, 0xF8, 0x59, 0xD7, 0x7D, 0x38, 0xEB, 0x82,
+	0x4F, 0x06, 0x70, 0x0B, 0x46, 0x3A, 0x97, 0x7B, 0x34, 0x82, 0xFA, 0x37,
+	    0x20, 0xDD, 0x6A, 0x19, 0x74, 0xE7, 0xBB, 0x52,
+	0xFB, 0x0D, 0x75, 0x27, 0x31, 0x4B, 0xAA, 0x15, 0x1F, 0x0A, 0x43, 0x89,
+	    0xEC, 0xC8, 0x1A, 0x4F, 0x6D, 0x2B, 0x84, 0x69,
+	0x8B, 0x87, 0x12, 0x89, 0xAB, 0x5B, 0x86, 0xF9, 0x6B, 0xB5, 0x2C, 0xCF,
+	    0xB3, 0x65, 0x57, 0x37, 0x60, 0x7A, 0xB0, 0xEE,
+	0x15, 0xA6, 0x63, 0x44, 0xEA, 0xDB, 0xCF, 0x41, 0x2E, 0x0E, 0xF6, 0x2A,
+	    0x88, 0xEB, 0xFA, 0xA2, 0xB6, 0x21, 0x44, 0x0A,
+	0x22, 0x41, 0x06, 0xFF, 0xFB, 0x53, 0x80, 0xA7, 0xA7, 0x00, 0x42, 0xB4,
+	    0x08, 0x60, 0x60, 0xC8, 0xA9, 0xE2, 0xA5, 0x82,
+	0x5D, 0xEF, 0xAC, 0x16, 0x8C, 0x2D, 0x3E, 0x43, 0x93, 0x81, 0x41, 0x48,
+	    0x21, 0x0A, 0xAA, 0x49, 0x3B, 0xF1, 0x2B, 0xEE,
+	0x22, 0xF3, 0xB5, 0x18, 0x8B, 0x62, 0xFF, 0x5D, 0x3F, 0xAC, 0x22, 0x0F,
+	    0x64, 0x34, 0xD2, 0x04, 0x06, 0xB8, 0x3F, 0x16,
+	0x30, 0x3A, 0x6B, 0x9D, 0x9F, 0xCD, 0x20, 0xC6, 0x8F, 0x32, 0x36, 0x20,
+	    0xC3, 0x53, 0x77, 0xB3, 0x90, 0x37, 0x0A, 0xD2,
+	0x01, 0xC5, 0x28, 0xD6, 0x8A, 0x33, 0x17, 0xC4, 0x4B, 0x56, 0xC9, 0x01,
+	    0x9A, 0x68, 0xC6, 0x5F, 0x09, 0x63, 0xC1, 0xA3,
+	0x51, 0xED, 0xDD, 0xF0, 0x48, 0x22, 0x7B, 0xF6, 0xB7, 0x70, 0x60, 0x76,
+	    0x4C, 0xA5, 0xC2, 0xDD, 0x7E, 0x8E, 0xC0, 0xE4,
+	0x87, 0x6B, 0xDE, 0xC6, 0x81, 0x69, 0xEC, 0x9E, 0x4C, 0xF2, 0xEC, 0x23,
+	    0xA8, 0x35, 0x34, 0xD4, 0xCA, 0x44, 0x75, 0xE5,
+	0x92, 0xB4, 0x88, 0x63, 0xC2, 0x8A, 0x3B, 0x87, 0xFF, 0xA3, 0x85, 0x31,
+	    0x0A, 0xBD, 0xDF, 0xC7, 0x20, 0x77, 0x6D, 0x1A,
+	0x11, 0x17, 0x39, 0x1B, 0x1B, 0x32, 0xDD, 0x53, 0x11, 0x47, 0x86, 0x3F,
+	    0x52, 0x78, 0xE2, 0xC0, 0x42, 0xA8, 0x4D, 0x32,
+	0x04, 0xDA, 0x10, 0xEA, 0x48, 0x30, 0x97, 0x08, 0x43, 0x21, 0x53, 0xCF,
+	    0xBE, 0x50, 0xF4, 0xFE, 0x8D, 0xFE, 0xB2, 0x6B,
+	0xAD, 0x94, 0x22, 0xE3, 0xE3, 0xE4, 0x12, 0x3C, 0x43, 0x1D, 0xCA, 0xBA,
+	    0xD8, 0xA6, 0xC7, 0x2D, 0xE1, 0x9B, 0xDE, 0x8A,
+	0x1D, 0x85, 0x19, 0xD2, 0xB9, 0x53, 0x97, 0xED, 0xDA, 0x38, 0x5D, 0x2B,
+	    0xAF, 0x58, 0xED, 0x9D, 0xBA, 0xF8, 0x27, 0x47,
+	0x45, 0x56, 0x2B, 0xDF, 0x74, 0xFD, 0x86, 0x5C, 0x4F, 0x1A, 0xC7, 0x2A,
+	    0x1E, 0xE3, 0xED, 0x4D, 0x9D, 0xD7, 0x4D, 0x73,
+	0x93, 0xC5, 0xFA, 0xBA, 0x90, 0x78, 0x0E, 0x59, 0x9E, 0xE0, 0x04, 0xD6,
+	    0x1D, 0xF2, 0x4F, 0xEF, 0x56, 0x72, 0x36, 0x4D,
+	0x0B, 0x01, 0xFA, 0x36, 0xC9, 0x3E, 0x66, 0xD4, 0x01, 0x1A, 0x34, 0xC9,
+	    0x77, 0xD8, 0x77, 0x37, 0x07, 0x12, 0xE5, 0x37,
+	0xF8, 0x30, 0xFB, 0x9B, 0xCF, 0xFE, 0xED, 0xCC, 0xC3, 0xDE, 0x6A, 0x1F,
+	    0x65, 0xA0, 0xD8, 0x21, 0xB7, 0x0D, 0xF0, 0x83,
+	0xB5, 0x6F, 0x88, 0xD9, 0x52, 0xA3, 0x3E, 0x3B, 0xEE, 0xC5, 0x28, 0x57,
+	    0x61, 0x0A, 0x3A, 0xD0, 0x6D, 0xA0, 0x18, 0x44,
+	0x37, 0x66, 0x79, 0xBE, 0xE7, 0x9E, 0x34, 0xD7, 0x37, 0xAB, 0x95, 0x51,
+	    0x67, 0xA7, 0x3C, 0x17, 0x9D, 0x4D, 0x13, 0xA3,
+	0x6B, 0x2C, 0xD1, 0x13, 0x7C, 0xF2, 0x60, 0x2C, 0x20, 0x1C, 0x79, 0x96,
+	    0x75, 0x5C, 0x18, 0x65, 0xFB, 0x8B, 0x9E, 0x16,
+	0x94, 0xA0, 0xCB, 0xC7, 0x8C, 0xC9, 0xF4, 0x8D, 0xE5, 0xA4, 0xA8, 0xF3,
+	    0x30, 0x28, 0xD2, 0xAD, 0xE4, 0xE4, 0x29, 0x8D,
+	0xF2, 0x16, 0x78, 0x44, 0x37, 0xF0, 0x3B, 0xA5, 0xEE, 0xD7, 0xFD, 0x25,
+	    0x7D, 0x0E, 0x0E, 0x99, 0x7B, 0x67, 0x6A, 0xA2,
+	0xBD, 0xE9, 0x7C, 0xB1, 0xE4, 0x8D, 0x50, 0xA8, 0xB9, 0x01, 0x82, 0x18,
+	    0xBD, 0x78, 0x87, 0x71, 0x3E, 0xE8, 0x86, 0x68,
+	0x81, 0x01, 0x62, 0xAF, 0x69, 0xEA, 0x33, 0x5C, 0xB3, 0x53, 0x72, 0xD7,
+	    0x6D, 0x86, 0x39, 0x68, 0xF2, 0x24, 0xB3, 0xF6,
+	0x99, 0xE4, 0xFE, 0xC8, 0x4B, 0xEA, 0xD8, 0x3F, 0x5E, 0x78, 0x03, 0x99,
+	    0x5C, 0x80, 0x73, 0x2B, 0x9A, 0x11, 0x33, 0xD2,
+	0x88, 0x88, 0x0C, 0xBD, 0xDC, 0x37, 0x3E, 0x2A, 0x2C, 0x0A, 0xD4, 0x58,
+	    0x60, 0x1D, 0x00, 0xBF, 0xE7, 0xCE, 0x7B, 0x9E,
+	0xCA, 0x34, 0x74, 0x63, 0xBD, 0x21, 0xDA, 0xB0, 0x7D, 0xBD, 0x4B, 0xD2,
+	    0xBD, 0x8C, 0xA0, 0x40, 0xB5, 0x88, 0x54, 0x73,
+	0x82, 0x0B, 0xDF, 0xE2, 0xF4, 0xC9, 0xA1, 0x7A, 0xBF, 0x2E, 0x6D, 0x8D,
+	    0xDB, 0x60, 0xF6, 0xAD, 0xC6, 0xBF, 0x74, 0xBC,
+	0x1A, 0x25, 0xB1, 0x1F, 0x32, 0x6D, 0x63, 0x94, 0xBD, 0x10, 0x6D, 0x9B,
+	    0x8B, 0xAF, 0x7B, 0x18, 0x76, 0x7C, 0x4C, 0xD3,
+	0xC9, 0xAD, 0xA9, 0xD8, 0x34, 0x8B, 0x38, 0x9F, 0xDA, 0x92, 0xFA, 0x64,
+	    0x30, 0x1D, 0xCB, 0x65, 0xAE, 0xA9, 0xEC, 0xD8,
+	0x15, 0xF4, 0x39, 0x16, 0x03, 0xE2, 0x6C, 0x32, 0x11, 0xAA, 0x68, 0x5A,
+	    0x7A, 0x9C, 0x7C, 0x17, 0xF1, 0xFC, 0xCF, 0xC2,
+	0xA0, 0x3F, 0x34, 0x03, 0x9E, 0x6B, 0x8E, 0x30, 0xD1, 0xDA, 0xD7, 0xA4,
+	    0xF7, 0x00, 0x77, 0x41, 0xCD, 0xA2, 0x37, 0x13,
+	0xA3, 0xFB, 0x5B, 0xDE, 0x1E, 0xC1, 0x46, 0x90, 0x54, 0x0C, 0x99, 0xE6,
+	    0x4E, 0x99, 0xCD, 0xAE, 0xC1, 0x49, 0x4C, 0xD3,
+	0xC7, 0x55, 0xCC, 0xC2, 0x45, 0x00, 0x12, 0xD4, 0xC6, 0x16, 0x7C, 0xE8,
+	    0x3E, 0x40, 0x2E, 0x40, 0x8C, 0xB1, 0x03, 0x0E,
+	0x77, 0x4E, 0x73, 0xA1, 0xC6, 0xB7, 0xCF, 0x17, 0xEA, 0xAE, 0xE5, 0x10,
+	    0x62, 0x5B, 0x4F, 0x19, 0xE6, 0x3B, 0x1F, 0x20,
+	0x2B, 0x9A, 0x65, 0x2F, 0xB7, 0xF7, 0x45, 0xD7, 0xE1, 0x55, 0x79, 0xD3,
+	    0x94, 0xE6, 0xE6, 0x2E, 0x60, 0x15, 0xC6, 0x11,
+	0xCF, 0xFA, 0x8E, 0x39, 0x59, 0x47, 0x76, 0x5B, 0x6D, 0xBA, 0xBB, 0x4A,
+	    0x8E, 0x92, 0xFA, 0x4A, 0xCA, 0xDC, 0x5D, 0x7A,
+	0x33, 0x52, 0x0A, 0xC1, 0xDE, 0x42, 0x5F, 0xCA, 0xD8, 0x37, 0x65, 0xC5,
+	    0x49, 0xF8, 0x9B, 0xD4, 0x36, 0x07, 0xE3, 0xA9,
+	0x09, 0xF5, 0xAF, 0xDA, 0xD9, 0x6E, 0x97, 0x60, 0x3F, 0x5C, 0x7F, 0x8A,
+	    0xD1, 0x74, 0xBB, 0x80, 0xC5, 0xB9, 0x1D, 0xED,
+	0x8F, 0x23, 0x22, 0xA8, 0xD5, 0xD8, 0x7B, 0x2D, 0x87, 0x54, 0xE0, 0x46,
+	    0x95, 0xB8, 0x56, 0x25, 0x0B, 0x30, 0x02, 0x4D,
+	0x09, 0x10, 0x07, 0x89, 0x62, 0x54, 0x5A, 0xDA, 0x96, 0xEE, 0xD3, 0xA9,
+	    0x59, 0xFB, 0xDF, 0x35, 0x12, 0xB3, 0x90, 0x95,
+	0x8F, 0xDA, 0xCD, 0x5F, 0x46, 0x51, 0xFE, 0xCB, 0x67, 0xF6, 0xBA, 0xAF,
+	    0x3F, 0xA0, 0x5F, 0x71, 0xCB, 0xC0, 0xCD, 0xCF,
+	0x4B, 0x50, 0xA0, 0x73, 0xA3, 0x83, 0x7F, 0x43, 0x23, 0x84, 0xD0, 0xF8,
+	    0x8A, 0xE4, 0xF2, 0x39, 0x51, 0x00, 0x3A, 0x20,
+	0xE5, 0xAE, 0x73, 0xFC, 0x95, 0xEC, 0xBE, 0xC0, 0x1D, 0x4E, 0x88, 0x52,
+	    0xAE, 0x7A, 0xB0, 0x25, 0x69, 0x11, 0x3B, 0x9A,
+	0x6F, 0xA0, 0x69, 0x90, 0x42, 0xE5, 0xCB, 0x38, 0x77, 0x79, 0xA9, 0x62,
+	    0x22, 0x80, 0x25, 0x8B, 0x90, 0xA3, 0x27, 0x80,
+	0xE0, 0xA3, 0xDF, 0x53, 0x26, 0x97, 0x12, 0xF7, 0xE9, 0x60, 0x16, 0x44,
+	    0x14, 0xDD, 0xA4, 0x64, 0xE1, 0x21, 0x78, 0xE0,
+	0x2F, 0xCA, 0x8A, 0xFD, 0x80, 0x08, 0x32, 0xD6, 0xF1, 0x16, 0xE2, 0x00,
+	    0x4B, 0x4C, 0x18, 0x68, 0xBB, 0x6F, 0x79, 0xAA,
+	0x31, 0x44, 0xAF, 0x05, 0x96, 0x0B, 0x29, 0x45, 0xF1, 0xF2, 0x99, 0x1C,
+	    0xB1, 0x84, 0x34, 0x93, 0x22, 0x18, 0x09, 0x4C,
+	0x9A, 0x65, 0xD9, 0x12, 0xFD, 0x41, 0x99, 0x4A, 0xAB, 0xBC, 0xB3, 0x2C,
+	    0xBD, 0xA9, 0x3D, 0x3C, 0xEF, 0xE7, 0x6A, 0xAA,
+	0xAE, 0x3C, 0xEA, 0x3E, 0xB3, 0xCB, 0xB2, 0x3C, 0x32, 0x53, 0xEA, 0xBC,
+	    0x01, 0x26, 0xE8, 0x37, 0xE8, 0x27, 0xA4, 0xDE,
+	0x78, 0x29, 0x3B, 0x39, 0xDB, 0x15, 0xDA, 0x0B, 0x7D, 0xD5, 0x2B, 0x39,
+	    0x6B, 0x4C, 0x28, 0x32, 0x7B, 0xEE, 0xB7, 0x5E,
+	0x87, 0x94, 0xD2, 0x34, 0x3C, 0xDA, 0x79, 0x35, 0xC8, 0x7B, 0x9D, 0x8C,
+	    0x30, 0xC8, 0xFF, 0x15, 0xF5, 0x51, 0xCB, 0xAE,
+	0xC6, 0x5D, 0xA6, 0x6D, 0xEB, 0xCC, 0xD2, 0x57, 0x66, 0xF7, 0x35, 0x32,
+	    0x5A, 0x92, 0xB5, 0xD8, 0x60, 0x67, 0xAE, 0x7C,
+	0xEA, 0xCD, 0xFA, 0x96, 0xC9, 0x67, 0xC8, 0xB7, 0x33, 0xB6, 0xA3, 0xEA,
+	    0xD0, 0x23, 0x2B, 0x89, 0x8E, 0x48, 0xD3, 0x16,
+	0x04, 0xE5, 0x23, 0x5F, 0x08, 0x6B, 0x6C, 0x65, 0x72, 0xBE, 0x23, 0xFB,
+	    0x65, 0x0F, 0xDA, 0xFF, 0x39, 0x5F, 0x75, 0x94,
+	0x26, 0xD2, 0xBC, 0x6C, 0x22, 0x7F, 0x44, 0x21, 0x48, 0x56, 0x94, 0xA4,
+	    0x43, 0xD2, 0x9C, 0xE2, 0x9E, 0x4A, 0xD5, 0x93,
+	0xF7, 0xCE, 0x45, 0xB6, 0xA7, 0x6A, 0x63, 0xC7, 0x17, 0x1F, 0x9F, 0x03,
+	    0x12, 0x52, 0x29, 0x6C, 0x34, 0xDF, 0x45, 0xBC,
+	0x41, 0x3E, 0x2D, 0xE2, 0x3A, 0xD1, 0x8D, 0x7A, 0x12, 0x53, 0xED, 0x35,
+	    0xA1, 0x3E, 0x08, 0x56, 0xD2, 0x62, 0x7A, 0xF5,
+	0xF5, 0x87, 0x7F, 0xE7, 0x81, 0x71, 0x02, 0xE3, 0x34, 0x84, 0x94, 0x9D,
+	    0xA9, 0x5C, 0x61, 0x06, 0xF2, 0x85, 0x4D, 0xB2,
+	0xA1, 0x80, 0x6B, 0xF9, 0xB1, 0x52, 0x9B, 0x74, 0x3B, 0x86, 0xEA, 0xB4,
+	    0x79, 0xD8, 0x7A, 0x23, 0x20, 0x15, 0xC9, 0x41,
+	0xA3, 0x39, 0xD5, 0x82, 0x05, 0x18, 0x8F, 0xE8, 0xF4, 0xA6, 0x17, 0x33,
+	    0xA5, 0x8D, 0x4E, 0xB7, 0x48, 0x75, 0x9D, 0xB9,
+	0x40, 0x8C, 0xCA, 0xC5, 0xA3, 0x35, 0x44, 0x66, 0xC9, 0x63, 0x7D, 0xF3,
+	    0xEC, 0x37, 0xAE, 0x57, 0x4A, 0xB5, 0x44, 0xDE,
+	0x93, 0xFB, 0x6E, 0x2F, 0xDE, 0x58, 0x7C, 0x11, 0x3F, 0xA3, 0x26, 0x50,
+	    0xED, 0x96, 0xC8, 0x7C, 0x2C, 0x3B, 0x47, 0x67,
+	0x13, 0x05, 0xA5, 0x7E, 0x96, 0x3C, 0x12, 0x5B, 0xA8, 0x15, 0xA9, 0x1D,
+	    0x75, 0xDC, 0xF0, 0xE7, 0x0A, 0x7E, 0xE9, 0x1F,
+	0x5F, 0x09, 0xF7, 0xA9, 0xDA, 0x6A, 0xD4, 0x55, 0x78, 0x1F, 0xD5, 0xAA,
+	    0xD5, 0x1A, 0x99, 0x08, 0xE6, 0xAD, 0x56, 0x6A,
+	0xC4, 0xEC, 0xD1, 0x98, 0x79, 0x6C, 0xF1, 0xE4, 0xA9, 0x88, 0xD6, 0xD8,
+	    0x92, 0x52, 0x26, 0x7A, 0xC5, 0xDF, 0x2B, 0x1E,
+	0xFB, 0x9F, 0xB5, 0x40, 0x0B, 0xC1, 0xA7, 0x6A, 0x11, 0x33, 0xEC, 0x0B,
+	    0x46, 0xA3, 0xB7, 0x5F, 0xE2, 0xF5, 0x11, 0x3B,
+	0x8F, 0xB4, 0xDF, 0x40, 0xBF, 0x12, 0xE4, 0x1B, 0x47, 0xA2, 0x73, 0x0D,
+	    0xF1, 0x3D, 0x25, 0x65, 0x0A, 0x3F, 0x5F, 0x84,
+	0x36, 0x50, 0x6A, 0x2E, 0xE7, 0xC6, 0x23, 0xB6, 0x9C, 0x43, 0x83, 0x7C,
+	    0xD0, 0xC1, 0xF1, 0x10, 0xF0, 0x7E, 0x40, 0xB0,
+	0x67, 0xD1, 0x40, 0x44, 0xBE, 0x22, 0xB1, 0x5C, 0x39, 0x7E, 0xD9, 0xA7,
+	    0xD4, 0x72, 0x47, 0x34, 0xA7, 0x32, 0xC9, 0x35,
+	0xE7, 0xE3, 0xED, 0x75, 0xED, 0x8E, 0xC9, 0xB7, 0x8D, 0x5E, 0x63, 0x32,
+	    0x66, 0xC5, 0xC7, 0x92, 0xE6, 0xE2, 0xA0, 0xD6,
+	0x63, 0x24, 0x0C, 0xD5, 0x6E, 0xAC, 0xB0, 0x7B, 0x60, 0xC2, 0xAA, 0x48,
+	    0xF5, 0xE0, 0xDD, 0x43, 0x29, 0xA0, 0xB2, 0x52,
+	0xB4, 0xE7, 0x7F, 0xC1, 0x44, 0x65, 0x9E, 0x4F, 0xE8, 0x48, 0xB3, 0x52,
+	    0xE4, 0x82, 0x63, 0xC5, 0x38, 0x89, 0x51, 0x50,
+	0x49, 0x84, 0x7A, 0x20, 0xB5, 0x46, 0xDA, 0xBB, 0x0B, 0x4A, 0x6E, 0xAB,
+	    0x91, 0x37, 0x20, 0xFD, 0x62, 0xCE, 0x6C, 0x30,
+	0x49, 0xEF, 0x30, 0xD3, 0xB7, 0xE5, 0xDA, 0x8C, 0x3E, 0x58, 0x62, 0x36,
+	    0xEF, 0xCE, 0x0A, 0xD1, 0xB5, 0x8B, 0xEA, 0x8E,
+	0x68, 0x8F, 0xAF, 0x7C, 0x2E, 0x4B, 0x9A, 0xCC, 0xC8, 0x49, 0x7A, 0xE6,
+	    0x6E, 0xAB, 0xB3, 0x89, 0x3E, 0x5A, 0x18, 0xED,
+	0x1E, 0xA9, 0x63, 0x22, 0x6D, 0xD1, 0x1F, 0xB0, 0xDF, 0x41, 0x5A, 0x17,
+	    0xA9, 0x8D, 0x53, 0x9D, 0xBF, 0x5B, 0x01, 0xD3,
+	0xFD, 0x84, 0x79, 0xC3, 0xDD, 0xEB, 0x02, 0x70, 0x2D, 0x83, 0x05, 0xCC,
+	    0xB0, 0x2E, 0xF6, 0xEE, 0x12, 0x27, 0x36, 0x11,
+	0x3E, 0x2C, 0x12, 0xB2, 0x13, 0xC0, 0x7F, 0xBC, 0x3B, 0xAB, 0x79, 0xD9,
+	    0x24, 0x0E, 0xFD, 0x17, 0x5C, 0xFD, 0x3A, 0x58,
+	0x6B, 0xEB, 0xD9, 0xAD, 0x32, 0x03, 0x63, 0xF6, 0xE4, 0x8C, 0x0C, 0x1D,
+	    0xA8, 0xAC, 0x10, 0x53, 0x2A, 0x30, 0x99, 0xF6,
+	0x99, 0x1F, 0x79, 0x8A, 0xA1, 0xCF, 0x9B, 0xCD, 0xC7, 0x64, 0x9B, 0x60,
+	    0x00, 0x4B, 0x9A, 0x64, 0x97, 0xF2, 0x8C, 0x4A,
+	0x54, 0x9F, 0x9C, 0xA0, 0xD5, 0xEF, 0x0C, 0x6B, 0xCB, 0xEA, 0x6A, 0xE9,
+	    0x96, 0x3C, 0x44, 0x5A, 0x7B, 0x9E, 0x84, 0x58,
+	0xD9, 0xFC, 0xD3, 0x7E, 0x4B, 0x09, 0x7F, 0xE9, 0x36, 0x75, 0x0F, 0x21,
+	    0x0E, 0x5E, 0x01, 0xC5, 0x4F, 0x97, 0x3D, 0x17,
+	0x9E, 0x72, 0xCD, 0x21, 0xF6, 0xBC, 0xFD, 0x4F, 0xDB, 0xC8, 0x40, 0xDD,
+	    0x74, 0xFE, 0x71, 0xC3, 0x4D, 0xC5, 0x18, 0xB5,
+	0x46, 0xDA, 0x0C, 0x66, 0x3A, 0x0F, 0x77, 0xD0, 0x77, 0x04, 0x54, 0x21,
+	    0x5F, 0x94, 0xD0, 0x31, 0xB5, 0xB1, 0x25, 0x47,
+	0xC2, 0x0A, 0x3C, 0xEF, 0x12, 0xFF, 0x65, 0x41, 0x26, 0x73, 0x83, 0xFE,
+	    0xB7, 0xF6, 0xB5, 0xFB, 0x38, 0x97, 0xCB, 0xDE,
+	0x96, 0xB4, 0xFF, 0x5B, 0x94, 0x23, 0x5F, 0xB5, 0xDC, 0xB8, 0x7C, 0x95,
+	    0x18, 0xCC, 0x7F, 0x75, 0x15, 0xC7, 0x1C, 0x62,
+	0x18, 0xD7, 0xC6, 0x8C, 0xB8, 0xB5, 0x92, 0xDC, 0x93, 0xC3, 0x8B, 0xEC,
+	    0xDD, 0x75, 0x77, 0x9D, 0xEB, 0x36, 0xF6, 0x9A,
+	0x7D, 0xF6, 0x76, 0xBF, 0x90, 0x59, 0xC5, 0x4E, 0x92, 0x58, 0x8B, 0x62,
+	    0x64, 0x77, 0xFE, 0xAF, 0x1B, 0xF7, 0x97, 0xDD,
+	0x63, 0x2C, 0x68, 0xAE, 0x0B, 0x45, 0xFB, 0x19, 0x4B, 0xEF, 0xF6, 0xBF,
+	    0x18, 0xD5, 0xC5, 0x53, 0xDD, 0x96, 0x6D, 0x4C,
+	0x79, 0x76, 0xDC, 0xBA, 0x26, 0x95, 0x32, 0xFC, 0xF6, 0xB3, 0x7A, 0x8C,
+	    0x9D, 0xCC, 0xAC, 0x40, 0xDD, 0xBE, 0xFC, 0x5E,
+	0x7F, 0x5B, 0x9C, 0x77, 0x39, 0x0D, 0x2B, 0x7E, 0x3F, 0x91, 0xBE, 0xEF,
+	    0xFA, 0xFF, 0xE7, 0xA8, 0x49, 0xD0, 0x35, 0x3C,
+	0xD0, 0xB8, 0xCF, 0x10, 0x6C, 0x59, 0x38, 0x20, 0xDA, 0xFD, 0xC7, 0x46,
+	    0x4E, 0x99, 0xE3, 0xF8, 0xB9, 0x2F, 0x21, 0x4F,
+	0xE7, 0x74, 0x3F, 0xDE, 0x4C, 0xBE, 0x5E, 0x29, 0x48, 0xA2, 0x38, 0xEA,
+	    0x00, 0x6D, 0x9A, 0x0C, 0xAB, 0x24, 0x9E, 0xD7,
+	0xF1, 0xE0, 0x50, 0x14, 0x29, 0xFD, 0x58, 0x2B, 0x2D, 0xF4, 0x20, 0xC3,
+	    0x6B, 0x03, 0x12, 0x9D, 0x57, 0xA9, 0x14, 0x85,
+	0xC5, 0x07, 0x7C, 0x3E, 0xBE, 0xB7, 0x29, 0xD2, 0xE2, 0x27, 0xE9, 0x56,
+	    0xE8, 0x20, 0x37, 0x38, 0x87, 0xCB, 0x18, 0x91,
+	0xA2, 0xDC, 0x93, 0x32, 0x2A, 0x27, 0x74, 0x46, 0xE9, 0x21, 0x9D, 0x78,
+	    0x79, 0x26, 0x44, 0xB5, 0x26, 0xDB, 0x40, 0x12,
+	0x71, 0x36, 0x47, 0x5A, 0x26, 0x7F, 0xDD, 0xD2, 0xE5, 0x77, 0x59, 0x94,
+	    0x5F, 0x3E, 0x38, 0xC3, 0x82, 0x4A, 0x73, 0xF1,
+	0xC0, 0x5A, 0x81, 0x7C, 0x8C, 0xF2, 0xFF, 0x7C, 0x1D, 0x80, 0xA9, 0x63,
+	    0x8A, 0xCB, 0x55, 0x3B, 0x5F, 0x04, 0x71, 0xAE,
+	0xBC, 0x96, 0x8D, 0x33, 0x51, 0x23, 0x00, 0x4D, 0x66, 0xB8, 0x26, 0x85,
+	    0xB4, 0xC6, 0xDC, 0xF7, 0xE1, 0x39, 0x21, 0x20,
+	0xC4, 0x59, 0x2A, 0xC7, 0x7F, 0x48, 0x18, 0x00, 0xB3, 0x0C, 0x74, 0x1E,
+	    0xE8, 0x8A, 0x0E, 0x19, 0x3B, 0xCB, 0xAD, 0x05,
+	0xBD, 0x98, 0xA4, 0x05, 0xFA, 0x2B, 0x15, 0x6B, 0xE8, 0x2C, 0xBE, 0x6D,
+	    0xDC, 0x2B, 0x24, 0x8C, 0x38, 0x09, 0xAD, 0x15,
+	0x7B, 0x0F, 0xFD, 0x22, 0x0D, 0x94, 0x92, 0xBD, 0xD7, 0xD3, 0xDB, 0xC9,
+	    0x61, 0x9F, 0x11, 0x50, 0xDF, 0xA3, 0x78, 0xB3,
+	0x0C, 0xFD, 0xCA, 0xE5, 0x29, 0x0E, 0x0B, 0xE5, 0xEF, 0xCC, 0xC7, 0xE8,
+	    0x09, 0x64, 0xED, 0x65, 0xE2, 0xFC, 0xC8, 0xBA,
+	0xFA, 0x36, 0xDA, 0x19, 0x91, 0xC0, 0xE4, 0x55, 0xB9, 0xAB, 0x87, 0xB8,
+	    0xFE, 0x0E, 0x7B, 0xAD, 0xD6, 0x63, 0xAB, 0xAE,
+	0x14, 0x44, 0x6C, 0x8F, 0x92, 0x5F, 0x31, 0x08, 0xFF, 0x06, 0x4B, 0xBB,
+	    0xA8, 0x0D, 0xA3, 0xFD, 0xFE, 0x9F, 0x37, 0xFF,
+	0x31, 0xE3, 0x7A, 0x86, 0xC1, 0x93, 0x7F, 0x43, 0xC9, 0xC6, 0x16, 0xD3,
+	    0x54, 0xF9, 0x2B, 0x42, 0x76, 0xB8, 0xCC, 0xC4,
+	0xAA, 0x64, 0xD6, 0x54, 0x59, 0x00, 0x0B, 0xC1, 0x0B, 0x5A, 0x8A, 0x9D,
+	    0xC2, 0x8C, 0xF3, 0xBA, 0x24, 0x8D, 0xBE, 0x1B,
+	0xB3, 0x00, 0xC5, 0x41, 0xB8, 0xFF, 0xA5, 0x5A, 0x93, 0xC4, 0xAD, 0x7F,
+	    0xA7, 0xDB, 0xF4, 0xF3, 0xF2, 0xC3, 0x1F, 0xC2,
+	0x91, 0xFA, 0x65, 0xB7, 0xD5, 0x68, 0xA3, 0x00, 0x26, 0xE0, 0xD4, 0xB7,
+	    0x3E, 0x76, 0xD4, 0xA0, 0x76, 0xF9, 0xD1, 0x0C,
+	0xA0, 0x39, 0x88, 0x00, 0x5D, 0x79, 0xC0, 0xD6, 0x7D, 0x2E, 0x5E, 0x82,
+	    0x50, 0x77, 0x4B, 0x12, 0xF1, 0xB2, 0x56, 0xB2,
+	0xDA, 0x74, 0x51, 0x1F, 0xB4, 0xCD, 0xC4, 0x73, 0x15, 0x5C, 0x2A, 0x0D,
+	    0xF6, 0x3B, 0x2B, 0xE9, 0xA2, 0xF4, 0xDA, 0xB3,
+	0x3E, 0x55, 0xA5, 0x73, 0x05, 0x45, 0x11, 0x97, 0x0C, 0x6C, 0xA3, 0x7B,
+	    0x5A, 0xBC, 0x9C, 0x8D, 0x19, 0x4A, 0x44, 0x48,
+	0x60, 0x6A, 0xF7, 0xCA, 0x87, 0x3A, 0x3A, 0x1C, 0x6C, 0x60, 0x4E, 0xCD,
+	    0xD2, 0x34, 0x67, 0xDE, 0x6F, 0x91, 0x21, 0x5E,
+	0xDC, 0x86, 0xA7, 0x30, 0xAE, 0x00, 0xDD, 0xC7, 0xD0, 0x0B, 0x4D, 0x32,
+	    0x80, 0x6B, 0x1D, 0xAE, 0x13, 0x1E, 0x71, 0x9E,
+	0x08, 0xB4, 0x23, 0x0F, 0xE9, 0x31, 0xF8, 0x47, 0x64, 0xAD, 0x5F, 0xE9,
+	    0x65, 0xD4, 0x1F, 0xCF, 0xCF, 0xE3, 0x39, 0x8B,
+	0xD3, 0x6D, 0x68, 0xC5, 0xC9, 0xF7, 0x56, 0x8A, 0xF7, 0x8A, 0x5B, 0xAB,
+	    0x17, 0x71, 0x22, 0x43, 0x3A, 0xFD, 0x4B, 0x7A,
+	0x8D, 0x2F, 0x1E, 0x18, 0x5B, 0x3C, 0x87, 0x11, 0x3A, 0xB1, 0x20, 0x32,
+	    0x53, 0x8F, 0x2F, 0xF4, 0x2A, 0xF1, 0xDF, 0xFC,
+	0x1B, 0x31, 0x29, 0xF0, 0xA8, 0x8E, 0x96, 0x5C, 0x1E, 0xBE, 0x67, 0x88,
+	    0xD3, 0x56, 0x00, 0xF9, 0xFD, 0x84, 0xE0, 0x56,
+	0xC9, 0xF5, 0x60, 0x52, 0xE0, 0x3F, 0xA1, 0x3D, 0x78, 0x82, 0x5D, 0xA2,
+	    0x11, 0xCA, 0x0C, 0xE1, 0x77, 0x25, 0xFC, 0x28,
+	0x37, 0xE3, 0x00, 0xDD, 0xBD, 0x62, 0x86, 0x0F, 0xF6, 0x6A, 0x81, 0xED,
+	    0x82, 0x4A, 0x1E, 0x82, 0x6F, 0x57, 0xBB, 0x2C,
+	0x2F, 0xA6, 0x8F, 0x1F, 0x77, 0x87, 0x89, 0xAA, 0x83, 0x99, 0xF6, 0x7F,
+	    0x44, 0x7E, 0x0A, 0x83, 0x39, 0xE0, 0xDE, 0x06,
+	0xED, 0xFC, 0xE4, 0x51, 0x7A, 0xF5, 0x58, 0x56, 0xB1, 0x2E, 0xD3, 0x5E,
+	    0x9A, 0x35, 0xC8, 0x86, 0x4C, 0xFF, 0x36, 0xB0,
+	0x5B, 0x00, 0x6A, 0x30, 0x98, 0x23, 0xEB, 0x81, 0x7B, 0x48, 0x38, 0x82,
+	    0xE2, 0x11, 0x01, 0xF5, 0x98, 0x8B, 0x66, 0x37,
+	0xD6, 0xAF, 0x57, 0x5E, 0xB6, 0x6B, 0xB5, 0x01, 0xF5, 0x64, 0x96, 0xD1,
+	    0x61, 0xB5, 0xC9, 0x17, 0xB9, 0x2A, 0x07, 0x5F,
+	0xF4, 0xE5, 0xEC, 0xF5, 0x31, 0x05, 0x16, 0x79, 0x34, 0xCA, 0x89, 0x55,
+	    0xE1, 0x14, 0x81, 0x8A, 0x4A, 0x43, 0x0A, 0x69,
+	0x52, 0xAA, 0x92, 0xE5, 0xE4, 0xB8, 0x15, 0x9B, 0x7D, 0xA9, 0x2D, 0xD3,
+	    0x45, 0x64, 0x2D, 0x2E, 0xA2, 0x62, 0xA9, 0x49,
+	0x7B, 0x9A, 0x63, 0x5B, 0x68, 0x75, 0x07, 0x35, 0xBC, 0x3E, 0x39, 0xB0,
+	    0x51, 0x88, 0x3D, 0x79, 0xED, 0xFD, 0x54, 0x61,
+	0xFF, 0x74, 0xAE, 0x4A, 0xE3, 0xC0, 0x36, 0x0E, 0xE5, 0xF4, 0x5A, 0x77,
+	    0xF1, 0xCE, 0xBB, 0xCF, 0xB9, 0x01, 0xCA, 0x0A,
+	0x56, 0xCA, 0xCA, 0x1F, 0x66, 0xE5, 0x7D, 0xB2, 0x4D, 0xC0, 0x15, 0xDA,
+	    0x44, 0x41, 0x1C, 0x57, 0xA4, 0x9C, 0xC0, 0x96,
+	0x5B, 0xA2, 0x39, 0x37, 0x7B, 0x21, 0x76, 0xA7, 0x12, 0x6F, 0x81, 0xE3,
+	    0x6F, 0xA2, 0x75, 0x1C, 0xE6, 0xE1, 0x94, 0x28,
+	0xFF, 0xE3, 0x8B, 0x5D, 0xE4, 0xA2, 0x45, 0x57, 0x40, 0x49, 0xA2, 0x61,
+	    0x3A, 0xE6, 0xF4, 0xA5, 0x85, 0x3F, 0x27, 0x95,
+	0x40, 0xE1, 0x7C, 0x06, 0x91, 0xBC, 0x10, 0xD9, 0xD7, 0xB2, 0x14, 0x61,
+	    0x47, 0xF4, 0xFC, 0xAE, 0xFD, 0x92, 0x65, 0x7E,
+	0xC0, 0x8E, 0x86, 0x54, 0x73, 0x39, 0xF1, 0x07, 0xE1, 0xB8, 0x83, 0xBA,
+	    0x88, 0x16, 0x57, 0x23, 0xE7, 0x43, 0x3F, 0xF0,
+	0x1F, 0x96, 0x15, 0x60, 0xCF, 0x3E, 0xBA, 0x95, 0xE5, 0x17, 0x3C, 0xD5,
+	    0x5A, 0x66, 0xD1, 0x44, 0x79, 0x7E, 0x04, 0x71,
+	0xE7, 0x99, 0xA4, 0x20, 0xB4, 0x73, 0x36, 0x60, 0x80, 0x36, 0x5D, 0x1B,
+	    0x72, 0xB6, 0x64, 0xF6, 0xCE, 0xE4, 0xFF, 0x11,
+	0xE9, 0xBD, 0x7F, 0x1A, 0x6D, 0x5E, 0x82, 0xDF, 0x9E, 0xC4, 0x67, 0x21,
+	    0x64, 0xB6, 0xA3, 0xA5, 0x49, 0x1B, 0x4D, 0x92,
+	0xDE, 0xDF, 0x2A, 0xD8, 0xD2, 0x7B, 0xFA, 0x2C, 0xA1, 0x2D, 0xBD, 0xA5,
+	    0x5C, 0x86, 0x79, 0x15, 0x0E, 0xE6, 0xEB, 0x95,
+	0x97, 0x63, 0x33, 0x0E, 0x69, 0xAB, 0x76, 0xA2, 0xF4, 0xDB, 0x60, 0x90,
+	    0x0E, 0x2D, 0xCE, 0xDD, 0x44, 0xF1, 0xBD, 0xBD,
+	0x8C, 0x36, 0x88, 0x2F, 0x45, 0x32, 0x67, 0x45, 0xB9, 0x48, 0xE0, 0x86,
+	    0x82, 0xFF, 0x59, 0x8C, 0x0D, 0x35, 0x32, 0x9C,
+	0xDE, 0x2B, 0x20, 0x95, 0x9C, 0x98, 0x37, 0xAE, 0xF0, 0xBB, 0xB8, 0xE8,
+	    0x95, 0xD9, 0x86, 0xAE, 0x85, 0xF9, 0x98, 0x82,
+	0xDE, 0xC1, 0x4D, 0x2A, 0x5C, 0x04, 0xC8, 0x48, 0xAE, 0x27, 0xBC, 0x3A,
+	    0x56, 0x8D, 0x0E, 0x98, 0x5D, 0x9C, 0x8B, 0x29,
+	0xD3, 0x7A, 0xAE, 0xFF, 0xFC, 0xDF, 0xB0, 0x3C, 0x73, 0x38, 0x68, 0xC2,
+	    0x84, 0x8C, 0xFE, 0xBE, 0x20, 0x76, 0x5F, 0xEB,
+	0x47, 0xFE, 0x27, 0x17, 0xBF, 0xB3, 0x8F, 0x03, 0x96, 0x93, 0xF7, 0x66,
+	    0x53, 0x78, 0xB0, 0x9A, 0xA9, 0xD4, 0xC9, 0x3D,
+	0xCB, 0x10, 0xD3, 0x68, 0x9F, 0xD5, 0x43, 0x7B, 0xD5, 0xE4, 0x38, 0xE0,
+	    0x4F, 0x8B, 0xAC, 0xF4, 0x13, 0x11, 0xCA, 0x42,
+	0xFB, 0xCF, 0xE9, 0x5B, 0xF7, 0xEB, 0xB0, 0xE3, 0x3D, 0x8A, 0xBC, 0x26,
+	    0x17, 0x02, 0x42, 0xF0, 0x79, 0x5E, 0xA1, 0x76,
+	0xF0, 0x2C, 0x49, 0x30, 0xB8, 0x1D, 0xF8, 0x76, 0xAC, 0x6D, 0x49, 0x25,
+	    0x68, 0x12, 0xD9, 0x14, 0xE4, 0x7D, 0x63, 0x20,
+	0xB9, 0x41, 0x53, 0x77, 0x72, 0x2A, 0xA1, 0xC2, 0xFD, 0x58, 0x66, 0xDD,
+	    0xBB, 0x2E, 0x90, 0xB3, 0x2C, 0x8F, 0x3F, 0x35,
+	0x2A, 0x2D, 0x2E, 0xD0, 0xA9, 0xE7, 0xCB, 0x85, 0xB3, 0x7F, 0xB7, 0xD2,
+	    0xE1, 0xC6, 0x0C, 0xAA, 0xF8, 0x06, 0x08, 0x37,
+	0x81, 0x41, 0x07, 0xAC, 0x6C, 0x35, 0xC1, 0xC5, 0x9C, 0xC8, 0x88, 0x36,
+	    0xA6, 0x4A, 0x0F, 0x4C, 0xCA, 0xEB, 0x72, 0x93,
+	0xA5, 0xBA, 0x71, 0xAB, 0x2F, 0x0A, 0xF7, 0x30, 0x1E, 0x45, 0x51, 0x78,
+	    0xA0, 0x43, 0xA6, 0xF1, 0xA4, 0xC8, 0xD2, 0x1D,
+	0xA9, 0xF7, 0x02, 0x2F, 0xF8, 0x6A, 0xF4, 0x4E, 0xB7, 0x75, 0x69, 0x53,
+	    0x0D, 0x97, 0xB5, 0xB8, 0xA4, 0x19, 0xA9, 0x8A,
+	0xEC, 0x3B, 0x24, 0x15, 0x0A, 0x46, 0x62, 0x3E, 0x41, 0xC9, 0x3D, 0x24,
+	    0xAB, 0x4B, 0x53, 0x9E, 0x17, 0x31, 0xBF, 0xB6,
+	0xC9, 0x12, 0xFB, 0x4F, 0x6B, 0x97, 0x6B, 0xAB, 0x8C, 0x06, 0x69, 0xDD,
+	    0x9D, 0x0E, 0x43, 0x69, 0x22, 0x1A, 0x0A, 0x4E,
+	0xED, 0x07, 0x3D, 0x75, 0xE1, 0x48, 0xDC, 0x65, 0x3B, 0xCC, 0x44, 0xC8,
+	    0xA1, 0x4F, 0xB2, 0xC6, 0x6A, 0x61, 0x72, 0xA6,
+	0xA7, 0x00, 0xDF, 0xBC, 0x5B, 0x8D, 0x9F, 0x6B, 0xB7, 0x4E, 0x5E, 0x1E,
+	    0x19, 0x62, 0x79, 0xF1, 0x61, 0x6A, 0x7C, 0x0A,
+	0x94, 0x87, 0x0D, 0x44, 0x35, 0x0C, 0x3F, 0xFF, 0xDA, 0x66, 0xB4, 0xA9,
+	    0x87, 0x4D, 0x9F, 0x4C, 0xB1, 0x82, 0x9B, 0xF4,
+	0x0D, 0x9B, 0xEC, 0x18, 0x3A, 0x90, 0x3E, 0x73, 0x1C, 0xEF, 0x28, 0xFB,
+	    0xEA, 0xED, 0x40, 0x4C, 0xC1, 0xD0, 0x38, 0x37,
+	0x5D, 0x78, 0xD9, 0x60, 0x22, 0xB0, 0xAC, 0x74, 0x90, 0x53, 0x8D, 0x34,
+	    0x42, 0x2A, 0xE2, 0x98, 0x98, 0x20, 0x3B, 0xA8,
+	0xA6, 0x51, 0xE6, 0xC5, 0xAC, 0x34, 0x6D, 0x9A, 0xD8, 0xA7, 0x15, 0xC6,
+	    0x9D, 0xFF, 0x18, 0x7B, 0x48, 0x62, 0x49, 0x45,
+	0xCF, 0x30, 0xDD, 0x10, 0x0D, 0x6E, 0x31, 0x26, 0xD4, 0x7B, 0x90, 0xF1,
+	    0x83, 0xEB, 0xBA, 0xC3, 0x93, 0xCB, 0x87, 0x1E,
+	0xEF, 0x31, 0x77, 0x92, 0xA4, 0x72, 0xE0, 0xA3, 0x49, 0xE3, 0x73, 0x8F,
+	    0xE2, 0xE8, 0xFC, 0x23, 0xE7, 0x15, 0x68, 0x16,
+	0x86, 0x7C, 0x7B, 0x65, 0x8C, 0xC9, 0x05, 0x48, 0x74, 0x8A, 0x6D, 0x7E,
+	    0x19, 0xF6, 0xA4, 0xD1, 0x51, 0xFB, 0xF6, 0xA1,
+	0x23, 0x08, 0xE6, 0x92, 0x30, 0x3A, 0x1B, 0xF6, 0xA9, 0x13, 0x5F, 0x77,
+	    0x41, 0xB6, 0xFE, 0x78, 0xEB, 0xB9, 0xBE, 0x48,
+	0xD9, 0x97, 0xD6, 0x0C, 0x56, 0x43, 0x16, 0xCF, 0x55, 0x3A, 0xB1, 0x7A,
+	    0x61, 0x28, 0x05, 0x7C, 0x38, 0x7B, 0xC4, 0x48,
+	0x96, 0x56, 0x2A, 0xDE, 0x86, 0xD4, 0x12, 0x0D, 0x8E, 0xFA, 0x16, 0x09,
+	    0x9E, 0xCB, 0x30, 0xBD, 0xEE, 0x79, 0x56, 0x40,
+	0x59, 0xA5, 0x31, 0xB0, 0xC8, 0xBB, 0xDB, 0xAA, 0xDA, 0x56, 0x2B, 0x8B,
+	    0xA1, 0x0A, 0x0E, 0x39, 0xEF, 0xA0, 0x78, 0x78,
+	0x4B, 0x18, 0x21, 0x33, 0xB9, 0x31, 0x6E, 0x76, 0xE9, 0x18, 0xEE, 0x0C,
+	    0x2C, 0xD1, 0xDC, 0x9F, 0xC2, 0xBE, 0x6A, 0x3E,
+	0x97, 0xC0, 0x61, 0x1A, 0x6D, 0x0F, 0x69, 0x99, 0x7D, 0xEC, 0x26, 0x09,
+	    0xAE, 0x1A, 0x24, 0x0F, 0x3E, 0x30, 0x3F, 0xEE,
+	0x49, 0x3B, 0x4B, 0xDC, 0x5B, 0xC1, 0x29, 0x7C, 0x42, 0x5C, 0xB7, 0xCC,
+	    0x8F, 0x9F, 0x82, 0xBB, 0x67, 0x53, 0x92, 0x7F,
+	0x49, 0xBE, 0xA8, 0x2F, 0x84, 0x20, 0x92, 0xF7, 0xB7, 0xE0, 0x69, 0xB5,
+	    0xE1, 0x3F, 0xD2, 0x37, 0x55, 0xC7, 0xD7, 0x90,
+	0xA3, 0x5E, 0x33, 0xE8, 0xB9, 0xAC, 0x30, 0x36, 0xED, 0x44, 0x28, 0xB4,
+	    0xD5, 0x26, 0x7F, 0x2E, 0x8C, 0x0F, 0x9F, 0x2E,
+	0x92, 0x81, 0x0F, 0x0F, 0x49, 0x34, 0xB7, 0x0E, 0x5C, 0x4B, 0x11, 0xD4,
+	    0x47, 0xA3, 0x56, 0xD0, 0x57, 0xA1, 0xF9, 0x97,
+	0xB9, 0x1B, 0x81, 0xC8, 0xA2, 0xE3, 0xA5, 0x94, 0xB9, 0x39, 0x71, 0x7A,
+	    0x10, 0xF6, 0x63, 0x7D, 0x3E, 0x69, 0x30, 0x5E,
+	0x4D, 0xFF, 0x3B, 0xA1, 0x8B, 0x88, 0x48, 0x34, 0xE0, 0xC0, 0x50, 0x75,
+	    0xC6, 0x81, 0x69, 0x94, 0xBE, 0x8C, 0xF4, 0xB0,
+	0x02, 0x0B, 0x3A, 0x05, 0x1A, 0xAA, 0xE0, 0xE7, 0xD0, 0x1D, 0x52, 0x11,
+	    0x54, 0xF1, 0x12, 0x74, 0x26, 0x76, 0xD1, 0xA8,
+	0x62, 0xAB, 0xCE, 0x5E, 0x3A, 0xA4, 0xEF, 0x15, 0x28, 0x4A, 0x2A, 0x9F,
+	    0x6F, 0xE8, 0x19, 0x9C, 0x1C, 0xA0, 0x6A, 0x12,
+	0x2F, 0xA5, 0xE9, 0xD1, 0x27, 0x17, 0x0A, 0x07, 0xE4, 0xF8, 0xB8, 0xFC,
+	    0xE6, 0xBB, 0x02, 0xAA, 0xEE, 0x42, 0x6A, 0x21,
+	0x73, 0x64, 0x35, 0x26, 0x67, 0xFB, 0x63, 0xE7, 0x87, 0xE7, 0x26, 0xAF,
+	    0xE6, 0x91, 0x73, 0xAA, 0x79, 0x3E, 0x61, 0xF9,
+	0xAC, 0xBB, 0x13, 0xAF, 0x62, 0x34, 0x87, 0x0A, 0xF9, 0x89, 0xC5, 0x16,
+	    0x34, 0xDA, 0x9D, 0x30, 0x78, 0x53, 0xDA, 0x31,
+	0x9F, 0xA1, 0x14, 0x08, 0xB9, 0x59, 0x6E, 0x9F, 0xFD, 0x8C, 0xAA, 0xCA,
+	    0x16, 0x59, 0x2D, 0x6F, 0x35, 0x02, 0xBE, 0x1C,
+	0xA6, 0x6E, 0xB7, 0xFC, 0xED, 0xBC, 0x38, 0x4B, 0xF5, 0x2E, 0x23, 0xC2,
+	    0x56, 0x25, 0x60, 0x50, 0xB6, 0x8C, 0xC1, 0x94,
+	0xD8, 0x7F, 0x39, 0x44, 0xE5, 0x22, 0x4B, 0x2D, 0xFD, 0x8B, 0xEC, 0x84,
+	    0x26, 0x4C, 0xC3, 0x81, 0x52, 0xF4, 0x7C, 0x88,
+	0xC5, 0x3F, 0xB2, 0xAA, 0x32, 0x93, 0x10, 0x80, 0x8D, 0xA1, 0x8C, 0x5C,
+	    0xD8, 0xFD, 0x4A, 0x5F, 0x24, 0xD1, 0x9B, 0xBA,
+	0xC9, 0x80, 0xF0, 0x9F, 0xC6, 0x2D, 0x6F, 0x45, 0x01, 0x5C, 0x30, 0xF0,
+	    0x9C, 0xFE, 0x7C, 0x77, 0xBC, 0xBD, 0x7F, 0xBE,
+	0xC5, 0xB2, 0x22, 0x54, 0x88, 0x6F, 0x19, 0xB9, 0x4C, 0xA2, 0x6D, 0x7F,
+	    0x89, 0x38, 0x00, 0xEC, 0xE3, 0x88, 0x2C, 0xF0,
+	0xFB, 0x72, 0x7E, 0xC0, 0x95, 0x39, 0x75, 0xE5, 0xA3, 0x14, 0xD4, 0xA5,
+	    0xCA, 0xD9, 0xCC, 0x19, 0xF4, 0xE3, 0x24, 0xDA,
+	0xEF, 0xD6, 0xB1, 0xC9, 0xDA, 0x6A, 0x12, 0xF4, 0x63, 0x77, 0x50, 0x1E,
+	    0xA3, 0x38, 0x37, 0xB3, 0x26, 0x80, 0xF0, 0xE4,
+	0x40, 0xF7, 0x92, 0x1C, 0xAE, 0x92, 0x64, 0x85, 0x8A, 0x09, 0x3F, 0xC0,
+	    0x89, 0x34, 0xE8, 0xA0, 0x84, 0xF7, 0xD9, 0x62,
+	0x63, 0xDA, 0x1A, 0x75, 0x45, 0x16, 0x30, 0xE8, 0x4C, 0x22, 0xE6, 0xBF,
+	    0x04, 0x17, 0xC3, 0xF1, 0xD5, 0x64, 0xF3, 0x5D,
+	0xF8, 0x75, 0x6B, 0xFD, 0x0E, 0xD9, 0xD0, 0x99, 0x9C, 0x46, 0x2E, 0x3E,
+	    0x4B, 0x7F, 0x86, 0x4D, 0x5F, 0xFA, 0x5A, 0xEC,
+	0x8F, 0xDA, 0x07, 0xFD, 0xDE, 0xBF, 0x80, 0x82, 0xEA, 0xA1, 0xE5, 0xAC,
+	    0x17, 0x9E, 0x1B, 0xA9, 0xAB, 0xB8, 0xF5, 0x04,
+	0xD5, 0xEA, 0xC0, 0xD0, 0xEB, 0xF8, 0x7E, 0xAE, 0x1C, 0x54, 0x46, 0x4E,
+	    0xA1, 0x31, 0x4A, 0x6B, 0xEB, 0xDF, 0x95, 0x28,
+	0xEA, 0xD2, 0x8E, 0x06, 0xAA, 0x31, 0x3C, 0xAA, 0xAF, 0x1B, 0xB7, 0x74,
+	    0xCA, 0xF2, 0x06, 0x89, 0x57, 0xD4, 0xA6, 0xEF,
+	0xFD, 0xEA, 0x31, 0x59, 0xAE, 0x33, 0x4C, 0x05, 0x05, 0x41, 0xD3, 0x09,
+	    0x42, 0x23, 0x97, 0x45, 0x96, 0xF1, 0x4F, 0x9B,
+	0xE7, 0x12, 0xEE, 0xA0, 0x18, 0xFD, 0x67, 0x88, 0xC2, 0x5D, 0xEA, 0xEF,
+	    0x5C, 0xBE, 0x10, 0x04, 0x04, 0x21, 0x7B, 0x7B,
+	0x23, 0x60, 0xA8, 0x80, 0x14, 0x62, 0x36, 0xA0, 0x6D, 0x2D, 0x10, 0x14,
+	    0x29, 0xC5, 0x4C, 0xDE, 0xAA, 0xDE, 0xDE, 0x56,
+	0xC3, 0x42, 0xBC, 0x68, 0xF0, 0x68, 0xA3, 0xE9, 0xB4, 0x4F, 0x2A, 0x42,
+	    0x9E, 0xFE, 0xD1, 0x21, 0x86, 0x59, 0x39, 0x21,
+	0xF4, 0x64, 0x59, 0x99, 0x94, 0x05, 0xE9, 0x55, 0x73, 0xFE, 0x1C, 0xD3,
+	    0xF2, 0x51, 0x19, 0x74, 0x34, 0x60, 0x3E, 0x69,
+	0x31, 0xE2, 0xF8, 0x94, 0xE5, 0x2B, 0x18, 0xF1, 0x44, 0x94, 0x65, 0x06,
+	    0x13, 0xE4, 0xE4, 0xCF, 0x02, 0x45, 0xA8, 0x10,
+	0x9B, 0x28, 0xEF, 0x4D, 0xB7, 0x94, 0xA0, 0x16, 0x10, 0x1A, 0xF9, 0xBE,
+	    0x6B, 0x37, 0xF9, 0x95, 0x69, 0x29, 0xBA, 0xE5,
+	0x96, 0xC7, 0xA9, 0x07, 0x93, 0x6E, 0x45, 0xE7, 0xE0, 0x7F, 0x83, 0xAE,
+	    0x30, 0x21, 0x99, 0x88, 0xF2, 0x41, 0xA1, 0xF7,
+	0xD6, 0x83, 0xAD, 0xEA, 0xA9, 0x8F, 0xFA, 0x2B, 0xE5, 0x27, 0xAA, 0xAA,
+	    0x6A, 0xB8, 0xD7, 0x31, 0xDA, 0x6C, 0x0E, 0x5F,
+	0x08, 0x49, 0x8E, 0xFE, 0xF8, 0x96, 0x9A, 0x4A, 0x7A, 0x0B, 0x32, 0xB5,
+	    0xDB, 0x0E, 0x87, 0x0C, 0x07, 0x0E, 0xE3, 0x4D,
+	0x76, 0xA1, 0x6B, 0xEF, 0xC8, 0x06, 0x1F, 0xDD, 0xDC, 0x65, 0x1F, 0x0F,
+	    0xA9, 0xBB, 0x74, 0x99, 0xEC, 0x35, 0xE3, 0xBB,
+	0xCC, 0x81, 0x1A, 0xAD, 0x7A, 0x43, 0x54, 0x61, 0xB9, 0x41, 0x92, 0x63,
+	    0xBB, 0xA6, 0x72, 0xA0, 0x4C, 0xFC, 0x88, 0x6D,
+	0xF9, 0x6A, 0x70, 0xA3, 0xF7, 0x3C, 0xD2, 0xAC, 0x1A, 0x22, 0xDD, 0x24,
+	    0x4D, 0x9D, 0xBA, 0xDC, 0x61, 0x62, 0x1B, 0x4D,
+	0x83, 0x49, 0x34, 0xAF, 0x18, 0x66, 0x21, 0x29, 0xD4, 0x0C, 0x83, 0x7C,
+	    0x3B, 0x61, 0x8B, 0xE1, 0x07, 0xDB, 0x7F, 0xAD,
+	0x97, 0x20, 0xB3, 0x8A, 0x47, 0xE2, 0xBB, 0xDD, 0x81, 0x60, 0xF0, 0x06,
+	    0x52, 0x5C, 0x3E, 0x64, 0x39, 0x2B, 0x1C, 0x25,
+	0xC1, 0xD8, 0x0B, 0xC4, 0x3C, 0x8D, 0x72, 0x40, 0xCA, 0xBB, 0xCD, 0x16,
+	    0x9F, 0x41, 0x1E, 0x52, 0xC0, 0xD9, 0xBC, 0xAC,
+	0xD5, 0x50, 0x52, 0xF3, 0x4B, 0x78, 0x23, 0xF3, 0x52, 0x12, 0x95, 0x43,
+	    0x41, 0xDA, 0xED, 0x05, 0x98, 0x50, 0x73, 0x45,
+	0x5A, 0xE8, 0xB5, 0x6F, 0x1D, 0x3E, 0x0D, 0x53, 0x40, 0xDB, 0xCD, 0x84,
+	    0xF9, 0x14, 0x43, 0xD8, 0xCB, 0x25, 0x70, 0xA6,
+	0x71, 0xC3, 0x74, 0x13, 0x5A, 0xA9, 0xAC, 0x66, 0x77, 0xB4, 0x72, 0xE9,
+	    0x80, 0xB8, 0xB4, 0x56, 0x32, 0x77, 0x1C, 0x72,
+	0xEB, 0x2D, 0xBC, 0xB0, 0x67, 0x78, 0x3D, 0x45, 0xFA, 0xB6, 0xBD, 0xA7,
+	    0xF1, 0xC8, 0x4D, 0xE4, 0xEF, 0x67, 0xED, 0x35,
+	0x09, 0x79, 0x5E, 0x55, 0xFB, 0x97, 0xF5, 0x05, 0x44, 0x38, 0x65, 0x91,
+	    0xEF, 0xFC, 0x97, 0x0E, 0x50, 0x71, 0x82, 0x0C,
+	0x46, 0x24, 0xF9, 0x64, 0xA8, 0x75, 0x1E, 0x4A, 0xEA, 0x10, 0xDE, 0xB9,
+	    0xDC, 0xD9, 0x4F, 0x70, 0xB1, 0xD4, 0x51, 0xDE,
+	0x4E, 0xDD, 0x66, 0x3A, 0x6C, 0x5D, 0x15, 0x3E, 0x9B, 0x49, 0xEF, 0x90,
+	    0x8C, 0x56, 0x7E, 0x85, 0x1D, 0x45, 0x33, 0xCB,
+	0xA9, 0x7A, 0x77, 0x8C, 0xFE, 0x8A, 0xF0, 0x71, 0x65, 0xD6, 0x4F, 0x68,
+	    0xA3, 0x3F, 0x27, 0xE9, 0x69, 0x54, 0xA7, 0x42,
+	0xD8, 0x9B, 0xF9, 0x2A, 0x2C, 0xAC, 0x72, 0xAE, 0x79, 0x43, 0x43, 0xEA,
+	    0xE8, 0x3B, 0x5E, 0xF0, 0xDB, 0xF6, 0x70, 0xE4,
+	0x2D, 0xAD, 0xB6, 0x5E, 0x3E, 0xBC, 0x5F, 0x7A, 0xE3, 0x85, 0xDA, 0x9E,
+	    0x38, 0xA2, 0x41, 0xBA, 0xD6, 0x11, 0xBF, 0xAF,
+	0xF9, 0x81, 0xD6, 0x8B, 0x08, 0x7E, 0xA8, 0x0F, 0x78, 0x36, 0x4D, 0xA6,
+	    0x08, 0x94, 0xF5, 0x3F, 0x17, 0x30, 0x61, 0xD0,
+	0x48, 0x5B, 0xA7, 0x9F, 0xBA, 0x3F, 0xF2, 0xEA, 0x5E, 0xCD, 0x08, 0x9E,
+	    0x30, 0x0D, 0x6A, 0x27, 0xE7, 0xC6, 0x0A, 0x54,
+	0xD6, 0x87, 0xE8, 0xE6, 0x39, 0x3A, 0x31, 0xCB, 0x35, 0x83, 0xB0, 0x52,
+	    0x26, 0x3A, 0x02, 0xC9, 0xD7, 0xA6, 0x79, 0x07,
+	0xAC, 0x46, 0xFF, 0xE7, 0xD6, 0xE0, 0xB9, 0xEF, 0x67, 0xC4, 0x30, 0xC5,
+	    0xE7, 0x56, 0xAE, 0xEE, 0xD1, 0xC1, 0x2A, 0xFF,
+	0x55, 0x6E, 0x41, 0x14, 0xA6, 0x3C, 0x42, 0x55, 0xA8, 0xEA, 0x73, 0x5D,
+	    0x7E, 0x3F, 0x80, 0x02, 0x01, 0x29, 0x63, 0x80,
+	0xEA, 0x69, 0x90, 0xC6, 0x4A, 0xEB, 0x3B, 0x55, 0xD3, 0x54, 0x90, 0xD4,
+	    0x12, 0xA1, 0x93, 0x81, 0xCB, 0x68, 0x98, 0x37,
+	0xE2, 0xE8, 0x65, 0x7C, 0xBE, 0xC4, 0x99, 0xC5, 0x93, 0x6C, 0x66, 0x81,
+	    0xC0, 0x16, 0x91, 0xC7, 0xBA, 0xE9, 0xCE, 0x6E,
+	0xE4, 0xFF, 0xD1, 0x87, 0xE8, 0xA8, 0xEA, 0x91, 0x6B, 0x6A, 0xB3, 0x8C,
+	    0x74, 0xE1, 0xF9, 0xC1, 0x67, 0x02, 0xD0, 0x0F,
+	0x0C, 0xB3, 0x4A, 0xA8, 0x49, 0xA2, 0x34, 0x51, 0xFF, 0xEB, 0xAD, 0xE7,
+	    0x59, 0xCB, 0x6E, 0xED, 0x76, 0xEB, 0x5A, 0x7B,
+	0xC1, 0xC4, 0xE3, 0xB0, 0xF8, 0x16, 0xA4, 0xE6, 0xD0, 0x31, 0xB1, 0x69,
+	    0x63, 0xC6, 0x0B, 0x7B, 0xC4, 0xC5, 0xA5, 0x0A,
+	0x5C, 0x38, 0xF0, 0x20, 0x29, 0x1B, 0xF6, 0x43, 0xAE, 0x2F, 0x31, 0xBB,
+	    0x6E, 0xCD, 0xDB, 0x98, 0xDD, 0xE6, 0x74, 0x63,
+	0xBD, 0xC1, 0x56, 0x2C, 0x5D, 0x73, 0xE5, 0x88, 0x06, 0xFD, 0xFE, 0x05,
+	    0xFF, 0x66, 0xDD, 0x76, 0x47, 0xDC, 0xD2, 0x8E,
+	0xA0, 0xA2, 0xBA, 0x63, 0x43, 0x30, 0x85, 0x9C, 0xDD, 0xA5, 0x7B, 0xB3,
+	    0xC6, 0xFF, 0x9B, 0xCD, 0x9F, 0xEC, 0x7F, 0x6F,
+	0xFD, 0x98, 0x08, 0x8D, 0x7F, 0x64, 0x31, 0x1B, 0xF3, 0xCD, 0xD3, 0x8F,
+	    0x64, 0xA0, 0x03, 0x08, 0xF3, 0x47, 0x7B, 0x1D,
+	0x9C, 0x50, 0x88, 0x1D, 0x27, 0xD0, 0x30, 0x6E, 0xF8, 0x7D, 0x6D, 0x27,
+	    0xC1, 0x59, 0xD4, 0xA5, 0x69, 0xFF, 0x28, 0xF2,
+	0x63, 0x97, 0x4E, 0x56, 0x2F, 0x4C, 0x34, 0xF0, 0xC4, 0x0E, 0x9B, 0xC0,
+	    0x56, 0x21, 0x31, 0xA6, 0x59, 0x1B, 0x5A, 0xC0,
+	0x87, 0x86, 0x31, 0x43, 0xDE, 0xD4, 0x75, 0xBA, 0xA1, 0xE9, 0xD9, 0x9E,
+	    0x04, 0x4C, 0xB5, 0x03, 0x37, 0xD4, 0x89, 0xD1,
+	0x1A, 0xD5, 0xE4, 0x39, 0x50, 0xF8, 0xE9, 0xF3, 0x1E, 0x8B, 0x84, 0x86,
+	    0x9A, 0x34, 0x72, 0x90, 0xE4, 0xF0, 0x8C, 0x64,
+	0x73, 0x54, 0x14, 0xC3, 0x13, 0x35, 0xD6, 0x34, 0xB5, 0x9D, 0xFD, 0x70,
+	    0xC9, 0x85, 0xC4, 0xA6, 0x73, 0xFA, 0xA5, 0xDA,
+	0xAA, 0x6B, 0x9D, 0x45, 0xB3, 0xEF, 0xFE, 0x01, 0xC4, 0x54, 0xCD, 0x37,
+	    0x01, 0xF9, 0xFC, 0x57, 0xF3, 0xD9, 0x4D, 0xB5,
+	0xF6, 0xF7, 0x45, 0x41, 0xEF, 0xB7, 0x9D, 0xB3, 0xEF, 0xFA, 0x92, 0xE8,
+	    0xD3, 0xDA, 0x23, 0xEC, 0x8B, 0xDD, 0x3E, 0x1D,
+	0x8D, 0xD7, 0xB3, 0x2C, 0xD2, 0xA8, 0xF7, 0x8D, 0x56, 0x95, 0x17, 0xC0,
+	    0x3B, 0x72, 0x45, 0x9D, 0xCC, 0xB5, 0xE5, 0x01,
+	0x16, 0xA8, 0xFD, 0x4A, 0x93, 0x96, 0x9F, 0x60, 0x43, 0x66, 0x57, 0xEB,
+	    0x0E, 0xD7, 0x8F, 0x4F, 0xF0, 0xBA, 0x74, 0x8C,
+	0xAB, 0xE2, 0xE3, 0x66, 0x3C, 0x20, 0xD8, 0x44, 0x1C, 0x0D, 0x38, 0xCD,
+	    0x16, 0x8A, 0xA6, 0xD6, 0x4E, 0x69, 0x9E, 0x4C,
+	0x3F, 0xDF, 0xB6, 0x13, 0xCB, 0x9D, 0xBC, 0x10, 0xDD, 0xF1, 0x31, 0xB2,
+	    0xAD, 0x99, 0xE2, 0xD8, 0x9E, 0x37, 0x06, 0x78,
+	0x6A, 0xE4, 0x76, 0xE7, 0xDE, 0x77, 0x70, 0xF5, 0xDE, 0xDC, 0xBD, 0xCE,
+	    0x1D, 0xB8, 0x17, 0xAF, 0x9F, 0x53, 0xFD, 0xEB,
+	0x5D, 0xF8, 0xA1, 0x5F, 0xF7, 0x18, 0x90, 0x3D, 0x3D, 0xBC, 0x07, 0x79,
+	    0xEA, 0xB5, 0x04, 0x1D, 0x5E, 0x77, 0x80, 0xE2,
+	0x7F, 0x89, 0xC2, 0x4D, 0x92, 0x87, 0xF2, 0xA8, 0xA5, 0xC9, 0xE9, 0x57,
+	    0x6A, 0x2F, 0x80, 0x85, 0xA0, 0xFE, 0xF7, 0x96,
+	0xA3, 0x10, 0x02, 0x32, 0xD3, 0x4B, 0x34, 0xDC, 0xEB, 0x2C, 0xC1, 0xF8,
+	    0xF2, 0x04, 0xAF, 0x67, 0x1D, 0x40, 0x31, 0xCB,
+	0x29, 0x71, 0x90, 0x56, 0xE6, 0x2D, 0x23, 0x94, 0x8F, 0x89, 0xB1, 0x05,
+	    0x49, 0x2C, 0x99, 0x12, 0x6D, 0x45, 0xFF, 0x99,
+	0xC3, 0x2E, 0x48, 0x54, 0xCA, 0x75, 0xB7, 0xB4, 0x52, 0x2B, 0xF8, 0x65,
+	    0xC0, 0x23, 0x89, 0x41, 0xF7, 0x9B, 0xE4, 0x23,
+	0x73, 0xA3, 0x24, 0xC6, 0x13, 0x2D, 0xAD, 0x71, 0x01, 0x7E, 0xD0, 0xF0,
+	    0x73, 0x37, 0x56, 0x52, 0xF2, 0xD7, 0xA1, 0xE2,
+	0x94, 0x2B, 0x91, 0x91, 0xC0, 0x49, 0xEF, 0xD5, 0x5F, 0x90, 0x19, 0x22,
+	    0xFF, 0x8E, 0xCF, 0x37, 0xD1, 0x28, 0xFE, 0x06,
+	0x34, 0x77, 0x5E, 0x9D, 0xAB, 0x2A, 0x86, 0xA8, 0xA9, 0x78, 0xB0, 0xF7,
+	    0x97, 0xD5, 0xE6, 0x0C, 0x2B, 0x68, 0xF4, 0x85,
+	0x5B, 0xF8, 0x40, 0xE3, 0xAA, 0x04, 0x11, 0x96, 0x18, 0x99, 0x86, 0xDA,
+	    0x89, 0xE6, 0xA4, 0x90, 0xFE, 0x6F, 0x63, 0x4D,
+	0x80, 0x07, 0xE4, 0xFD, 0x18, 0x35, 0x6B, 0x5A, 0xAE, 0xEE, 0xAD, 0x84,
+	    0x7F, 0x7A, 0x01, 0x18, 0x2A, 0xF6, 0xB1, 0xFF,
+	0x72, 0x18, 0x03, 0x29, 0x22, 0x62, 0xEA, 0x10, 0x24, 0x64, 0x62, 0xA2,
+	    0xE3, 0x7D, 0x6A, 0x49, 0x3E, 0xD8, 0xEC, 0x80,
+	0x4E, 0x90, 0xC0, 0x64, 0xA5, 0xE1, 0xC8, 0x4B, 0x37, 0xFC, 0x1A, 0xAC,
+	    0x07, 0xDC, 0x33, 0x93, 0x4D, 0x9D, 0x27, 0x02,
+	0x6D, 0x32, 0x59, 0x4B, 0x18, 0x04, 0x93, 0x56, 0xB0, 0x5A, 0xFF, 0xEC,
+	    0x1F, 0x2C, 0x07, 0x93, 0x27, 0x1F, 0x6D, 0x61,
+	0xA9, 0xAF, 0x0B, 0x85, 0xF9, 0x22, 0x1D, 0xB9, 0x93, 0x21, 0x7E, 0xC8,
+	    0x6E, 0x66, 0x4E, 0x7B, 0x83, 0x1D, 0x44, 0x09,
+	0xC5, 0xBB, 0x96, 0x24, 0x7E, 0x1B, 0x07, 0x57, 0x0C, 0xDF, 0xA0, 0x15,
+	    0x03, 0x1C, 0x73, 0x10, 0x49, 0x24, 0x45, 0xAE,
+	0x84, 0x3D, 0xA2, 0x9D, 0xBB, 0xD8, 0x0F, 0x80, 0x03, 0xEF, 0x81, 0x67,
+	    0xDB, 0x3A, 0x1D, 0xA5, 0x48, 0x37, 0xC5, 0x56,
+	0xC8, 0x1E, 0x88, 0x13, 0xA4, 0xA3, 0xAB, 0x77, 0xE6, 0x98, 0x7F, 0xA0,
+	    0xE0, 0x13, 0xA7, 0x26, 0x90, 0x79, 0x62, 0xF9,
+	0x5E, 0xB0, 0xFA, 0x6C, 0xEC, 0x9B, 0x6E, 0x13, 0x56, 0xF9, 0x14, 0x14,
+	    0x07, 0xA9, 0x5B, 0xC3, 0x53, 0xC4, 0xF6, 0x27,
+	0x1D, 0x98, 0x14, 0xF9, 0x9F, 0x04, 0x89, 0x34, 0x37, 0xD1, 0xD6, 0x61,
+	    0x6A, 0x67, 0x97, 0x34, 0x88, 0xC9, 0xC4, 0xA6,
+	0x28, 0x1F, 0xAB, 0x50, 0x7F, 0xD0, 0x77, 0x3E, 0x4A, 0x14, 0x19, 0x92,
+	    0x79, 0x94, 0x9D, 0xF9, 0xE3, 0xF7, 0x0B, 0x5C,
+	0x3B, 0xF4, 0x3E, 0x58, 0xD3, 0x17, 0x8E, 0x8D, 0x3E, 0x89, 0x22, 0x9F,
+	    0x95, 0xF1, 0x5E, 0x40, 0xDA, 0x43, 0x9E, 0x87,
+	0x4F, 0xAD, 0xD7, 0x40, 0x3F, 0xFB, 0x4F, 0xC9, 0x0F, 0x52, 0x1D, 0xD2,
+	    0x7F, 0xFB, 0x3F, 0xD9, 0xA0, 0x15, 0xB6, 0x9E,
+	0x1B, 0xC0, 0x46, 0xC9, 0xAC, 0xF7, 0x4D, 0xDE, 0xC0, 0x38, 0xD9, 0x8A,
+	    0xCF, 0x08, 0x04, 0x75, 0x6D, 0xF6, 0x83, 0xCA,
+	0xDB, 0xF2, 0xF9, 0x42, 0x0D, 0x74, 0xF5, 0xF5, 0x19, 0x5C, 0xCE, 0xC8,
+	    0x93, 0xD2, 0xC7, 0xEA, 0xC9, 0x5A, 0x04, 0xFD,
+	0x54, 0xDC, 0xE5, 0x12, 0x90, 0x5F, 0x0E, 0x04, 0x7C, 0x30, 0xF2, 0x10,
+	    0x52, 0x10, 0x95, 0xB4, 0xDA, 0x82, 0xEB, 0x6C,
+	0x7F, 0x7D, 0xF9, 0x6C, 0xD2, 0x5D, 0xA3, 0xE8, 0x4B, 0xA1, 0x85, 0x8E,
+	    0xE7, 0x3C, 0xCC, 0x48, 0xAA, 0xDF, 0x34, 0xFA,
+	0x1A, 0x40, 0xB8, 0x09, 0x6B, 0xF0, 0xE1, 0x54, 0x74, 0x89, 0x0A, 0x87,
+	    0x0A, 0xE2, 0xFE, 0xAA, 0x1C, 0xA6, 0x0E, 0x97,
+	0x06, 0x3F, 0xE9, 0x38, 0x10, 0x40, 0xAD, 0x90, 0x00, 0x21, 0xD0, 0x94,
+	    0xA7, 0xB0, 0x66, 0xD0, 0x41, 0x83, 0x0D, 0x83,
+	0xAD, 0x22, 0x6B, 0x02, 0xA6, 0x8F, 0xD0, 0x2F, 0xF7, 0xC2, 0x2F, 0x8B,
+	    0xE5, 0x72, 0xE0, 0x24, 0xF5, 0xA3, 0x11, 0xC3,
+	0x7E, 0x8C, 0x91, 0xF7, 0x99, 0xC6, 0xFC, 0xDD, 0xC3, 0xB1, 0x0E, 0x9F,
+	    0xD3, 0xBB, 0x75, 0x40, 0xE6, 0x71, 0x9E, 0xEE,
+	0x7D, 0x07, 0x4E, 0x5E, 0x75, 0x50, 0x74, 0x97, 0x38, 0x1B, 0xB3, 0x8B,
+	    0xD3, 0x74, 0xD0, 0xC6, 0x7E, 0xA6, 0xFB, 0xFF,
+	0x46, 0x35, 0x07, 0x05, 0x39, 0x8B, 0x31, 0x7D, 0xFA, 0xC4, 0x66, 0xC5,
+	    0x70, 0xD2, 0x93, 0xEB, 0x23, 0x84, 0x31, 0xBF,
+	0xA4, 0xEB, 0xCE, 0xF3, 0x0A, 0x2A, 0xB1, 0x43, 0x15, 0x00, 0x22, 0xD1,
+	    0xBC, 0x0C, 0x1E, 0x37, 0x93, 0xA5, 0x1A, 0x5A,
+	0x04, 0x87, 0xA0, 0xEC, 0x9E, 0xCF, 0xEA, 0x6A, 0x48, 0xED, 0x44, 0x51,
+	    0x94, 0x81, 0xD5, 0xBA, 0xAC, 0xF9, 0xD2, 0x9C,
+	0xF7, 0x6D, 0xE8, 0x5A, 0x15, 0x62, 0xE3, 0x56, 0xFA, 0xF9, 0x43, 0x4F,
+	    0xCA, 0x87, 0x24, 0x6D, 0x11, 0xC8, 0x87, 0x58,
+	0xFE, 0x63, 0xCB, 0x3D, 0xF8, 0x67, 0x4B, 0x5F, 0x95, 0x86, 0x93, 0x58,
+	    0x93, 0xA4, 0x43, 0x3F, 0xCB, 0x59, 0x43, 0xCC,
+	0xA5, 0x44, 0xF1, 0xD9, 0x2C, 0x21, 0x44, 0x2C, 0xF5, 0x0F, 0xC7, 0x1B,
+	    0xFA, 0x45, 0xB9, 0xD6, 0xB7, 0x0F, 0x22, 0xDE,
+	0xC7, 0x7C, 0x46, 0xDA, 0x4C, 0xB9, 0xBA, 0x8F, 0x55, 0x8F, 0xBB, 0x39,
+	    0x95, 0xBE, 0xF4, 0xCF, 0xDA, 0xFC, 0xBA, 0x48,
+	0x7B, 0x51, 0xAC, 0x43, 0xB9, 0x0B, 0x8B, 0x1C, 0xBC, 0xE7, 0xFE, 0x48,
+	    0xAD, 0x1E, 0xA9, 0xAC, 0xA9, 0xC3, 0x33, 0x7B,
+	0x49, 0xBE, 0xB3, 0xFA, 0x23, 0x6C, 0x1A, 0x2A, 0xA9, 0x36, 0xD9, 0x02,
+	    0x22, 0xB6, 0xE6, 0x53, 0xC7, 0x90, 0x8A, 0x8F,
+	0x72, 0x20, 0x9A, 0x16, 0x3B, 0x4C, 0xFD, 0x85, 0x18, 0xBE, 0xC5, 0xB0,
+	    0x69, 0x93, 0x84, 0xF1, 0xAB, 0x5E, 0xF3, 0xC3,
+	0xA0, 0xB7, 0x65, 0x13, 0xD1, 0x1F, 0x6D, 0xB2, 0xE2, 0xA0, 0xEB, 0xC5,
+	    0x07, 0x97, 0x15, 0xF3, 0xA1, 0xB6, 0x8F, 0xA8,
+	0x16, 0x38, 0x7E, 0xA7, 0x0E, 0xB7, 0xAE, 0xCD, 0x23, 0x5C, 0x8C, 0xC7,
+	    0x19, 0xB4, 0x4D, 0xB8, 0xA3, 0x41, 0x0C, 0x6A,
+	0xC3, 0x5D, 0xFC, 0xF2, 0x70, 0x6E, 0x27, 0x2D, 0x54, 0x95, 0xB7, 0x4F,
+	    0xEB, 0x56, 0x3A, 0x70, 0xC9, 0x62, 0xCD, 0x52,
+	0x92, 0x9B, 0x45, 0xE7, 0xA0, 0x66, 0xB4, 0xD6, 0x84, 0xF4, 0x55, 0x70,
+	    0x45, 0xDC, 0xFC, 0x94, 0xCC, 0xF9, 0x32, 0xD7,
+	0xA1, 0x15, 0xD7, 0x3C, 0x04, 0x28, 0x45, 0x61, 0xE7, 0xDF, 0x9B, 0x5E,
+	    0xF4, 0x97, 0x92, 0xF9, 0x1E, 0xDA, 0x4D, 0xA7,
+	0xD7, 0xFC, 0x0E, 0x59, 0x52, 0xBD, 0x23, 0x69, 0x95, 0x69, 0x7B, 0xBD,
+	    0x8C, 0x36, 0x0A, 0xE1, 0x9E, 0x84, 0xEB, 0x81,
+	0x1F, 0x0C, 0xA4, 0xBC, 0xCE, 0x54, 0xE2, 0xBD, 0x0D, 0x35, 0x9D, 0x3F,
+	    0x12, 0x15, 0x0F, 0x58, 0x9E, 0x4F, 0xD1, 0x93,
+	0x15, 0x4B, 0xFE, 0xDC, 0x9E, 0x9D, 0xB9, 0xFD, 0xDD, 0x21, 0x6A, 0x84,
+	    0xDB, 0x99, 0x2A, 0xCF, 0x7D, 0xED, 0x6B, 0x0D,
+	0xC7, 0x9F, 0x99, 0x30, 0x38, 0x3E, 0xF2, 0x88, 0x2C, 0xD3, 0x29, 0x11,
+	    0x5A, 0x39, 0x17, 0xA9, 0x53, 0x14, 0x2C, 0xF6,
+	0xAA, 0x60, 0x26, 0xF6, 0xEA, 0xBD, 0xC4, 0x01, 0x79, 0x06, 0x80, 0xB5,
+	    0xCF, 0x9A, 0x1E, 0x27, 0xF2, 0xFC, 0x17, 0x4C,
+	0x14, 0xD3, 0xA2, 0xD0, 0x98, 0xBF, 0x4F, 0x51, 0xAE, 0x8F, 0x46, 0x90,
+	    0x42, 0xC3, 0x5F, 0xEF, 0x6D, 0xB8, 0xEA, 0xFB,
+	0x80, 0x5C, 0xDB, 0x3B, 0x7F, 0xD8, 0x5B, 0x2F, 0x6F, 0x31, 0x1E, 0xA4,
+	    0x39, 0x68, 0x34, 0x00, 0xB9, 0x51, 0x1A, 0x8C,
+	0xFA, 0x07, 0xB2, 0xEF, 0x17, 0xEA, 0xC5, 0x52, 0xC3, 0xA6, 0x8A, 0x47,
+	    0xBA, 0x25, 0x61, 0xB3, 0xA0, 0x0F, 0x34, 0x74,
+	0x24, 0xAB, 0x41, 0xB1, 0xCC, 0x00, 0xBB, 0x80, 0x93, 0x6F, 0x7B, 0x8C,
+	    0x20, 0x80, 0x2C, 0x91, 0xFD, 0x3A, 0xE7, 0xC1,
+	0x9D, 0x4C, 0xA3, 0x85, 0x33, 0xCC, 0x12, 0xE7, 0x26, 0x8F, 0xE9, 0x3B,
+	    0xD3, 0xAE, 0x68, 0x8F, 0xBF, 0x35, 0xEF, 0x16,
+	0xB9, 0x95, 0xE8, 0x22, 0x61, 0x62, 0x91, 0x6B, 0xB6, 0xDA, 0xC8, 0x83,
+	    0xCF, 0x18, 0xA6, 0xD0, 0xA3, 0xB4, 0x2B, 0x70,
+	0xBE, 0xA9, 0x46, 0x0D, 0x79, 0x97, 0xAC, 0x1F, 0xF4, 0x19, 0xAF, 0xC5,
+	    0x39, 0x45, 0x37, 0x56, 0xA7, 0xA8, 0x25, 0xC6,
+	0xEB, 0x2D, 0x21, 0x56, 0x7E, 0x48, 0xE2, 0xB2, 0x09, 0x6D, 0x02, 0xF2,
+	    0x37, 0xF8, 0x42, 0xD0, 0x97, 0x6A, 0x72, 0x9F,
+	0xA7, 0x45, 0x36, 0x08, 0xEF, 0x0D, 0x4F, 0x9A, 0xEB, 0xFB, 0x55, 0x36,
+	    0x94, 0x84, 0x44, 0xDA, 0x4D, 0xCC, 0xA2, 0x0C,
+	0x75, 0xC6, 0xDA, 0x09, 0x8E, 0xE1, 0x99, 0xE4, 0xEF, 0x7F, 0x51, 0xCB,
+	    0x69, 0xB5, 0xAB, 0xC2, 0x21, 0xCB, 0x33, 0xE7,
+	0x25, 0x06, 0x95, 0x8E, 0xB4, 0x94, 0x09, 0x65, 0x22, 0x0F, 0x3B, 0x4F,
+	    0xBB, 0x0C, 0xE6, 0xB9, 0xA9, 0x4C, 0xC4, 0xC8,
+	0x33, 0x4F, 0x0C, 0x8A, 0x4E, 0xB1, 0xC0, 0xE8, 0x73, 0x6C, 0x63, 0x3A,
+	    0xB8, 0x68, 0x5A, 0xB4, 0xFF, 0x60, 0x62, 0x48,
+	0x18, 0x52, 0xA4, 0xDC, 0xBA, 0xCE, 0x7D, 0x71, 0x8C, 0xCC, 0xCB, 0x48,
+	    0xE5, 0xF1, 0xC3, 0x1A, 0xF2, 0xEF, 0xAD, 0x54,
+	0xB2, 0x6D, 0x73, 0xA2, 0x76, 0xAE, 0x92, 0x72, 0x3C, 0x6D, 0xE3, 0x87,
+	    0xDB, 0x02, 0x4C, 0x8E, 0xA7, 0xF2, 0x57, 0x7E,
+	0x1F, 0xE0, 0xC8, 0xB7, 0x36, 0x4B, 0x74, 0x17, 0x8F, 0x5D, 0x05, 0x95,
+	    0xD1, 0xF1, 0x49, 0x6D, 0x29, 0x53, 0x57, 0xBF,
+	0x4E, 0x20, 0xDC, 0xAD, 0x4C, 0xFE, 0x9D, 0xCB, 0xD6, 0x30, 0xDC, 0x81,
+	    0xA6, 0xF9, 0xA1, 0x81, 0x8B, 0x64, 0x6A, 0x50,
+	0x43, 0x12, 0x30, 0x4F, 0x05, 0x3D, 0x57, 0x84, 0xA7, 0x9A, 0x38, 0xE4,
+	    0x05, 0xBA, 0xB9, 0xCF, 0x42, 0x36, 0x66, 0x92,
+	0x50, 0x8C, 0x7E, 0x26, 0x32, 0x5B, 0x19, 0xC5, 0x49, 0x84, 0xD0, 0x1D,
+	    0x9D, 0x15, 0x01, 0x9A, 0xF3, 0x79, 0x4D, 0xB6,
+	0xD8, 0xB8, 0x73, 0x8F, 0xBE, 0x88, 0x58, 0x12, 0xE4, 0x14, 0x4B, 0xCB,
+	    0x51, 0x09, 0xD5, 0x2B, 0x07, 0x89, 0x05, 0xD8,
+	0x22, 0x8A, 0x35, 0x46, 0xC6, 0xDD, 0x6A, 0xA7, 0x53, 0xA3, 0x58, 0x83,
+	    0x8D, 0x9D, 0xAB, 0xE9, 0x3C, 0xB1, 0x04, 0xC2,
+	0x46, 0xA8, 0x62, 0xBA, 0x66, 0xAA, 0x69, 0x74, 0xA0, 0xE3, 0xBC, 0x77,
+	    0x3E, 0xF3, 0xA9, 0x4A, 0x91, 0x53, 0xA9, 0x9D,
+	0xD9, 0xF9, 0x1F, 0x8B, 0x48, 0x91, 0x31, 0x7E, 0xD0, 0x68, 0x24, 0x3A,
+	    0xC7, 0x18, 0xCC, 0x1B, 0x5D, 0xA6, 0x2F, 0x65,
+	0x4C, 0x61, 0x22, 0xA9, 0x1B, 0x5F, 0xE2, 0x2D, 0x81, 0x52, 0x55, 0x5E,
+	    0x7C, 0xF7, 0x29, 0xE8, 0xE0, 0xA0, 0xD1, 0x7F,
+	0xBD, 0x3D, 0x67, 0x3D, 0xCC, 0xB5, 0x2B, 0xDF, 0x06, 0xC6, 0x7E, 0xEC,
+	    0xC1, 0x78, 0x42, 0x8C, 0x36, 0xC7, 0xFA, 0x93,
+	0xB4, 0xD7, 0x7F, 0x9E, 0xC1, 0x63, 0xB3, 0x9F, 0xD6, 0x6B, 0xF5, 0x9B,
+	    0xF1, 0xEC, 0x16, 0xF0, 0x58, 0xFA, 0xE6, 0x02,
+	0x7D, 0xDF, 0x7F, 0x27, 0x06, 0x13, 0x3C, 0xE9, 0x5B, 0xA1, 0x77, 0x03,
+	    0x9B, 0x48, 0xBF, 0x8F, 0x05, 0x70, 0xB0, 0xA7,
+	0x3D, 0xC0, 0x87, 0xC1, 0xBD, 0x16, 0xE7, 0x19, 0xE7, 0xA4, 0xF9, 0xE3,
+	    0xD1, 0x8B, 0xDF, 0xEE, 0xFC, 0xFB, 0x9E, 0x76,
+	0xD6, 0xA0, 0x0E, 0xC0, 0x26, 0x75, 0xCE, 0x21, 0xF5, 0x7F, 0x03, 0x7C,
+	    0xD4, 0x2A, 0x7F, 0x62, 0x13, 0xAA, 0x40, 0x36,
+	0xB8, 0x44, 0x29, 0x09, 0x6D, 0xA3, 0xAA, 0x58, 0x39, 0x3E, 0xDA, 0xEA,
+	    0xA5, 0x09, 0xF1, 0x3F, 0xA4, 0x69, 0x05, 0x45,
+	0xF0, 0x57, 0x26, 0x13, 0xEE, 0x5B, 0xD7, 0x93, 0xEB, 0x66, 0x2B, 0xED,
+	    0x2E, 0x87, 0x64, 0x17, 0x29, 0xB2, 0x58, 0x66,
+	0xF1, 0xE1, 0xFC, 0xCF, 0xA3, 0xAB, 0xE0, 0xA5, 0xAF, 0x75, 0xF2, 0x8D,
+	    0xBF, 0x55, 0x97, 0x30, 0xF4, 0xE0, 0x5B, 0x30,
+	0x57, 0x0E, 0xE8, 0x34, 0x63, 0xDE, 0x80, 0x47, 0x71, 0x4A, 0x59, 0xC1,
+	    0x68, 0x78, 0x55, 0x28, 0x35, 0xBD, 0x13, 0x63,
+	0x2F, 0x57, 0xD4, 0x85, 0x36, 0x33, 0x51, 0xA8, 0xA3, 0x2A, 0x91, 0x5F,
+	    0x77, 0x58, 0xC9, 0x15, 0x38, 0xDC, 0x29, 0x09,
+	0xBD, 0xC4, 0xA5, 0x8E, 0x31, 0xC5, 0x62, 0x4F, 0x10, 0xEA, 0x0C, 0xC8,
+	    0x2E, 0x7D, 0x72, 0xC2, 0xE2, 0x45, 0x51, 0x3D,
+	0xAC, 0x36, 0x4F, 0x9A, 0x48, 0x78, 0x8E, 0x58, 0xC0, 0x7F, 0xF1, 0xD4,
+	    0xF8, 0x36, 0x43, 0xB9, 0xD2, 0x87, 0xB3, 0x0F,
+	0x9A, 0x79, 0x4D, 0x2C, 0x6D, 0x15, 0xA6, 0x1E, 0x7D, 0x6B, 0x39, 0x87,
+	    0x72, 0x06, 0x6B, 0xEA, 0xFA, 0xE9, 0xC4, 0x45,
+	0x1F, 0x14, 0xBA, 0x59, 0x22, 0x46, 0xF3, 0x7B, 0xAF, 0x0D, 0x72, 0xA6,
+	    0xEA, 0xE1, 0x41, 0x0C, 0xBD, 0xDC, 0x8C, 0xCF,
+	0x0E, 0xE8, 0x6B, 0x3C, 0x2B, 0x2C, 0x95, 0xDA, 0x43, 0xB9, 0x20, 0x78,
+	    0xFC, 0x50, 0x2A, 0x0C, 0xAC, 0x52, 0xC6, 0xA1,
+	0x2B, 0x51, 0x1C, 0xA2, 0x61, 0x23, 0xCB, 0x90, 0x43, 0x38, 0x1D, 0x51,
+	    0xF4, 0x1B, 0x53, 0x6B, 0x13, 0x90, 0x4C, 0x63,
+	0x3A, 0x50, 0x61, 0x79, 0x5D, 0xC5, 0xA2, 0x7A, 0xD9, 0x2D, 0x0C, 0x7A,
+	    0xE8, 0xD2, 0x94, 0x92, 0x32, 0x72, 0xEB, 0xA6,
+	0x62, 0x5B, 0xA2, 0xC4, 0x14, 0xFC, 0xAE, 0xF0, 0xD2, 0xF4, 0x13, 0xCC,
+	    0xC4, 0x1A, 0xFC, 0x4B, 0xE6, 0xD0, 0x48, 0x45,
+	0xF9, 0xB0, 0x3A, 0xC2, 0x26, 0xF5, 0x8C, 0xE5, 0x90, 0x2E, 0xB3, 0x27,
+	    0x9B, 0x6C, 0xCB, 0xA1, 0x15, 0x71, 0x15, 0x11,
+	0x0B, 0x91, 0xD5, 0x93, 0x37, 0x45, 0x7F, 0xB6, 0xE3, 0x98, 0x83, 0x9E,
+	    0x9D, 0xFE, 0xF4, 0x31, 0xAA, 0x3F, 0xE4, 0x42,
+	0x1F, 0xF7, 0x8B, 0xC6, 0x46, 0xDC, 0x24, 0x0E, 0x92, 0xB9, 0xAE, 0x98,
+	    0xD6, 0x9A, 0x7C, 0xCE, 0xB7, 0x28, 0x36, 0xEF,
+	0x98, 0x0E, 0xFD, 0x90, 0x84, 0xE5, 0x1D, 0xC7, 0x5B, 0xD4, 0xED, 0xC2,
+	    0xC9, 0x69, 0x7E, 0x0B, 0x5E, 0x9B, 0x0A, 0x0F,
+	0x4A, 0xB9, 0xD9, 0xA8, 0x04, 0xD6, 0xB6, 0xCE, 0x46, 0xD9, 0x7D, 0x1B,
+	    0x17, 0x9A, 0x45, 0x0C, 0x0A, 0xB5, 0xE6, 0x93,
+	0x69, 0x9E, 0xDD, 0x0A, 0x7A, 0xA4, 0x56, 0x2E, 0x71, 0x8E, 0xA4, 0x7D,
+	    0x97, 0xBC, 0x9A, 0xF8, 0x92, 0x3D, 0xB8, 0xB7,
+	0xD6, 0xFD, 0xA8, 0xD2, 0x6B, 0xFA, 0x81, 0x8F, 0xDC, 0x78, 0x55, 0x3F,
+	    0x0D, 0xC5, 0x9F, 0xAB, 0xDF, 0xF5, 0xF7, 0x0A,
+	0xFD, 0x98, 0x8D, 0x1F, 0x12, 0xBB, 0x35, 0xCB, 0x65, 0x32, 0x95, 0x2F,
+	    0x63, 0x14, 0x36, 0x3F, 0x95, 0x3C, 0x16, 0x4C,
+	0x79, 0x76, 0x59, 0xFB, 0x8F, 0x1D, 0x81, 0x8E, 0x6A, 0xFE, 0x8F, 0xE2,
+	    0xCB, 0xA3, 0xEA, 0x67, 0x8F, 0xF3, 0x3C, 0x7D,
+	0xC4, 0xF9, 0x3E, 0x9E, 0x33, 0x46, 0xBE, 0x7F, 0xCA, 0x00, 0x2E, 0xDA,
+	    0xFA, 0xEE, 0xF3, 0x38, 0x2A, 0x13, 0xFB, 0xCF,
+	0xB8, 0x97, 0x08, 0xB1, 0x5B, 0x42, 0x43, 0x94, 0x5D, 0x0B, 0xFF, 0xB9,
+	    0x18, 0xFA, 0x14, 0xFB, 0xED, 0xBB, 0x55, 0x11,
+	0xAC, 0xD0, 0xA6, 0x73, 0x5A, 0xF4, 0x5F, 0xE8, 0x0E, 0x4D, 0xB8, 0xE4,
+	    0x1A, 0xAD, 0xA8, 0xC0, 0x04, 0x5B, 0x14, 0x84,
+	0x24, 0xF0, 0x50, 0x30, 0x33, 0xB8, 0x29, 0x62, 0xEA, 0xDA, 0x98, 0xCD,
+	    0x71, 0x5A, 0xFE, 0x08, 0xF6, 0x73, 0x19, 0xE4,
+	0xA2, 0x02, 0xD8, 0x05, 0x37, 0x39, 0xD2, 0x47, 0x3F, 0x46, 0x3D, 0xCD,
+	    0x2E, 0x2F, 0xE1, 0xB9, 0xA1, 0xA2, 0x8D, 0x91,
+	0xE4, 0x3D, 0xD8, 0x57, 0x1D, 0x4C, 0x21, 0xA7, 0xD1, 0x2C, 0x60, 0xAA,
+	    0x77, 0x12, 0xD6, 0xE4, 0xF9, 0x27, 0x00, 0x58,
+	0x5E, 0x06, 0xD3, 0x00, 0xD3, 0x00, 0x6E, 0x32, 0x20, 0x85, 0x5F, 0xD0,
+	    0x47, 0x52, 0x01, 0xF6, 0x24, 0xC5, 0xE0, 0xE7,
+	0x71, 0x9A, 0x49, 0x4D, 0x00, 0xA1, 0x7A, 0xF4, 0xEE, 0x89, 0x88, 0x5C,
+	    0xC1, 0x86, 0xF9, 0x63, 0x5F, 0x03, 0x10, 0xD7,
+	0xE4, 0xE7, 0xDE, 0xAA, 0x7A, 0x28, 0xF1, 0x30, 0xE7, 0xB3, 0xDF, 0x73,
+	    0x18, 0x23, 0x80, 0x8A, 0xA6, 0x27, 0xB8, 0xF3,
+	0x98, 0x79, 0x20, 0xD7, 0x7B, 0x68, 0xCB, 0x92, 0xFD, 0x78, 0x54, 0x0C,
+	    0x8E, 0x4B, 0x9B, 0x9E, 0x99, 0x83, 0x8D, 0xDE,
+	0xA8, 0x52, 0x4A, 0x38, 0xDE, 0x4A, 0x3B, 0xE9, 0x61, 0x48, 0xDA, 0x88,
+	    0x3D, 0x21, 0xEB, 0xC1, 0x88, 0x07, 0xC3, 0x5A,
+	0xDA, 0x69, 0xCB, 0x40, 0xC6, 0x45, 0xB3, 0xCD, 0xC5, 0x80, 0xDA, 0xDF,
+	    0xFA, 0xCB, 0x73, 0x99, 0xEA, 0xBC, 0x1B, 0x47,
+	0x0C, 0xF4, 0x91, 0xC8, 0x4A, 0x35, 0x47, 0x73, 0x7E, 0x38, 0x52, 0xFD,
+	    0xD6, 0xCE, 0x72, 0x9F, 0xC9, 0x0D, 0xDC, 0xF8,
+	0xF0, 0x6E, 0x24, 0x45, 0xA0, 0x4E, 0xB2, 0x7A, 0xD8, 0x09, 0x92, 0xCB,
+	    0x2C, 0xD1, 0xFB, 0xB3, 0x36, 0x23, 0xC6, 0x1B,
+	0x21, 0x9F, 0x73, 0x0F, 0x10, 0x9F, 0x43, 0x48, 0xB8, 0xFB, 0x70, 0xEC,
+	    0xB1, 0x80, 0x25, 0xD8, 0x20, 0x0C, 0xA3, 0x5A,
+	0x26, 0x60, 0xBE, 0x7E, 0x30, 0xDD, 0x52, 0xA4, 0x72, 0xB0, 0x34, 0xB0,
+	    0x81, 0x4B, 0x4E, 0xA0, 0x43, 0x20, 0x8C, 0x14,
+	0x63, 0x29, 0x1C, 0xE6, 0xDA, 0xE0, 0x11, 0xD2, 0x9E, 0x57, 0x94, 0xA9,
+	    0xF3, 0xD6, 0xFA, 0x79, 0xA0, 0xA9, 0xBF, 0x6D,
+	0xB0, 0x7D, 0x76, 0x47, 0x62, 0x95, 0x2D, 0xE2, 0x32, 0xE1, 0xE1, 0xE2,
+	    0xFA, 0xE5, 0xF2, 0x7C, 0x6D, 0xDE, 0xEF, 0xF9,
+	0x40, 0x3D, 0xBB, 0xD7, 0xD2, 0x43, 0x84, 0x9D, 0xF6, 0x0F, 0x94, 0xFA,
+	    0x18, 0xC1, 0xB8, 0x9B, 0xA8, 0x05, 0xAC, 0xC3,
+	0x8F, 0x7B, 0xFB, 0x09, 0xD7, 0x8F, 0x97, 0xD4, 0x35, 0xB7, 0x14, 0x39,
+	    0x65, 0x85, 0x4C, 0x76, 0xAE, 0x7A, 0x62, 0xB7,
+	0x81, 0xF7, 0x15, 0x9E, 0x0F, 0x8A, 0x0F, 0xE3, 0x93, 0x40, 0xD3, 0xDD,
+	    0x5B, 0x7D, 0xE1, 0x39, 0x2A, 0x5A, 0xC0, 0xCB,
+	0x99, 0xC3, 0xA8, 0x0E, 0xE5, 0x87, 0x87, 0xF4, 0x50, 0x71, 0xBD, 0xF8,
+	    0xA8, 0x07, 0x2A, 0x09, 0x20, 0xD5, 0xF1, 0x68,
+	0x24, 0x43, 0x6E, 0x44, 0x5C, 0xF8, 0x6F, 0x58, 0x05, 0x1A, 0xED, 0xFA,
+	    0x18, 0x99, 0x89, 0x5A, 0x5A, 0xAD, 0x18, 0x3E,
+	0xD7, 0x56, 0x39, 0x51, 0xC9, 0x1E, 0x43, 0x7E, 0xC4, 0x21, 0x74, 0xCF,
+	    0x17, 0x57, 0x6F, 0x45, 0x7E, 0xB1, 0x87, 0x14,
+	0xD6, 0x2A, 0xD1, 0xA1, 0xB1, 0x80, 0xA5, 0x47, 0xF9, 0x96, 0xA7, 0x0F,
+	    0xF1, 0x4B, 0xA1, 0xB6, 0x2C, 0xE4, 0x16, 0x8B,
+	0xD3, 0xCD, 0xAC, 0x16, 0x97, 0xFD, 0x79, 0x1E, 0x19, 0xE2, 0xB6, 0xD0,
+	    0xD6, 0x52, 0x86, 0xCD, 0xDA, 0x92, 0xA5, 0x08,
+	0xDB, 0xAC, 0xE0, 0x2D, 0xD8, 0x18, 0x03, 0x09, 0xAC, 0xC3, 0xDD, 0xCF,
+	    0x78, 0x3A, 0x6F, 0x16, 0x1F, 0x3D, 0xAF, 0x6F,
+	0x27, 0xB1, 0x1F, 0xE1, 0xBF, 0x5D, 0x58, 0x2E, 0x99, 0x53, 0x21, 0xFF,
+	    0x88, 0x0A, 0xE1, 0x29, 0x58, 0x3A, 0x21, 0x86,
+	0x7D, 0xFC, 0xD8, 0x0A, 0xF4, 0x5F, 0x88, 0xE5, 0x86, 0x49, 0xEA, 0x27,
+	    0xF3, 0xF0, 0xF7, 0x50, 0x32, 0x44, 0x4F, 0x65,
+	0xB6, 0x28, 0x5B, 0xD4, 0x76, 0x57, 0xA3, 0xD7, 0x53, 0xE8, 0xC9, 0x02,
+	    0xF3, 0xA6, 0xF8, 0x07, 0x31, 0xCC, 0x39, 0xBB,
+	0x61, 0x43, 0xEB, 0x1F, 0x73, 0xA0, 0xF4, 0x3B, 0x4D, 0x0A, 0x89, 0xFD,
+	    0xF6, 0xA7, 0x63, 0x32, 0x62, 0xD8, 0x9D, 0xB5,
+	0x67, 0xA2, 0xA0, 0x1F, 0x30, 0xC6, 0xB4, 0x57, 0x62, 0x04, 0x56, 0x4B,
+	    0x36, 0x69, 0x30, 0x7A, 0xE8, 0xA6, 0x4F, 0xD6,
+	0x3A, 0x3D, 0x7B, 0x91, 0xD5, 0x85, 0x30, 0x8B, 0xAE, 0x54, 0xD0, 0x70,
+	    0xDA, 0x80, 0x2B, 0x18, 0x80, 0x2C, 0xF2, 0x04,
+	0x3A, 0x0B, 0x62, 0xA4, 0x0C, 0x97, 0xF2, 0x03, 0x57, 0x82, 0x79, 0x6E,
+	    0xC3, 0x86, 0xE1, 0x72, 0x63, 0x56, 0x6F, 0x5E,
+	0x2C, 0x76, 0xC1, 0xE4, 0xF1, 0x18, 0x28, 0x19, 0x65, 0x20, 0xC3, 0x4E,
+	    0x48, 0xAB, 0x32, 0x4C, 0x0C, 0x87, 0x8A, 0x9C,
+	0x1E, 0x38, 0xEA, 0x63, 0x04, 0xCB, 0xFC, 0x7C, 0x3E, 0x09, 0xC5, 0xBE,
+	    0x30, 0xDB, 0xE2, 0x36, 0xDF, 0xFE, 0x7C, 0x49,
+	0xFF, 0x6E, 0xB5, 0x1B, 0x1E, 0x2D, 0x23, 0xAE, 0x90, 0x47, 0xD3, 0x9C,
+	    0x14, 0xE7, 0x22, 0x1B, 0xBE, 0x7F, 0x74, 0x1E,
+	0x9B, 0x00, 0x33, 0x33, 0x4A, 0xF9, 0x2B, 0xDD, 0xEE, 0xAD, 0xB0, 0x4F,
+	    0x2E, 0x1D, 0x55, 0xEE, 0xF7, 0x7D, 0x0D, 0xCF,
+	0x84, 0xC1, 0xF4, 0x68, 0x95, 0xA8, 0x3A, 0x73, 0x1F, 0x96, 0xB1, 0x5E,
+	    0x19, 0x2F, 0x6F, 0x8A, 0xCF, 0xD2, 0x5A, 0x1C,
+	0x95, 0xCE, 0x2E, 0x6B, 0xA8, 0xFE, 0x1E, 0xA3, 0x9E, 0x11, 0x08, 0x2C,
+	    0x37, 0x68, 0x73, 0xFE, 0x52, 0x4C, 0x42, 0xAB,
+	0x93, 0xC0, 0xE6, 0x41, 0xE3, 0x5B, 0x60, 0xF1, 0xCE, 0xA6, 0x93, 0x79,
+	    0x5C, 0x8B, 0x7B, 0xAF, 0x22, 0x23, 0x24, 0x04,
+	0x86, 0xD1, 0xCB, 0x5A, 0x64, 0x6B, 0xA4, 0x97, 0x30, 0xEB, 0xD3, 0x55,
+	    0xCC, 0xC0, 0xD4, 0x14, 0x87, 0xE3, 0xD0, 0xC1,
+	0x3E, 0x27, 0xB0, 0x34, 0xD3, 0x0E, 0x45, 0x6B, 0x00, 0xDF, 0x9D, 0xC0,
+	    0x7E, 0x63, 0xB5, 0x27, 0xA6, 0xEA, 0x55, 0x53,
+	0xB8, 0xBE, 0xCA, 0x63, 0x25, 0x8C, 0x95, 0xD0, 0x7F, 0x62, 0x86, 0xC3,
+	    0x65, 0xCC, 0x85, 0x48, 0x77, 0x94, 0xBD, 0xFF,
+	0x25, 0x34, 0xDA, 0x67, 0x57, 0xB0, 0xA7, 0x66, 0x32, 0x1E, 0xA7, 0x94,
+	    0x58, 0x78, 0xAB, 0x3A, 0xB6, 0x1E, 0xD6, 0x25,
+	0x1D, 0x1A, 0xBC, 0xEA, 0xC4, 0xDF, 0xF3, 0x08, 0xD3, 0x46, 0xA5, 0x9E,
+	    0x72, 0x92, 0x87, 0xC5, 0xB5, 0x16, 0xB5, 0xFE,
+	0xB5, 0x29, 0x21, 0x42, 0xB5, 0xFA, 0xE8, 0x35, 0x83, 0xD5, 0x3D, 0xC4,
+	    0x8F, 0x26, 0xAF, 0x80, 0xCA, 0x7C, 0xC7, 0x52,
+	0x36, 0x94, 0x38, 0xA3, 0xBE, 0x90, 0xDE, 0x0C, 0x8E, 0x99, 0x08, 0x72,
+	    0x0D, 0xDC, 0x72, 0xCC, 0x00, 0x07, 0x28, 0x1E,
+	0x5A, 0xC8, 0xD6, 0xB9, 0x9C, 0x18, 0xAA, 0x36, 0x4D, 0x78, 0x26, 0xF9,
+	    0x73, 0x46, 0x25, 0x4D, 0x80, 0x9E, 0x9F, 0xC8,
+	0x76, 0x6B, 0x56, 0x6B, 0xE0, 0xD9, 0x8D, 0x0A, 0x0B, 0x57, 0x33, 0x61,
+	    0x9E, 0xF9, 0x3C, 0x7D, 0x9F, 0xF8, 0xBD, 0x39,
+	0x43, 0xF4, 0x53, 0xC0, 0x27, 0x70, 0xE9, 0xD4, 0x1D, 0x80, 0xD8, 0xF6,
+	    0xB1, 0x1A, 0x0E, 0xEF, 0x8E, 0x23, 0xBC, 0x8C,
+	0x2B, 0x43, 0xD6, 0x1D, 0xED, 0xCD, 0x72, 0x2F, 0x9C, 0xDD, 0x84, 0x7E,
+	    0x3F, 0xC4, 0x32, 0x7A, 0x44, 0x76, 0xDF, 0xFA,
+	0xDA, 0xD1, 0x76, 0x0F, 0xB5, 0x13, 0x40, 0xD2, 0xE8, 0x0E, 0xD1, 0x3F,
+	    0xE9, 0x8B, 0x67, 0x5B, 0x4E, 0xD0, 0xDD, 0x27,
+	0xBF, 0xFD, 0x47, 0x05, 0x43, 0xD2, 0x20, 0xFF, 0xDB, 0xFF, 0x28, 0x62,
+	    0x81, 0x0F, 0xA0, 0x18, 0x23, 0x71, 0x4E, 0xE7,
+	0x8A, 0x8B, 0x86, 0x18, 0x56, 0xF0, 0x20, 0xD2, 0x6A, 0x0F, 0x48, 0xE5,
+	    0x20, 0x66, 0x22, 0xCF, 0x47, 0xBA, 0x0B, 0x36,
+	0xF3, 0xC5, 0x29, 0x06, 0x01, 0x46, 0xBB, 0xE3, 0x17, 0x62, 0x59, 0x25,
+	    0xE8, 0x20, 0x32, 0x5A, 0x73, 0xC2, 0x49, 0x31,
+	0xD9, 0xE3, 0x8A, 0x91, 0xFA, 0x5C, 0x0C, 0xC0, 0xAA, 0x43, 0xC9, 0x09,
+	    0x38, 0x0A, 0xD5, 0xAF, 0xF7, 0x57, 0x04, 0xBB,
+	0x9F, 0x89, 0x46, 0x88, 0xA9, 0x77, 0xF6, 0x86, 0x26, 0xCB, 0x5F, 0xAB,
+	    0xF2, 0xA6, 0x2B, 0x94, 0x17, 0x6B, 0x09, 0x4B,
+	0x69, 0xB0, 0xB2, 0x9C, 0xC3, 0x28, 0xB8, 0xC5, 0xD6, 0x71, 0x15, 0xDA,
+	    0x7B, 0x65, 0xEA, 0xD0, 0xAD, 0xE9, 0x46, 0x9D,
+	0x0C, 0xDD, 0x31, 0xAB, 0x5E, 0x7A, 0x9C, 0x12, 0x6A, 0x81, 0x8F, 0x4F,
+	    0xA5, 0x05, 0x20, 0x7D, 0x76, 0x18, 0x5B, 0x91,
+	0x6B, 0x28, 0x42, 0xD4, 0xA2, 0x2E, 0xE2, 0x35, 0x7B, 0xCC, 0xD0, 0xD3,
+	    0xB1, 0xB9, 0x9B, 0x7E, 0x28, 0x49, 0x3E, 0x7E,
+	0xE6, 0x2F, 0x9A, 0xD1, 0x89, 0xA4, 0x96, 0xF4, 0xB8, 0xC6, 0xFB, 0x28,
+	    0xE4, 0x11, 0xD3, 0x0B, 0x39, 0xF5, 0x91, 0xEF,
+	0xDA, 0x04, 0x3F, 0xB2, 0xD9, 0x2A, 0x0F, 0xCF, 0x60, 0xA0, 0x25, 0x4E,
+	    0x38, 0xDA, 0xB7, 0xD1, 0x0D, 0x8D, 0x0C, 0x4E,
+	0xA5, 0x07, 0xED, 0x16, 0xBF, 0xD0, 0x16, 0xBF, 0x70, 0xB1, 0x8A, 0x3E,
+	    0xAB, 0xF3, 0x0D, 0x2E, 0x2D, 0x88, 0xC9, 0x43,
+	0x0D, 0x9D, 0x26, 0x2F, 0x71, 0x36, 0x65, 0x3F, 0x95, 0x47, 0x4D, 0x4D,
+	    0xFA, 0x12, 0x83, 0xCC, 0x69, 0x4C, 0xA5, 0xE9,
+	0x71, 0xAD, 0x6D, 0x0C, 0x88, 0xB1, 0x13, 0x98, 0xC0, 0xC3, 0x6A, 0x26,
+	    0x28, 0x4D, 0xAB, 0xCB, 0x89, 0xE2, 0x91, 0x02,
+	0xAB, 0x6F, 0xE5, 0x41, 0xF5, 0x30, 0x10, 0xE6, 0xCB, 0x9A, 0xCC, 0xCD,
+	    0xD9, 0x59, 0x1C, 0x61, 0x42, 0x80, 0x03, 0xE3,
+	0xBA, 0x73, 0x52, 0x00, 0xDE, 0x54, 0x9E, 0x8D, 0xDA, 0x75, 0x18, 0x56,
+	    0xE4, 0x11, 0xC8, 0xB6, 0x35, 0xDC, 0xC5, 0x7D,
+	0x58, 0xBF, 0xDB, 0x67, 0xA4, 0xB7, 0x16, 0x49, 0xD4, 0xD9, 0x9D, 0xB4,
+	    0x38, 0xA3, 0x0E, 0x36, 0x27, 0x80, 0xB7, 0x25,
+	0x92, 0x9C, 0xDD, 0x49, 0x09, 0x57, 0x0A, 0x84, 0x50, 0xDC, 0xD3, 0x44,
+	    0x7E, 0x54, 0xDE, 0xC6, 0x81, 0x99, 0x94, 0xBD,
+	0x2D, 0xAB, 0x48, 0x06, 0x92, 0xDF, 0xEC, 0xA3, 0xAF, 0x86, 0xC4, 0xD0,
+	    0xB4, 0x06, 0x09, 0xF6, 0xAB, 0x46, 0xF4, 0x0B,
+	0x9A, 0x7A, 0x7B, 0xC7, 0xDA, 0xB9, 0x97, 0xB5, 0x32, 0x20, 0xEE, 0x6F,
+	    0x15, 0xF2, 0xAD, 0xE1, 0x12, 0xF7, 0x33, 0xD6,
+	0x5E, 0x18, 0x9D, 0x7C, 0xDB, 0x31, 0xF9, 0x75, 0xBE, 0xBD, 0x8F, 0xE2,
+	    0x04, 0x6C, 0xB6, 0x95, 0xAE, 0xAB, 0x22, 0xFF,
+	0xBC, 0x99, 0x9E, 0x2C, 0x03, 0x27, 0xC2, 0x28, 0x28, 0x03, 0x44, 0x98,
+	    0x42, 0xB3, 0xB4, 0x1B, 0xC6, 0x7B, 0x28, 0x50,
+	0x73, 0x14, 0xA9, 0xD9, 0x0A, 0x79, 0x59, 0x4C, 0xA8, 0xB1, 0x14, 0x09,
+	    0xE8, 0xEE, 0x37, 0x10, 0xEE, 0xC1, 0xAF, 0x52,
+	0x8F, 0x7A, 0x0F, 0x68, 0xEE, 0x1B, 0x88, 0xBB, 0xD1, 0xEA, 0xE0, 0x51,
+	    0xDD, 0x16, 0x5F, 0x38, 0x5C, 0x86, 0x40, 0xF5,
+	0x02, 0xAA, 0xE6, 0x90, 0x9B, 0xB0, 0x28, 0x59, 0x9F, 0x0A, 0x90, 0x8A,
+	    0x81, 0x21, 0xDE, 0x9E, 0x11, 0x06, 0xF6, 0x54,
+	0xB9, 0x19, 0xDB, 0xBF, 0x8A, 0xFB, 0xA6, 0xF8, 0x9B, 0xFC, 0x41, 0xF5,
+	    0x82, 0xCA, 0x03, 0x1D, 0xF6, 0x3F, 0x29, 0x59,
+	0xC8, 0xB3, 0xF0, 0x0F, 0x1A, 0xD5, 0xE9, 0xBF, 0x40, 0x3C, 0x8D, 0xBF,
+	    0x44, 0x51, 0x09, 0x0A, 0x81, 0xD2, 0xB5, 0x0E,
+	0x7F, 0xD2, 0x3A, 0x03, 0x27, 0xE1, 0xD8, 0x84, 0xD9, 0x2C, 0x38, 0xC3,
+	    0xC1, 0x30, 0xD6, 0x43, 0x55, 0xA0, 0x2F, 0x74,
+	0xFE, 0xC3, 0xC0, 0xD4, 0x91, 0xAF, 0x61, 0x30, 0x01, 0xFA, 0xE0, 0x22,
+	    0x53, 0x71, 0xE1, 0xCF, 0xFF, 0x99, 0x99, 0xBB,
+	0x37, 0xAC, 0x68, 0x31, 0xA3, 0xC2, 0xBD, 0xF7, 0x3D, 0x13, 0xF3, 0x3E,
+	    0x79, 0x48, 0x0D, 0xD5, 0x36, 0xAD, 0x19, 0x44,
+	0xF6, 0xE7, 0x64, 0x55, 0x55, 0x73, 0xE3, 0x59, 0x00, 0x14, 0xFA, 0x44,
+	    0xA5, 0x09, 0x8F, 0x10, 0x68, 0x1B, 0xCA, 0x9D,
+	0x29, 0xE8, 0xFB, 0xD6, 0x5B, 0xC5, 0xE0, 0x72, 0x11, 0x5D, 0xC3, 0xD7,
+	    0xB0, 0x68, 0x5D, 0xF4, 0xD7, 0xDC, 0x40, 0x21,
+	0x79, 0x2B, 0xB3, 0x37, 0x16, 0xB0, 0xCE, 0x52, 0x67, 0x39, 0x2A, 0x70,
+	    0xD0, 0x2D, 0x09, 0xF4, 0xC5, 0x2C, 0xAA, 0x35,
+	0x60, 0xC2, 0xAF, 0x4E, 0x2C, 0x83, 0xC1, 0x64, 0xFA, 0xE8, 0xE2, 0xF6,
+	    0x97, 0x93, 0x9A, 0xAA, 0xF5, 0xC1, 0xD0, 0x6A,
+	0x6D, 0xD3, 0x8C, 0x4B, 0x1E, 0x41, 0x3C, 0x7C, 0xF6, 0x92, 0x90, 0xED,
+	    0x69, 0x04, 0x9C, 0x2E, 0x76, 0x2D, 0xB9, 0xD3,
+	0xFC, 0x69, 0x31, 0x6D, 0x73, 0x91, 0x0F, 0x8A, 0x77, 0xA9, 0x13, 0xDF,
+	    0xCC, 0xD1, 0x24, 0xCF, 0xCC, 0xA8, 0x0A, 0x6D,
+	0x32, 0x90, 0x38, 0x58, 0x57, 0xC2, 0x85, 0xD3, 0x55, 0x0D, 0x44, 0x3D,
+	    0xCE, 0x46, 0x1A, 0x52, 0xF7, 0xCE, 0xDA, 0xA6,
+	0x1A, 0x70, 0x4C, 0xDE, 0x38, 0x63, 0xC0, 0x7D, 0xFD, 0x3D, 0x12, 0x42,
+	    0xEF, 0x2C, 0x83, 0xB5, 0xE0, 0xC3, 0x42, 0x85,
+	0x87, 0x2E, 0x43, 0x39, 0x95, 0xA4, 0xA1, 0x01, 0x7F, 0x25, 0x4F, 0xCA,
+	    0x4B, 0xCC, 0xD7, 0x09, 0x39, 0xAB, 0x8D, 0x52,
+	0x3F, 0xB1, 0xCF, 0xA8, 0x03, 0x22, 0xD5, 0xEE, 0x41, 0x72, 0xDB, 0x68,
+	    0xA9, 0xAB, 0xB3, 0x9B, 0x6A, 0x4B, 0x1E, 0x79,
+	0x22, 0x73, 0x64, 0x9E, 0xE0, 0x4D, 0x98, 0x3D, 0x67, 0x02, 0xA2, 0xC4,
+	    0xCB, 0x2D, 0x75, 0x80, 0xC0, 0x9A, 0xBA, 0xAA,
+	0x33, 0x21, 0x38, 0xF2, 0x61, 0x96, 0xE2, 0x54, 0x25, 0x74, 0x08, 0xA3,
+	    0xAE, 0x10, 0xDD, 0x03, 0xEC, 0xF7, 0x6C, 0xB5,
+	0x01, 0x54, 0x61, 0x49, 0x1D, 0x23, 0xAA, 0x7B, 0xC5, 0xDE, 0x0E, 0xF5,
+	    0x4A, 0x1E, 0xBA, 0x13, 0xB9, 0x73, 0xAF, 0x8F,
+	0x1E, 0xB7, 0x3E, 0x3D, 0x81, 0x39, 0x84, 0x70, 0x71, 0xB9, 0x12, 0x52,
+	    0x8D, 0x57, 0x8C, 0x56, 0xA8, 0x41, 0x64, 0xD3,
+	0x03, 0x18, 0x8C, 0x60, 0x7C, 0xB8, 0x02, 0x57, 0x8E, 0x56, 0x38, 0x05,
+	    0x1D, 0x80, 0x31, 0x84, 0x6C, 0xDF, 0x02, 0x37,
+	0x36, 0xA9, 0x4B, 0x52, 0x8E, 0xB5, 0x55, 0x1D, 0x43, 0x9A, 0x13, 0x77,
+	    0x4C, 0xF4, 0xF7, 0xD5, 0x25, 0xBF, 0x2B, 0x57,
+	0x0C, 0x94, 0x61, 0x73, 0x8A, 0x11, 0x8A, 0x0F, 0xD3, 0x31, 0xF6, 0x7F,
+	    0x9F, 0x28, 0xF6, 0x57, 0x4F, 0xDC, 0x8C, 0x1E,
+	0xD2, 0xBA, 0x38, 0x6B, 0xC6, 0x32, 0x0E, 0xEC, 0x5F, 0xDE, 0xFE, 0x57,
+	    0x44, 0xC2, 0x65, 0xBE, 0x85, 0xDA, 0x79, 0x6B,
+	0xE4, 0x67, 0x95, 0xBF, 0x94, 0x15, 0xB3, 0x2F, 0x93, 0x73, 0xB4, 0xA5,
+	    0x5D, 0x05, 0xEF, 0x72, 0xF8, 0x36, 0xD1, 0x98,
+	0x54, 0xFF, 0xAE, 0xDD, 0xAD, 0x94, 0x7F, 0x3A, 0x58, 0x06, 0x38, 0x7E,
+	    0xCE, 0x37, 0xE2, 0xEA, 0xB1, 0xFD, 0x71, 0xE8,
+	0xC6, 0x9E, 0x4F, 0xFD, 0x53, 0xF3, 0x2C, 0xC9, 0x05, 0x92, 0x56, 0x21,
+	    0x0C, 0x7F, 0xCA, 0x98, 0x94, 0x40, 0xC0, 0xC2,
+	0x15, 0xF2, 0xB1, 0x89, 0x47, 0xF7, 0x4B, 0xEB, 0x8D, 0x1C, 0xF8, 0x73,
+	    0x4F, 0x41, 0xC5, 0xDE, 0x82, 0x01, 0x5D, 0x5F,
+	0xF2, 0x83, 0x57, 0xC0, 0x1C, 0x3A, 0xD3, 0x7E, 0x18, 0x62, 0x04, 0x80,
+	    0x97, 0xF2, 0xFF, 0x7E, 0x2E, 0xDF, 0xA9, 0xFB,
+	0xF1, 0x83, 0xCE, 0xA9, 0x64, 0xDC, 0x42, 0x1B, 0x3E, 0x22, 0xB3, 0xA0,
+	    0xCD, 0xDE, 0xEE, 0xB5, 0xE4, 0x87, 0x9B, 0xD8,
+	0x6B, 0x0C, 0x67, 0xF6, 0xF0, 0xBE, 0xBE, 0x31, 0x01, 0xFD, 0xD3, 0xFB,
+	    0x1D, 0xDF, 0xAE, 0x7B, 0x39, 0x4B, 0x12, 0x28,
+	0x53, 0x6F, 0xB1, 0xEA, 0x34, 0xB7, 0xD9, 0x55, 0x97, 0x8E, 0x67, 0x99,
+	    0xD1, 0x0E, 0x59, 0xA4, 0x19, 0x22, 0x7B, 0xDE,
+	0xDB, 0xF9, 0x2C, 0xD6, 0x12, 0x2C, 0x2E, 0x67, 0xFF, 0x4B, 0x10, 0xB8,
+	    0x0B, 0xC9, 0x4B, 0x2A, 0xA0, 0x60, 0x5F, 0xAB,
+	0x70, 0xDA, 0x40, 0x74, 0xEB, 0x49, 0xD4, 0x9E, 0xA6, 0x2A, 0x6E, 0xBB,
+	    0x84, 0x2F, 0x44, 0xDC, 0xF1, 0x39, 0xD0, 0x0F,
+	0xA3, 0x96, 0xC4, 0x54, 0x73, 0xE7, 0x76, 0xB3, 0x0C, 0xA1, 0x1A, 0xAB,
+	    0x13, 0xEA, 0x68, 0x48, 0x27, 0xB6, 0xD8, 0x0A,
+	0x74, 0xC7, 0x7A, 0x3A, 0x63, 0x07, 0x54, 0x3C, 0x89, 0xD7, 0x6C, 0x81,
+	    0xCA, 0x4C, 0x35, 0x15, 0x80, 0xB9, 0x74, 0x1E,
+	0xE0, 0x06, 0x66, 0x6F, 0x73, 0xDF, 0x8D, 0x5E, 0xA2, 0x5A, 0xCA, 0xCF,
+	    0x73, 0xC6, 0x83, 0x3B, 0xE8, 0x84, 0xB9, 0xBC,
+	0xFE, 0xF5, 0xDE, 0x2B, 0x98, 0x51, 0xA9, 0xDE, 0xA4, 0xC5, 0x59, 0x86,
+	    0x71, 0x4F, 0xB5, 0xAD, 0x4F, 0x23, 0x1A, 0x5F,
+	0x22, 0x78, 0x4B, 0x4E, 0xB0, 0xCA, 0x12, 0x3B, 0x76, 0x85, 0x02, 0x1D,
+	    0xB1, 0x21, 0x53, 0x5E, 0x68, 0x59, 0xC7, 0x1F,
+	0x62, 0x00, 0x6A, 0xD2, 0x0A, 0x1D, 0x82, 0xD0, 0x1D, 0x85, 0xE8, 0xDC,
+	    0x6F, 0xC0, 0xF6, 0x5A, 0x7F, 0xC2, 0x63, 0xA3,
+	0x7B, 0x87, 0x3C, 0x36, 0x17, 0xD8, 0xC0, 0x5F, 0xE0, 0x5E, 0xB1, 0x7C,
+	    0xD9, 0x2E, 0x68, 0x64, 0x53, 0x0C, 0xB7, 0x3F,
+	0x64, 0x43, 0x3B, 0xD3, 0xD5, 0x40, 0x7F, 0x1F, 0x28, 0x0A, 0xFB, 0x08,
+	    0x85, 0x83, 0xD2, 0x17, 0x1A, 0x9D, 0x2C, 0x25,
+	0x6E, 0x32, 0x3B, 0xCA, 0xAD, 0x32, 0xF1, 0x7C, 0x21, 0x7D, 0x0E, 0x87,
+	    0x13, 0xB2, 0x58, 0xCA, 0x09, 0x5C, 0xB1, 0xDF,
+	0xFE, 0xF7, 0xFE, 0x69, 0xEA, 0x5F, 0xD7, 0x16, 0x92, 0x38, 0x5F, 0xA0,
+	    0x99, 0x5B, 0x8E, 0x88, 0x69, 0x8F, 0xB2, 0x1E,
+	0x5E, 0xCE, 0xAB, 0x34, 0xDB, 0x5F, 0x0F, 0xF0, 0x52, 0x1E, 0x19, 0xF5,
+	    0xED, 0xFE, 0x51, 0x33, 0xA6, 0x99, 0x9E, 0x44,
+	0x91, 0x76, 0x06, 0x52, 0x64, 0x9C, 0x6E, 0x04, 0x6E, 0x6F, 0x74, 0x2F,
+	    0x54, 0x15, 0x60, 0x46, 0x63, 0x3F, 0x9C, 0x4D,
+	0xFD, 0x88, 0x74, 0xE1, 0xF6, 0x97, 0x17, 0x77, 0x49, 0x72, 0xCB, 0x26,
+	    0x13, 0x49, 0x20, 0x65, 0xA7, 0xB7, 0x30, 0x83,
+	0xD1, 0xB6, 0x8D, 0x54, 0x06, 0xEA, 0x4F, 0x57, 0x01, 0x45, 0x75, 0x93,
+	    0x1E, 0x5B, 0x75, 0xA4, 0x12, 0x6C, 0xE7, 0x76,
+	0xD5, 0xB9, 0xB8, 0x3D, 0xF2, 0x1B, 0x68, 0x18, 0x78, 0x15, 0x6B, 0x28,
+	    0x51, 0xE8, 0xF5, 0x68, 0xEA, 0xE8, 0xE8, 0x3C,
+	0xD2, 0xBA, 0x3E, 0xA5, 0x98, 0xF8, 0xB2, 0x54, 0xB1, 0xFA, 0x3F, 0x76,
+	    0x5D, 0x79, 0xF9, 0x3C, 0x51, 0xB9, 0x69, 0x18,
+	0xDB, 0x00, 0xAD, 0x4F, 0x54, 0x75, 0x71, 0x9F, 0xCA, 0xED, 0x23, 0xEE,
+	    0xD7, 0x9D, 0x27, 0x89, 0x87, 0x44, 0x3F, 0xAE,
+	0xD7, 0x1F, 0x1F, 0xD8, 0xFF, 0x59, 0x9C, 0xCD, 0x99, 0x91, 0x6E, 0x9B,
+	    0x52, 0xD0, 0xF1, 0x1A, 0x93, 0x06, 0x27, 0x32,
+	0xD0, 0x81, 0x0E, 0x88, 0x5D, 0x88, 0x50, 0x0B, 0xEF, 0xD0, 0xFA, 0x78,
+	    0x64, 0x58, 0xF9, 0x4C, 0x7F, 0x7C, 0xD2, 0x49,
+	0xFF, 0xD5, 0x83, 0x39, 0x4B, 0xDF, 0xCF, 0xF1, 0xFC, 0x65, 0xF4, 0x83,
+	    0x5A, 0x1C, 0x6F, 0x27, 0xBD, 0xE5, 0x0D, 0x4B,
+	0xED, 0x97, 0x1F, 0xB4, 0x38, 0x3D, 0x5B, 0x6C, 0x89, 0xE2, 0x22, 0xF6,
+	    0x09, 0x31, 0x50, 0x20, 0x17, 0xCD, 0x88, 0xD9,
+	0xBD, 0x69, 0x9D, 0x77, 0x03, 0x78, 0x96, 0xA7, 0xDF, 0x42, 0x66, 0xD0,
+	    0x65, 0x44, 0x90, 0xC5, 0x37, 0x3C, 0x3B, 0x02,
+	0x6F, 0x21, 0xD8, 0x75, 0x33, 0xCE, 0x4C, 0x71, 0x87, 0x32, 0x65, 0xD9,
+	    0x29, 0x63, 0xCF, 0x1F, 0x05, 0x97, 0x97, 0xA7,
+	0x5F, 0x60, 0x1F, 0xD1, 0xE7, 0x6C, 0xEB, 0x20, 0x3E, 0x80, 0x39, 0x74,
+	    0xBF, 0xCB, 0x87, 0x01, 0x18, 0x7B, 0x0E, 0x4B,
+	0x25, 0xBC, 0xC8, 0x9D, 0x50, 0x5F, 0x56, 0xF3, 0x66, 0x81, 0xB1, 0xE2,
+	    0xB2, 0x1A, 0x20, 0x7F, 0x74, 0x06, 0x42, 0x85,
+	0x48, 0xE3, 0xCD, 0x38, 0x4C, 0xC5, 0x4D, 0x38, 0x40, 0x59, 0x67, 0x4A,
+	    0x75, 0x8B, 0xE8, 0x43, 0xE5, 0x32, 0x10, 0x29,
+	0xE6, 0x83, 0x29, 0xAA, 0x7F, 0xE5, 0xC1, 0x8C, 0xC1, 0x6F, 0x0F, 0xB1,
+	    0x74, 0x3C, 0x72, 0x4E, 0x51, 0x25, 0xAA, 0x16,
+	0xF5, 0x4B, 0x66, 0x41, 0x0F, 0x38, 0xE8, 0x6C, 0x20, 0x47, 0x18, 0xE1,
+	    0xFD, 0x86, 0x94, 0xAA, 0x7F, 0x56, 0x1C, 0xD8,
+	0x6B, 0x66, 0x0D, 0x38, 0xB6, 0x4A, 0xBF, 0xFA, 0x2F, 0xCA, 0xB1, 0xF0,
+	    0x77, 0x09, 0x6D, 0xC9, 0xEC, 0x4F, 0x13, 0xDF,
+	0x54, 0x39, 0x72, 0x10, 0x28, 0x3A, 0xD5, 0xAF, 0x10, 0x06, 0xEF, 0xB9,
+	    0x4D, 0x73, 0x1C, 0x8B, 0x3C, 0xB4, 0x03, 0x8A,
+	0x1E, 0x18, 0xEC, 0xAD, 0xE3, 0xA3, 0x0E, 0x15, 0xED, 0xE1, 0x59, 0x93,
+	    0x43, 0x97, 0x58, 0x31, 0xA8, 0x8C, 0x06, 0xCC,
+	0x1D, 0xA5, 0xAE, 0xAA, 0xEE, 0x4C, 0x21, 0x8D, 0xB6, 0x97, 0x37, 0x50,
+	    0xA8, 0x95, 0x23, 0x1E, 0x35, 0xA3, 0xD4, 0x18,
+	0xF6, 0x42, 0xF5, 0x1D, 0x25, 0xAC, 0x63, 0x7B, 0xEC, 0x22, 0x69, 0xDB,
+	    0xD6, 0x80, 0x45, 0x88, 0x4B, 0x42, 0xA3, 0xFF,
+	0xEC, 0x5B, 0xF7, 0x71, 0xA8, 0xFC, 0xF0, 0x75, 0x5A, 0x1D, 0x8C, 0x51,
+	    0x06, 0xC0, 0xEA, 0x44, 0x70, 0xAD, 0x4F, 0x7C,
+	0xCC, 0x38, 0x7E, 0xA8, 0x57, 0x44, 0x75, 0xD4, 0x8E, 0x12, 0x47, 0x91,
+	    0xD4, 0x0E, 0x98, 0x18, 0x1B, 0xCF, 0x77, 0x14,
+	0x96, 0x1D, 0x8D, 0x50, 0x8E, 0xC9, 0x75, 0x33, 0x65, 0xFF, 0x3B, 0xF1,
+	    0x5A, 0x3E, 0xFB, 0x13, 0xE1, 0xC3, 0x3C, 0xD5,
+	0x0E, 0x30, 0x9B, 0x03, 0x71, 0x57, 0xDA, 0xD2, 0xC7, 0xEB, 0xEB, 0xB5,
+	    0x0E, 0x15, 0x01, 0x66, 0x23, 0x17, 0x36, 0x34,
+	0xF6, 0x84, 0x0E, 0x2D, 0xD6, 0x1C, 0x57, 0x30, 0x27, 0x48, 0x44, 0xCF,
+	    0x98, 0xDB, 0x23, 0x91, 0x00, 0x03, 0x45, 0x47,
+	0x29, 0x2B, 0xDD, 0xF7, 0xD8, 0xA9, 0xB5, 0x5E, 0x78, 0xD8, 0x28, 0xF6,
+	    0x17, 0x49, 0x4D, 0x41, 0x27, 0x9F, 0x15, 0xA4,
+	0x8F, 0xF5, 0x45, 0x4F, 0x6A, 0xB5, 0x3D, 0x0B, 0x1C, 0xB5, 0x3C, 0x2F,
+	    0xDB, 0x65, 0x15, 0x26, 0xC0, 0x8B, 0x9A, 0xD9,
+	0x02, 0x7E, 0xE0, 0xA9, 0x17, 0xF7, 0x7C, 0x8D, 0xDE, 0x6C, 0x57, 0xE0,
+	    0xBC, 0xB4, 0xEC, 0x29, 0x4B, 0x76, 0x97, 0xDC,
+	0x8E, 0x9C, 0x35, 0xC9, 0x57, 0x47, 0xDC, 0x74, 0xBA, 0x38, 0xE3, 0x58,
+	    0x82, 0x77, 0x37, 0xC1, 0xFA, 0x38, 0x8F, 0xA5,
+	0x21, 0xD9, 0x10, 0xDD, 0x1C, 0x6E, 0xED, 0xC8, 0x87, 0x5A, 0x87, 0xF8,
+	    0x23, 0x04, 0x64, 0x27, 0xD1, 0x98, 0x6C, 0x8C,
+	0xC9, 0xAC, 0x8D, 0x95, 0x60, 0x23, 0x62, 0x99, 0x78, 0xEE, 0x50, 0x23,
+	    0x1B, 0x32, 0xD9, 0xD8, 0xCC, 0xFF, 0x1C, 0xF2,
+	0x9A, 0x5B, 0x9E, 0x49, 0xF8, 0xF0, 0xE3, 0x84, 0x57, 0xE2, 0x5F, 0x4B,
+	    0xFB, 0x5F, 0x28, 0x6B, 0x61, 0x23, 0xF7, 0x6B,
+	0xC1, 0xDB, 0xCF, 0xA9, 0xC5, 0x04, 0xE1, 0x3C, 0x1E, 0xC0, 0x7F, 0xBB,
+	    0xE5, 0x62, 0xA6, 0x70, 0x58, 0xBE, 0x3A, 0xF3,
+	0x70, 0xAF, 0xCA, 0x19, 0x34, 0xAD, 0x2E, 0x18, 0xCD, 0xC6, 0x50, 0xB0,
+	    0xC1, 0xBD, 0x9F, 0x92, 0x04, 0x69, 0x48, 0x40,
+	0x2B, 0x94, 0x8B, 0xA2, 0x51, 0x49, 0xBE, 0x08, 0xD5, 0xC5, 0x16, 0xF2,
+	    0xF4, 0xAD, 0xFF, 0x2C, 0x79, 0x13, 0x10, 0x61,
+	0xDC, 0xEF, 0xE9, 0x02, 0x2D, 0x6D, 0x31, 0xC1, 0x76, 0x0C, 0x29, 0xEF,
+	    0x78, 0x12, 0x1F, 0xC0, 0xF5, 0x03, 0x8E, 0x32,
+	0xBA, 0x6C, 0x46, 0x80, 0x06, 0x25, 0x55, 0xD4, 0xB1, 0x65, 0x5A, 0x40,
+	    0xE1, 0x49, 0x73, 0xFA, 0x8E, 0x92, 0xEE, 0x22,
+	0xA0, 0x03, 0x64, 0x16, 0x90, 0xF1, 0x50, 0xF4, 0xE2, 0xCD, 0x58, 0x6A,
+	    0xB7, 0x91, 0xC3, 0x65, 0x00, 0x4E, 0x2D, 0xC5,
+	0x6E, 0x06, 0x5B, 0x21, 0x61, 0x40, 0xAF, 0xFE, 0xB9, 0xF0, 0x45, 0x2F,
+	    0x22, 0x8D, 0x18, 0x4A, 0xAD, 0x93, 0xD9, 0x93,
+	0x62, 0xCF, 0x6F, 0x86, 0x3B, 0xCC, 0x62, 0x49, 0xBF, 0x05, 0x42, 0x58,
+	    0x2C, 0xDD, 0x32, 0xA5, 0xA1, 0xD9, 0x12, 0x5F,
+	0x6C, 0x2A, 0x06, 0xF3, 0xA8, 0x81, 0x19, 0xEC, 0x04, 0x88, 0x1C, 0x4A,
+	    0xA2, 0x18, 0x7C, 0x4F, 0x6D, 0x62, 0x49, 0xF2,
+	0x2B, 0x0C, 0x23, 0xFE, 0xE0, 0xDE, 0xBF, 0xBB, 0xD8, 0x42, 0x51, 0x67,
+	    0xDE, 0xA2, 0x8B, 0xFB, 0x0B, 0x23, 0x9E, 0xF7,
+	0x3C, 0x20, 0x3B, 0x24, 0x20, 0x9A, 0xF2, 0x4E, 0xE1, 0xCA, 0x3D, 0xAA,
+	    0x88, 0x24, 0x62, 0x56, 0x96, 0xA1, 0x50, 0x8A,
+	0xC8, 0x04, 0xE0, 0x68, 0xDF, 0x7A, 0x32, 0xDA, 0x02, 0xC2, 0x94, 0xCF,
+	    0x0B, 0x82, 0x3A, 0x38, 0xE6, 0x42, 0x84, 0x73,
+	0x57, 0x23, 0xBB, 0x2B, 0xC9, 0xB1, 0xBD, 0xDB, 0x71, 0xC8, 0x41, 0x99,
+	    0xC2, 0x41, 0x72, 0x77, 0x46, 0xDA, 0x73, 0x89,
+	0x70, 0x00, 0xA9, 0x43, 0x4D, 0xDB, 0x3B, 0x39, 0x67, 0xC2, 0xBA, 0xF9,
+	    0xAC, 0xAE, 0x13, 0x53, 0x18, 0x6D, 0xDE, 0x7B,
+	0x93, 0x55, 0x6A, 0x8D, 0xE0, 0x90, 0xED, 0xDF, 0xD7, 0xDD, 0x46, 0x6B,
+	    0x82, 0x1C, 0xB7, 0x64, 0xEB, 0x90, 0x89, 0x4F,
+	0x88, 0x00, 0x5C, 0xE0, 0x38, 0x33, 0x65, 0xC0, 0x1B, 0x1F, 0xFD, 0xF6,
+	    0x84, 0x39, 0x4B, 0x8D, 0x1F, 0xF9, 0x80, 0x21,
+	0xB5, 0xCB, 0x07, 0x90, 0x02, 0x15, 0x98, 0x7F, 0x50, 0x7C, 0x07, 0xB5,
+	    0xC0, 0xD3, 0x17, 0x64, 0x18, 0x02, 0x7C, 0x10,
+	0xD5, 0x1B, 0x1F, 0xF0, 0xFA, 0x67, 0x50, 0x02, 0xE0, 0x1C, 0xB3, 0xE0,
+	    0x19, 0xE2, 0x2C, 0x91, 0xD8, 0x18, 0xB2, 0x47,
+	0x58, 0xB3, 0x24, 0x72, 0x66, 0x9F, 0x6A, 0x05, 0x9B, 0x35, 0x7D, 0x11,
+	    0x59, 0x19, 0x27, 0xD6, 0x8C, 0xD0, 0x75, 0x83,
+	0xA3, 0x52, 0x55, 0xFB, 0x16, 0x82, 0x07, 0x2F, 0x00, 0x1A, 0x4D, 0xEA,
+	    0x37, 0xE2, 0x07, 0xF4, 0x40, 0x51, 0x83, 0xC7,
+	0xF7, 0x3B, 0x0A, 0x73, 0x89, 0x92, 0x92, 0x62, 0xD1, 0x09, 0x28, 0x84,
+	    0x4B, 0xB8, 0xEE, 0xDF, 0x08, 0x3A, 0x0A, 0x7A,
+	0x42, 0x28, 0xB0, 0xB5, 0x3F, 0xF1, 0x14, 0xBC, 0xCA, 0xF4, 0xE0, 0xBA,
+	    0x98, 0xFA, 0x78, 0x6B, 0x09, 0x92, 0x47, 0xD9,
+	0xD7, 0xC5, 0x77, 0xE8, 0x53, 0x57, 0x1D, 0xE1, 0x98, 0x5C, 0x8E, 0x1D,
+	    0xA8, 0xB4, 0xA7, 0x6E, 0x85, 0x2B, 0x8A, 0x4B,
+	0xC8, 0xBB, 0x69, 0x39, 0xBC, 0xD3, 0x0C, 0x33, 0x89, 0x1A, 0x62, 0xD2,
+	    0xEC, 0xC8, 0xDE, 0x24, 0xC9, 0x5A, 0xB7, 0xE2,
+	0xAA, 0x08, 0xCE, 0x3A, 0xA9, 0x15, 0x90, 0x46, 0x3F, 0xE9, 0x26, 0xDF,
+	    0x08, 0xA2, 0x36, 0x76, 0x7D, 0xA6, 0x4B, 0xCF,
+	0x0B, 0x96, 0x20, 0x3C, 0x60, 0x7E, 0xDF, 0x89, 0x89, 0xA5, 0xF0, 0x1C,
+	    0x66, 0xBC, 0x9B, 0xAB, 0x08, 0x19, 0x7D, 0xC2,
+	0x57, 0x94, 0x27, 0x7B, 0xC9, 0x2A, 0x4D, 0x8E, 0x85, 0xDE, 0xDB, 0x60,
+	    0x47, 0x3F, 0xF4, 0x1D, 0x90, 0x34, 0x9C, 0xB0,
+	0x54, 0xC8, 0x88, 0x16, 0xF9, 0x4F, 0x10, 0x42, 0x01, 0x8E, 0x90, 0xE4,
+	    0x36, 0xE1, 0x18, 0x37, 0x2E, 0x90, 0x78, 0x62,
+	0x1C, 0x60, 0x59, 0x81, 0x8D, 0x3D, 0x05, 0x65, 0x63, 0xC7, 0x37, 0xD2,
+	    0xF0, 0xE2, 0x11, 0x55, 0xB6, 0x05, 0x77, 0x3A,
+	0x91, 0xC1, 0x12, 0xE5, 0xB6, 0xE3, 0xC6, 0x40, 0xBD, 0xAF, 0x86, 0xC4,
+	    0x51, 0x6E, 0x00, 0x03, 0xF1, 0x89, 0x07, 0xB5,
+	0xCC, 0x0F, 0x08, 0xE0, 0x47, 0xA3, 0xD6, 0xD9, 0x28, 0x40, 0x64, 0x29,
+	    0xA6, 0x0F, 0x5B, 0x51, 0xC3, 0x60, 0x40, 0xA2,
+	0x1B, 0x4D, 0xAF, 0x65, 0xA5, 0x76, 0x2B, 0xB8, 0x25, 0x80, 0x82, 0x43,
+	    0x6A, 0xE2, 0x09, 0xE1, 0xC7, 0x81, 0x02, 0xDB,
+	0x1E, 0x51, 0x92, 0xB1, 0x26, 0x0F, 0x4E, 0x60, 0xFC, 0x02, 0x69, 0x91,
+	    0x45, 0xCF, 0xDF, 0xDB, 0x11, 0x43, 0x2A, 0xF9,
+	0x2C, 0x85, 0xB6, 0xE0, 0x77, 0xF9, 0x50, 0x22, 0x4D, 0xCA, 0xE0, 0x99,
+	    0x5A, 0x20, 0x00, 0x9F, 0x4E, 0x69, 0x0A, 0x04,
+	0x91, 0x04, 0x32, 0x2B, 0x26, 0xB8, 0xAF, 0xD4, 0xF8, 0x56, 0xA3, 0x1A,
+	    0xFC, 0x77, 0xE3, 0x9E, 0xA8, 0x1E, 0x0D, 0x16,
+	0x0E, 0xDA, 0xD5, 0xDF, 0xC1, 0x4B, 0x3B, 0x79, 0x89, 0x2B, 0x3A, 0x9B,
+	    0xD8, 0x8A, 0xBF, 0x39, 0xD1, 0x46, 0xE1, 0xA4,
+	0xB5, 0xDA, 0xE2, 0xA8, 0x8C, 0xA4, 0x62, 0xBF, 0xFE, 0xEC, 0x02, 0x10,
+	    0xED, 0xA9, 0x27, 0xF9, 0xB5, 0x4A, 0x12, 0x38,
+	0x4C, 0x32, 0x4F, 0x45, 0x74, 0xD9, 0xBC, 0x05, 0xEC, 0xCB, 0x5A, 0x40,
+	    0xD3, 0x39, 0x1F, 0x29, 0xCD, 0x51, 0x4B, 0xC5,
+	0x0A, 0x3A, 0x4C, 0x89, 0x4C, 0xC6, 0xAD, 0xFD, 0xDA, 0x1B, 0x13, 0xD9,
+	    0x86, 0x20, 0xAF, 0x99, 0x0D, 0xED, 0xF3, 0x78,
+	0x6E, 0x47, 0x18, 0x60, 0x01, 0x44, 0x74, 0xE0, 0x20, 0x30, 0x1C, 0x75,
+	    0x44, 0x04, 0x54, 0xE3, 0x9F, 0xDD, 0xA6, 0x29,
+	0x9F, 0xB4, 0x66, 0x87, 0x07, 0x9C, 0x55, 0xB1, 0x94, 0x3E, 0xAD, 0x00,
+	    0x9A, 0xB1, 0x36, 0x25, 0xF5, 0x21, 0xB6, 0xFC,
+	0x65, 0xF0, 0x05, 0x9D, 0x38, 0xBF, 0x3F, 0xA7, 0x47, 0x7F, 0x8F, 0x17,
+	    0x1A, 0xB0, 0xAD, 0x82, 0xD9, 0x3D, 0xF5, 0x93,
+	0x00, 0x3C, 0xE2, 0x4C, 0xC1, 0x7E, 0x7D, 0x7E, 0xFC, 0x46, 0x68, 0xC4,
+	    0x87, 0x1E, 0xD2, 0xC2, 0x5D, 0x31, 0x4C, 0x32,
+	0x98, 0xDB, 0x03, 0x15, 0x08, 0x59, 0xF5, 0x22, 0x2F, 0x9A, 0xCF, 0xD9,
+	    0xEF, 0x1E, 0x76, 0xF6, 0xC4, 0xD8, 0x2F, 0x85,
+	0x0D, 0x56, 0x1A, 0x21, 0x24, 0xDE, 0x65, 0x81, 0x24, 0xE2, 0x15, 0xA7,
+	    0xE9, 0xDB, 0x26, 0x56, 0x00, 0x59, 0x0D, 0x93,
+	0xA9, 0x9A, 0x48, 0x42, 0x30, 0xA1, 0x77, 0xF2, 0x44, 0xD1, 0x8A, 0x04,
+	    0x8D, 0x5A, 0x33, 0xE5, 0xAE, 0xB0, 0xFE, 0x62,
+	0x57, 0xE9, 0xA3, 0x9B, 0x58, 0x27, 0x25, 0x94, 0x04, 0x0D, 0x56, 0x18,
+	    0x24, 0x26, 0x0E, 0x84, 0xB1, 0x12, 0x61, 0x02,
+	0xEF, 0x91, 0xF3, 0xFF, 0x35, 0xC8, 0x5A, 0xE9, 0xEF, 0x45, 0xE7, 0x1E,
+	    0x88, 0x0E, 0xA7, 0x56, 0x8D, 0x98, 0xA4, 0x91,
+	0xC0, 0xB8, 0x17, 0x4B, 0x5A, 0x94, 0xD7, 0x9B, 0x54, 0xEA, 0xF9, 0xD9,
+	    0x12, 0x57, 0x81, 0x96, 0x70, 0x7D, 0x6C, 0xCE,
+	0x8D, 0x91, 0x26, 0x32, 0x5A, 0x13, 0xFE, 0x83, 0x0D, 0xFC, 0xA5, 0x5F,
+	    0x8C, 0x53, 0x66, 0x5E, 0x8E, 0x15, 0x88, 0xD6,
+	0xD4, 0x3B, 0x06, 0x78, 0x66, 0x3B, 0x2D, 0xC5, 0x05, 0x62, 0x6D, 0xDB,
+	    0x0D, 0x98, 0x05, 0x3C, 0x70, 0x15, 0x0F, 0x69,
+	0xEB, 0x47, 0xA4, 0xD0, 0x80, 0x2B, 0x6B, 0x39, 0x03, 0x92, 0x58, 0xD9,
+	    0x4B, 0xDB, 0x7D, 0x19, 0x6D, 0x97, 0x97, 0x3D,
+	0x79, 0x0A, 0x90, 0xFD, 0x00, 0xDB, 0xD8, 0xBC, 0x23, 0x55, 0xE6, 0xDD,
+	    0x48, 0x02, 0x8C, 0x6C, 0xF1, 0x9F, 0x68, 0x50,
+	0xAF, 0x8A, 0xF7, 0x69, 0x32, 0x62, 0x20, 0x42, 0x72, 0x13, 0x58, 0xC8,
+	    0xBC, 0x7A, 0x03, 0x85, 0xF3, 0x88, 0x39, 0xFA,
+	0x82, 0x6F, 0x8E, 0xA9, 0xC6, 0x39, 0x89, 0xB4, 0x28, 0xD3, 0x0D, 0xF3,
+	    0x03, 0x2B, 0xE9, 0x17, 0x96, 0x2E, 0xE1, 0xB3,
+	0xE3, 0x10, 0x2D, 0x53, 0x26, 0x9E, 0x7A, 0xF0, 0xFD, 0xDB, 0x20, 0x32,
+	    0x9F, 0xA2, 0xC0, 0x90, 0xF8, 0xE5, 0xF0, 0xD0,
+	0x61, 0x02, 0xF3, 0xF5, 0xF4, 0xA8, 0x9C, 0x4C, 0x33, 0xA6, 0x0A, 0xC7,
+	    0x67, 0xCE, 0xA7, 0x33, 0xEE, 0xD3, 0xFE, 0x70,
+	0x23, 0xF9, 0x45, 0x85, 0xCE, 0x25, 0x44, 0x92, 0x46, 0xCB, 0x6B, 0x9A,
+	    0x5F, 0x04, 0x5E, 0x6C, 0x68, 0x43, 0xCC, 0x75,
+	0xD7, 0xE7, 0xAA, 0x40, 0xFB, 0xE8, 0x83, 0x77, 0x60, 0x3E, 0xB9, 0x6A,
+	    0x4B, 0xB7, 0xC8, 0x11, 0x73, 0x27, 0x48, 0x2C,
+	0xEB, 0x2D, 0x7E, 0xB2, 0x5B, 0x88, 0x32, 0x48, 0x0D, 0x06, 0x4A, 0x7D,
+	    0x1A, 0x24, 0x4B, 0x5A, 0x0A, 0xB9, 0x0D, 0x3E,
+	0x41, 0xC9, 0x7B, 0x8B, 0x81, 0xB7, 0x03, 0x3F, 0x67, 0x97, 0x29, 0xCB,
+	    0x4A, 0x49, 0xAD, 0x11, 0x98, 0xC5, 0xD4, 0xBD,
+	0x8F, 0xB0, 0xF0, 0x3A, 0x38, 0x47, 0x11, 0x59, 0x6A, 0x4A, 0x08, 0x4E,
+	    0xAD, 0x07, 0x7C, 0x70, 0x7C, 0xA3, 0x92, 0x7D,
+	0x16, 0x6E, 0xF2, 0x1A, 0x28, 0xAB, 0xB3, 0xAC, 0x32, 0x91, 0x72, 0xA7,
+	    0xC3, 0xBC, 0x15, 0xCE, 0x13, 0x80, 0xCF, 0x9A,
+	0xE7, 0xE0, 0x25, 0x3B, 0x68, 0x01, 0xE7, 0x2B, 0x7D, 0x6B, 0x8E, 0x2F,
+	    0x15, 0x83, 0xC3, 0x9A, 0x46, 0xE3, 0x17, 0xE8,
+	0x99, 0x9D, 0xEB, 0x4A, 0xFB, 0x6B, 0x10, 0xCF, 0x9B, 0x25, 0x48, 0x9B,
+	    0xEF, 0xB0, 0x63, 0xE2, 0xB8, 0x6B, 0x60, 0x82,
+	0xF7, 0x16, 0x3C, 0x64, 0x3C, 0x33, 0x74, 0x16, 0x71, 0x5D, 0xD5, 0x42,
+	    0x54, 0x8D, 0x73, 0x72, 0xA3, 0x15, 0x08, 0x10,
+	0x0E, 0xCE, 0xDC, 0xDD, 0xF3, 0x13, 0xA2, 0x89, 0xD6, 0x6A, 0x09, 0xFA,
+	    0x01, 0x98, 0xD4, 0x91, 0x90, 0x21, 0xF9, 0x3E,
+	0xE1, 0x22, 0xCD, 0xB4, 0xC3, 0xD5, 0x07, 0xF3, 0xE0, 0x53, 0xB3, 0xAC,
+	    0x53, 0xCC, 0x04, 0xB1, 0x00, 0x55, 0xEB, 0xD3,
+	0x98, 0x82, 0xE4, 0xB2, 0x40, 0x93, 0x79, 0x5B, 0x87, 0xBD, 0x42, 0x82,
+	    0x02, 0x7C, 0xB0, 0x92, 0x53, 0xF4, 0x34, 0xAF,
+	0x8F, 0x1A, 0x24, 0x60, 0xB3, 0xD5, 0xF0, 0xC1, 0x5B, 0xFA, 0x07, 0xC2,
+	    0x0C, 0x64, 0xD5, 0x32, 0x2E, 0xCB, 0xE5, 0x4F,
+	0xB3, 0xB6, 0x2C, 0x87, 0xC6, 0xDD, 0x3D, 0xD9, 0x77, 0xF5, 0x73, 0xF8,
+	    0xCB, 0x1A, 0xAD, 0xD7, 0xF2, 0x3A, 0xFD, 0x83,
+	0x81, 0xB0, 0x00, 0xF5, 0xC4, 0x17, 0x7E, 0xCE, 0x2A, 0x54, 0x87, 0xFE,
+	    0xD3, 0xC9, 0xE4, 0xE0, 0xCB, 0x1A, 0x8E, 0xA4,
+	0x99, 0x6A, 0x54, 0x67, 0x8A, 0x1F, 0x03, 0xEF, 0x41, 0xBE, 0xE0, 0x98,
+	    0x6F, 0x39, 0x66, 0x98, 0x4A, 0xFE, 0x07, 0x0B,
+	0x4A, 0x0A, 0xDE, 0x2A, 0x1F, 0x3E, 0xCC, 0xE6, 0xEE, 0xA8, 0x6F, 0xA5,
+	    0x9B, 0xBA, 0x7D, 0x91, 0x08, 0x9C, 0x74, 0x08,
+	0xD2, 0xCA, 0xDF, 0x48, 0xAD, 0x17, 0x27, 0x9D, 0x14, 0x1B, 0xD6, 0xBB,
+	    0x12, 0xBD, 0xCC, 0x8C, 0x99, 0x70, 0xC6, 0x18,
+	0xB3, 0xFD, 0xEC, 0x17, 0x7C, 0xB7, 0xEE, 0xAA, 0x49, 0xFA, 0xC6, 0x10,
+	    0x1B, 0xBE, 0x0C, 0x4F, 0x4F, 0xF2, 0xF6, 0x1E,
+	0xFA, 0x19, 0x7F, 0xF9, 0x56, 0xB1, 0x50, 0x49, 0xE7, 0xC2, 0x42, 0x1A,
+	    0x6E, 0xD3, 0x72, 0xC9, 0x7B, 0x73, 0x31, 0xDE,
+	0x8F, 0xC4, 0x02, 0x7D, 0x9D, 0x7E, 0xFB, 0x8A, 0xDF, 0x50, 0xF7, 0xFB,
+	    0x7A, 0x71, 0x73, 0x80, 0x01, 0x62, 0x47, 0xF9,
+	0xE5, 0x06, 0x30, 0x2F, 0x42, 0x1B, 0xD2, 0x36, 0x55, 0x0E, 0x78, 0x70,
+	    0x17, 0x87, 0xE7, 0xFE, 0xA9, 0xEC, 0x94, 0xA0,
+	0x51, 0xC9, 0x54, 0xA4, 0x15, 0xE9, 0x19, 0xFC, 0x09, 0xE0, 0xD9, 0xF9,
+	    0x92, 0x79, 0xA0, 0xCB, 0xD2, 0x8F, 0x8F, 0x1A,
+	0xF5, 0x42, 0x25, 0x6D, 0x24, 0x09, 0x69, 0x76, 0x8F, 0xAE, 0xC1, 0xB7,
+	    0xBA, 0xE5, 0xBC, 0x45, 0xE6, 0x64, 0xDD, 0xB3,
+	0xA5, 0xC4, 0x60, 0x25, 0xA4, 0xEA, 0x2A, 0x2F, 0x2E, 0xF5, 0x30, 0x3B,
+	    0x58, 0xEE, 0x56, 0x7B, 0xC6, 0xE6, 0x17, 0xAD,
+	0x24, 0x29, 0xA8, 0x74, 0x8F, 0xE6, 0x9A, 0x77, 0x56, 0x75, 0xE1, 0xD7,
+	    0x17, 0x79, 0xF2, 0xAF, 0x18, 0x6B, 0x08, 0x05,
+	0xE2, 0x62, 0x35, 0x20, 0x3F, 0x3D, 0x23, 0x31, 0xE7, 0xEA, 0x51, 0xB9,
+	    0x87, 0xEA, 0xDD, 0x57, 0xF4, 0x9D, 0x39, 0x2A,
+	0xB8, 0xA5, 0x5D, 0xE8, 0x8E, 0xA0, 0xD9, 0x29, 0xBD, 0xC4, 0x62, 0x2A,
+	    0x6C, 0xC9, 0x4A, 0x26, 0xB5, 0x19, 0x52, 0xE7,
+	0x2B, 0xCB, 0xAC, 0x9A, 0x22, 0x56, 0x80, 0xDA, 0x5F, 0xCF, 0x02, 0xC1,
+	    0xD2, 0x6F, 0x1C, 0x69, 0xCD, 0xCA, 0x44, 0x75,
+	0x4A, 0xA0, 0x36, 0x3A, 0xFF, 0x7E, 0x4B, 0x0B, 0xEF, 0x4D, 0x74, 0xA3,
+	    0x8B, 0x70, 0x43, 0xB7, 0xAE, 0x4E, 0xC9, 0x72,
+	0x6C, 0x34, 0xB9, 0x7F, 0x9D, 0x66, 0x1C, 0x4C, 0xEF, 0x0F, 0x1F, 0xD5,
+	    0x7D, 0xA8, 0xCA, 0x94, 0x5E, 0x81, 0x7D, 0x4D,
+	0xDE, 0x6C, 0x7F, 0x08, 0x21, 0x07, 0x8B, 0x9E, 0x09, 0x50, 0xEA, 0x89,
+	    0xC3, 0xC0, 0x56, 0x0D, 0x28, 0x6B, 0x11, 0x6F,
+	0x71, 0x23, 0x9A, 0x21, 0xFF, 0xAA, 0x8C, 0x15, 0x43, 0xAC, 0xAA, 0xEC,
+	    0xB9, 0xCE, 0x53, 0x6B, 0x82, 0x20, 0x47, 0xDA,
+	0x60, 0xC1, 0x80, 0x5C, 0x6E, 0x8E, 0xFF, 0x3F, 0x97, 0xF4, 0xDB, 0x8E,
+	    0x22, 0x98, 0xA2, 0x6E, 0xD8, 0xFD, 0xF4, 0x82,
+	0x6C, 0xB0, 0x0C, 0xB6, 0xD3, 0xEB, 0x93, 0x70, 0xA5, 0x6C, 0xB5, 0xF0,
+	    0xB8, 0x37, 0x38, 0x92, 0x75, 0xB1, 0xDE, 0xB2,
+	0x74, 0x71, 0x25, 0x01, 0x46, 0x82, 0xFD, 0x3B, 0xB2, 0x9B, 0xF5, 0xDA,
+	    0x79, 0x9E, 0xC7, 0xC1, 0x0B, 0x9C, 0x4D, 0x21,
+	0xB5, 0x9E, 0xEF, 0xD7, 0xDF, 0xFF, 0xFD, 0xEA, 0xAA, 0x9F, 0x02, 0xE7,
+	    0x75, 0xBC, 0x64, 0x46, 0x45, 0xB1, 0xBD, 0x41,
+	0xD3, 0x1F, 0xC0, 0x91, 0x5A, 0xDB, 0xAA, 0x24, 0x64, 0xB6, 0x3F, 0xD5,
+	    0x03, 0x38, 0x28, 0x29, 0xB8, 0xC8, 0xEF, 0xB4,
+	0x01, 0x9B, 0x98, 0x74, 0x76, 0x92, 0x43, 0x7A, 0x22, 0x32, 0x9D, 0xC2,
+	    0x56, 0xDA, 0xE5, 0xA5, 0x96, 0x9A, 0xF5, 0x63,
+	0xF0, 0x0D, 0x78, 0xE2, 0x06, 0x16, 0x0A, 0x27, 0x37, 0xA8, 0xEA, 0x71,
+	    0x67, 0x5F, 0xC7, 0x15, 0x75, 0xDF, 0x46, 0x89,
+	0x39, 0x97, 0xAA, 0xFC, 0x9B, 0xBC, 0x37, 0x2E, 0x6C, 0x18, 0x26, 0x5E,
+	    0xED, 0x59, 0x24, 0x9B, 0x8E, 0xDB, 0x94, 0x6D,
+	0x49, 0x32, 0x8C, 0xA5, 0x15, 0x95, 0xEC, 0x09, 0x96, 0x9D, 0x47, 0x89,
+	    0xED, 0x97, 0x30, 0x7E, 0xC0, 0x7A, 0xF7, 0x0E,
+	0x5B, 0xDE, 0xA2, 0x5C, 0x78, 0x77, 0xF1, 0x5D, 0xAB, 0x02, 0xB9, 0xAE,
+	    0xC9, 0xF9, 0x6E, 0x53, 0x01, 0x96, 0x2F, 0x8F,
+	0x02, 0x04, 0x50, 0x39, 0xAA, 0x11, 0x7F, 0x44, 0x3F, 0xFC, 0x4E, 0x3A,
+	    0x90, 0xD3, 0x52, 0x8C, 0x3F, 0xDC, 0x56, 0xEA,
+	0x41, 0x82, 0x54, 0x99, 0xFD, 0xFD, 0x10, 0x7E, 0x20, 0x88, 0x5E, 0x3C,
+	    0xF3, 0xF3, 0x35, 0x7C, 0x8A, 0x3F, 0xC7, 0x73,
+	0x8D, 0x98, 0x67, 0x6E, 0xEA, 0xF3, 0x8F, 0x2D, 0x7D, 0xF0, 0xD7, 0x25,
+	    0xBF, 0xD2, 0xA7, 0x73, 0xD8, 0xFF, 0xBF, 0x2B,
+	0xA3, 0xC4, 0x87, 0x3D, 0x5E, 0xBC, 0x3A, 0xF3, 0x2A, 0xAD, 0x38, 0x75,
+	    0x64, 0x2B, 0x07, 0xC8, 0x9C, 0x8D, 0x52, 0xB1,
+	0x51, 0x12, 0x00, 0x14, 0x09, 0xFC, 0x97, 0x54, 0x59, 0x8A, 0x43, 0x30,
+	    0x3A, 0x01, 0x8A, 0x47, 0xBA, 0x25, 0x55, 0x46,
+	0x4A, 0x4B, 0xC1, 0xC2, 0x96, 0xD2, 0xE8, 0x29, 0x25, 0x3D, 0xAF, 0x81,
+	    0xB8, 0x6F, 0xC9, 0xFD, 0x34, 0x82, 0x5D, 0x01,
+	0xB9, 0x0D, 0xE6, 0x6F, 0x74, 0x9F, 0xA3, 0x85, 0x7F, 0x21, 0x56, 0x78,
+	    0x04, 0x27, 0x40, 0x25, 0xD4, 0xA9, 0x22, 0x71,
+	0x12, 0xCF, 0xD1, 0xE0, 0x4C, 0xF5, 0xA0, 0x01, 0x49, 0x7F, 0xF6, 0x14,
+	    0x27, 0xDA, 0x0C, 0x9C, 0x20, 0xBA, 0xAB, 0xF0,
+	0x4D, 0xF4, 0x98, 0xB1, 0x7D, 0x09, 0xBF, 0x14, 0x79, 0xEE, 0xA9, 0x50,
+	    0xB2, 0x04, 0x8B, 0x64, 0x71, 0x4E, 0x45, 0x72,
+	0x06, 0xAF, 0x65, 0x26, 0xE5, 0xAE, 0x21, 0x73, 0xC5, 0xCC, 0x83, 0x74,
+	    0x70, 0x63, 0x13, 0xF7, 0xE1, 0x07, 0xDC, 0xA9,
+	0x1E, 0x09, 0xD2, 0xB8, 0x51, 0x26, 0x15, 0x19, 0xE8, 0xEB, 0x96, 0xE0,
+	    0x09, 0x72, 0x71, 0x14, 0xBC, 0xD6, 0x1C, 0xBA,
+	0xE7, 0x2B, 0xD2, 0x2D, 0x91, 0x2A, 0x51, 0x3F, 0x7F, 0xBF, 0xEF, 0xE5,
+	    0x91, 0x67, 0xD3, 0xC5, 0x13, 0x42, 0x3F, 0xA9,
+	0x9E, 0x88, 0x9C, 0xE8, 0xE7, 0xBA, 0xBC, 0xBC, 0x69, 0x28, 0x3B, 0xAC,
+	    0x44, 0xC6, 0x4F, 0x3F, 0x95, 0xCB, 0x78, 0xBB,
+	0x32, 0xA1, 0xE2, 0xA6, 0xE7, 0xA5, 0xAA, 0x59, 0x3A, 0x0E, 0xD4, 0x2B,
+	    0xEF, 0xCA, 0xC9, 0x2B, 0x33, 0xAC, 0x77, 0x2C,
+	0x9B, 0x32, 0x22, 0x48, 0xE6, 0x0F, 0x75, 0x58, 0xBA, 0xC2, 0x56, 0x38,
+	    0xBE, 0x07, 0xE3, 0xC7, 0x9B, 0xAC, 0x07, 0x85,
+	0x23, 0x7F, 0xDB, 0x83, 0x07, 0x33, 0x73, 0x69, 0x5B, 0x30, 0x74, 0x2D,
+	    0x1B, 0x39, 0x0F, 0x95, 0xA8, 0x6F, 0xC8, 0x8E,
+	0xE3, 0xC2, 0x22, 0xBC, 0x02, 0x0B, 0x7B, 0xBF, 0x4C, 0xA5, 0x34, 0x4A,
+	    0x89, 0xA1, 0x40, 0x36, 0x6C, 0x7A, 0xB6, 0x6F,
+	0x52, 0x11, 0x4C, 0x88, 0x2D, 0x3F, 0x99, 0xA3, 0x1D, 0xCB, 0xBC, 0xB1,
+	    0xFC, 0xFA, 0xA0, 0xF7, 0x57, 0x02, 0x16, 0x01,
+	0xCB, 0x2B, 0x0F, 0xA3, 0x72, 0x5A, 0x93, 0xE2, 0x93, 0x02, 0x52, 0x81,
+	    0xA7, 0x91, 0xB5, 0x6A, 0x32, 0x3E, 0x3B, 0x11,
+	0xBA, 0x48, 0x09, 0x26, 0xDF, 0xDC, 0xE7, 0xFD, 0xFE, 0x17, 0x00, 0xA2,
+	    0x68, 0x76, 0xD4, 0x81, 0xA4, 0x29, 0xC1, 0xF7,
+	0x5F, 0x7B, 0x54, 0xF4, 0xDB, 0x24, 0xAA, 0x80, 0xDA, 0x9D, 0xDC, 0x91,
+	    0xA5, 0x08, 0x4D, 0x70, 0x23, 0xFC, 0x7B, 0xE8,
+	0xC3, 0xB6, 0x87, 0x8C, 0x3D, 0xCB, 0x95, 0x6C, 0xE3, 0x5E, 0xE7, 0x1D,
+	    0xF2, 0xD7, 0xFA, 0xE9, 0xA5, 0x0C, 0xD7, 0xD7,
+	0x00, 0xEA, 0xA2, 0x75, 0xF5, 0x4B, 0xE5, 0x0F, 0x5F, 0x7A, 0x0B, 0xCF,
+	    0xC1, 0x1B, 0x7D, 0x4E, 0x99, 0x87, 0xB0, 0xDB,
+	0x42, 0x17, 0x42, 0x93, 0x56, 0x39, 0x77, 0xEB, 0x55, 0x90, 0xC8, 0x8F,
+	    0xE5, 0xDA, 0x4A, 0x8A, 0x09, 0xD7, 0x22, 0x8D,
+	0x4D, 0x3B, 0xE0, 0xF7, 0xC9, 0x1E, 0xEF, 0xEF, 0x4B, 0x78, 0x49, 0x4B,
+	    0xEC, 0xF7, 0xAD, 0x5E, 0xCC, 0xF1, 0x2F, 0x13,
+	0xAA, 0x01, 0x2C, 0x29, 0x61, 0x98, 0x61, 0xBF, 0x00, 0x54, 0xCB, 0x51,
+	    0x58, 0x15, 0x46, 0xB7, 0x42, 0xCD, 0xDC, 0xCE,
+	0xA8, 0x34, 0x28, 0xA9, 0xC6, 0x51, 0xA9, 0xDD, 0x5C, 0xD3, 0x59, 0x2B,
+	    0x53, 0xA8, 0xF0, 0x8C, 0xF1, 0xF5, 0xCF, 0x16,
+	0x6D, 0x2F, 0xA0, 0x5D, 0x18, 0x2C, 0x39, 0xF5, 0x5F, 0xBD, 0x47, 0xCF,
+	    0x8E, 0x50, 0x29, 0xAD, 0x03, 0x56, 0x07, 0x97,
+	0x90, 0x5D, 0x5A, 0xE6, 0x97, 0x5D, 0xF1, 0x8C, 0xBD, 0x6D, 0x08, 0xB9,
+	    0xBB, 0x22, 0x1F, 0xE5, 0xDC, 0x72, 0x7E, 0xAA,
+	0x0C, 0xC2, 0x60, 0xFF, 0x25, 0x2D, 0xD5, 0xDD, 0xA5, 0x96, 0x60, 0x55,
+	    0x72, 0x67, 0x4E, 0x2E, 0xEE, 0x50, 0x51, 0xFD,
+	0xA6, 0xE3, 0xB8, 0xB6, 0x07, 0xF9, 0x3F, 0x4F, 0x56, 0x01, 0xBD, 0x3D,
+	    0x09, 0x0F, 0xDA, 0xFC, 0xAB, 0x2B, 0xCA, 0xDB,
+	0xC4, 0x79, 0x33, 0x61, 0x59, 0xA0, 0x13, 0x80, 0xFD, 0x2C, 0xEB, 0xF9,
+	    0x64, 0xAF, 0x95, 0xB7, 0xF2, 0x7D, 0x15, 0xC7,
+	0x9B, 0x45, 0xDC, 0xA2, 0x02, 0xB6, 0xA8, 0x4A, 0xEB, 0xE6, 0x08, 0x92,
+	    0xEB, 0x65, 0xE5, 0x21, 0x9C, 0xAD, 0x7D, 0x21,
+	0x3F, 0x02, 0x5C, 0x34, 0xFC, 0x6D, 0x22, 0x73, 0xE4, 0x65, 0xC2, 0x85,
+	    0x7D, 0x4A, 0xDD, 0xA3, 0xCA, 0x26, 0x20, 0x0D,
+	0x7D, 0x0E, 0xE0, 0xE7, 0xEC, 0x9D, 0xF9, 0x63, 0x5E, 0x3C, 0x6F, 0x20,
+	    0x7F, 0xD6, 0xB6, 0x42, 0x91, 0xD5, 0xE8, 0x00,
+	0xF3, 0xAB, 0x29, 0x84, 0xAF, 0x48, 0x35, 0xCD, 0xE5, 0x59, 0x9A, 0x75,
+	    0x9D, 0xA5, 0x7A, 0x3E, 0xCE, 0x8F, 0x66, 0xDD,
+	0x72, 0x84, 0xEA, 0xF6, 0xA4, 0x81, 0x82, 0x7C, 0x2E, 0x4A, 0xD6, 0x49,
+	    0x6F, 0x6F, 0x2D, 0xB6, 0xF8, 0x4F, 0x45, 0xAB,
+	0x65, 0x7B, 0x18, 0x4D, 0x3D, 0x57, 0xCC, 0x49, 0x8C, 0xC5, 0xEA, 0x87,
+	    0x79, 0x4C, 0xA9, 0x08, 0xF5, 0x7A, 0x13, 0xE1,
+	0x8D, 0xE6, 0x74, 0x48, 0x9E, 0x42, 0x28, 0xFF, 0xDB, 0x46, 0xD5, 0x67,
+	    0x08, 0x97, 0xFF, 0x57, 0x18, 0xFE, 0x10, 0x7B,
+	0x4D, 0x8C, 0x61, 0x9F, 0x6A, 0xCC, 0xF9, 0x61, 0x3B, 0x78, 0x66, 0x61,
+	    0x5E, 0x36, 0xA9, 0x34, 0xB2, 0x91, 0x05, 0x0D,
+	0x6B, 0x81, 0x63, 0x55, 0xF6, 0x7A, 0x58, 0x0F, 0xBE, 0x7B, 0x67, 0xBC,
+	    0xEA, 0x7A, 0xCD, 0x0A, 0xBE, 0x31, 0x78, 0xDF,
+	0xBC, 0x8F, 0xEB, 0xA6, 0x83, 0xED, 0xBB, 0xF6, 0xB5, 0xC5, 0x1C, 0xBF,
+	    0xCE, 0x42, 0x1A, 0x23, 0x64, 0xD2, 0x87, 0x36,
+	0x5F, 0xD3, 0x66, 0x3D, 0x8F, 0xB4, 0xD6, 0xA7, 0x77, 0xB0, 0xEC, 0x7E,
+	    0xCE, 0x4E, 0x92, 0x32, 0x5D, 0xBC, 0x02, 0x12,
+	0xC6, 0x71, 0x7C, 0x5E, 0xB2, 0xF7, 0xFC, 0xF9, 0xC4, 0x53, 0x27, 0xF5,
+	    0x5F, 0xF1, 0x0B, 0x9E, 0x47, 0xB7, 0xB9, 0x88,
+	0x08, 0xA3, 0x99, 0xF1, 0x5A, 0xD1, 0xBF, 0xF0, 0x5E, 0xF7, 0x69, 0xB2,
+	    0xE9, 0x92, 0x5A, 0x65, 0x54, 0x5C, 0x3D, 0xC2,
+	0xDB, 0x35, 0x1E, 0x86, 0x42, 0x61, 0xB4, 0x6F, 0x67, 0xDE, 0x0F, 0xC1,
+	    0xD7, 0x0B, 0x3A, 0xEF, 0xCC, 0x64, 0xEC, 0x2F,
+	0x7F, 0xF7, 0x44, 0x92, 0x63, 0xFC, 0xC7, 0x68, 0x80, 0xB7, 0x35, 0x30,
+	    0x84, 0x4B, 0xE9, 0xF8, 0xB3, 0x2D, 0xF7, 0x67,
+	0xF8, 0x47, 0x59, 0x9C, 0x28, 0x09, 0x81, 0xA0, 0xD3, 0x31, 0x29, 0xB1,
+	    0xCC, 0xA7, 0x19, 0x77, 0xF1, 0x4B, 0x26, 0x2E,
+	0x23, 0x06, 0xFF, 0xE4, 0x4C, 0x89, 0x9C, 0x3E, 0x92, 0xFA, 0x95, 0x96,
+	    0xB0, 0x29, 0x23, 0x89, 0xDD, 0x57, 0x9A, 0xF8,
+	0x51, 0x36, 0x1F, 0x2A, 0x85, 0x1A, 0x67, 0x12, 0xC8, 0x70, 0x2B, 0x3A,
+	    0x22, 0x13, 0xE7, 0x67, 0x47, 0x05, 0x20, 0xBA,
+	0x00, 0x59, 0x14, 0x0B, 0x34, 0xF9, 0xA4, 0x94, 0x8C, 0x0F, 0xBC, 0xE1,
+	    0xDB, 0x34, 0x9E, 0x2F, 0x30, 0xF9, 0xA8, 0x5B,
+	0xAD, 0xC9, 0xF7, 0x3F, 0x9E, 0xB4, 0x36, 0xB9, 0x56, 0x3A, 0x26, 0x42,
+	    0xCB, 0xB4, 0x08, 0xAF, 0xC2, 0xD1, 0x51, 0x4E,
+	0xF3, 0x51, 0xFB, 0xC9, 0x5F, 0xEC, 0xB7, 0x5C, 0xF9, 0x10, 0xBE, 0x77,
+	    0x56, 0x6F, 0xE9, 0x6D, 0x03, 0xF7, 0xF0, 0x8B,
+	0xE2, 0x6B, 0xA5, 0x08, 0x57, 0x76, 0x09, 0xBB, 0x95, 0xAE, 0x64, 0x7C,
+	    0xDC, 0x53, 0xC8, 0xE3, 0x46, 0xAE, 0xE1, 0x57,
+	0x79, 0xB7, 0xBF, 0x77, 0x1A, 0xD7, 0x7D, 0xEC, 0x83, 0x4E, 0x26, 0xA0,
+	    0x74, 0xA0, 0xB8, 0xD4, 0xCF, 0x2F, 0x28, 0xF0,
+	0xFF, 0x4F, 0xC4, 0x5A, 0x32, 0x84, 0x5C, 0x2F, 0x27, 0xAC, 0xF0, 0x33,
+	    0xB2, 0x27, 0x12, 0x20, 0xE2, 0x4C, 0x45, 0xE6,
+	0x3A, 0x82, 0x90, 0x03, 0x78, 0xD7, 0xE1, 0x41, 0xB1, 0xAF, 0x71, 0x81,
+	    0x7C, 0x4F, 0xEF, 0x85, 0xE7, 0x94, 0x95, 0x21,
+	0x7A, 0xBC, 0x01, 0xC9, 0xD1, 0x2C, 0x53, 0xDE, 0x62, 0x45, 0x99, 0x26,
+	    0xFC, 0x70, 0x82, 0x34, 0x4A, 0xF5, 0xB6, 0x52,
+	0xB1, 0x65, 0xD7, 0x20, 0x5A, 0x08, 0x8D, 0xF2, 0xFF, 0xC5, 0x97, 0x82,
+	    0xEA, 0x6C, 0x5F, 0xA7, 0x97, 0x88, 0x38, 0xD7,
+	0xD8, 0x4A, 0x0C, 0x8A, 0xAE, 0xE4, 0x61, 0x6B, 0xF5, 0xF0, 0x15, 0xBB,
+	    0x7B, 0x3D, 0x5D, 0x63, 0x8A, 0xCB, 0xE9, 0x9A,
+	0xC8, 0x0B, 0xB4, 0xBD, 0x83, 0xBC, 0x17, 0xE9, 0x78, 0x43, 0x39, 0xC7,
+	    0x88, 0x4A, 0xF1, 0x51, 0x32, 0x7C, 0x38, 0xB8,
+	0xF7, 0x97, 0x36, 0x6E, 0x59, 0x68, 0x42, 0xA8, 0x2B, 0xB8, 0xCD, 0x2E,
+	    0xA4, 0x4B, 0x5E, 0x07, 0x2F, 0xA2, 0xD0, 0x1D,
+	0xBA, 0x2F, 0x22, 0xE8, 0xEA, 0xC1, 0x43, 0x0B, 0x66, 0xE7, 0xC3, 0x99,
+	    0x91, 0xDE, 0xFB, 0x8F, 0x9D, 0x71, 0x6B, 0xAB,
+	0xEA, 0x1F, 0x68, 0xA9, 0xA1, 0xAE, 0x9E, 0x08, 0x0B, 0xAC, 0x03, 0xF4,
+	    0x3A, 0x2D, 0x9D, 0xDB, 0x4B, 0x48, 0xC5, 0x88,
+	0xD9, 0xCF, 0x43, 0xCC, 0x61, 0x50, 0x52, 0x3C, 0x9A, 0x83, 0xAB, 0x4F,
+	    0xEB, 0x33, 0xFA, 0x8A, 0x4A, 0x23, 0x74, 0x3D,
+	0xB4, 0x56, 0xEA, 0xCF, 0xB8, 0x6C, 0x4F, 0xFC, 0x1B, 0x32, 0xA4, 0x81,
+	    0x38, 0x4D, 0x98, 0xD6, 0xF5, 0x80, 0xBB, 0xC5,
+	0x3F, 0xA7, 0xFF, 0xFA, 0xFE, 0xE3, 0x43, 0x1F, 0xB2, 0x95, 0x4B, 0x62,
+	    0xA1, 0x9A, 0xF5, 0xFC, 0xF3, 0x22, 0x13, 0x25,
+	0xF8, 0xFB, 0x8D, 0x81, 0x30, 0xB4, 0xE3, 0xF3, 0x5C, 0xC6, 0x7D, 0x00,
+	    0x4B, 0xA3, 0x12, 0xC2, 0x21, 0x40, 0xEC, 0x14,
+	0xAE, 0xDF, 0xDC, 0x78, 0xF1, 0xD7, 0x53, 0x79, 0xB3, 0x32, 0x64, 0x32,
+	    0x43, 0x21, 0x3C, 0xD6, 0x82, 0x14, 0x0D, 0x11,
+	0x2F, 0xBF, 0x45, 0x78, 0x2E, 0x70, 0x6D, 0x86, 0x83, 0xA2, 0x31, 0xE7,
+	    0x7C, 0x7E, 0x4C, 0xE7, 0xC0, 0x17, 0x1D, 0xE7,
+	0x12, 0x35, 0x25, 0x61, 0x42, 0x5C, 0xA5, 0x4E, 0x5D, 0x7E, 0x1A, 0xE9,
+	    0x22, 0xBB, 0x7E, 0x9B, 0x91, 0x51, 0x0F, 0xE0,
+	0x19, 0x14, 0x44, 0x66, 0xC0, 0x55, 0x54, 0xDD, 0xA1, 0xB2, 0x65, 0xB2,
+	    0x53, 0x75, 0x3C, 0x46, 0x24, 0x58, 0x82, 0x16,
+	0x77, 0xF0, 0xD4, 0x29, 0xB6, 0x5B, 0x7A, 0x27, 0x96, 0x2D, 0x95, 0x71,
+	    0xFB, 0x3A, 0x8F, 0x41, 0x51, 0x37, 0xEF, 0xB3,
+	0x82, 0xB7, 0xB2, 0x5D, 0x16, 0xB4, 0xBA, 0x8F, 0x82, 0x53, 0x6E, 0x17,
+	    0xD7, 0x1B, 0x7F, 0xFB, 0x02, 0x91, 0x8E, 0xC4,
+	0x78, 0x37, 0x76, 0x08, 0x62, 0xD3, 0x6D, 0x8B, 0xD9, 0x87, 0x08, 0xA0,
+	    0x61, 0x28, 0x16, 0xA5, 0x1B, 0x71, 0xD2, 0xDA,
+	0x2A, 0x86, 0x09, 0x8E, 0x19, 0xF7, 0x27, 0x03, 0xA9, 0x5A, 0x07, 0xB0,
+	    0x0B, 0x9E, 0x50, 0x4B, 0x6A, 0x12, 0xC9, 0x4F,
+	0xB8, 0xD7, 0x13, 0x06, 0x40, 0x8A, 0x0F, 0x8C, 0xC1, 0x99, 0x67, 0xDB,
+	    0xAA, 0xE4, 0xE1, 0xBB, 0x10, 0x74, 0x18, 0xE1,
+	0x2A, 0xB3, 0xC6, 0x36, 0xC6, 0x27, 0x2F, 0x6A, 0x8C, 0xF6, 0xE8, 0x11,
+	    0xB8, 0xDC, 0x10, 0x3A, 0x2F, 0xB0, 0xB6, 0xD8,
+	0xC2, 0x7F, 0x16, 0x71, 0x58, 0x0D, 0x4E, 0xA7, 0x86, 0xC1, 0xD6, 0x69,
+	    0x8E, 0xEF, 0x74, 0x38, 0x9E, 0x95, 0x6F, 0x99,
+	0x6A, 0x48, 0xE9, 0x11, 0x38, 0x7E, 0xD3, 0x5D, 0xF7, 0x76, 0x0D, 0x97,
+	    0x1A, 0x60, 0xE7, 0xE9, 0x4C, 0x5B, 0xF4, 0x83,
+	0x2A, 0x3D, 0x06, 0x60, 0x25, 0xE0, 0x28, 0xFB, 0xF5, 0xAF, 0x76, 0xD2,
+	    0x4C, 0xCF, 0x2C, 0x8E, 0xAC, 0x31, 0xF8, 0x2C,
+	0x2F, 0xC3, 0xD0, 0x94, 0x10, 0xA5, 0xBE, 0xD0, 0xC7, 0xC2, 0x78, 0x4F,
+	    0x91, 0x6C, 0x7F, 0x2E, 0x88, 0x77, 0xC1, 0x43,
+	0xE3, 0x22, 0x51, 0x83, 0xCA, 0x49, 0x06, 0x86, 0x20, 0xE1, 0xF2, 0xCA,
+	    0x51, 0x72, 0x91, 0xC7, 0x4A, 0xAC, 0x3A, 0xC3,
+	0xC9, 0xCC, 0xC7, 0x0A, 0x3C, 0x12, 0x30, 0xC6, 0x29, 0xC7, 0xF2, 0xC4,
+	    0xFD, 0xE0, 0xCA, 0x02, 0x30, 0xDF, 0x60, 0xE4,
+	0xD6, 0x6C, 0x68, 0x12, 0x03, 0xA0, 0x4C, 0x72, 0x24, 0x03, 0xB8, 0x6A,
+	    0xAA, 0xCF, 0x68, 0x65, 0x36, 0x6D, 0x5F, 0x7A,
+	0x09, 0x00, 0xDB, 0xF7, 0x0C, 0x09, 0xE1, 0x05, 0xE7, 0xB6, 0xC9, 0x37,
+	    0xF6, 0xE9, 0xA6, 0x77, 0x81, 0x77, 0x51, 0xB9,
+	0x87, 0xEA, 0xFB, 0xF7, 0x93, 0x43, 0xDF, 0x06, 0x9E, 0xA6, 0x85, 0xAA,
+	    0xF0, 0xF9, 0xC2, 0xBB, 0x32, 0xA5, 0x52, 0x6E,
+	0x13, 0xC5, 0x1E, 0xBD, 0x71, 0xE2, 0x1D, 0x26, 0x0B, 0xEB, 0xA0, 0x1F,
+	    0xBE, 0xA4, 0x6A, 0x15, 0xEC, 0x41, 0x84, 0x03,
+	0xBD, 0x68, 0xF8, 0x0B, 0x7C, 0x3B, 0xE9, 0xE0, 0x3F, 0xA7, 0x39, 0x2A,
+	    0x6F, 0xCC, 0xFF, 0xDE, 0x7F, 0x6A, 0x93, 0xDC,
+	0x64, 0x88, 0xA1, 0x1B, 0x3E, 0x50, 0x33, 0xD9, 0x4F, 0xC8, 0xD1, 0xCC,
+	    0x59, 0x46, 0x29, 0xB3, 0x02, 0xCE, 0x1F, 0xB6,
+	0x9A, 0x17, 0xB2, 0x96, 0xA5, 0xCA, 0xCA, 0x80, 0xF2, 0xE1, 0xCD, 0x76,
+	    0x8D, 0xEA, 0x58, 0x7A, 0xFA, 0x52, 0x18, 0xFA,
+	0x4C, 0x1F, 0x51, 0x5A, 0xDD, 0xFA, 0x64, 0xE3, 0x5A, 0xBF, 0xCB, 0xB2,
+	    0xAE, 0x75, 0x02, 0xF7, 0x6F, 0xA0, 0x0E, 0x90,
+	0x0B, 0xB3, 0xEC, 0x39, 0xAE, 0x2F, 0xEA, 0xDD, 0x2D, 0x5D, 0xC8, 0x52,
+	    0x33, 0x9E, 0x6F, 0x8F, 0xDB, 0xE0, 0x3C, 0x96,
+	0xA6, 0x37, 0xB3, 0x76, 0xCB, 0x11, 0x4C, 0x20, 0x61, 0x1A, 0xE6, 0x91,
+	    0x9F, 0x94, 0x4C, 0x21, 0xED, 0x9C, 0xFE, 0x94,
+	0xDE, 0xD5, 0xF5, 0x50, 0xE7, 0x99, 0xC1, 0x91, 0xD4, 0xAE, 0x03, 0x73,
+	    0x82, 0x9D, 0xB2, 0x74, 0x30, 0x3F, 0x0F, 0x41,
+	0x66, 0x9A, 0x8D, 0x4D, 0x58, 0xFF, 0xC1, 0x01, 0xA5, 0x9B, 0x95, 0x64,
+	    0xC1, 0x1E, 0xE3, 0x43, 0xD9, 0xDC, 0x09, 0xD5,
+	0x4A, 0x0E, 0xA4, 0xDE, 0x61, 0xD6, 0x50, 0xA4, 0x89, 0xD8, 0xB4, 0x0A,
+	    0x42, 0x5F, 0xAB, 0x1A, 0xEB, 0x09, 0x35, 0xC9,
+	0xC2, 0x9E, 0x8A, 0xB0, 0x80, 0xA5, 0xFD, 0x14, 0xE7, 0x35, 0x3C, 0x0F,
+	    0x00, 0x99, 0x66, 0xB4, 0xA5, 0x17, 0x5A, 0x48,
+	0x92, 0xAD, 0x71, 0x05, 0x07, 0xCD, 0x58, 0xA9, 0x03, 0xAA, 0xAA, 0x51,
+	    0x09, 0xA9, 0x55, 0x38, 0xCC, 0xA6, 0x47, 0x1B,
+	0xF3, 0x98, 0x42, 0x78, 0x08, 0x2A, 0xA0, 0xF8, 0x1F, 0xCE, 0x3A, 0x9D,
+	    0x44, 0xB7, 0x56, 0xCA, 0x10, 0xD5, 0x23, 0x51,
+	0x89, 0xAB, 0xBE, 0x18, 0x2C, 0xFB, 0x90, 0x7C, 0x13, 0x66, 0x46, 0xD8,
+	    0x2E, 0xC6, 0x85, 0x16, 0x8E, 0xF7, 0xDF, 0xE9,
+	0xEE, 0x95, 0x95, 0xBE, 0x1D, 0x45, 0x7D, 0xFC, 0xAD, 0xCA, 0x4C, 0xD4,
+	    0xC6, 0x45, 0x17, 0x4B, 0x56, 0x94, 0x10, 0xAF,
+	0x3C, 0x14, 0x47, 0x39, 0x83, 0xB8, 0x1F, 0x7D, 0x71, 0xB9, 0x5E, 0xDA,
+	    0x8D, 0x91, 0xBD, 0xF8, 0x41, 0xB0, 0x2F, 0xCE,
+	0xC9, 0xDA, 0x17, 0x10, 0xF3, 0x01, 0x6C, 0xA8, 0x1C, 0xCB, 0xFD, 0x18,
+	    0x5D, 0x30, 0x8A, 0xE7, 0xCC, 0xDB, 0x7A, 0x39,
+	0xFF, 0xDD, 0x98, 0x59, 0xE6, 0x96, 0x3C, 0xC9, 0x9A, 0xF0, 0x53, 0x7A,
+	    0x4F, 0xD8, 0x90, 0x91, 0x2C, 0xF6, 0x97, 0xA4,
+	0x20, 0x19, 0xB6, 0x5C, 0x58, 0xFE, 0x5B, 0x6B, 0x4E, 0xD9, 0x53, 0x3F,
+	    0x46, 0xBE, 0x5E, 0xA1, 0x04, 0x8D, 0x3B, 0x4A,
+	0x23, 0x7A, 0xED, 0xE7, 0x9E, 0x1D, 0x93, 0xAF, 0xD5, 0x71, 0x51, 0x1F,
+	    0xE4, 0x5E, 0x77, 0xED, 0x4D, 0x63, 0x9B, 0x7E,
+	0xCE, 0xFC, 0xEA, 0x9C, 0xF2, 0x23, 0x7F, 0xA5, 0x6B, 0x61, 0x39, 0xFB,
+	    0x80, 0x6F, 0xF2, 0xE1, 0xD4, 0x00, 0x51, 0x39,
+	0x4E, 0x64, 0x08, 0x67, 0x3E, 0x98, 0x4D, 0xE7, 0x30, 0xA9, 0xFE, 0x4B,
+	    0x17, 0x4B, 0x9E, 0x89, 0xD7, 0x7B, 0x20, 0xE7,
+	0xA9, 0x0B, 0x92, 0x46, 0xA5, 0x66, 0xF8, 0x20, 0xC7, 0xB7, 0x00, 0xFB,
+	    0xBB, 0x47, 0x11, 0x4B, 0xE4, 0x06, 0x82, 0x41,
+	0x32, 0xC5, 0x98, 0x89, 0xA0, 0x43, 0x73, 0x1A, 0x86, 0x7E, 0x81, 0x9C,
+	    0x1D, 0x8B, 0x05, 0x0E, 0x79, 0xF7, 0x6B, 0x89,
+	0x72, 0x09, 0x32, 0x25, 0x98, 0x1B, 0x5F, 0x30, 0xB0, 0xB3, 0xF7, 0x69,
+	    0x70, 0x2E, 0x79, 0x2D, 0x62, 0x25, 0x59, 0x32,
+	0xFD, 0xBB, 0x02, 0xF1, 0x4A, 0xF7, 0x05, 0xF7, 0x6B, 0x28, 0x92, 0xEF,
+	    0x6C, 0xC5, 0xEA, 0xAE, 0xBA, 0x38, 0xCE, 0x7E,
+	0xDD, 0x8A, 0x86, 0x7A, 0xEA, 0x39, 0x63, 0xBA, 0xAF, 0xEF, 0xB8, 0x5E,
+	    0x19, 0x66, 0xA8, 0x67, 0x5D, 0x48, 0x43, 0x88,
+	0x3D, 0x31, 0xCE, 0x2D, 0x7F, 0x75, 0x2C, 0xCF, 0x5A, 0xCD, 0xAC, 0xA8,
+	    0xAB, 0x7A, 0x33, 0xE6, 0x14, 0x5D, 0x23, 0xC3,
+	0x65, 0x46, 0xC3, 0x29, 0x5B, 0xCC, 0xF8, 0xFA, 0x02, 0xCC, 0x42, 0x8A,
+	    0x1B, 0xA7, 0xB2, 0x2C, 0x6A, 0x04, 0x06, 0x32,
+	0xC9, 0x53, 0x52, 0xC9, 0x38, 0x5B, 0xC3, 0x2F, 0x6F, 0x22, 0x7A, 0xF2,
+	    0xEA, 0x56, 0xBC, 0xD9, 0x5A, 0xCC, 0x23, 0xEE,
+	0x21, 0x03, 0xD5, 0x70, 0x9C, 0x07, 0xD3, 0x08, 0xB0, 0x48, 0x7F, 0xFE,
+	    0xB8, 0xB3, 0xF3, 0xB9, 0x89, 0x09, 0x4C, 0xE2,
+	0xDB, 0xC1, 0x6D, 0x9F, 0x67, 0x42, 0x80, 0x7D, 0xA0, 0xAF, 0x62, 0x04,
+	    0x66, 0xD9, 0xA3, 0xF2, 0x13, 0xD1, 0xB7, 0xD6,
+	0x08, 0x33, 0x8C, 0xA0, 0x79, 0x3B, 0x58, 0xE2, 0x12, 0xC5, 0x4C, 0x8D,
+	    0x2E, 0x3B, 0x04, 0xB4, 0x69, 0xB9, 0x53, 0x7B,
+	0x77, 0x81, 0xC5, 0xF9, 0x8B, 0xB0, 0x45, 0x9C, 0xCC, 0x5E, 0x6B, 0x04,
+	    0x09, 0x71, 0x85, 0x90, 0xE8, 0x30, 0xF7, 0xE2,
+	0x87, 0xB2, 0x48, 0xB2, 0xB7, 0x83, 0x23, 0x14, 0xC0, 0x13, 0x43, 0x73,
+	    0x9D, 0x32, 0x43, 0x64, 0xA0, 0x10, 0xE9, 0xBF,
+	0xAB, 0x81, 0x2C, 0x00, 0x22, 0xA9, 0x50, 0x19, 0x7A, 0x35, 0x04, 0x59,
+	    0xA1, 0x72, 0xD5, 0x19, 0xE7, 0xC4, 0x7C, 0x7E,
+	0xC2, 0xD9, 0xCA, 0x96, 0x13, 0xD5, 0xF1, 0x45, 0xFA, 0x91, 0x56, 0xB7,
+	    0x4D, 0x74, 0x5F, 0x81, 0x45, 0x50, 0x8C, 0x6A,
+	0x57, 0x89, 0x4F, 0x55, 0xFB, 0x54, 0x6A, 0x75, 0x4B, 0xE6, 0x17, 0xEC,
+	    0xA3, 0x51, 0xA2, 0x8A, 0x11, 0x37, 0x9A, 0x73,
+	0xD4, 0x5B, 0xF4, 0xCC, 0x72, 0x3E, 0xFA, 0x8C, 0xE5, 0x19, 0xF6, 0xAF,
+	    0x65, 0x75, 0x92, 0xA9, 0x88, 0xB8, 0x09, 0x18,
+	0x61, 0xBB, 0x8F, 0xDC, 0x5A, 0xED, 0xBE, 0xB8, 0xFC, 0xD8, 0xC7, 0xB1,
+	    0xB3, 0xB7, 0x73, 0x6E, 0x19, 0x31, 0x07, 0x81,
+	0x81, 0x5B, 0xCF, 0xBD, 0x7F, 0xDB, 0xDF, 0x6A, 0x8F, 0x00, 0xD6, 0xD0,
+	    0xDA, 0x33, 0xA5, 0xC9, 0xE1, 0x50, 0x5F, 0xA1,
+	0x39, 0x39, 0x26, 0xCA, 0x8E, 0x5E, 0x19, 0xCD, 0x3C, 0x25, 0xA4, 0x9B,
+	    0xC9, 0x5A, 0xD0, 0x4C, 0x77, 0x3C, 0x8E, 0xC1,
+	0x57, 0x1B, 0x1E, 0x87, 0x82, 0x81, 0xD9, 0xE8, 0xE9, 0x9A, 0x4B, 0x03,
+	    0x92, 0x8C, 0x40, 0x7B, 0xA9, 0x6E, 0x0A, 0xD3,
+	0x90, 0xCA, 0x77, 0x67, 0x4B, 0xD4, 0x88, 0xE9, 0x13, 0x7D, 0x6F, 0xFA,
+	    0xAD, 0xAF, 0x10, 0xD9, 0xBD, 0x26, 0xE5, 0x1B,
+	0x69, 0x5B, 0x0E, 0x03, 0x88, 0x7F, 0xA3, 0x86, 0x50, 0xDC, 0x9B, 0x88,
+	    0x17, 0x60, 0x4F, 0x05, 0xE5, 0x1F, 0x14, 0x44,
+	0x14, 0xEF, 0x56, 0xA3, 0xEC, 0x02, 0xE0, 0x1A, 0x13, 0x31, 0x7E, 0x21,
+	    0xD4, 0x5C, 0xBD, 0xD4, 0xD7, 0x66, 0x8D, 0x70,
+	0xEE, 0x74, 0x9E, 0x98, 0x65, 0x74, 0x85, 0x41, 0x3B, 0x80, 0x21, 0x55,
+	    0x56, 0x65, 0xCA, 0xE0, 0xE7, 0xF6, 0x4B, 0xD1,
+	0xA5, 0xE1, 0x10, 0xB7, 0x99, 0x4B, 0xEF, 0x55, 0x2A, 0x6A, 0x94, 0xA5,
+	    0xA7, 0x04, 0xF0, 0x06, 0x56, 0x29, 0x29, 0x44,
+	0xE1, 0xC2, 0x30, 0xFE, 0x3E, 0x8A, 0x9C, 0xB4, 0xA6, 0x05, 0x70, 0x25,
+	    0x32, 0x01, 0xFF, 0x7A, 0xE0, 0xC8, 0x2C, 0xE8,
+	0x56, 0xF7, 0x19, 0xA3, 0xDA, 0x80, 0xB8, 0x60, 0x31, 0x04, 0x51, 0xF4,
+	    0x67, 0x4C, 0xCF, 0xD7, 0x08, 0x4B, 0x11, 0x51,
+	0xCB, 0x0A, 0x75, 0xB5, 0x77, 0x26, 0x53, 0xA3, 0x9B, 0x6C, 0xC7, 0xD7,
+	    0x23, 0x16, 0x3C, 0x24, 0x6D, 0x33, 0x25, 0xAA,
+	0x9C, 0xB8, 0x81, 0x9A, 0xB0, 0x6B, 0xB6, 0x4E, 0x48, 0xA4, 0x3B, 0xE6,
+	    0xE9, 0xCB, 0xD8, 0xB6, 0x5D, 0xA6, 0xFA, 0xAE,
+	0x03, 0xC3, 0xDA, 0x3D, 0x40, 0xE6, 0x0B, 0xF3, 0x6C, 0x71, 0x63, 0x13,
+	    0x02, 0xAC, 0x09, 0xD1, 0x37, 0xA6, 0x25, 0xE9,
+	0xB4, 0x67, 0xA7, 0x0B, 0x0F, 0x4C, 0xFB, 0x37, 0xF4, 0xB0, 0xBB, 0x7C,
+	    0xE9, 0xD0, 0x2B, 0x40, 0xBC, 0xCB, 0x02, 0xED,
+	0xA9, 0x83, 0xF3, 0xBD, 0x9A, 0x27, 0x0A, 0x66, 0xAE, 0xD7, 0xAB, 0x6A,
+	    0xD3, 0x8F, 0x00, 0xDE, 0x26, 0x16, 0x4A, 0xAD,
+	0x6C, 0x59, 0x19, 0x18, 0x7C, 0xF8, 0x87, 0x39, 0x95, 0xAE, 0xD7, 0xA9,
+	    0x88, 0x84, 0xD6, 0xFE, 0x3D, 0x5B, 0xC5, 0x8D,
+	0x4C, 0xCA, 0x58, 0xCA, 0x0B, 0xF0, 0x0B, 0xFC, 0x28, 0xCD, 0xB4, 0x7B,
+	    0x43, 0x7E, 0x83, 0x1D, 0x30, 0x45, 0x40, 0xEC,
+	0xF5, 0xE5, 0x87, 0xF4, 0xAB, 0x16, 0x5C, 0x6E, 0xEC, 0x7B, 0xF9, 0x4A,
+	    0x73, 0x9D, 0x6F, 0x55, 0x47, 0x44, 0xD3, 0x16,
+	0x0A, 0xDF, 0x04, 0xBE, 0x11, 0xF3, 0x67, 0xB2, 0x1E, 0x21, 0xB8, 0x76,
+	    0x79, 0xF2, 0x21, 0xC3, 0xB7, 0x1F, 0xA1, 0x03,
+	0xE8, 0xF1, 0xCE, 0xAB, 0x41, 0x2D, 0x0F, 0x58, 0x7B, 0x74, 0x92, 0x61,
+	    0x84, 0xF2, 0xAE, 0x34, 0x37, 0xB7, 0xFD, 0x36,
+	0x06, 0xD5, 0x38, 0xB2, 0xF3, 0x03, 0x16, 0x82, 0x7A, 0xD6, 0x29, 0xD8,
+	    0x18, 0x40, 0x91, 0x80, 0xA7, 0x5E, 0x34, 0x63,
+	0xD3, 0x68, 0x0C, 0x60, 0x3F, 0x1E, 0x33, 0xD3, 0x31, 0xAC, 0xC2, 0x10,
+	    0xE5, 0xD1, 0xD3, 0x85, 0x51, 0x54, 0xAA, 0x0C,
+	0x23, 0x37, 0xB7, 0x9C, 0x0F, 0x0A, 0xF2, 0xF3, 0x64, 0x11, 0x4E, 0xBD,
+	    0x2F, 0x0B, 0x23, 0x31, 0x83, 0xD5, 0x20, 0x98,
+	0x4A, 0xCB, 0x98, 0x91, 0xA4, 0x27, 0xAF, 0x08, 0x1E, 0xD4, 0x7F, 0x56,
+	    0x89, 0x07, 0x94, 0xEC, 0x57, 0x7B, 0x16, 0x80,
+	0xCD, 0x54, 0x68, 0x2C, 0xD2, 0xD7, 0xAD, 0xE6, 0x1E, 0x03, 0x31, 0x4D,
+	    0x3E, 0xEB, 0x3E, 0x3E, 0x63, 0x94, 0xE6, 0xA7,
+	0xFF, 0x9E, 0x26, 0xED, 0x57, 0xD8, 0xA7, 0x7C, 0xD2, 0xF8, 0x7D, 0xB6,
+	    0x17, 0x41, 0x8F, 0xCF, 0xBE, 0x07, 0x97, 0x75,
+	0xBD, 0xD6, 0xCF, 0x38, 0x2A, 0xF9, 0x92, 0xC4, 0x70, 0x87, 0x2F, 0xDD,
+	    0xDE, 0x1B, 0xA5, 0x17, 0x0A, 0x47, 0x4F, 0xB0,
+	0xAB, 0x69, 0x74, 0x68, 0x88, 0xC1, 0xA0, 0x4B, 0x89, 0x01, 0x6D, 0xA8,
+	    0xD4, 0xDF, 0xEE, 0x27, 0x7B, 0xFF, 0x25, 0xFA,
+	0x50, 0xFD, 0x2A, 0x00, 0xF0, 0x00, 0xCC, 0x36, 0x5E, 0xE5, 0x70, 0xF0,
+	    0x9C, 0x25, 0x0F, 0x99, 0x11, 0x23, 0xE1, 0x8D,
+	0x01, 0x23, 0xB4, 0x28, 0x2A, 0xB7, 0x2B, 0xB9, 0x30, 0x12, 0x6D, 0x7C,
+	    0x54, 0x42, 0x98, 0x81, 0x2D, 0xF7, 0x84, 0xFD,
+	0x08, 0x41, 0x06, 0x77, 0x32, 0x2F, 0xC4, 0x53, 0x66, 0x02, 0xE8, 0x00,
+	    0xD2, 0x77, 0x76, 0xB0, 0xEA, 0x22, 0xE8, 0xBE,
+	0x47, 0x2C, 0x26, 0x94, 0xE6, 0x51, 0x2C, 0x47, 0x7B, 0x6E, 0xDE, 0x01,
+	    0xA4, 0x8F, 0x35, 0x76, 0xBA, 0x2D, 0x9E, 0xA0,
+	0xC3, 0xA2, 0xD2, 0x56, 0xF2, 0x6D, 0x50, 0x43, 0x26, 0x13, 0x76, 0x52,
+	    0x53, 0x63, 0x27, 0x94, 0x66, 0xEE, 0x09, 0xDC,
+	0x0D, 0x8E, 0x1F, 0x3C, 0xBE, 0x6D, 0x40, 0x27, 0xAA, 0x4A, 0x6E, 0x66,
+	    0x9C, 0xEB, 0x78, 0xC1, 0xD7, 0x67, 0x0D, 0xB8,
+	0x85, 0xCE, 0x0A, 0x70, 0xEE, 0xA2, 0x26, 0x77, 0xCE, 0xE8, 0xD9, 0x53,
+	    0x55, 0x9D, 0x98, 0x41, 0x84, 0xED, 0xA3, 0x50,
+	0x93, 0x66, 0xF1, 0x12, 0x4E, 0x90, 0x88, 0x6A, 0x37, 0x99, 0x4D, 0x53,
+	    0xE5, 0x01, 0xCD, 0x65, 0x11, 0x03, 0xF9, 0xE2,
+	0xB5, 0xEA, 0xD1, 0xF1, 0x8E, 0x30, 0xFA, 0xF4, 0x92, 0xF3, 0xCA, 0x08,
+	    0x9D, 0x2B, 0x85, 0x19, 0x62, 0xE7, 0x3E, 0xA9,
+	0xAF, 0x58, 0x75, 0x9C, 0x6E, 0x7D, 0x62, 0xBC, 0x6A, 0x5C, 0x64, 0x98,
+	    0x01, 0x98, 0xEB, 0xA1, 0xF8, 0xF6, 0x63, 0xE4,
+	0x89, 0x55, 0x3C, 0xBF, 0x9A, 0x08, 0x47, 0x5B, 0xA2, 0x49, 0x2D, 0xA8,
+	    0x27, 0x6C, 0x52, 0x52, 0x2C, 0xA4, 0xD4, 0xFD,
+	0x25, 0x82, 0x3B, 0xA7, 0xBE, 0x7D, 0x2F, 0x5F, 0x22, 0x6D, 0x33, 0x6D,
+	    0xAB, 0x07, 0x80, 0x2E, 0x97, 0x4E, 0xF6, 0xFB,
+	0x30, 0x4F, 0xB2, 0xC6, 0x4C, 0xEC, 0x3B, 0x79, 0xAA, 0x06, 0xF2, 0x61,
+	    0xE4, 0x2B, 0xFE, 0x6B, 0x3D, 0x09, 0x55, 0x3F,
+	0xBA, 0x6B, 0xC3, 0x8F, 0xE0, 0x08, 0x3C, 0xCF, 0x7C, 0x64, 0xED, 0x25,
+	    0x02, 0xFD, 0xAB, 0x2B, 0xB4, 0x2C, 0xCB, 0x9F,
+	0xA5, 0x4D, 0x39, 0x9C, 0x3A, 0xAC, 0x7B, 0x3D, 0x46, 0xE2, 0xAA, 0xE5,
+	    0x78, 0x0A, 0x9C, 0x40, 0x3F, 0xBD, 0x0B, 0x26,
+	0x36, 0x52, 0xA7, 0x14, 0x66, 0xF2, 0x6F, 0x63, 0x99, 0x99, 0x32, 0x30,
+	    0x0F, 0xCE, 0xD8, 0xEA, 0xFB, 0x32, 0xE4, 0xB8,
+	0x9C, 0x1E, 0xE5, 0xC7, 0x14, 0xF8, 0x51, 0xB0, 0x01, 0xED, 0xFF, 0x42,
+	    0x4D, 0x94, 0x33, 0x49, 0x65, 0x8F, 0x72, 0xDB,
+	0x91, 0x76, 0xB2, 0xA1, 0x62, 0xEC, 0x85, 0x25, 0x8A, 0xA7, 0x8D, 0x59,
+	    0x7D, 0x9E, 0xBD, 0x3F, 0xF2, 0x08, 0x7C, 0x3E,
+	0x24, 0xFF, 0xB6, 0xD4, 0x20, 0x6F, 0x32, 0xA5, 0x64, 0x26, 0x78, 0x77,
+	    0x57, 0x7E, 0x8C, 0x8D, 0xAA, 0x54, 0x71, 0x8B,
+	0xE6, 0x68, 0xFC, 0x8E, 0x09, 0x31, 0x5C, 0x0B, 0x92, 0xD6, 0x00, 0x45,
+	    0xFF, 0x41, 0xF2, 0x28, 0x65, 0xCA, 0x99, 0xD0,
+	0x66, 0xF9, 0x04, 0x96, 0xDC, 0xF7, 0x6E, 0x68, 0x7B, 0xC4, 0x66, 0x2D,
+	    0x47, 0x8C, 0x23, 0xF6, 0x0A, 0xDF, 0x0D, 0x0B,
+	0x98, 0xFF, 0xBD, 0x38, 0xF6, 0xC7, 0x38, 0xBD, 0x99, 0xC7, 0x68, 0x0C,
+	    0x78, 0x95, 0x56, 0xF1, 0xCE, 0x34, 0x0E, 0x61,
+	0xA8, 0x82, 0xB0, 0x3D, 0x45, 0xC6, 0xC1, 0x90, 0xD5, 0xF0, 0xF9, 0xC6,
+	    0x18, 0x7D, 0x39, 0xB4, 0x17, 0x41, 0xC2, 0xFA,
+	0x96, 0xE5, 0x69, 0x0C, 0x9F, 0x9F, 0xC1, 0xEA, 0x11, 0x43, 0x3D, 0x1D,
+	    0xA4, 0x9B, 0xB1, 0x3D, 0xCF, 0xE4, 0xAE, 0xC9,
+	0x92, 0xD5, 0xE6, 0xCE, 0xC8, 0xF2, 0xE1, 0xCE, 0xFE, 0x78, 0x5D, 0xBF,
+	    0x17, 0x97, 0x44, 0x17, 0x95, 0xF1, 0xD6, 0xFF,
+	0x14, 0xD4, 0xC4, 0x9F, 0xE9, 0xBD, 0x0E, 0xA5, 0x32, 0xE6, 0x9B, 0xAA,
+	    0x6A, 0xDD, 0xE9, 0x59, 0x8B, 0x3E, 0x7D, 0x3A,
+	0xEF, 0xB3, 0xCD, 0xCD, 0x51, 0x96, 0xDB, 0x59, 0x15, 0x1C, 0x62, 0x5C,
+	    0x4E, 0xFD, 0x47, 0xDD, 0x22, 0xD0, 0xEB, 0x20,
+	0x3A, 0x7D, 0xFC, 0xFE, 0x37, 0x1B, 0x1F, 0x84, 0xF2, 0xD2, 0x2A, 0x0A,
+	    0xA1, 0x2F, 0x11, 0x76, 0x6B, 0xB1, 0xEF, 0xA0,
+	0xBC, 0x89, 0xC1, 0x03, 0xF5, 0xE9, 0xCF, 0x29, 0x36, 0x14, 0xED, 0x94,
+	    0xA7, 0x73, 0x43, 0x2D, 0x2B, 0x15, 0x80, 0x56,
+	0x2B, 0x8D, 0x2F, 0xEE, 0x47, 0xD9, 0x7A, 0x31, 0x90, 0x49, 0x6A, 0x23,
+	    0xC2, 0x89, 0xBF, 0xA5, 0x66, 0xC3, 0xF7, 0xEE,
+	0x46, 0x58, 0x91, 0x67, 0xB5, 0xA8, 0xEB, 0x28, 0xAF, 0x57, 0x87, 0x5E,
+	    0x0B, 0x3E, 0xEF, 0x6E, 0x00, 0x6F, 0xE0, 0xB8,
+	0x99, 0x59, 0x7A, 0xF1, 0x43, 0x3B, 0x88, 0x8E, 0x87, 0xAB, 0xF3, 0x2C,
+	    0x86, 0x88, 0xC8, 0xC4, 0x97, 0xAF, 0xB8, 0xFF,
+	0x86, 0xCD, 0x02, 0x52, 0x3C, 0xA6, 0x24, 0xBF, 0x72, 0x7D, 0x83, 0x47,
+	    0x63, 0x2F, 0x4F, 0x26, 0x0C, 0xEE, 0xF0, 0x81,
+	0xE5, 0xA0, 0xD6, 0x11, 0x26, 0xC5, 0x2B, 0xD3, 0xA0, 0x56, 0xAD, 0x00,
+	    0x8E, 0x4D, 0xDD, 0x86, 0xF9, 0xEB, 0xC5, 0x8E,
+	0x75, 0xA0, 0x6F, 0xAE, 0x3E, 0xB2, 0x60, 0x14, 0x2D, 0x3D, 0xA8, 0x2C,
+	    0xEF, 0x45, 0xBD, 0x68, 0xE6, 0x58, 0x12, 0xE5,
+	0x6E, 0xA9, 0x93, 0x44, 0xD8, 0x44, 0xF2, 0xAA, 0xD0, 0x64, 0x1D, 0x6E,
+	    0xCE, 0x25, 0x0B, 0xAF, 0xAF, 0x2E, 0x2D, 0x64,
+	0x31, 0xB6, 0xAA, 0x5F, 0x5C, 0xFC, 0x15, 0x27, 0x00, 0x2D, 0xCB, 0xB5,
+	    0xCF, 0xE9, 0x46, 0xD1, 0x31, 0x28, 0x5C, 0xC0,
+	0x3C, 0x3D, 0xED, 0x48, 0xF5, 0x51, 0xEA, 0xCF, 0x2D, 0xEA, 0xF5, 0x81,
+	    0xA7, 0x84, 0xAC, 0xDE, 0x80, 0x47, 0xF6, 0xB5,
+	0x38, 0x8D, 0xF2, 0x57, 0xE2, 0x24, 0x76, 0xCB, 0xC3, 0x31, 0xB8, 0x8D,
+	    0x31, 0x60, 0x31, 0x4D, 0x7D, 0x23, 0x59, 0xB0,
+	0xFF, 0x6E, 0x65, 0x6D, 0x13, 0x63, 0xA5, 0xBD, 0x37, 0x87, 0x03, 0x39,
+	    0x70, 0x81, 0x6D, 0x3F, 0xDF, 0x52, 0xD7, 0xE8,
+	0x8E, 0x33, 0x85, 0xCB, 0x36, 0x2C, 0x1A, 0xBE, 0x22, 0x68, 0x48, 0xE9,
+	    0xEA, 0xED, 0x6F, 0x3D, 0x62, 0xB8, 0x94, 0x2C,
+	0x75, 0x19, 0x93, 0x70, 0xCC, 0x60, 0x19, 0x6B, 0x16, 0xC4, 0xC5, 0x59,
+	    0xD6, 0x93, 0x68, 0x92, 0x55, 0x52, 0xE6, 0xFD,
+	0x07, 0xF7, 0x46, 0xC7, 0xAA, 0x69, 0x37, 0xD1, 0xDB, 0x82, 0x75, 0xFA,
+	    0x7D, 0xBE, 0x52, 0x6B, 0xA5, 0xE8, 0xB3, 0xB9,
+	0xD4, 0x08, 0x7B, 0xA0, 0x31, 0xD0, 0x39, 0x17, 0xDB, 0x01, 0x5A, 0x7E,
+	    0x1A, 0x6B, 0x3A, 0xF4, 0x14, 0xD6, 0x72, 0xB6,
+	0xD3, 0xB8, 0x22, 0x62, 0x2B, 0xE8, 0xAC, 0x5F, 0xEE, 0x9F, 0x2C, 0x32,
+	    0xC4, 0x48, 0x81, 0x81, 0x6E, 0xB9, 0x47, 0x47,
+	0x15, 0x5A, 0x5B, 0x7A, 0x90, 0xFA, 0xA1, 0x43, 0xEB, 0x5E, 0xB1, 0x0D,
+	    0x5B, 0xB4, 0xE3, 0x56, 0x1D, 0x55, 0x39, 0xA0,
+	0xEE, 0x1B, 0xF7, 0xD6, 0xE2, 0xBE, 0xB9, 0x00, 0xEE, 0x7A, 0xAF, 0x84,
+	    0xDA, 0xB5, 0xF6, 0x7B, 0x52, 0x8B, 0xB7, 0x76,
+	0xD8, 0xFA, 0x91, 0x0B, 0xE1, 0xDE, 0x76, 0xF3, 0x11, 0xBA, 0xEE, 0x7A,
+	    0xC6, 0xF5, 0x74, 0x8A, 0xDC, 0xBF, 0x6A, 0x38,
+	0xDF, 0x4B, 0x9E, 0x41, 0x88, 0x7A, 0xF8, 0xC9, 0xDB, 0x1F, 0x79, 0x06,
+	    0x8F, 0xFC, 0x46, 0x32, 0x4D, 0x7C, 0x69, 0x26,
+	0xFA, 0x02, 0x76, 0xC8, 0x08, 0x3D, 0xDE, 0x07, 0x1E, 0xDE, 0x07, 0x28,
+	    0xCF, 0xD1, 0x1F, 0x41, 0x8E, 0x2E, 0x2C, 0xD7,
+	0x95, 0xF0, 0xE0, 0x33, 0x32, 0xFE, 0xFE, 0x6F, 0x85, 0x94, 0x79, 0xA4,
+	    0x16, 0x9F, 0xD5, 0x49, 0xA3, 0xDF, 0xD0, 0xAC,
+	0xBD, 0xAA, 0xC9, 0xFC, 0x4B, 0xC6, 0x2E, 0x0D, 0x59, 0x5D, 0xD8, 0x58,
+	    0x2A, 0x61, 0x7B, 0x8A, 0xB8, 0x76, 0x5B, 0x3E,
+	0x1A, 0xBA, 0x89, 0x4A, 0x0B, 0x5D, 0xAA, 0x1E, 0x50, 0xF3, 0x2C, 0x3D,
+	    0x3A, 0x1C, 0x9F, 0x8D, 0x10, 0xD4, 0x2D, 0xFD,
+	0x01, 0xBE, 0x3A, 0xEF, 0xEB, 0x31, 0x34, 0x77, 0x7E, 0x2F, 0xD0, 0xAD,
+	    0x51, 0x30, 0x23, 0x95, 0x56, 0xDB, 0x51, 0x0E,
+	0xE4, 0xFE, 0x8E, 0x7F, 0x70, 0x8B, 0x69, 0x1C, 0xE0, 0x2D, 0xB3, 0x4A,
+	    0x80, 0xCC, 0x7F, 0x2D, 0x3B, 0x5D, 0xBC, 0x75,
+	0x24, 0x2B, 0x90, 0x20, 0xD0, 0x44, 0x88, 0x7E, 0x2D, 0xDE, 0xB0, 0x56,
+	    0x5F, 0x09, 0xD1, 0x81, 0x97, 0xEB, 0x7F, 0x18,
+	0x62, 0x45, 0xCB, 0x67, 0x62, 0xE9, 0xD7, 0xD1, 0x7E, 0x0F, 0xC8, 0x40,
+	    0xB4, 0xB7, 0x68, 0xE5, 0xC4, 0x86, 0xA8, 0xD4,
+	0x9E, 0xCB, 0xDF, 0x61, 0xA2, 0xBA, 0xCC, 0xF3, 0x12, 0x05, 0xE8, 0xC8,
+	    0xA2, 0x26, 0xDA, 0x46, 0x33, 0x69, 0xC1, 0xD0,
+	0xF6, 0xAB, 0x71, 0xFD, 0xB0, 0xE4, 0xE1, 0xF5, 0x44, 0xD5, 0x75, 0x1E,
+	    0xB9, 0x69, 0x77, 0x6D, 0xAD, 0x98, 0x4E, 0x49,
+	0x13, 0xE0, 0x22, 0x41, 0xFB, 0x05, 0xA6, 0x06, 0x70, 0xE4, 0xD8, 0xE0,
+	    0xBA, 0x45, 0x98, 0x6E, 0xE7, 0x33, 0x63, 0x1C,
+	0xE9, 0x24, 0x15, 0x66, 0x69, 0x97, 0x8A, 0x46, 0x84, 0x6B, 0x8A, 0xF1,
+	    0x09, 0x72, 0x22, 0x7F, 0xD3, 0x46, 0xE2, 0x74,
+	0xAE, 0x05, 0xF8, 0x01, 0x2D, 0x11, 0x22, 0x6B, 0x63, 0xB1, 0x75, 0x05,
+	    0x6B, 0x2F, 0xAD, 0x88, 0x19, 0xE0, 0xA0, 0x9C,
+	0x1A, 0x34, 0x8B, 0x99, 0xDC, 0xD1, 0x42, 0x27, 0x74, 0x84, 0x24, 0xA6,
+	    0x2C, 0xFD, 0x7C, 0xE9, 0x72, 0xA3, 0x52, 0x3E,
+	0xF1, 0xFD, 0xC8, 0xCE, 0x44, 0x4A, 0x74, 0x96, 0xFF, 0xC7, 0x34, 0x5F,
+	    0xAA, 0x48, 0x35, 0x2E, 0x35, 0xF2, 0xF8, 0x0E,
+	0xBC, 0x23, 0x6B, 0x9E, 0xA7, 0x29, 0xE3, 0x3A, 0xA8, 0x9D, 0xFD, 0x71,
+	    0xFA, 0x6E, 0x36, 0xA9, 0x69, 0x55, 0xAB, 0x69,
+	0x3A, 0x11, 0xF5, 0xDC, 0x7C, 0x6A, 0x92, 0xCC, 0x3E, 0x10, 0x39, 0x78,
+	    0xCA, 0xCE, 0x68, 0x7A, 0xDF, 0x84, 0xE3, 0x40,
+	0x60, 0xB0, 0x14, 0x9A, 0x4C, 0xC4, 0xD3, 0x5F, 0x17, 0x50, 0xB4, 0x35,
+	    0x76, 0xB8, 0x7D, 0xA4, 0x80, 0xE0, 0x5C, 0x10,
+	0x74, 0xD4, 0x24, 0x4A, 0xCD, 0x5C, 0x67, 0x93, 0xD0, 0xD0, 0x10, 0x83,
+	    0xA2, 0x14, 0xD5, 0x9F, 0x9A, 0x86, 0x32, 0xA7,
+	0x30, 0x36, 0x23, 0x82, 0x5C, 0x7F, 0xF2, 0xFF, 0x2C, 0xE5, 0xB5, 0x66,
+	    0xDB, 0x56, 0x62, 0x8C, 0x5E, 0x8E, 0xCD, 0x4A,
+	0x18, 0x82, 0xFE, 0x3F, 0x2C, 0xAB, 0x57, 0xCF, 0x91, 0xB1, 0x2A, 0xE7,
+	    0x9F, 0x5B, 0xCF, 0x97, 0x4A, 0xD5, 0x2B, 0x20,
+	0xA3, 0x57, 0x9A, 0x36, 0xC4, 0xC8, 0xE4, 0x0B, 0x96, 0x39, 0x60, 0x14,
+	    0x77, 0x47, 0xE9, 0x29, 0x6B, 0x5B, 0xD3, 0xA0,
+	0x4D, 0xAB, 0x8A, 0xE0, 0xD1, 0xF4, 0xED, 0xD5, 0xA9, 0x49, 0xC2, 0x54,
+	    0xA0, 0x46, 0xDB, 0xB7, 0x4C, 0xEA, 0x3A, 0x31,
+	0xEA, 0x4C, 0x61, 0x95, 0xE4, 0xFC, 0x4E, 0x98, 0x60, 0x49, 0xBE, 0x7F,
+	    0x5E, 0x7A, 0x45, 0x46, 0xE7, 0xF5, 0x45, 0xEB,
+	0x76, 0xA7, 0x7F, 0xA9, 0x88, 0x9B, 0xB6, 0x6F, 0x57, 0x5C, 0xFF, 0xF8,
+	    0x29, 0x65, 0x14, 0x8B, 0x8C, 0x76, 0x27, 0x88,
+	0xB0, 0x1C, 0x0D, 0xBA, 0x14, 0x5F, 0xC1, 0x26, 0x01, 0x99, 0x28, 0x28,
+	    0x07, 0x38, 0x77, 0x9B, 0xC1, 0x66, 0xB7, 0x6E,
+	0x8B, 0x96, 0x15, 0xB8, 0x70, 0xF6, 0x2B, 0xC2, 0x5A, 0x3A, 0xF9, 0x4D,
+	    0x24, 0x96, 0x12, 0x32, 0xC7, 0xBD, 0xF4, 0x9E,
+	0xD1, 0xE3, 0x29, 0x1F, 0x0A, 0xD3, 0xF6, 0x47, 0x2D, 0xE5, 0x68, 0x26,
+	    0xB6, 0x40, 0x02, 0x03, 0x08, 0x6C, 0xA0, 0xD0,
+	0x92, 0x2C, 0x90, 0x36, 0x27, 0x0C, 0xEF, 0x36, 0x4F, 0xBD, 0xEC, 0xAE,
+	    0xEC, 0x97, 0xC0, 0x1E, 0xC6, 0xF3, 0x09, 0x19,
+	0xB5, 0x04, 0xA9, 0xB8, 0x04, 0xB2, 0xCC, 0x7D, 0x8E, 0x18, 0xC9, 0x9F,
+	    0x9B, 0xEB, 0xDF, 0x86, 0x56, 0xC2, 0x1F, 0xE4,
+	0x94, 0x22, 0xA0, 0x3C, 0x22, 0x34, 0xF8, 0x06, 0xBD, 0x63, 0x84, 0x8D,
+	    0xF4, 0x57, 0x57, 0xFE, 0x87, 0xEC, 0x6D, 0x3C,
+	0x73, 0xB5, 0x86, 0x9E, 0x3D, 0xEC, 0x5A, 0x0B, 0x21, 0x3D, 0x61, 0x53,
+	    0xF5, 0xAF, 0xE7, 0x39, 0xF6, 0x76, 0xBF, 0x82,
+	0xF5, 0xB0, 0x21, 0x1B, 0x7C, 0x05, 0xD6, 0xEF, 0x95, 0xD8, 0xEC, 0x20,
+	    0xFB, 0x87, 0x46, 0x44, 0xBB, 0x80, 0x58, 0xC7,
+	0xF9, 0x29, 0x1D, 0xBD, 0x65, 0xA4, 0x48, 0x32, 0x47, 0xCB, 0xB5, 0x8B,
+	    0x1E, 0x69, 0x56, 0xA7, 0x75, 0x2A, 0xFE, 0x33,
+	0xE8, 0x38, 0x72, 0x70, 0xE4, 0x58, 0x1F, 0xF2, 0x20, 0x4A, 0x38, 0x7A,
+	    0x6D, 0xC2, 0x21, 0xC2, 0x33, 0x5B, 0x21, 0xDB,
+	0x86, 0xCB, 0x8E, 0x9A, 0x7B, 0x3D, 0xCD, 0x2D, 0x5B, 0x88, 0x3A, 0xA9,
+	    0x6A, 0x06, 0x06, 0x34, 0xA4, 0xE7, 0x24, 0x66,
+	0xAC, 0x18, 0xA2, 0x70, 0xCE, 0x88, 0xA6, 0xE2, 0x1C, 0xEA, 0x14, 0x86,
+	    0xC0, 0xC5, 0x49, 0x5D, 0x7E, 0x19, 0x23, 0x98,
+	0xBF, 0xD8, 0x8C, 0xB3, 0x99, 0x0D, 0x47, 0xD2, 0xD9, 0x84, 0x41, 0xC6,
+	    0x5D, 0x52, 0x6B, 0x22, 0x8A, 0xF8, 0x29, 0xD2,
+	0x61, 0xA5, 0x25, 0x49, 0xA4, 0xC7, 0x4C, 0x5C, 0xA0, 0x39, 0x13, 0xE4,
+	    0x38, 0xE7, 0x7A, 0x18, 0x24, 0xA4, 0xFF, 0xBE,
+	0xC3, 0x41, 0x3F, 0xBB, 0xD3, 0x64, 0xA2, 0xDA, 0x71, 0x21, 0xDA, 0xB1,
+	    0xEB, 0xCF, 0xB2, 0x1E, 0x65, 0xA0, 0x2D, 0x88,
+	0x29, 0x1A, 0xC0, 0xDE, 0x52, 0x71, 0x94, 0x58, 0xEA, 0x2E, 0xC0, 0x4A,
+	    0x4C, 0x62, 0x84, 0x57, 0xB6, 0xDC, 0xF4, 0x1A,
+	0xFA, 0x85, 0x18, 0x30, 0xFE, 0xA2, 0xB7, 0x94, 0xFD, 0xDA, 0x33, 0x93,
+	    0x35, 0x63, 0x63, 0xE3, 0xBC, 0xE9, 0x4D, 0xAC,
+	0x13, 0x02, 0xDB, 0x09, 0xAD, 0xF9, 0x57, 0xEC, 0xC0, 0xE5, 0xBD, 0xE2,
+	    0x04, 0xCD, 0x74, 0xB6, 0x74, 0x1F, 0xE2, 0x9F,
+	0x9B, 0x7D, 0xEA, 0x06, 0xAA, 0x5B, 0xEC, 0x1E, 0xA7, 0xD3, 0x6C, 0xC2,
+	    0x8F, 0x0E, 0x03, 0x2D, 0x94, 0x07, 0x82, 0x4B,
+	0x3C, 0x2A, 0xE5, 0x0F, 0x81, 0xEF, 0x05, 0xF5, 0xDE, 0x91, 0xE7, 0x1F,
+	    0x13, 0xBC, 0xE1, 0x75, 0x71, 0xD1, 0xEF, 0xE7,
+	0xA3, 0x01, 0x86, 0xE9, 0x64, 0x46, 0x35, 0xA3, 0x7C, 0x5B, 0xE5, 0xBF,
+	    0xF3, 0x19, 0x00, 0xB4, 0xAB, 0x12, 0x86, 0xC6,
+	0x81, 0x41, 0x13, 0xC4, 0x8B, 0xB6, 0x89, 0x81, 0x55, 0xB4, 0x4C, 0x52,
+	    0x21, 0x6D, 0x32, 0x5F, 0x7F, 0x64, 0x26, 0x32,
+	0x1B, 0xD1, 0xA6, 0x36, 0x1F, 0xA4, 0xE1, 0x03, 0xAA, 0x56, 0x45, 0xF9,
+	    0x3A, 0xF4, 0x0A, 0xC3, 0x94, 0x76, 0xB0, 0x80,
+	0xD7, 0xD7, 0xB3, 0x94, 0x4E, 0x4C, 0xD3, 0xEB, 0x3A, 0x31, 0xFF, 0x1B,
+	    0x77, 0x1A, 0x84, 0x91, 0x96, 0xD7, 0xE6, 0x74,
+	0x3C, 0xD5, 0xF7, 0xB0, 0x52, 0xFA, 0xB6, 0xE1, 0xD5, 0x52, 0x07, 0x2A,
+	    0x0B, 0x38, 0x3C, 0x42, 0x9E, 0x44, 0x09, 0x2E,
+	0xC5, 0xAA, 0x6B, 0xBC, 0xA5, 0xCA, 0x06, 0x4D, 0x09, 0xE9, 0xD8, 0xE4,
+	    0xC4, 0x97, 0xF8, 0xE7, 0x68, 0xD9, 0xB3, 0xCB,
+	0xB4, 0x7E, 0xBB, 0x43, 0xCF, 0xC6, 0xD7, 0x93, 0x50, 0xD4, 0x9C, 0x2A,
+	    0x41, 0x78, 0x9B, 0xC8, 0x8B, 0xD4, 0x07, 0x4C,
+	0x81, 0x56, 0x04, 0xCB, 0x2D, 0xFC, 0x64, 0x8E, 0x96, 0xA7, 0xE1, 0xDA,
+	    0x6D, 0x73, 0xEE, 0x7B, 0x86, 0xAD, 0xE1, 0xF9,
+	0x2B, 0xA4, 0x96, 0xD6, 0xDF, 0x3C, 0x00, 0xFD, 0x96, 0xD2, 0x8D, 0xB9,
+	    0x82, 0x5B, 0xA7, 0x96, 0x64, 0xDC, 0xA1, 0xA9,
+	0x45, 0x15, 0xD7, 0x99, 0x8C, 0xE8, 0x40, 0xC6, 0xF8, 0x37, 0xE8, 0x59,
+	    0x41, 0xAE, 0xC7, 0x2C, 0x3B, 0x12, 0x42, 0x3C,
+	0x2D, 0xFF, 0xE8, 0x81, 0x35, 0x6E, 0x48, 0x15, 0xD4, 0x91, 0x40, 0xDC,
+	    0xB8, 0xA1, 0x6E, 0x26, 0xA1, 0xC3, 0x54, 0xF4,
+	0x2E, 0x1F, 0x9D, 0x01, 0x35, 0xAC, 0xDA, 0x9E, 0x17, 0x9B, 0x41, 0x23,
+	    0xA4, 0xB7, 0x7D, 0xC4, 0xD1, 0x7E, 0xA6, 0x38,
+	0x48, 0x53, 0xD9, 0xF6, 0x14, 0xAF, 0x67, 0xD2, 0x4C, 0x03, 0x48, 0x25,
+	    0x5F, 0x9F, 0x98, 0x56, 0x43, 0xA3, 0xDF, 0xF8,
+	0x99, 0x78, 0xE2, 0xD9, 0xF1, 0x0E, 0x02, 0xBF, 0xD2, 0x83, 0x66, 0xE0,
+	    0x28, 0xAB, 0xC3, 0xAE, 0x13, 0xB4, 0x00, 0x1A,
+	0x28, 0xB5, 0xAF, 0x95, 0xF1, 0x24, 0x68, 0x55, 0xCB, 0x06, 0xB7, 0xB9,
+	    0x17, 0xA8, 0x66, 0x4C, 0x45, 0xED, 0x17, 0x9A,
+	0xFF, 0x68, 0x11, 0x52, 0xA8, 0x45, 0xFF, 0x20, 0x9C, 0xA4, 0x2F, 0x5C,
+	    0x42, 0x16, 0xEF, 0xC1, 0xD4, 0x45, 0x99, 0xB9,
+	0xCD, 0xAA, 0x36, 0xD1, 0xF5, 0xD3, 0x26, 0x0F, 0x60, 0x22, 0x24, 0x32,
+	    0x2A, 0x11, 0x0A, 0x42, 0xE1, 0x79, 0xF4, 0xE5,
+	0xA9, 0x6A, 0x6D, 0x6F, 0xBD, 0xFE, 0x2F, 0x15, 0xED, 0xFB, 0xF2, 0x29,
+	    0x31, 0x4B, 0xEC, 0xE7, 0x96, 0xD4, 0x38, 0xDA,
+	0xA0, 0x2A, 0xF9, 0x5A, 0xE6, 0x72, 0x79, 0x69, 0xCE, 0x81, 0xC8, 0x36,
+	    0x9E, 0xA8, 0x83, 0xD8, 0x6B, 0xBA, 0xC3, 0x5A,
+	0xDE, 0x71, 0x5F, 0xF5, 0x60, 0x7A, 0xEC, 0x63, 0x53, 0x24, 0x45, 0xDB,
+	    0x95, 0xCF, 0x6D, 0x5B, 0xE5, 0x24, 0x12, 0xAE,
+	0x88, 0x0F, 0x02, 0x55, 0x43, 0x87, 0xED, 0x8A, 0x56, 0x3B, 0xAD, 0x16,
+	    0xCC, 0xF3, 0x74, 0xFC, 0xAC, 0x0B, 0xF8, 0x6C,
+	0xFB, 0x82, 0xE7, 0xFC, 0x02, 0xF2, 0x65, 0x27, 0x8A, 0xB0, 0x46, 0xAB,
+	    0xB9, 0x1C, 0xBB, 0x59, 0x73, 0x47, 0x13, 0x26,
+	0xF5, 0xBE, 0x13, 0x01, 0x78, 0xD2, 0x1B, 0x44, 0x28, 0x14, 0x6B, 0x2E,
+	    0x38, 0xAC, 0xE0, 0x9B, 0x67, 0xB2, 0xF0, 0x80,
+	0xDB, 0xB4, 0x7A, 0x86, 0xC1, 0x93, 0xDD, 0x37, 0x95, 0x39, 0x17, 0xB4,
+	    0x03, 0x58, 0xAE, 0x4C, 0x96, 0x3F, 0x56, 0x45,
+	0x49, 0x12, 0xAB, 0xE2, 0x12, 0x6A, 0x22, 0x74, 0x09, 0x5C, 0xCC, 0x45,
+	    0x5B, 0x51, 0x36, 0x72, 0x2C, 0x53, 0x05, 0xA6,
+	0x75, 0x29, 0x03, 0x65, 0x0B, 0x18, 0x94, 0x43, 0xD4, 0x86, 0x73, 0x97,
+	    0x40, 0x90, 0xD4, 0xB3, 0x14, 0x0C, 0x0F, 0x31,
+	0x0A, 0x17, 0xC7, 0xF9, 0x99, 0x50, 0x94, 0x22, 0x24, 0x0F, 0x04, 0xD8,
+	    0x4B, 0x5A, 0x6E, 0x0E, 0xD9, 0x4B, 0xE6, 0x1B,
+	0x86, 0x7B, 0x04, 0xD4, 0xA6, 0x96, 0xCB, 0xA7, 0x1E, 0x57, 0x1A, 0xE3,
+	    0xBF, 0x16, 0x3F, 0x34, 0x27, 0xC0, 0x8F, 0x45,
+	0xD9, 0x03, 0x05, 0xDD, 0x01, 0x3E, 0x3D, 0x83, 0x1D, 0x14, 0x79, 0x9E,
+	    0x2C, 0xEB, 0xDD, 0xCF, 0x97, 0xE3, 0x32, 0xA6,
+	0x9E, 0xB5, 0xFE, 0x50, 0x3B, 0x54, 0x0D, 0xCA, 0xD9, 0x35, 0xF4, 0x7B,
+	    0xA4, 0x59, 0x91, 0xFE, 0x4A, 0x3B, 0x2C, 0x18,
+	0xFA, 0x1A, 0x56, 0x74, 0x5B, 0x75, 0x1C, 0xCE, 0xC2, 0x5D, 0x36, 0x73,
+	    0x0A, 0xFE, 0x60, 0xBE, 0x88, 0xDA, 0x79, 0xFC,
+	0x35, 0xD9, 0x39, 0x48, 0xC0, 0x17, 0x39, 0xA5, 0x8B, 0xAC, 0x5C, 0x8A,
+	    0x88, 0x59, 0x68, 0xDE, 0xDA, 0x16, 0x35, 0x29,
+	0x43, 0xB4, 0x37, 0xB0, 0x1E, 0x76, 0x7E, 0x3D, 0xB2, 0xF8, 0xCB, 0xCE,
+	    0xD3, 0xFC, 0xD3, 0xD2, 0x5A, 0xA8, 0xB9, 0x21,
+	0xCD, 0x7E, 0x75, 0xD5, 0x4E, 0x1E, 0xC8, 0x13, 0x86, 0x5F, 0x30, 0x7C,
+	    0xC0, 0x3E, 0x9A, 0xC7, 0x1D, 0xC0, 0x51, 0x09,
+	0xC8, 0xDD, 0x4E, 0xBB, 0x5F, 0x3F, 0x50, 0xC6, 0xDE, 0x93, 0x15, 0xD2,
+	    0x9E, 0xCA, 0x4C, 0x08, 0xEC, 0xEE, 0x17, 0xF8,
+	0x6E, 0x10, 0x31, 0x79, 0x40, 0xEE, 0x0F, 0x7C, 0x86, 0xE0, 0x61, 0x9C,
+	    0x0B, 0xDE, 0x5C, 0x66, 0xFD, 0x8F, 0x58, 0x32,
+	0xA9, 0xC2, 0xA8, 0x0F, 0x12, 0x3A, 0xA0, 0xD1, 0xC8, 0xCD, 0x08, 0xE1,
+	    0x96, 0x32, 0x50, 0x03, 0x3D, 0x85, 0x68, 0x86,
+	0xCC, 0x01, 0x06, 0xF6, 0x2D, 0xCC, 0x28, 0x71, 0xA8, 0x57, 0x75, 0xEF,
+	    0x25, 0x02, 0x96, 0x79, 0x48, 0xAD, 0xCA, 0x04,
+	0x65, 0x3D, 0xB9, 0x07, 0x51, 0xCA, 0x0E, 0x37, 0x07, 0x44, 0xE5, 0x64,
+	    0x9E, 0xCF, 0xA9, 0xC2, 0x66, 0x83, 0x46, 0x49,
+	0x07, 0x3C, 0xE5, 0x24, 0xF1, 0x94, 0x51, 0xC2, 0x42, 0x25, 0x08, 0xAD,
+	    0xAD, 0x60, 0xF6, 0xE4, 0xD6, 0x83, 0x64, 0xD6,
+	0x55, 0xEC, 0x13, 0xA7, 0xB4, 0x65, 0xDC, 0x01, 0x73, 0xCA, 0xA6, 0x94,
+	    0xD7, 0x60, 0xD9, 0xBC, 0x80, 0xFD, 0x76, 0xB8,
+	0x67, 0x75, 0x66, 0x65, 0x0E, 0x57, 0xC9, 0x07, 0xC6, 0xEB, 0x30, 0x5E,
+	    0x22, 0x78, 0xD7, 0x32, 0x77, 0x26, 0xCD, 0x00,
+	0xFB, 0xC8, 0x06, 0x49, 0x74, 0xE4, 0xE7, 0x68, 0x6C, 0xF8, 0xC0, 0x13,
+	    0x1D, 0xBC, 0x0C, 0xEB, 0xAC, 0x67, 0xEB, 0x08,
+	0xF9, 0x84, 0xD8, 0xE9, 0x81, 0xC8, 0xD1, 0x39, 0xBC, 0x16, 0xAA, 0x48,
+	    0xA6, 0xE3, 0xDD, 0xCE, 0xDD, 0xF6, 0x5D, 0x0D,
+	0x6D, 0x09, 0x33, 0xFC, 0x10, 0xA7, 0x93, 0x38, 0x6F, 0xAE, 0x77, 0xD4,
+	    0x51, 0x17, 0x71, 0xEF, 0xE5, 0x08, 0x6B, 0x73,
+	0x3F, 0xEA, 0x1D, 0xFA, 0xCA, 0xC8, 0x20, 0xB5, 0xDE, 0x2B, 0x63, 0x2C,
+	    0x8C, 0x88, 0x50, 0xBD, 0x9A, 0x01, 0xC5, 0xCE,
+	0xBA, 0xEF, 0xFC, 0xEA, 0x29, 0x2C, 0xD5, 0xB8, 0xA3, 0x20, 0x69, 0x8A,
+	    0x90, 0xEF, 0xC5, 0x38, 0xEE, 0x38, 0x88, 0x1C,
+	0x7E, 0xFD, 0x33, 0x14, 0x2D, 0xEB, 0x9B, 0xFF, 0x2A, 0xEC, 0x44, 0xCB,
+	    0x3E, 0x3F, 0x2C, 0x6F, 0x5C, 0xEA, 0x3B, 0xB9,
+	0x23, 0x22, 0xE8, 0xB4, 0x9E, 0x6D, 0xE8, 0x34, 0x32, 0xB3, 0xC3, 0x8E,
+	    0x7C, 0xEB, 0x80, 0xA6, 0x47, 0x24, 0x48, 0x14,
+	0x7C, 0xB8, 0xF4, 0x7A, 0x27, 0xDD, 0x36, 0xC8, 0x17, 0x44, 0x7E, 0x24,
+	    0xCE, 0xF5, 0x94, 0x04, 0x37, 0xB9, 0xDB, 0xC8,
+	0xB3, 0xDB, 0xA2, 0xD4, 0xF7, 0x36, 0xB2, 0x70, 0x20, 0x1F, 0xB9, 0x05,
+	    0x06, 0x60, 0x4E, 0x84, 0x45, 0xBE, 0xA3, 0x06,
+	0xF2, 0x68, 0xBD, 0x63, 0xB0, 0x62, 0xE0, 0xD1, 0xBC, 0xA8, 0x3C, 0x37,
+	    0xB6, 0x59, 0x3C, 0x55, 0x09, 0xD0, 0x99, 0xAD,
+	0xAB, 0x32, 0x50, 0xA4, 0xC9, 0x1F, 0xC5, 0x11, 0xE2, 0x79, 0x20, 0xA0,
+	    0x46, 0xB8, 0xE6, 0x5E, 0x86, 0x4A, 0xB8, 0xAA,
+	0xC4, 0xD0, 0xFF, 0xC2, 0x1B, 0x2A, 0x84, 0xD1, 0xD4, 0xB9, 0xF6, 0x03,
+	    0x8E, 0xD4, 0x9D, 0xC3, 0x4F, 0xF4, 0x0D, 0x53,
+	0x52, 0x94, 0x64, 0x65, 0x58, 0xB9, 0xD9, 0xB1, 0x58, 0x1A, 0xD5, 0x2C,
+	    0x3A, 0x4A, 0x46, 0x4F, 0x10, 0x95, 0x6F, 0x75,
+	0x59, 0x75, 0x58, 0x8C, 0xCD, 0x1B, 0x94, 0xE8, 0x0F, 0xED, 0x8D, 0x48,
+	    0xC0, 0x25, 0x76, 0xD2, 0xB2, 0xFB, 0x10, 0x3F,
+	0x45, 0x94, 0x95, 0x7C, 0x91, 0x04, 0x06, 0x8A, 0x6E, 0x76, 0x06, 0x8F,
+	    0x5F, 0x56, 0xD5, 0x78, 0x20, 0xDB, 0x5F, 0x0B,
+	0x95, 0xB0, 0x4F, 0xD8, 0xEB, 0x7B, 0xF3, 0x3F, 0xCF, 0xCB, 0x39, 0xF9,
+	    0xCD, 0x8F, 0xD7, 0xBB, 0x04, 0xD9, 0x9F, 0xC9,
+	0x8F, 0xCD, 0x6F, 0x1F, 0xBD, 0x4B, 0x1D, 0x31, 0xC7, 0xDF, 0x81, 0x31,
+	    0xCB, 0x2A, 0xF5, 0x36, 0x68, 0x0C, 0x8E, 0xC9,
+	0xDD, 0xFA, 0x3A, 0x66, 0xC4, 0xBE, 0xD0, 0x7F, 0x39, 0x9E, 0x03, 0xBA,
+	    0x25, 0x9F, 0x86, 0xB8, 0x21, 0xFB, 0xF0, 0x38,
+	0x88, 0x33, 0x1C, 0x3E, 0x1D, 0xFE, 0xBD, 0x2C, 0xE8, 0x4E, 0x03, 0xF6,
+	    0x5D, 0x9B, 0x50, 0x6A, 0x8D, 0x30, 0x20, 0x25,
+	0x13, 0xB2, 0xFC, 0x82, 0x60, 0x9D, 0x8D, 0x57, 0x5C, 0xBE, 0x3A, 0xE8,
+	    0x5E, 0x4F, 0xBE, 0xFD, 0x60, 0x8F, 0x80, 0xC8,
+	0x9C, 0x8D, 0xB7, 0x52, 0x73, 0x00, 0xFE, 0x59, 0xA0, 0x6D, 0xF6, 0x13,
+	    0xB0, 0x60, 0x43, 0x30, 0x3A, 0x81, 0xEA, 0x9C,
+	0xF0, 0x6A, 0x51, 0x80, 0xD0, 0x04, 0x21, 0x77, 0xFA, 0xB9, 0xEA, 0x29,
+	    0x25, 0xBD, 0x39, 0x09, 0xF4, 0x64, 0x6B, 0x80,
+	0x80, 0x63, 0x30, 0x24, 0x30, 0xA2, 0xD9, 0xB4, 0x22, 0x97, 0x96, 0xB7,
+	    0x51, 0xE6, 0xE4, 0x36, 0x80, 0xC3, 0x78, 0xF6,
+	0x52, 0xC4, 0x5C, 0xFA, 0x4B, 0xE1, 0xAE, 0xC4, 0xBB, 0x67, 0xF7, 0x17,
+	    0xC1, 0xE5, 0x91, 0x7E, 0xB4, 0x90, 0xC8, 0x36,
+	0x01, 0x04, 0x30, 0xF6, 0xD3, 0x0D, 0xC8, 0xA3, 0xFD, 0x26, 0x01, 0x2D,
+	    0x74, 0xAB, 0x5D, 0xDB, 0x45, 0xC4, 0x7D, 0xF7,
+	0x90, 0x6C, 0x01, 0xE0, 0x5B, 0x43, 0xDA, 0x6F, 0xAF, 0xD2, 0x63, 0x8E,
+	    0xC5, 0xBC, 0xE1, 0x95, 0x9B, 0xCA, 0x58, 0x09,
+	0xAF, 0x85, 0xB7, 0xFF, 0x9C, 0xA5, 0x40, 0x37, 0x22, 0x0A, 0xAA, 0xDD,
+	    0xFB, 0x28, 0xD1, 0xAE, 0x76, 0x9B, 0x1A, 0x2D,
+	0xB8, 0xA8, 0xC3, 0xA7, 0x3A, 0x2D, 0xE4, 0x89, 0xDB, 0x0E, 0x7D, 0x35,
+	    0x63, 0xFB, 0xD1, 0xBB, 0x73, 0x4E, 0x9C, 0x02,
+	0xF7, 0xC4, 0xA1, 0x3E, 0x7B, 0xA9, 0xD6, 0x21, 0xF2, 0xF4, 0xBF, 0xEE,
+	    0x1D, 0xA6, 0xDB, 0x64, 0xE7, 0x09, 0x72, 0xB9,
+	0x89, 0xEC, 0x61, 0x4F, 0xA6, 0x01, 0x53, 0x72, 0x22, 0x6E, 0xFB, 0x1A,
+	    0xB5, 0x0C, 0x45, 0xDE, 0x56, 0x1C, 0xF1, 0xBA,
+	0xD3, 0x49, 0xB9, 0xD8, 0x3D, 0x18, 0x72, 0x3E, 0x51, 0x0C, 0x1A, 0x21,
+	    0xC0, 0xCD, 0xB8, 0xCD, 0xD9, 0x47, 0x8C, 0x0D,
+	0x9C, 0x17, 0x8C, 0x56, 0xCC, 0x75, 0x0C, 0x07, 0xAD, 0x0E, 0x68, 0x5E,
+	    0x27, 0x6A, 0x0B, 0x0D, 0x20, 0xA2, 0x04, 0x79,
+	0xB8, 0x46, 0x8B, 0x7F, 0x76, 0x69, 0x5E, 0x18, 0x48, 0xC1, 0xFA, 0x82,
+	    0xD1, 0xB3, 0x75, 0x60, 0x72, 0x3C, 0x38, 0x36,
+	0x74, 0x7A, 0xFE, 0x14, 0x44, 0x75, 0xF2, 0x92, 0xD0, 0xB2, 0x26, 0x23,
+	    0x03, 0x8E, 0x5C, 0xAD, 0x57, 0x1F, 0x7B, 0x87,
+	0x41, 0x91, 0x77, 0x76, 0x3C, 0x73, 0x2F, 0x32, 0x8A, 0xAD, 0xD3, 0x27,
+	    0x5E, 0xF2, 0x3A, 0xAD, 0xE9, 0xC2, 0x7B, 0x66,
+	0x3D, 0x72, 0xB1, 0xC2, 0xCF, 0xA5, 0x5D, 0xAC, 0xEE, 0x79, 0x3F, 0xC2,
+	    0xEB, 0x0F, 0x25, 0x22, 0x16, 0xC0, 0x5A, 0x82,
+	0x21, 0xEB, 0xAC, 0xE0, 0x92, 0xD5, 0x04, 0x32, 0x5C, 0x35, 0xF4, 0x84,
+	    0x31, 0x3A, 0x64, 0x20, 0x94, 0x5A, 0x8A, 0x50,
+	0x98, 0xB3, 0x63, 0xB7, 0x20, 0xD1, 0x52, 0x47, 0x32, 0x9E, 0x2D, 0x63,
+	    0x62, 0x87, 0x01, 0x1A, 0x1B, 0x79, 0x8D, 0x09,
+	0xDA, 0x1A, 0xF7, 0x57, 0x3B, 0xEF, 0x65, 0x21, 0x18, 0x58, 0x7A, 0x62,
+	    0x12, 0xD8, 0x5C, 0xBC, 0x50, 0xB7, 0x90, 0xEE,
+	0x58, 0x0E, 0xAD, 0xD8, 0xE8, 0x47, 0x93, 0x28, 0x20, 0xFA, 0x2E, 0x05,
+	    0x2F, 0xD0, 0x7C, 0x6F, 0xB5, 0x78, 0x7F, 0x78,
+	0x23, 0x2C, 0x9A, 0x5E, 0xFB, 0x1E, 0xA7, 0xFB, 0xCA, 0xDD, 0xF9, 0x8B,
+	    0x59, 0xB9, 0x29, 0x0D, 0x89, 0x5E, 0xF7, 0x1F,
+	0xCA, 0xF1, 0x3D, 0x0B, 0x95, 0x11, 0xB1, 0x64, 0xC1, 0x94, 0x01, 0x97,
+	    0x88, 0xE0, 0x99, 0xDF, 0xB9, 0x74, 0xBD, 0x20,
+	0xAE, 0xD1, 0xBE, 0xBF, 0x46, 0xBB, 0x6E, 0x1A, 0xE8, 0x58, 0xB0, 0x1D,
+	    0xB8, 0x3C, 0xC9, 0x67, 0x6F, 0x12, 0xEE, 0x9D,
+	0x98, 0x3B, 0xD6, 0x90, 0x14, 0x6C, 0x0A, 0x63, 0x90, 0xCB, 0xEB, 0x57,
+	    0xAB, 0x9E, 0x43, 0xDC, 0x5B, 0x38, 0xC0, 0x0B,
+	0xCE, 0x5D, 0xF1, 0x49, 0x2C, 0xDA, 0x8F, 0x01, 0x8E, 0x12, 0xEF, 0x98,
+	    0x52, 0xCE, 0x00, 0xD4, 0xED, 0xEC, 0x81, 0x67,
+	0xFF, 0xD0, 0xE0, 0xFE, 0xEF, 0x83, 0xF2, 0xB0, 0xFF, 0xC4, 0x2F, 0x63,
+	    0x7B, 0xC3, 0x70, 0x5B, 0x9F, 0xEA, 0x6E, 0x10,
+	0x09, 0x2A, 0xCE, 0x74, 0xE6, 0x5C, 0x26, 0x08, 0x24, 0x3A, 0x78, 0x2F,
+	    0x5C, 0xA3, 0x65, 0x12, 0xEF, 0x81, 0x31, 0x68,
+	0x6F, 0xC1, 0x6F, 0x9E, 0xE2, 0x77, 0xE7, 0xA5, 0x7A, 0xBC, 0x79, 0x3E,
+	    0x64, 0x7C, 0xBE, 0xEC, 0x74, 0x30, 0x53, 0xCF,
+	0x1B, 0x81, 0xB0, 0xD5, 0x0C, 0x1E, 0x58, 0x73, 0xA7, 0x5B, 0xB9, 0xC8,
+	    0xB1, 0xBF, 0xAF, 0x63, 0x42, 0x8C, 0xD0, 0x23,
+	0x35, 0x1B, 0xC8, 0x20, 0x65, 0x42, 0x17, 0xD0, 0x3B, 0x58, 0xFA, 0xF0,
+	    0xC7, 0x6D, 0xC0, 0xA6, 0xAA, 0xEA, 0x3B, 0x0A,
+	0xFA, 0x29, 0x93, 0x21, 0x69, 0x27, 0xF3, 0xA5, 0xD0, 0x88, 0x89, 0xE5,
+	    0x56, 0x4E, 0x17, 0x54, 0x26, 0xF8, 0xB9, 0x20,
+	0x99, 0xB7, 0x41, 0x23, 0xC3, 0xC8, 0x15, 0x53, 0x58, 0xE5, 0x7B, 0x9E,
+	    0xA9, 0x57, 0xD9, 0x2A, 0xE3, 0xB3, 0x6A, 0xD9,
+	0xC3, 0x65, 0x9D, 0xAC, 0xBE, 0xB8, 0xA4, 0x9E, 0x68, 0x0C, 0x06, 0x80,
+	    0x39, 0x54, 0x68, 0x4A, 0xCD, 0xD6, 0x72, 0xBC,
+	0xBF, 0xFA, 0x9C, 0x4C, 0x5A, 0x80, 0x95, 0x69, 0x6B, 0x57, 0x67, 0xB8,
+	    0xA6, 0x67, 0x8B, 0xD0, 0xDA, 0x51, 0x4D, 0xBB,
+	0x8E, 0xD9, 0xBD, 0x7D, 0xFD, 0x96, 0x05, 0x9B, 0xAC, 0xCF, 0xE1, 0x3B,
+	    0x7E, 0x16, 0xCE, 0x34, 0x90, 0x53, 0x5A, 0xDE,
+	0xE1, 0x27, 0x12, 0x68, 0x3A, 0xC1, 0x45, 0x6F, 0xD3, 0xE0, 0x12, 0x47,
+	    0x6C, 0xED, 0xEB, 0x5C, 0x1B, 0xC1, 0x70, 0x7E,
+	0xCF, 0xAF, 0x2E, 0x64, 0x3D, 0x59, 0xA3, 0x93, 0xF7, 0x53, 0xE7, 0x05,
+	    0x63, 0xB2, 0x79, 0x6A, 0x6D, 0xC3, 0x9B, 0x71,
+	0xF8, 0x1A, 0x7C, 0xA0, 0x6E, 0x1C, 0x3F, 0x95, 0x6C, 0xB4, 0xD3, 0xF7,
+	    0x4D, 0xCB, 0xAD, 0x0C, 0xED, 0x44, 0x67, 0x72,
+	0x02, 0x31, 0x04, 0xF5, 0x47, 0x23, 0x1C, 0x5A, 0xE8, 0x2B, 0xEC, 0xB2,
+	    0xF6, 0x97, 0x7E, 0x24, 0x23, 0x58, 0xF5, 0x0C,
+	0x90, 0x4E, 0xE2, 0x3B, 0x84, 0xD7, 0xDC, 0x04, 0x47, 0xFC, 0xB2, 0x70,
+	    0x20, 0x1F, 0xDB, 0x80, 0x15, 0xF3, 0x24, 0x5F,
+	0x00, 0x90, 0xB7, 0xC5, 0xB4, 0xFD, 0x89, 0xA8, 0xD9, 0x33, 0xF4, 0x30,
+	    0x10, 0x42, 0x4C, 0x2F, 0x46, 0x92, 0xCF, 0xB6,
+	0xBD, 0xE8, 0x04, 0x74, 0x32, 0x9B, 0x9C, 0x3B, 0x87, 0x6F, 0x14, 0x0A,
+	    0x8A, 0x99, 0x46, 0x15, 0x9A, 0x5F, 0x4C, 0x92,
+	0x86, 0x12, 0x2C, 0x2F, 0x57, 0x4E, 0xBC, 0x0E, 0x81, 0x2E, 0x54, 0x7C,
+	    0xFA, 0x58, 0xE5, 0xBF, 0x68, 0x90, 0x61, 0x43,
+	0xEB, 0x88, 0x2D, 0xD2, 0xC6, 0x25, 0xC3, 0xEF, 0x1D, 0x73, 0x6C, 0xD3,
+	    0xA4, 0x5E, 0xD4, 0x2B, 0xBB, 0xF5, 0x40, 0x0B,
+	0x01, 0x6C, 0xAB, 0x64, 0xC5, 0x58, 0xB1, 0x7A, 0x5E, 0x29, 0x5E, 0xAA,
+	    0xE6, 0x25, 0x56, 0x00, 0x3A, 0xD5, 0x3B, 0x5E,
+	0x7D, 0xB7, 0xDC, 0x69, 0xA1, 0x44, 0xB4, 0x9C, 0xAF, 0xF8, 0x5C, 0x9A,
+	    0x6C, 0xB9, 0x9E, 0x3C, 0x9B, 0x4D, 0x59, 0x8D,
+	0x4D, 0x19, 0xBD, 0x8D, 0x0F, 0xE7, 0x35, 0x49, 0x4D, 0xB4, 0x27, 0x56,
+	    0x78, 0x61, 0x57, 0x86, 0x2D, 0x9C, 0xFF, 0xB3,
+	0xD6, 0xA0, 0x65, 0x9B, 0x4E, 0x9A, 0xE5, 0xBD, 0x5E, 0xE0, 0x06, 0xAE,
+	    0x49, 0x3D, 0x69, 0x05, 0x38, 0x67, 0x43, 0x07,
+	0x3C, 0x9E, 0xD1, 0x9D, 0x1C, 0x7A, 0x62, 0xD1, 0x26, 0xA9, 0xD0, 0xE3,
+	    0xDD, 0xFD, 0xBE, 0x03, 0x8C, 0xC6, 0x5B, 0xFB,
+	0xF8, 0xEB, 0x5F, 0x2E, 0xA7, 0x5A, 0x94, 0x4B, 0xC1, 0x98, 0x2A, 0xDE,
+	    0x69, 0x2D, 0xF7, 0x1C, 0x2E, 0x55, 0x63, 0xC1,
+	0xA6, 0x59, 0x6F, 0x98, 0x9B, 0x32, 0x4E, 0x9D, 0xAF, 0x90, 0x3F, 0x03,
+	    0x9B, 0xE3, 0xBD, 0x4A, 0xE4, 0x87, 0x1C, 0x35,
+	0xB1, 0x5F, 0x81, 0x42, 0xBF, 0x46, 0x50, 0x3D, 0xCD, 0x6A, 0xDE, 0x26,
+	    0xF1, 0x11, 0xF0, 0x10, 0xF8, 0x48, 0x9A, 0xB2,
+	0xF3, 0x80, 0xBE, 0x19, 0x2D, 0x67, 0x00, 0x37, 0x6A, 0x17, 0x41, 0xEC,
+	    0xFC, 0x89, 0x60, 0x14, 0x61, 0x4B, 0x13, 0x36,
+	0xE4, 0xB3, 0xBB, 0x2A, 0xFE, 0x03, 0xBB, 0x25, 0xC4, 0x8C, 0x21, 0x0C,
+	    0x3E, 0x01, 0x6B, 0xF4, 0x38, 0xF2, 0x80, 0xD8,
+	0x0C, 0x5B, 0x40, 0xD5, 0x9E, 0x86, 0xF4, 0x02, 0x66, 0xEB, 0xED, 0x04,
+	    0x59, 0x56, 0x5E, 0x32, 0x63, 0xBF, 0x64, 0x3B,
+	0xCD, 0xDA, 0x93, 0x4D, 0xA8, 0x01, 0xE6, 0x49, 0x8F, 0x6A, 0x40, 0x27,
+	    0x3D, 0xFB, 0x61, 0x27, 0xBC, 0xF9, 0xF5, 0x1F,
+	0x61, 0xCD, 0x88, 0xF4, 0x77, 0x99, 0x34, 0x16, 0x2E, 0x71, 0x70, 0xCB,
+	    0x4A, 0xDA, 0x63, 0xC1, 0x2D, 0xE8, 0xEB, 0x8A,
+	0x6A, 0xD8, 0x6A, 0xCA, 0x8E, 0xFD, 0x22, 0x7F, 0xBB, 0xAB, 0x4A, 0x82,
+	    0xEC, 0xC0, 0xEA, 0x0B, 0xB1, 0xD9, 0x5A, 0x37,
+	0xA8, 0x81, 0x71, 0x3B, 0xB8, 0xD6, 0x1A, 0xBC, 0x74, 0x69, 0xA4, 0x00,
+	    0xFA, 0x0C, 0x93, 0x4F, 0xD0, 0x0C, 0xB4, 0xFE,
+	0x14, 0x27, 0xF3, 0x6C, 0xCE, 0x50, 0xEB, 0xAF, 0x3E, 0xC0, 0x09, 0xFB,
+	    0x28, 0x81, 0xD5, 0xFF, 0x9D, 0x86, 0xDB, 0xF1,
+	0xC9, 0x50, 0xA5, 0x00, 0x7A, 0x2A, 0x07, 0x2F, 0x9C, 0x06, 0xED, 0xB6,
+	    0xE6, 0xDD, 0xF6, 0x0A, 0xBD, 0x0D, 0x89, 0x6C,
+	0x26, 0x93, 0x58, 0x80, 0xB8, 0x50, 0xBA, 0x78, 0x3B, 0xBF, 0x21, 0x03,
+	    0x2A, 0x2D, 0x65, 0x4D, 0xFA, 0x92, 0xC6, 0x36,
+	0xE2, 0x03, 0x70, 0x71, 0x9C, 0x77, 0x2C, 0x1B, 0xA8, 0x0D, 0xE8, 0xDC,
+	    0x79, 0xB1, 0xB3, 0x51, 0x36, 0x40, 0x02, 0x9B,
+	0xC9, 0x34, 0x25, 0x7F, 0x1B, 0x2B, 0x60, 0xD8, 0x2C, 0xE4, 0x83, 0xE0,
+	    0x60, 0x16, 0xBE, 0x77, 0x44, 0x9F, 0x88, 0xD2,
+	0x9F, 0x12, 0x92, 0xCB, 0xFD, 0x26, 0x84, 0x5D, 0xC0, 0x1E, 0x4C, 0x89,
+	    0x63, 0x9A, 0xA4, 0x4F, 0xE3, 0x46, 0x0C, 0xEB,
+	0x80, 0x8D, 0x55, 0x0C, 0x03, 0x14, 0x12, 0x74, 0x88, 0x12, 0x49, 0xD2,
+	    0xD3, 0xB4, 0xDD, 0xA0, 0x8F, 0x72, 0x6D, 0xD5,
+	0x84, 0x98, 0x5B, 0xAD, 0x79, 0x02, 0x0B, 0xD3, 0x6E, 0xA5, 0xB2, 0xDB,
+	    0x28, 0x31, 0x7C, 0x07, 0xF0, 0x1C, 0x3F, 0x26,
+	0xB0, 0x7C, 0x00, 0x2F, 0x64, 0x17, 0x00, 0x1A, 0x11, 0x78, 0xCC, 0x3D,
+	    0x23, 0xC8, 0xB4, 0x56, 0x36, 0x6F, 0x22, 0xF7,
+	0xCF, 0x58, 0x7A, 0x48, 0x98, 0x11, 0x47, 0x2C, 0xAA, 0x12, 0xDD, 0xB7,
+	    0x11, 0x53, 0x0A, 0x65, 0xC8, 0x58, 0x42, 0x16,
+	0x76, 0xFD, 0x07, 0xD0, 0x9E, 0x1E, 0xB5, 0x57, 0xB6, 0xFD, 0x4B, 0x93,
+	    0x1C, 0xF7, 0x64, 0xFA, 0x50, 0x35, 0x86, 0x6A,
+	0xAA, 0x3C, 0xD7, 0x08, 0x15, 0xED, 0x1E, 0xAD, 0xEF, 0x28, 0x49, 0x07,
+	    0x89, 0x29, 0x89, 0xF8, 0x69, 0x1F, 0x8C, 0x82,
+	0x0D, 0xCD, 0x7E, 0x12, 0x4D, 0x56, 0x23, 0xE3, 0xA0, 0xA4, 0xC3, 0xEB,
+	    0x69, 0x90, 0x47, 0x94, 0x25, 0x30, 0x87, 0xEF,
+	0xF4, 0xD7, 0x3B, 0x32, 0x43, 0x86, 0x87, 0xFD, 0x0A, 0x1D, 0x1A, 0x5A,
+	    0x50, 0x4A, 0x8F, 0x19, 0xEC, 0xA1, 0xB0, 0x39,
+	0x86, 0x4C, 0x47, 0x38, 0x02, 0xED, 0xBE, 0x4E, 0x3F, 0x38, 0xF6, 0x3B,
+	    0xEE, 0x1C, 0x94, 0x11, 0xFA, 0xE9, 0x36, 0xC5,
+	0x73, 0xC3, 0x7A, 0xBE, 0x78, 0xE2, 0x66, 0x5D, 0x9C, 0x31, 0x21, 0x8E,
+	    0x8C, 0xF6, 0x87, 0x45, 0x6C, 0x83, 0xFF, 0x1D,
+	0xC5, 0x31, 0x11, 0xEE, 0xA0, 0x1A, 0x47, 0x05, 0x76, 0xB3, 0x21, 0xFD,
+	    0x29, 0x57, 0xB7, 0x5F, 0xBA, 0x5D, 0xE2, 0x66,
+	0x00, 0xAE, 0x5A, 0xC1, 0xFD, 0xE5, 0xDD, 0xE0, 0x86, 0xC8, 0x3C, 0x34,
+	    0x74, 0x7E, 0x93, 0x54, 0xBB, 0xC6, 0x1B, 0x5D,
+	0x81, 0x5C, 0x71, 0x87, 0xA0, 0x87, 0xFA, 0x2D, 0xFE, 0xC5, 0x1F, 0x44,
+	    0xB2, 0x38, 0x79, 0xB4, 0xF4, 0x7E, 0xEE, 0xF3,
+	0x8C, 0x8D, 0xDF, 0x01, 0x7D, 0xAD, 0x40, 0x12, 0x67, 0xD9, 0x0E, 0x7C,
+	    0x2D, 0xA0, 0x79, 0x1A, 0x26, 0x85, 0x12, 0xF5,
+	0x39, 0x5E, 0x21, 0x3A, 0x30, 0xCA, 0x06, 0xB3, 0xC3, 0x1D, 0x5F, 0xC6,
+	    0x18, 0xBC, 0x24, 0x20, 0xF4, 0x84, 0xCF, 0x80,
+	0x12, 0x85, 0xD8, 0x5B, 0xBD, 0xA0, 0x50, 0xAD, 0xFE, 0x24, 0x97, 0xAB,
+	    0x1F, 0xE7, 0xD8, 0x00, 0x25, 0x22, 0x5C, 0x14,
+	0xE0, 0x80, 0xDE, 0x72, 0x27, 0x27, 0x23, 0xAF, 0x02, 0x6B, 0x2B, 0x2A,
+	    0xBA, 0x69, 0xAB, 0x70, 0xA0, 0x49, 0x51, 0x62,
+	0x26, 0x38, 0x72, 0x9D, 0xE8, 0xB9, 0x07, 0x74, 0x66, 0x18, 0xC1, 0x98,
+	    0x72, 0x18, 0x72, 0x13, 0x6F, 0xA8, 0xDA, 0xE6,
+	0xBA, 0xE5, 0xB0, 0xA8, 0xFE, 0x49, 0x4F, 0x50, 0x5A, 0xBA, 0x70, 0x0A,
+	    0xAE, 0x8F, 0xA6, 0x3A, 0x2E, 0xEE, 0x4B, 0x0A,
+	0xEC, 0xC0, 0x7A, 0xB2, 0x82, 0x36, 0x5B, 0x89, 0xAE, 0xF8, 0xD1, 0x07,
+	    0x90, 0xE4, 0x69, 0xAB, 0x6F, 0xCC, 0xD3, 0x4D,
+	0x6B, 0x37, 0x0F, 0x9E, 0x2C, 0x01, 0x13, 0x0F, 0x3A, 0xEA, 0xBB, 0xAB,
+	    0x6E, 0x7E, 0x80, 0xF8, 0x0B, 0xE1, 0xB9, 0x5A,
+	0x6D, 0xAD, 0x39, 0x47, 0x18, 0x37, 0xDE, 0x4E, 0xA5, 0x88, 0xCC, 0x52,
+	    0x82, 0xE3, 0x52, 0xA0, 0x6C, 0xAC, 0xB0, 0x5F,
+	0xBC, 0xAB, 0xDE, 0x18, 0xC2, 0x8C, 0xAC, 0x9C, 0xA8, 0x10, 0x74, 0xCF,
+	    0x98, 0x48, 0x7C, 0xCD, 0x9F, 0x49, 0x49, 0xDB,
+	0x20, 0x61, 0xC1, 0x56, 0x21, 0x73, 0xFC, 0xDF, 0x99, 0x49, 0x63, 0x9A,
+	    0x3E, 0x25, 0xBB, 0xDA, 0xA2, 0x8D, 0xED, 0x1D,
+	0x20, 0x32, 0x74, 0x1A, 0x47, 0xF0, 0xC2, 0xBB, 0xDD, 0x61, 0x24, 0xE3,
+	    0x37, 0x7D, 0x18, 0xD9, 0xEE, 0x70, 0x54, 0x10,
+	0x20, 0x0B, 0x2E, 0x85, 0x01, 0x60, 0x02, 0xC2, 0x4B, 0x4E, 0xC3, 0xC9,
+	    0x1D, 0xFC, 0x5D, 0x01, 0xA1, 0x28, 0x65, 0x9E,
+	0x2F, 0xBA, 0x2B, 0x92, 0x45, 0x6D, 0x4A, 0xE0, 0x49, 0x64, 0x77, 0x92,
+	    0x06, 0x95, 0x8B, 0xBA, 0xC9, 0x13, 0x67, 0xF1,
+	0x9D, 0x7C, 0x51, 0x2C, 0xF6, 0x83, 0x3B, 0x32, 0x22, 0x9B, 0xDC, 0x16,
+	    0xC8, 0xBB, 0xCD, 0x7C, 0x8D, 0x05, 0xA6, 0x99,
+	0xD5, 0x7F, 0x14, 0x50, 0x01, 0xDD, 0xD4, 0x06, 0x88, 0xBA, 0x87, 0xD5,
+	    0xC6, 0x2A, 0xF7, 0x84, 0xD4, 0x7E, 0x05, 0x87,
+	0x22, 0x1B, 0xDD, 0x17, 0x69, 0xB9, 0x4E, 0x67, 0xCC, 0x4C, 0x3B, 0xDB,
+	    0xF0, 0x6C, 0x15, 0xF4, 0x04, 0xF2, 0xD5, 0x07,
+	0x4C, 0xB8, 0xBD, 0x52, 0x54, 0x78, 0x7A, 0xCA, 0x08, 0x27, 0xAE, 0x8D,
+	    0x4F, 0x10, 0xB3, 0xFD, 0x04, 0x31, 0x96, 0x5A,
+	0xE4, 0x4B, 0x1A, 0xD0, 0xEA, 0x27, 0xBE, 0x1E, 0x45, 0xAC, 0x29, 0x06,
+	    0x56, 0x4A, 0x2C, 0xF8, 0x96, 0x44, 0x5D, 0xFE,
+	0x75, 0xB8, 0x5F, 0x7B, 0xA4, 0x95, 0x27, 0xEF, 0x37, 0xF8, 0x80, 0xAD,
+	    0x1B, 0x67, 0x08, 0x9E, 0x5D, 0x94, 0x87, 0xCB,
+	0x2F, 0x8C, 0xBC, 0x1B, 0x9E, 0x14, 0x6D, 0xAC, 0x1E, 0x76, 0x60, 0x40,
+	    0xD9, 0x46, 0xF6, 0x51, 0xD5, 0x11, 0x86, 0x8F,
+	0xB2, 0xB1, 0xD2, 0x6E, 0x48, 0x67, 0x05, 0xE2, 0xCF, 0x27, 0x7B, 0xE3,
+	    0xC4, 0xD9, 0x49, 0xE2, 0xE7, 0x4C, 0x46, 0xCB,
+	0xCE, 0x22, 0x1C, 0x12, 0x7F, 0x70, 0x05, 0xCB, 0x5D, 0x15, 0xAD, 0xB0,
+	    0x1D, 0xFF, 0xB7, 0x4F, 0xCD, 0xBB, 0xC4, 0x12,
+	0x99, 0x85, 0x35, 0x6C, 0xDD, 0x30, 0xB6, 0x4E, 0x1A, 0x80, 0x79, 0xFD,
+	    0x24, 0x9B, 0x80, 0xFB, 0x98, 0x8B, 0xDF, 0xA4,
+	0x77, 0x00, 0x40, 0x65, 0x2E, 0xBD, 0xD0, 0xAC, 0x80, 0x4D, 0xEE, 0xBE,
+	    0xBB, 0xA5, 0xCB, 0x6F, 0x54, 0x0A, 0x0F, 0x6B,
+	0x70, 0xF1, 0xD8, 0xBD, 0xE4, 0x03, 0x19, 0xC7, 0xB1, 0x2D, 0xBE, 0x9C,
+	    0xA3, 0x22, 0xF9, 0x22, 0x69, 0x2D, 0xE8, 0x06,
+	0x61, 0x3D, 0xEF, 0x12, 0xBB, 0xC7, 0xF7, 0x93, 0x5C, 0xDD, 0xD1, 0x3B,
+	    0xB5, 0x38, 0x5B, 0x78, 0x4E, 0x3E, 0xF8, 0x4E,
+	0x04, 0xFE, 0x48, 0x55, 0x31, 0xF1, 0x50, 0xE4, 0x72, 0x3C, 0x55, 0x82,
+	    0x60, 0x66, 0x88, 0xF5, 0x61, 0x22, 0xB0, 0x4D,
+	0xFD, 0xD5, 0x0C, 0x32, 0x9C, 0x3E, 0x38, 0xD0, 0x1F, 0x4A, 0x5B, 0xF0,
+	    0x0E, 0x8C, 0x7E, 0xA7, 0x92, 0xFB, 0x01, 0xC8,
+	0x37, 0x64, 0xD2, 0x89, 0xD0, 0x0B, 0x0B, 0x71, 0xF0, 0x85, 0x3A, 0x75,
+	    0xE8, 0x24, 0xD4, 0x33, 0x4D, 0xFA, 0x39, 0xD1,
+	0x9B, 0xCA, 0x59, 0x80, 0xC9, 0x61, 0x58, 0xEA, 0xAB, 0x6D, 0xAF, 0x6A,
+	    0xF3, 0x6B, 0xF5, 0x56, 0x4E, 0x3A, 0x39, 0xC4,
+	0x1C, 0x04, 0x50, 0x1C, 0xAA, 0x0F, 0x8C, 0xE1, 0xF0, 0xD2, 0x0C, 0x91,
+	    0xA2, 0x7A, 0xF3, 0xD7, 0xB2, 0xDD, 0x7B, 0x8B,
+	0x89, 0x72, 0x82, 0x6B, 0x73, 0x49, 0x1B, 0x69, 0xDC, 0x37, 0x47, 0x73,
+	    0xF6, 0xB6, 0x03, 0x55, 0xCB, 0x04, 0xD3, 0x19,
+	0xD1, 0xF0, 0xA2, 0x88, 0xFB, 0xE4, 0x38, 0x27, 0xDF, 0xB0, 0x46, 0xB8,
+	    0xF5, 0xA3, 0xD8, 0x4E, 0xF1, 0x23, 0x2A, 0x6A,
+	0x0E, 0x4A, 0xA3, 0xE0, 0x39, 0x0C, 0xB8, 0x57, 0xAA, 0xA6, 0xAC, 0xBE,
+	    0x1A, 0x2E, 0x22, 0x84, 0xCB, 0xB6, 0xBA, 0x23,
+	0x88, 0xE6, 0x93, 0xBA, 0xA4, 0x08, 0x82, 0x2B, 0xFB, 0x2A, 0x03, 0x70,
+	    0xA9, 0x6E, 0xAB, 0x2B, 0xB4, 0x2F, 0x33, 0x44,
+	0x6B, 0xF0, 0xAB, 0xF7, 0xAF, 0x22, 0xC6, 0x81, 0x4B, 0xF4, 0xA3, 0x9F,
+	    0x77, 0x60, 0x98, 0xC5, 0xA2, 0x38, 0xFF, 0xC3,
+	0x53, 0x10, 0x6B, 0x48, 0xC4, 0x1D, 0x95, 0x42, 0x60, 0x3F, 0x74, 0x14,
+	    0x5E, 0xA3, 0xF7, 0xE7, 0x1F, 0xB0, 0x23, 0x9D,
+	0x9A, 0x0C, 0x63, 0xC7, 0x0A, 0x80, 0xA1, 0xE3, 0xE1, 0x32, 0x62, 0x7E,
+	    0x51, 0xE4, 0xEE, 0x4E, 0xD7, 0x52, 0x94, 0x43,
+	0xE0, 0x3D, 0x6D, 0x51, 0x6F, 0x98, 0x89, 0x6A, 0x50, 0x90, 0x4E, 0x4B,
+	    0xE7, 0x7A, 0x5D, 0xD4, 0xFD, 0xCC, 0xEB, 0x44,
+	0x41, 0xCD, 0xA6, 0xC5, 0x33, 0x24, 0xD0, 0x11, 0xDD, 0xD4, 0xAC, 0x86,
+	    0x33, 0x7C, 0xF7, 0x43, 0x05, 0x1F, 0x33, 0x50,
+	0x4C, 0x0F, 0xA1, 0x61, 0x08, 0x2A, 0xE4, 0x0A, 0xDF, 0x78, 0xE9, 0xBE,
+	    0x68, 0x75, 0xA5, 0x6F, 0xD6, 0x3B, 0x0B, 0x0E,
+	0xE4, 0xFD, 0xAD, 0x67, 0x2F, 0xE8, 0xCF, 0xCF, 0x85, 0xE3, 0x5D, 0x12,
+	    0x31, 0x20, 0x5E, 0x51, 0x50, 0xE8, 0xC7, 0xC6,
+	0xD0, 0x17, 0xB7, 0x6A, 0xAA, 0xE4, 0x56, 0x72, 0xC5, 0x99, 0xC3, 0xCA,
+	    0xDF, 0x3D, 0xCD, 0xAC, 0xF5, 0x63, 0xBA, 0x7A,
+	0x0D, 0xED, 0x01, 0x8C, 0xC8, 0x36, 0x02, 0x5C, 0x68, 0xDB, 0xBE, 0x4F,
+	    0xDA, 0x6B, 0xEC, 0x79, 0x40, 0x15, 0xBF, 0x72,
+	0x4D, 0x78, 0x2F, 0x46, 0x67, 0x18, 0xA0, 0xCB, 0x22, 0xF1, 0x59, 0x82,
+	    0xCF, 0x96, 0x3B, 0xE6, 0x1A, 0x3D, 0xA4, 0x42,
+	0x66, 0x26, 0x27, 0xCD, 0x79, 0xDD, 0x92, 0xC3, 0x00, 0x2C, 0xD6, 0xAE,
+	    0xF0, 0x05, 0x08, 0x07, 0x7C, 0xC8, 0x6D, 0x9C,
+	0x92, 0x75, 0x35, 0xAB, 0x0D, 0xE2, 0xB7, 0x5E, 0x89, 0xCF, 0xA3, 0x51,
+	    0x49, 0x82, 0x42, 0xB9, 0xF9, 0x55, 0x67, 0xAF,
+	0x43, 0x3D, 0xF9, 0xA5, 0xDB, 0x3A, 0xAC, 0xF2, 0x15, 0xF5, 0xD4, 0x10,
+	    0xF6, 0x3C, 0x74, 0x27, 0x8F, 0x51, 0xF7, 0xAD,
+	0x3B, 0x29, 0xDB, 0x08, 0x54, 0xDF, 0x7B, 0x9F, 0xBA, 0x5F, 0x7F, 0x22,
+	    0x77, 0x80, 0x9E, 0xA3, 0x7C, 0xAD, 0x61, 0x33,
+	0x2A, 0xC4, 0xA4, 0x55, 0xBE, 0x48, 0xE8, 0x7B, 0x68, 0x7C, 0x27, 0x06,
+	    0xFC, 0x7A, 0x41, 0xE2, 0xE6, 0xDD, 0x93, 0xD8,
+	0xEA, 0xE5, 0xFE, 0x03, 0xF3, 0x8E, 0x5E, 0x74, 0xB2, 0xE0, 0x9F, 0x50,
+	    0xF6, 0x4E, 0xC3, 0xC7, 0x90, 0x69, 0xA2, 0x73,
+	0x93, 0x85, 0xD1, 0x30, 0x7C, 0x58, 0x20, 0xCD, 0x2C, 0xF0, 0xBB, 0x19,
+	    0x23, 0x96, 0x00, 0xF1, 0xCA, 0x89, 0x0C, 0xD4,
+	0x1E, 0xAC, 0x6B, 0xE6, 0x3B, 0xDE, 0x90, 0x26, 0xB8, 0x69, 0x38, 0xF2,
+	    0x0D, 0xD5, 0x37, 0x9F, 0x95, 0xB2, 0xF0, 0x75,
+	0x24, 0x45, 0x80, 0xF4, 0x56, 0x87, 0xF6, 0x73, 0x25, 0x29, 0xE7, 0x35,
+	    0x69, 0xE4, 0xB1, 0x5E, 0x75, 0xC0, 0x89, 0xE5,
+	0xD7, 0x91, 0x30, 0x7B, 0x22, 0x78, 0x7B, 0x35, 0x18, 0x21, 0x01, 0x01,
+	    0x64, 0x86, 0xC1, 0xA7, 0x08, 0xE8, 0x2E, 0x7D,
+	0x6F, 0x17, 0xDA, 0x7D, 0x32, 0x29, 0x18, 0xFA, 0x10, 0xD0, 0x45, 0x71,
+	    0xE1, 0x14, 0x70, 0x8C, 0xAE, 0xEC, 0x7A, 0xE4,
+	0xE1, 0xB2, 0x85, 0xBE, 0x64, 0x79, 0xD2, 0xB8, 0xA1, 0xA8, 0x5B, 0x89,
+	    0x51, 0x54, 0xA7, 0xF4, 0x7D, 0x09, 0xCC, 0x0F,
+	0x2D, 0x35, 0x18, 0x41, 0x09, 0xE4, 0x53, 0xE6, 0x81, 0xC9, 0x18, 0xEA,
+	    0x9B, 0xE0, 0x03, 0xC1, 0x61, 0xC6, 0x81, 0xD7,
+	0x2D, 0xA4, 0xCE, 0x39, 0x2C, 0x7A, 0xE6, 0x0E, 0x0E, 0xAA, 0x9E, 0xEA,
+	    0xB2, 0xEC, 0xCA, 0xBE, 0xA0, 0xE3, 0x57, 0x1D,
+	0xC5, 0x8E, 0x2A, 0xA3, 0x04, 0xAB, 0x81, 0x65, 0xB0, 0x66, 0x21, 0x52,
+	    0xDD, 0xE5, 0x1D, 0xEB, 0xB5, 0xAE, 0x92, 0x63,
+	0x3F, 0x51, 0xDF, 0x29, 0x4D, 0x1A, 0x33, 0x83, 0xD1, 0xAC, 0x23, 0xD3,
+	    0x52, 0xB2, 0x9A, 0x6A, 0x3E, 0xC1, 0x86, 0xD2,
+	0xED, 0x10, 0x3F, 0x1D, 0x9E, 0xEE, 0x5A, 0x2A, 0xCF, 0xA3, 0x84, 0xD6,
+	    0x95, 0x38, 0x53, 0x52, 0xE4, 0xCF, 0xCC, 0x66,
+	0x7E, 0xE0, 0x4C, 0xF0, 0xCE, 0x72, 0xEC, 0xA9, 0x3D, 0xDD, 0x34, 0x2E,
+	    0xE0, 0xF9, 0xFD, 0xD0, 0x46, 0xF6, 0x1B, 0x37,
+	0xA2, 0xC0, 0x85, 0x65, 0x90, 0xDC, 0x8C, 0xD3, 0x64, 0xC4, 0x0D, 0x4F,
+	    0x08, 0xBD, 0x13, 0x27, 0xA3, 0xC1, 0x85, 0x55,
+	0x61, 0x75, 0x95, 0x0E, 0x65, 0xC1, 0x45, 0x5F, 0x05, 0x6E, 0x63, 0x40,
+	    0x23, 0x6E, 0xEC, 0xFF, 0xB4, 0xA3, 0x2A, 0x0D,
+	0x60, 0x7F, 0x8C, 0xC2, 0xF9, 0xF6, 0x4C, 0xAB, 0x86, 0x1F, 0xE4, 0xE7,
+	    0xB5, 0xA2, 0xFF, 0x52, 0xD4, 0x6A, 0x94, 0xE8,
+	0xB1, 0x01, 0x3F, 0xC6, 0x05, 0x90, 0x26, 0xA5, 0x74, 0xB4, 0x88, 0x72,
+	    0x8D, 0xA9, 0x42, 0xE6, 0x7B, 0xFA, 0xEA, 0x51,
+	0x85, 0xE5, 0x2C, 0xB5, 0x55, 0x97, 0x23, 0x1C, 0xB5, 0x7C, 0x1B, 0x06,
+	    0x3D, 0xB7, 0xC9, 0x75, 0xC5, 0x7B, 0x01, 0x19,
+	0x57, 0x1E, 0x89, 0x2E, 0x45, 0x68, 0x4E, 0xA6, 0xFC, 0xFA, 0x10, 0x2B,
+	    0xE5, 0xF0, 0x94, 0x6D, 0xEB, 0x16, 0x41, 0xFD,
+	0xD0, 0x9B, 0x52, 0xC5, 0xE3, 0x72, 0xCB, 0x14, 0xAF, 0x2B, 0x27, 0x7E,
+	    0x7E, 0xFA, 0x0F, 0x51, 0x40, 0xD7, 0xEE, 0x90,
+	0x59, 0x85, 0x57, 0xA9, 0xC5, 0x78, 0x48, 0x6E, 0x67, 0xAB, 0x23, 0x5F,
+	    0xEE, 0xCB, 0x9F, 0x55, 0x8C, 0xED, 0x1E, 0x22,
+	0x32, 0xD1, 0x63, 0xEE, 0x50, 0xAC, 0x8B, 0xEF, 0x05, 0xA3, 0xA8, 0x7C,
+	    0x7A, 0x20, 0xAE, 0x37, 0x26, 0x86, 0x30, 0x57,
+	0xB8, 0x5E, 0xCD, 0x04, 0x93, 0x22, 0x51, 0xE0, 0xA9, 0x09, 0x9C, 0xC3,
+	    0x0B, 0x61, 0x27, 0x92, 0x8A, 0xFC, 0x27, 0x4B,
+	0x5D, 0x61, 0xCC, 0xB1, 0x23, 0x43, 0xA9, 0xBD, 0x2D, 0x9C, 0x8F, 0x75,
+	    0xA9, 0xB2, 0x17, 0x39, 0x69, 0x2A, 0x18, 0x0E,
+	0x25, 0xBF, 0x5E, 0x9A, 0x04, 0xDC, 0xFA, 0x64, 0x44, 0x62, 0xAF, 0x67,
+	    0x9A, 0xCD, 0x6F, 0xE6, 0xD3, 0x26, 0xA7, 0x0E,
+	0xE5, 0xF5, 0x80, 0x76, 0x70, 0x74, 0x84, 0x0D, 0x47, 0x13, 0x2F, 0x35,
+	    0xDC, 0x6D, 0xB8, 0x5F, 0x5D, 0x7F, 0x19, 0x70,
+	0x12, 0x26, 0x72, 0xE1, 0xBC, 0xEF, 0x26, 0x01, 0x5F, 0x60, 0xBF, 0xE0,
+	    0x69, 0x43, 0x91, 0x10, 0xF2, 0xDC, 0x3B, 0x53,
+	0x32, 0x26, 0xF1, 0x2B, 0x17, 0x97, 0xA7, 0xBD, 0xC1, 0x71, 0xA0, 0x00,
+	    0x1D, 0x29, 0x29, 0x62, 0x4E, 0x06, 0xB0, 0x20,
+	0x01, 0x6B, 0x60, 0xA8, 0xCF, 0x47, 0x82, 0xAF, 0xB0, 0xD9, 0x5F, 0x02,
+	    0xCE, 0xB3, 0x5C, 0x53, 0xF0, 0xD1, 0xD2, 0x6F,
+	0xFA, 0xBD, 0x8B, 0xBB, 0x31, 0x2B, 0x17, 0x72, 0xE0, 0xE8, 0x6E, 0x37,
+	    0xDC, 0xEC, 0x95, 0xF5, 0xA7, 0xBB, 0x72, 0x0A,
+	0x95, 0xFE, 0xA6, 0x03, 0x15, 0x98, 0x79, 0x6F, 0x5F, 0x6A, 0x5C, 0x3A,
+	    0x0C, 0x44, 0xFA, 0x8E, 0x90, 0x79, 0x2A, 0xD3,
+	0x23, 0x47, 0x74, 0xDD, 0x92, 0x28, 0x2C, 0x44, 0xD1, 0x4B, 0xCF, 0x6E,
+	    0x9B, 0x0D, 0x0B, 0xCB, 0xCD, 0xE4, 0xA5, 0x63,
+	0x32, 0xBF, 0x62, 0x1A, 0xD1, 0x9E, 0xBB, 0x7D, 0x90, 0x21, 0x93, 0x56,
+	    0x28, 0xCB, 0xCD, 0xBF, 0xDC, 0x96, 0xD0, 0x38,
+	0x75, 0xFC, 0x1A, 0xFF, 0x9F, 0xFB, 0x63, 0x89, 0x2D, 0xE4, 0x9B, 0x22,
+	    0x07, 0xC0, 0xFD, 0x13, 0xF3, 0x86, 0x45, 0xCE,
+	0x1B, 0x4F, 0x68, 0xF3, 0xB1, 0xC1, 0x98, 0x79, 0xD8, 0x24, 0x78, 0xA7,
+	    0x89, 0x45, 0x6D, 0x60, 0x1D, 0xD6, 0x48, 0x87,
+	0xB4, 0xC0, 0x8A, 0x63, 0x71, 0xF9, 0xC7, 0xB8, 0x29, 0x0C, 0x99, 0x4C,
+	    0x39, 0x6F, 0x30, 0x93, 0xEE, 0xB3, 0x4B, 0x8F,
+	0xFE, 0xBA, 0x6B, 0x3B, 0x3C, 0x6A, 0x67, 0x22, 0xFA, 0x0F, 0x09, 0x86,
+	    0x3C, 0x54, 0x0B, 0x66, 0xF5, 0x53, 0x3B, 0xB0,
+	0xD3, 0x8F, 0x14, 0x43, 0x32, 0xC5, 0xEF, 0x59, 0x68, 0xDB, 0x7C, 0x2E,
+	    0x76, 0xAB, 0x46, 0x0D, 0xDA, 0x12, 0x2F, 0x02,
+	0xED, 0xD7, 0x26, 0x00, 0xE1, 0xFE, 0x7C, 0x8B, 0x55, 0x72, 0x3E, 0x04,
+	    0xAE, 0x70, 0x81, 0xC2, 0x31, 0x3C, 0x05, 0x98,
+	0x0B, 0x16, 0x07, 0x5A, 0x73, 0x7C, 0x05, 0x04, 0x52, 0x7F, 0xB7, 0x66,
+	    0x7B, 0x98, 0xB9, 0xD3, 0x9C, 0x58, 0x1E, 0xF5,
+	0x73, 0xB4, 0xBB, 0x87, 0xE0, 0x24, 0x4B, 0xD4, 0x93, 0x9B, 0x2A, 0x15,
+	    0xBE, 0x4F, 0xF2, 0x44, 0xFE, 0xDF, 0x2E, 0x3A,
+	0x22, 0xD5, 0x13, 0x56, 0xB3, 0x5D, 0xE5, 0x55, 0x94, 0xF8, 0x1E, 0xBE,
+	    0x82, 0x7A, 0x4D, 0xD5, 0x5F, 0x78, 0x1E, 0xE2,
+	0x13, 0x99, 0xE8, 0xD0, 0x43, 0xA9, 0xAD, 0xE1, 0x07, 0x34, 0x2D, 0x95,
+	    0x9E, 0x1A, 0x97, 0x2A, 0x10, 0x31, 0xFD, 0x75,
+	0xBE, 0x47, 0x69, 0x8E, 0x50, 0x87, 0x64, 0x91, 0x2B, 0x38, 0xE4, 0x88,
+	    0xED, 0xA5, 0x04, 0xD7, 0x1C, 0x87, 0x17, 0xCE,
+	0x83, 0x71, 0x49, 0xE7, 0xA4, 0xAF, 0x2D, 0x02, 0xE5, 0xCF, 0x7E, 0xBA,
+	    0x01, 0x54, 0xA6, 0xAF, 0x54, 0x76, 0x04, 0xF2,
+	0x89, 0x3A, 0x2C, 0xD2, 0x41, 0xC6, 0x10, 0x12, 0xA0, 0x27, 0xC2, 0x2F,
+	    0x78, 0x43, 0x07, 0x94, 0x54, 0x75, 0xF1, 0x06,
+	0xD2, 0xAD, 0x8C, 0x59, 0xAF, 0xA6, 0xAD, 0xAE, 0x5A, 0xCA, 0xD1, 0x2A,
+	    0x0E, 0x50, 0xE6, 0x9D, 0x9B, 0xB6, 0x6E, 0x1B,
+	0x1D, 0x39, 0x51, 0xF0, 0xFA, 0x32, 0xC9, 0x7E, 0xE0, 0x90, 0x69, 0xDA,
+	    0xEF, 0x59, 0xF5, 0x83, 0xBE, 0xA0, 0x8A, 0xA7,
+	0xC6, 0xC1, 0x29, 0xA3, 0x88, 0xF3, 0x78, 0x2F, 0x35, 0x7F, 0x6F, 0x1A,
+	    0x95, 0x1F, 0x47, 0xF7, 0xD8, 0xCA, 0xE3, 0x56,
+	0x14, 0x92, 0xF7, 0x32, 0xB5, 0x5D, 0x1D, 0x99, 0xF3, 0xDF, 0xF4, 0x93,
+	    0x2A, 0x3D, 0x93, 0xBC, 0xFC, 0x37, 0xF5, 0xE6,
+	0x04, 0xE2, 0x94, 0x40, 0xF3, 0xA5, 0xD7, 0x2B, 0xB5, 0x4F, 0xC8, 0x2D,
+	    0x21, 0x0C, 0x28, 0x73, 0x18, 0x5A, 0x6B, 0xC8,
+	0xB8, 0x83, 0x17, 0x59, 0x88, 0x35, 0x12, 0xB9, 0x07, 0x8C, 0xA5, 0x7F,
+	    0xEB, 0xE2, 0x09, 0x1A, 0x3F, 0x9F, 0xD2, 0x79,
+	0x61, 0x3E, 0xD2, 0xE3, 0xED, 0x52, 0xAD, 0x93, 0xB8, 0xCB, 0xFC, 0x05,
+	    0x34, 0xCC, 0x0B, 0x28, 0x39, 0x48, 0x58, 0x92,
+	0xDB, 0xFB, 0x6B, 0x26, 0x10, 0x09, 0x5D, 0x04, 0xF1, 0xD4, 0x4D, 0x2D,
+	    0xAA, 0x47, 0xD5, 0x0F, 0xF8, 0x83, 0x68, 0xD2,
+	0x3A, 0xCD, 0x07, 0x00, 0x71, 0x5A, 0x9D, 0xB6, 0x6F, 0x41, 0xD8, 0x12,
+	    0x25, 0x59, 0x72, 0x27, 0xDE, 0x5D, 0xC9, 0x8C,
+	0xA6, 0x86, 0xCB, 0x99, 0x23, 0x8A, 0xE1, 0x51, 0x72, 0x88, 0x41, 0xD2,
+	    0x76, 0x08, 0xB9, 0xF6, 0x62, 0x3A, 0x2D, 0x71,
+	0x1F, 0xA4, 0xE2, 0x6B, 0x1D, 0x85, 0x82, 0x79, 0x9E, 0xAC, 0x86, 0x51,
+	    0xEF, 0x38, 0x84, 0x2C, 0x37, 0x6D, 0x48, 0x0A,
+	0x0E, 0x09, 0xD8, 0xAF, 0xBC, 0x50, 0x9B, 0xCE, 0x5C, 0xCF, 0x6C, 0x24,
+	    0x95, 0xFA, 0x5C, 0x6B, 0xAA, 0xE6, 0x2B, 0x6D,
+	0x63, 0xAC, 0x13, 0x90, 0xE8, 0xD1, 0xB1, 0x69, 0x4E, 0x4E, 0x70, 0x1B,
+	    0x0D, 0x0B, 0xB3, 0x1B, 0x60, 0xA4, 0x1B, 0x1B,
+	0x6C, 0x34, 0x9C, 0xCE, 0x41, 0x2B, 0xD6, 0x35, 0xAD, 0x31, 0x39, 0xBD,
+	    0x61, 0xC0, 0x64, 0x08, 0xB1, 0x11, 0x56, 0x9F,
+	0xFD, 0xAC, 0x0A, 0x1E, 0x32, 0x82, 0x43, 0x39, 0x77, 0xA0, 0xED, 0x89,
+	    0xCB, 0x46, 0xC2, 0x84, 0xF3, 0xE0, 0xA7, 0xCE,
+	0xCD, 0x7D, 0x73, 0x89, 0x90, 0x95, 0xA7, 0x95, 0xAD, 0xC0, 0x4C, 0xEB,
+	    0x98, 0xF2, 0x0B, 0x59, 0x47, 0x82, 0x14, 0xD6,
+	0x32, 0xED, 0x1E, 0xC7, 0x33, 0x8B, 0x84, 0x6C, 0xF5, 0xAB, 0x47, 0x42,
+	    0x60, 0x94, 0x24, 0xD8, 0x81, 0x6C, 0x98, 0x30,
+	0x42, 0xD8, 0xCA, 0x9A, 0x43, 0x06, 0x2E, 0x8E, 0xD3, 0x11, 0x1E, 0x89,
+	    0xD9, 0x1E, 0x65, 0x72, 0x71, 0xCA, 0x6A, 0x45,
+	0x47, 0x0A, 0x24, 0xFC, 0xDD, 0x9B, 0x0A, 0xE8, 0x69, 0x66, 0x75, 0xDC,
+	    0x6B, 0x54, 0x68, 0x75, 0x3C, 0x43, 0x05, 0xCC,
+	0x50, 0x6F, 0x9B, 0x66, 0x55, 0xF3, 0x9C, 0xCC, 0x02, 0x6C, 0x95, 0x4B,
+	    0x39, 0xB1, 0x85, 0x2C, 0xC7, 0xA2, 0x20, 0x16,
+	0x3A, 0xB2, 0x2C, 0x53, 0xE4, 0xDC, 0x6B, 0x15, 0x75, 0x44, 0x57, 0x72,
+	    0xCA, 0x77, 0xA6, 0xC3, 0xB5, 0xB6, 0x1C, 0xB6,
+	0x68, 0xD8, 0x4B, 0x57, 0x83, 0xF6, 0x18, 0xB1, 0x34, 0x89, 0x6D, 0x0A,
+	    0x15, 0xCB, 0xA1, 0x91, 0x45, 0x97, 0xC2, 0x56,
+	0x06, 0x75, 0x9D, 0x00, 0xA1, 0x4E, 0xAE, 0x35, 0x35, 0xFF, 0x37, 0x2C,
+	    0x44, 0xD1, 0x3D, 0x8A, 0x1C, 0xFF, 0xB6, 0xF8,
+	0xD3, 0x35, 0x0E, 0x04, 0xF4, 0x30, 0xE9, 0xAB, 0x68, 0x01, 0xA9, 0xB8,
+	    0x0B, 0x0E, 0x30, 0x01, 0xD6, 0x34, 0xF0, 0x91,
+	0x31, 0xF7, 0xA2, 0xFF, 0xED, 0x2E, 0x0F, 0x87, 0x06, 0x19, 0xBB, 0x70,
+	    0x21, 0x37, 0x84, 0x9C, 0xF5, 0x0E, 0x5E, 0x56,
+	0xAC, 0x98, 0x68, 0x7D, 0x40, 0x2B, 0x35, 0x09, 0xAD, 0x04, 0xCE, 0x1B,
+	    0xCA, 0x7A, 0x5F, 0xB9, 0xEC, 0xD6, 0x7F, 0x4E,
+	0x68, 0x20, 0x43, 0x4E, 0x64, 0x38, 0xAA, 0x3E, 0x32, 0xB3, 0xFE, 0x0F,
+	    0x0D, 0xFC, 0x76, 0x29, 0x5A, 0x90, 0x54, 0x54,
+	0x98, 0x10, 0xD6, 0x21, 0xFE, 0xDF, 0x44, 0x18, 0xED, 0x95, 0x12, 0x81,
+	    0xB5, 0x1E, 0x5D, 0x8C, 0x30, 0xE1, 0xC0, 0xC9,
+	0x6E, 0xDA, 0x0F, 0x69, 0xEB, 0x47, 0x67, 0x6B, 0x85, 0xE7, 0x0A, 0x30,
+	    0x4E, 0x89, 0x2B, 0x5A, 0xFC, 0x9F, 0x62, 0x19,
+	0x43, 0xD0, 0x44, 0x6C, 0x99, 0xBE, 0x60, 0x02, 0x62, 0x0D, 0xBA, 0xF7,
+	    0xDA, 0x8B, 0x44, 0x5C, 0xF3, 0x25, 0x63, 0xD4,
+	0x54, 0x2F, 0xA4, 0x34, 0x7E, 0x11, 0xF6, 0x23, 0x7A, 0x84, 0x20, 0x00,
+	    0x2F, 0x5D, 0xA2, 0xDC, 0xDB, 0xAE, 0x1B, 0x2F,
+	0xA1, 0x42, 0xE3, 0x01, 0x7B, 0xE7, 0x29, 0xCE, 0x3D, 0xE3, 0x90, 0xD5,
+	    0xC3, 0x2D, 0xCE, 0xE1, 0xB3, 0xF2, 0x88, 0xE6,
+	0x71, 0x6F, 0xE1, 0x39, 0x7C, 0x0C, 0xC4, 0x2A, 0x3C, 0x0F, 0x45, 0xB0,
+	    0x2A, 0xF5, 0x6C, 0x06, 0x91, 0xF0, 0x90, 0x9C,
+	0x26, 0xB1, 0xD0, 0x64, 0x52, 0x16, 0x0A, 0xB2, 0xFA, 0x87, 0xAE, 0x50,
+	    0x78, 0xA3, 0x2F, 0x4A, 0xB1, 0x4B, 0xD8, 0x4F,
+	0x5B, 0xCE, 0x81, 0xCD, 0x44, 0x0B, 0x23, 0x5A, 0x5C, 0x8D, 0xA6, 0x5F,
+	    0x34, 0xF3, 0xD1, 0xC8, 0xD2, 0xEF, 0xB2, 0xA1,
+	0xA7, 0xF6, 0x49, 0x27, 0x78, 0xE2, 0x31, 0xF7, 0x3F, 0x06, 0x4F, 0xF5,
+	    0xD6, 0x70, 0x7C, 0x0E, 0xE9, 0x8B, 0xE3, 0x16,
+	0xC8, 0x9C, 0x4C, 0xCA, 0x4C, 0xF5, 0x56, 0x25, 0xB5, 0x0A, 0xF1, 0xE8,
+	    0x2B, 0xF8, 0x62, 0x96, 0x1F, 0xF2, 0xAE, 0x5A,
+	0xF6, 0xB4, 0x06, 0xAC, 0xA6, 0xC4, 0x23, 0xFA, 0x04, 0x07, 0xA4, 0xFC,
+	    0x04, 0x38, 0xD3, 0x88, 0x97, 0x55, 0xCA, 0xAA,
+	0x3F, 0xC7, 0x75, 0x1F, 0x68, 0x88, 0x19, 0x57, 0x24, 0x37, 0x0D, 0x5B,
+	    0xA9, 0x63, 0x03, 0x22, 0x7A, 0xEE, 0x82, 0xC4,
+	0xE3, 0x60, 0xBC, 0x7B, 0x71, 0x89, 0x02, 0x2C, 0x6C, 0xC1, 0x45, 0x6C,
+	    0x5A, 0x24, 0xDA, 0x65, 0x0D, 0x5F, 0xAB, 0x46,
+	0xCB, 0x99, 0xC6, 0xB8, 0x7F, 0xE0, 0xD6, 0xD6, 0x2B, 0x6D, 0xA0, 0x89,
+	    0x9A, 0x85, 0x42, 0xBE, 0x7A, 0x62, 0x2C, 0x12,
+	0x47, 0xE8, 0xA2, 0x54, 0xDA, 0x6E, 0x75, 0x49, 0x28, 0x4E, 0xEC, 0xAC,
+	    0x07, 0x3D, 0x04, 0x40, 0xCD, 0x66, 0xDB, 0x81,
+	0xDB, 0xE4, 0x51, 0x20, 0x02, 0xEA, 0x7B, 0xF6, 0x52, 0xCF, 0x72, 0x89,
+	    0x63, 0x53, 0xAB, 0x42, 0x8D, 0xFC, 0x05, 0xC8,
+	0x68, 0x7B, 0xF2, 0x92, 0xD8, 0x1B, 0x8F, 0x50, 0x65, 0x63, 0x20, 0x47,
+	    0xF5, 0xFC, 0x8F, 0xD9, 0xA9, 0x78, 0x7E, 0xF6,
+	0xB7, 0xC3, 0x2B, 0x8D, 0xE6, 0xC0, 0x41, 0x75, 0x51, 0xF3, 0xC1, 0x4C,
+	    0x8B, 0x10, 0x5E, 0x66, 0x3D, 0x3E, 0xA1, 0xD1,
+	0xC9, 0xF7, 0xCF, 0x07, 0xF7, 0x30, 0x3C, 0x28, 0x2E, 0xC8, 0xBA, 0x52,
+	    0x59, 0x92, 0xE9, 0x02, 0x3A, 0x50, 0xD4, 0xDD,
+	0x8D, 0xA9, 0x25, 0x3B, 0xDC, 0x9E, 0xF6, 0x27, 0xE5, 0x9A, 0xFB, 0x5D,
+	    0x8A, 0x3C, 0x63, 0x71, 0x8C, 0xA8, 0xE9, 0x44,
+	0x77, 0x74, 0x45, 0x34, 0x70, 0xB6, 0x3D, 0xC5, 0x36, 0x05, 0x86, 0xA2,
+	    0xFC, 0xA9, 0x97, 0xE8, 0xA5, 0x8D, 0x2A, 0x24,
+	0x69, 0x27, 0x7A, 0x13, 0x03, 0xF6, 0xC5, 0xF0, 0x8C, 0x88, 0xD6, 0x20,
+	    0x28, 0xB8, 0x79, 0x7E, 0x19, 0x98, 0x03, 0x85,
+	0x81, 0x29, 0x11, 0x9C, 0x71, 0x64, 0x4E, 0x89, 0x29, 0x19, 0x85, 0xEF,
+	    0x3E, 0xA8, 0x56, 0x2C, 0x80, 0x28, 0xC4, 0x27,
+	0x05, 0x66, 0x47, 0x04, 0xF6, 0x68, 0xBD, 0x76, 0xBE, 0xE1, 0xBB, 0x41,
+	    0x3C, 0x9C, 0x6F, 0xA5, 0x01, 0x35, 0x0F, 0x9C,
+	0xAB, 0x69, 0xF1, 0x9B, 0x58, 0x98, 0xDF, 0x21, 0x9D, 0x50, 0x27, 0x43,
+	    0x9A, 0x03, 0x4E, 0xB7, 0x89, 0xAC, 0xB8, 0x56,
+	0xEF, 0xA1, 0x6E, 0x17, 0x83, 0x53, 0x46, 0xC8, 0x19, 0xA2, 0xA2, 0x58,
+	    0xD7, 0x3D, 0x6D, 0xEA, 0xE7, 0xD8, 0x4F, 0x0B,
+	0x11, 0x80, 0x8C, 0x5B, 0x90, 0x19, 0x30, 0x5F, 0x79, 0x5F, 0x6C, 0x92,
+	    0x43, 0xC2, 0x83, 0x17, 0x17, 0xDF, 0x40, 0x1E,
+	0x7E, 0xF3, 0xE3, 0x9B, 0x28, 0xCB, 0x91, 0xEE, 0xBF, 0x7D, 0x0D, 0xCF,
+	    0x00, 0xCC, 0xE7, 0x03, 0x76, 0xF9, 0x00, 0xF1,
+	0x88, 0x8D, 0x12, 0xB4, 0x04, 0x65, 0x19, 0xC4, 0x54, 0xBD, 0x4F, 0xCE,
+	    0xCD, 0x4D, 0xB8, 0x6D, 0x26, 0x8C, 0x9B, 0x1E,
+	0xF1, 0x14, 0x46, 0x34, 0xA4, 0x42, 0x40, 0x12, 0x8D, 0x70, 0xBA, 0x63,
+	    0x80, 0xEE, 0xD7, 0x2D, 0xEA, 0x67, 0xC9, 0xD3,
+	0xC6, 0x73, 0xC9, 0xC1, 0xC4, 0x1F, 0xF2, 0x11, 0xFA, 0x80, 0x56, 0xD5,
+	    0x16, 0xE5, 0x09, 0xC0, 0x49, 0xCE, 0x06, 0x65,
+	0xFB, 0x69, 0x5A, 0xB9, 0x65, 0x6E, 0x08, 0xCC, 0x10, 0x7F, 0xF4, 0x8D,
+	    0xBF, 0x1F, 0xAE, 0x5B, 0xA9, 0x39, 0x50, 0xAD,
+	0x8A, 0xE7, 0x1B, 0x6D, 0xED, 0x30, 0xC3, 0xC3, 0x26, 0x1A, 0x58, 0x85,
+	    0xDB, 0xE8, 0x76, 0xC7, 0xD5, 0x1E, 0x73, 0x78,
+	0x68, 0x73, 0x71, 0x52, 0xAF, 0x39, 0xA3, 0x5D, 0x21, 0x12, 0x11, 0x4A,
+	    0x7D, 0xD7, 0x9A, 0x95, 0x14, 0xE1, 0xC6, 0x42,
+	0x66, 0x38, 0x55, 0xF2, 0x2C, 0x82, 0x7D, 0x1A, 0xFF, 0xCA, 0x15, 0x2A,
+	    0xC8, 0x82, 0xC9, 0xDA, 0x51, 0x39, 0x8A, 0x1E,
+	0x51, 0x47, 0x32, 0x1E, 0x80, 0xC8, 0x81, 0x6D, 0x76, 0xA0, 0x9D, 0x13,
+	    0xAC, 0x66, 0x7A, 0x9A, 0x01, 0x68, 0xFB, 0xF1,
+	0x71, 0x52, 0x04, 0xCB, 0x4D, 0x17, 0x4A, 0x55, 0x6B, 0x8B, 0x13, 0x5D,
+	    0xBE, 0x6D, 0xC7, 0x3F, 0xC0, 0x01, 0xE8, 0x65,
+	0xFD, 0x54, 0xAA, 0x48, 0xF9, 0xA7, 0x6D, 0x75, 0x7A, 0xFB, 0x1E, 0x38,
+	    0xF5, 0x07, 0x55, 0x6A, 0x91, 0xAE, 0xC9, 0xCF,
+	0xB9, 0x47, 0xCA, 0x57, 0xA5, 0x61, 0x62, 0x38, 0xFC, 0x26, 0x82, 0x21,
+	    0x7F, 0xED, 0x20, 0x4C, 0x39, 0x62, 0x59, 0x79,
+	0xF3, 0x88, 0xB9, 0x72, 0x88, 0x14, 0x54, 0x4E, 0x13, 0xA2, 0x62, 0x56,
+	    0x25, 0x8A, 0x27, 0x95, 0x02, 0xAA, 0x13, 0x4E,
+	0x6F, 0x5A, 0x95, 0xC8, 0x7E, 0x7C, 0xDF, 0x09, 0x6C, 0xAA, 0xC3, 0x38,
+	    0xD1, 0x34, 0xE3, 0x1F, 0x3A, 0x92, 0xE8, 0x75,
+	0xB8, 0xBD, 0xB4, 0x2B, 0xC9, 0xD9, 0x23, 0x4C, 0x81, 0xBF, 0x6C, 0x1F,
+	    0x7B, 0xB0, 0xF3, 0x92, 0x33, 0x6A, 0xAD, 0x36,
+	0x0E, 0xE7, 0xE5, 0xA8, 0x90, 0x78, 0xA1, 0x83, 0xA4, 0xF2, 0x5A, 0x75,
+	    0x95, 0x12, 0xB3, 0x98, 0xD8, 0x27, 0x25, 0xD5,
+	0x1F, 0x71, 0xEA, 0x1E, 0xA7, 0xF3, 0xA6, 0xB3, 0x30, 0x02, 0x3B, 0x9E,
+	    0x65, 0x9E, 0xB9, 0x57, 0xD7, 0xF5, 0x86, 0xDD,
+	0xE8, 0x19, 0x3F, 0x4E, 0xC9, 0xBA, 0x2E, 0xA0, 0x1A, 0x7B, 0x74, 0x26,
+	    0x22, 0x59, 0xEC, 0x21, 0xC3, 0x3A, 0xC0, 0xCE,
+	0xBE, 0x45, 0xCB, 0xF4, 0x90, 0x7E, 0x3C, 0x7B, 0x9D, 0xFF, 0x1B, 0x50,
+	    0xCD, 0x10, 0x8D, 0x41, 0x4A, 0xF7, 0xD5, 0x13,
+	0x6E, 0x05, 0x69, 0x77, 0x7B, 0x94, 0xDB, 0x22, 0x4F, 0x87, 0xC1, 0xDB,
+	    0x3E, 0x85, 0x77, 0xF3, 0x2F, 0xBE, 0xFF, 0x88,
+	0xB7, 0x08, 0x26, 0x8F, 0x30, 0x8A, 0x0E, 0x3E, 0xB9, 0xFB, 0x30, 0x86,
+	    0xEC, 0xE4, 0xC7, 0x9E, 0xDD, 0xF3, 0x6F, 0x97,
+	0x21, 0x32, 0x0D, 0x76, 0xBB, 0x76, 0x3A, 0xFD, 0xEC, 0xD7, 0x7E, 0x32,
+	    0xBB, 0xF4, 0xE0, 0xAA, 0x84, 0x68, 0x0F, 0x2E,
+	0xBA, 0x42, 0xA7, 0x6C, 0xEE, 0x2F, 0x26, 0x5F, 0xD4, 0x0B, 0x57, 0x9F,
+	    0x54, 0xD9, 0xF6, 0xD0, 0x1A, 0xA0, 0x9C, 0x2D,
+	0x31, 0x3D, 0x53, 0x2D, 0xFD, 0xF3, 0x18, 0xF8, 0xAB, 0x8A, 0xC2, 0x4A,
+	    0x3E, 0x90, 0x78, 0xC5, 0x50, 0x89, 0x66, 0x9D,
+	0x53, 0x7D, 0x4D, 0xC5, 0xF7, 0x36, 0xEE, 0x9F, 0x91, 0x0A, 0x2D, 0xFE,
+	    0x16, 0xF5, 0xF6, 0xF2, 0x96, 0x94, 0xC8, 0xB0,
+	0x73, 0x31, 0x67, 0x8E, 0x10, 0xFC, 0xA6, 0xD0, 0x94, 0x4B, 0x88, 0x6B,
+	    0xE0, 0x59, 0xCA, 0x53, 0x28, 0x89, 0xEF, 0x83,
+	0x11, 0xD2, 0x93, 0x7B, 0x13, 0xFF, 0x3B, 0x04, 0x0A, 0x93, 0x67, 0x40,
+	    0x08, 0x41, 0x3B, 0xE6, 0xED, 0x2B, 0x49, 0x08,
+	0xE5, 0x31, 0xF0, 0x26, 0x29, 0x6D, 0x4A, 0x70, 0x07, 0x83, 0x30, 0xE7,
+	    0x69, 0xA0, 0x37, 0x4F, 0x98, 0x1C, 0xF8, 0x70,
+	0x2A, 0xEA, 0xDE, 0xFE, 0xA4, 0xFF, 0x38, 0x21, 0xA3, 0xE0, 0xEE, 0xA5,
+	    0xEF, 0xF4, 0xF1, 0x85, 0xCE, 0x6D, 0x11, 0x84,
+	0xC3, 0x0A, 0x70, 0x75, 0xD7, 0xA1, 0xF5, 0xAA, 0xC0, 0x23, 0x19, 0xD7,
+	    0x53, 0x20, 0x1B, 0x8B, 0x04, 0x8D, 0x9A, 0x91,
+	0x6A, 0x66, 0x80, 0x9C, 0xA4, 0xBF, 0xC6, 0x06, 0x73, 0xE4, 0x97, 0x79,
+	    0x7C, 0x45, 0x64, 0xCB, 0x10, 0xE5, 0x04, 0xD4,
+	0x67, 0x2B, 0x81, 0x5F, 0xF6, 0xE9, 0x07, 0xBC, 0x86, 0x44, 0x8A, 0x1D,
+	    0x33, 0xB9, 0x02, 0x5A, 0xA9, 0x04, 0xEB, 0x8D,
+	0x78, 0x29, 0x89, 0xAC, 0xE9, 0x01, 0x66, 0x2F, 0x4E, 0xFB, 0x19, 0x4E,
+	    0xCB, 0x2B, 0x93, 0x68, 0x2C, 0x7C, 0xC5, 0x98,
+	0x29, 0x29, 0x9A, 0x89, 0x78, 0xF7, 0xAB, 0x2A, 0x08, 0xF5, 0x98, 0xA8,
+	    0x1E, 0xB3, 0xCA, 0xF9, 0x7C, 0x0D, 0xCC, 0x98,
+	0x06, 0x0B, 0xCF, 0x43, 0xA2, 0xDA, 0x0A, 0x23, 0x29, 0xDD, 0x11, 0x19,
+	    0xAB, 0x0B, 0x9B, 0x08, 0xD8, 0x21, 0x3C, 0x47,
+	0x11, 0xE5, 0xD5, 0xFC, 0x93, 0xC0, 0xCE, 0x39, 0xF1, 0x19, 0xD2, 0x89,
+	    0x3C, 0xD4, 0xA8, 0x94, 0x35, 0xD8, 0x8C, 0xB9,
+	0xB0, 0x6E, 0xCA, 0xB1, 0x69, 0x2C, 0xFD, 0x12, 0x42, 0x28, 0x7A, 0xAA,
+	    0x21, 0x8A, 0xA6, 0x0A, 0xD7, 0x9A, 0x70, 0xBA,
+	0x89, 0x4E, 0x5A, 0x9B, 0x19, 0xD8, 0x3C, 0x75, 0xAA, 0xE2, 0x62, 0x83,
+	    0x68, 0x4A, 0x3B, 0xCB, 0x8F, 0x4A, 0x2A, 0x12,
+	0x6F, 0xD2, 0x53, 0x72, 0x04, 0xE5, 0x9B, 0x74, 0xE9, 0xF8, 0xC3, 0xBB,
+	    0x27, 0x00, 0xCF, 0x1A, 0x1A, 0x21, 0x39, 0x67,
+	0x2F, 0xBB, 0x63, 0x40, 0x7C, 0xE2, 0x9A, 0x68, 0x5B, 0xB0, 0xBA, 0xBD,
+	    0x13, 0xA0, 0xEB, 0xD3, 0xEC, 0x03, 0x6B, 0x26,
+	0xC2, 0xD1, 0x55, 0x78, 0x6B, 0x5C, 0xF4, 0x29, 0xD1, 0xCE, 0xA7, 0x2A,
+	    0x62, 0x71, 0x96, 0x90, 0xFE, 0x73, 0xDA, 0x91,
+	0xA6, 0xFB, 0xDC, 0x19, 0x15, 0x99, 0xEE, 0xE6, 0x1D, 0xE4, 0xAD, 0x35,
+	    0x53, 0x3C, 0x72, 0x60, 0x02, 0x53, 0x3E, 0x77,
+	0x31, 0x03, 0x8D, 0xEF, 0x10, 0x8F, 0x2A, 0xB4, 0x7C, 0x7F, 0xCB, 0x3F,
+	    0x86, 0xA4, 0x1F, 0x4C, 0xCD, 0x3A, 0xD4, 0x02,
+	0xE0, 0x57, 0x56, 0x60, 0x2F, 0x73, 0x98, 0x00, 0x82, 0xED, 0x60, 0xAB,
+	    0xF9, 0x4C, 0x3C, 0x50, 0x3D, 0x58, 0xA7, 0xD3,
+	0xD2, 0xCA, 0x7F, 0x64, 0x55, 0x9A, 0xAD, 0x43, 0x4E, 0x77, 0x12, 0x11,
+	    0xEA, 0x59, 0xB5, 0x57, 0x94, 0x7B, 0x33, 0x01,
+	0x9C, 0x37, 0x76, 0x46, 0x86, 0x3D, 0x57, 0xF0, 0x40, 0x51, 0x1D, 0xA8,
+	    0x4B, 0x37, 0x34, 0xB8, 0xA9, 0xB7, 0xB8, 0xB5,
+	0xDA, 0x18, 0xB9, 0xD3, 0xB5, 0x19, 0xFE, 0xD7, 0xB9, 0xF2, 0xA8, 0x6B,
+	    0xA5, 0xA4, 0x0E, 0x18, 0x4A, 0xC0, 0x4B, 0x5A,
+	0xC5, 0xD2, 0xF8, 0x4D, 0xA3, 0x69, 0xA7, 0xFA, 0x0B, 0x99, 0x80, 0x70,
+	    0x38, 0xE1, 0x77, 0xAA, 0xE9, 0xD1, 0xEF, 0xFD,
+	0xE8, 0xD5, 0x51, 0x7B, 0xE9, 0x9E, 0xEF, 0xDD, 0x57, 0xB0, 0x49, 0x5B,
+	    0x45, 0xD0, 0x3C, 0x8B, 0x25, 0x9E, 0xD6, 0x20,
+	0xBA, 0x51, 0xC0, 0x30, 0x3A, 0xC7, 0x06, 0x74, 0x8B, 0x53, 0xC9, 0xAD,
+	    0xF8, 0x78, 0x30, 0x84, 0x0F, 0x1C, 0x76, 0x26,
+	0x2B, 0x70, 0xDA, 0x1A, 0x8A, 0xA2, 0x1E, 0xE0, 0x41, 0x76, 0x39, 0x90,
+	    0xBA, 0x53, 0xC3, 0xE9, 0x89, 0x64, 0x37, 0xAD,
+	0xAD, 0xD5, 0xDF, 0x1D, 0x05, 0x71, 0x0B, 0xC8, 0x4A, 0xE0, 0xB0, 0x9A,
+	    0x71, 0x46, 0x9F, 0x04, 0xD3, 0xA4, 0x1A, 0x7F,
+	0x7B, 0xD6, 0xE0, 0xFA, 0x90, 0x84, 0x0C, 0x83, 0xB3, 0xA4, 0xA0, 0x3D,
+	    0xC0, 0x14, 0x0F, 0x46, 0x30, 0x8E, 0xE8, 0xA3,
+	0x1C, 0xC3, 0xF1, 0x82, 0xB0, 0x20, 0x03, 0x9E, 0xB2, 0xAF, 0xB0, 0xAB,
+	    0xD7, 0xF6, 0xE5, 0xA3, 0xFC, 0x80, 0xA4, 0x83,
+	0xF7, 0xD1, 0x95, 0x58, 0xF8, 0x3D, 0xAB, 0x25, 0x16, 0xE6, 0xE3, 0xFC,
+	    0x05, 0x93, 0x52, 0xF1, 0x93, 0xD0, 0x07, 0x35,
+	0x1B, 0x6E, 0x2F, 0x55, 0xF6, 0xB3, 0xD4, 0xC6, 0x40, 0x5F, 0x43, 0xD0,
+	    0xCA, 0x42, 0xC6, 0x93, 0xAE, 0xA4, 0xA9, 0xD4,
+	0xF1, 0xA5, 0xE8, 0xAE, 0xD1, 0xC0, 0x8A, 0x52, 0xFC, 0x73, 0x19, 0x7C,
+	    0x97, 0xB1, 0x43, 0x38, 0x3C, 0x34, 0x27, 0x92,
+	0xCD, 0x2C, 0xDB, 0xB4, 0x5C, 0x0D, 0x2F, 0x51, 0xCE, 0x8A, 0x5C, 0x18,
+	    0x4B, 0xBA, 0xAC, 0x21, 0xA9, 0x0F, 0x97, 0xC8,
+	0xFC, 0x11, 0x5E, 0x82, 0x5B, 0xD5, 0xDD, 0x86, 0xAB, 0xEB, 0xE2, 0xE3,
+	    0x8D, 0x8C, 0x78, 0xE6, 0x5A, 0x05, 0x96, 0xB4,
+	0x4D, 0xF8, 0x85, 0x17, 0xA0, 0x79, 0xF5, 0x1A, 0x29, 0x04, 0xBD, 0xF6,
+	    0x13, 0xE4, 0x04, 0x3D, 0xDB, 0x16, 0xBE, 0x23,
+	0xA5, 0x58, 0xA7, 0x8F, 0xFB, 0x53, 0xB4, 0xE9, 0xB8, 0x5E, 0x0D, 0x2D,
+	    0x52, 0x35, 0x73, 0xEA, 0xAA, 0x1D, 0x54, 0xE6,
+	0x85, 0xC9, 0xB5, 0x26, 0xBC, 0x4A, 0xAB, 0x48, 0x49, 0xBA, 0x0C, 0x07,
+	    0xDB, 0x42, 0x42, 0xB5, 0x3D, 0x7E, 0xE3, 0xBD,
+	0xCC, 0x70, 0x9A, 0xE0, 0x48, 0x17, 0xAD, 0x46, 0x2D, 0x29, 0x20, 0x18,
+	    0x52, 0x72, 0x45, 0x40, 0xFB, 0x59, 0x9A, 0x45,
+	0x6B, 0xCB, 0x6D, 0x40, 0x2B, 0xAF, 0xDB, 0x19, 0xA0, 0xED, 0xD8, 0x11,
+	    0x43, 0x13, 0xE1, 0x94, 0x4D, 0xC0, 0x33, 0x32,
+	0x66, 0x1B, 0x55, 0xBE, 0xE7, 0x82, 0x5D, 0xAC, 0x77, 0xED, 0x2B, 0xE6,
+	    0x6E, 0x47, 0xE4, 0x3E, 0x5D, 0x88, 0xD9, 0xAC,
+	0x87, 0x65, 0xA0, 0x64, 0x07, 0xD2, 0x64, 0x40, 0x85, 0xB5, 0xEA, 0x95,
+	    0xF0, 0x5B, 0x04, 0x6A, 0xE9, 0xD1, 0xCC, 0x36,
+	0x6B, 0xBC, 0x44, 0x95, 0x06, 0xD3, 0x1D, 0xAC, 0xE9, 0x45, 0x85, 0xBD,
+	    0x28, 0x29, 0x9B, 0xBE, 0x13, 0xF3, 0x4D, 0x84,
+	0x87, 0xD1, 0x87, 0xB7, 0x71, 0xE4, 0xF3, 0x1A, 0x38, 0x6E, 0xE7, 0x69,
+	    0x16, 0xB5, 0x45, 0x4E, 0xAF, 0x21, 0xE3, 0xB8,
+	0xA7, 0xBD, 0xA4, 0x3F, 0x1E, 0x4F, 0x19, 0xBC, 0xFC, 0xED, 0x7E, 0x60,
+	    0x8C, 0x18, 0xCC, 0x86, 0x3C, 0xF2, 0x32, 0x56,
+	0x0C, 0xD6, 0x57, 0x58, 0x36, 0x85, 0x07, 0xD6, 0x18, 0x2A, 0xF8, 0x96,
+	    0x3F, 0xB7, 0x97, 0x3E, 0xF4, 0x23, 0x1C, 0x00,
+	0x4B, 0xC0, 0x4F, 0x01, 0x4A, 0x28, 0xD1, 0xCB, 0x57, 0x7F, 0xB6, 0x65,
+	    0xD8, 0x56, 0xD2, 0xE7, 0x48, 0x48, 0x47, 0x0D,
+	0x1C, 0xD1, 0xA4, 0xCD, 0xF4, 0xE7, 0x8B, 0x0E, 0x03, 0x2E, 0x2E, 0x5A,
+	    0xDD, 0xB7, 0x89, 0x28, 0x4F, 0x0B, 0xD7, 0x2A,
+	0x0B, 0x39, 0x70, 0x22, 0x2D, 0x36, 0xE4, 0x65, 0x9E, 0xBF, 0xA9, 0x49,
+	    0xE9, 0x54, 0x5E, 0x81, 0x59, 0x74, 0x8E, 0xF4,
+	0x39, 0xC7, 0xC7, 0x2F, 0xE2, 0xB7, 0xD3, 0x55, 0x8F, 0xDA, 0x68, 0xAF,
+	    0x7F, 0xF4, 0xFA, 0x3B, 0xA7, 0x09, 0xFF, 0x06,
+	0x5C, 0xB4, 0x6D, 0xB9, 0x06, 0xBF, 0xE6, 0x26, 0x5A, 0xB9, 0x51, 0x3B,
+	    0x28, 0xB7, 0xDD, 0x7E, 0xC1, 0x63, 0x84, 0xE5,
+	0xCF, 0x43, 0xCC, 0x6C, 0xF6, 0xAD, 0xB5, 0x6C, 0x50, 0xDE, 0x7F, 0x36,
+	    0xA9, 0xF0, 0x3D, 0x78, 0x89, 0xAF, 0x21, 0xFF,
+	0x79, 0x94, 0xB7, 0x6B, 0xA4, 0xDC, 0x77, 0xEB, 0x9C, 0xF6, 0x48, 0xAC,
+	    0x3C, 0xD4, 0x8F, 0xEB, 0xF6, 0x67, 0x58, 0x2A,
+	0xA9, 0xB4, 0xB7, 0xEE, 0x3D, 0xA8, 0x47, 0x82, 0xCE, 0x9D, 0x73, 0xFD,
+	    0x64, 0xFF, 0xC0, 0xA1, 0x6D, 0x42, 0xBB, 0x96,
+	0x14, 0x2A, 0x86, 0xCD, 0x08, 0xCD, 0xED, 0x4B, 0xF3, 0x66, 0xBC, 0x72,
+	    0x8C, 0xF7, 0xEB, 0xD4, 0x53, 0xAC, 0x28, 0xB4,
+	0x36, 0xEE, 0xE0, 0xB6, 0x50, 0x1C, 0x55, 0xCE, 0x21, 0x5D, 0x03, 0x7A,
+	    0x4A, 0xFF, 0x6E, 0xDC, 0xC2, 0x99, 0x3E, 0xCF,
+	0x39, 0x38, 0xF6, 0x7F, 0x57, 0xDC, 0x1C, 0xFA, 0x24, 0xA0, 0x23, 0xC2,
+	    0xF9, 0xEE, 0xC3, 0x34, 0x72, 0x60, 0x7E, 0x25,
+	0x62, 0x24, 0xCC, 0x23, 0xB3, 0xAE, 0x30, 0x63, 0x17, 0x49, 0x33, 0x44,
+	    0x4E, 0x54, 0xC8, 0xA5, 0x19, 0x47, 0xCC, 0xB6,
+	0x6C, 0xAC, 0x5F, 0x98, 0x55, 0x08, 0x34, 0xE6, 0x53, 0x6D, 0xBC, 0x33,
+	    0xAC, 0x59, 0xBE, 0xA7, 0x33, 0xAE, 0xBD, 0xF3,
+	0xC2, 0x4E, 0xB1, 0xD6, 0x1A, 0x6B, 0x16, 0xAD, 0x01, 0x60, 0x09, 0xAC,
+	    0xE1, 0x21, 0xB5, 0xE3, 0xA2, 0x4D, 0x58, 0xF1,
+	0x87, 0xE3, 0x5C, 0xEA, 0x0C, 0x95, 0x79, 0xE2, 0x97, 0x95, 0x07, 0x6F,
+	    0x7B, 0x9C, 0x6D, 0xD7, 0xDA, 0x60, 0xBE, 0x7A,
+	0xB6, 0x4B, 0x8D, 0x63, 0xC3, 0xF4, 0x0F, 0xBC, 0x1B, 0x98, 0xE7, 0x18,
+	    0x5F, 0xB9, 0xC3, 0xA8, 0xD7, 0x55, 0x66, 0x77,
+	0x0E, 0x22, 0xF1, 0xE9, 0x8A, 0xE7, 0x6C, 0x4F, 0xF8, 0x67, 0x5F, 0xF3,
+	    0x8F, 0x28, 0xE8, 0xDD, 0xD5, 0xF7, 0x43, 0x3D,
+	0xD3, 0x26, 0xCE, 0x5D, 0x8B, 0x70, 0xB1, 0x2A, 0xF9, 0x69, 0xCA, 0x99,
+	    0xBB, 0xD3, 0x54, 0xEC, 0x35, 0x6A, 0x12, 0x90,
+	0xB1, 0xE1, 0x2D, 0xA3, 0xFE, 0x9B, 0x80, 0xA2, 0xB8, 0x20, 0x62, 0x23,
+	    0xB6, 0xF1, 0xCF, 0x6B, 0x7B, 0xEF, 0x7B, 0xB2,
+	0x07, 0xF3, 0xA3, 0x0C, 0x37, 0x23, 0x73, 0x07, 0xCE, 0x35, 0x8A, 0x76,
+	    0x3D, 0x2C, 0x30, 0x1E, 0x72, 0x89, 0xC1, 0x59,
+	0x38, 0x6E, 0x9B, 0xD8, 0x14, 0x42, 0x5F, 0xF9, 0xEC, 0xA4, 0x56, 0x32,
+	    0x26, 0x53, 0x88, 0xA9, 0xDB, 0x74, 0x0C, 0xA4,
+	0xED, 0x11, 0x38, 0xD7, 0x07, 0xF6, 0xF7, 0xB7, 0x80, 0xEE, 0x28, 0xEB,
+	    0x92, 0x35, 0x5C, 0xD6, 0x1C, 0x5A, 0x13, 0x27,
+	0xF4, 0x80, 0x20, 0x05, 0x8A, 0xE8, 0xBF, 0x34, 0xB1, 0x9D, 0xD5, 0x5C,
+	    0xB9, 0x49, 0x91, 0x65, 0xFC, 0x30, 0x32, 0x15,
+	0x8B, 0x97, 0x35, 0xB1, 0x58, 0x98, 0x99, 0x39, 0x44, 0x8A, 0x35, 0x89,
+	    0xF7, 0x8B, 0x0C, 0xDD, 0x11, 0xF0, 0x54, 0xB6,
+	0xC1, 0x8B, 0x00, 0xC2, 0x99, 0xA9, 0x44, 0x60, 0x58, 0x9D, 0x9D, 0x19,
+	    0x20, 0x35, 0xB1, 0x3E, 0x35, 0xB7, 0x24, 0xD7,
+	0x9A, 0x5A, 0x0C, 0x30, 0x18, 0x7A, 0x7B, 0x61, 0x05, 0x54, 0x18, 0x45,
+	    0x85, 0xD7, 0x95, 0x40, 0x43, 0xCB, 0x15, 0x44,
+	0x23, 0x34, 0xDD, 0xC0, 0x81, 0x13, 0x34, 0x38, 0xCB, 0x6C, 0xE2, 0x75,
+	    0xC9, 0xB1, 0x5D, 0x8F, 0xF5, 0x54, 0xBD, 0x6A,
+	0x84, 0xE5, 0x2A, 0x1F, 0x5F, 0x32, 0x0E, 0xAC, 0xE5, 0x19, 0x48, 0x28,
+	    0x37, 0x2D, 0x5C, 0x68, 0x9D, 0x16, 0xDE, 0x81,
+	0x71, 0x3A, 0x24, 0x43, 0x9A, 0xE4, 0x83, 0xA1, 0x7F, 0x81, 0x7F, 0xAD,
+	    0x2A, 0x1E, 0xC4, 0x09, 0xCB, 0x04, 0xFB, 0x8D,
+	0x1C, 0x20, 0x57, 0x51, 0xBC, 0x38, 0xD4, 0x9B, 0xD6, 0x18, 0x4D, 0x8C,
+	    0x39, 0x2B, 0xB3, 0x2A, 0xF6, 0x51, 0xAB, 0xED,
+	0xF8, 0x74, 0xFF, 0x8F, 0x0E, 0x1A, 0x33, 0x25, 0x2A, 0x27, 0x29, 0x97,
+	    0x6C, 0x7F, 0x19, 0x68, 0x50, 0x3A, 0x36, 0x5A,
+	0xF6, 0xD2, 0xAE, 0x7C, 0x7D, 0xB0, 0x26, 0xDF, 0x92, 0x52, 0xA1, 0x92,
+	    0xA9, 0xE2, 0xE8, 0x3B, 0xC9, 0x5E, 0xC7, 0x49,
+	0xCF, 0x54, 0x2A, 0x1A, 0x66, 0xC3, 0xA8, 0xAA, 0x47, 0xC8, 0x15, 0xF7,
+	    0x08, 0x7A, 0xB7, 0xFA, 0x46, 0x30, 0xCF, 0x8A,
+	0x9F, 0xA9, 0x1F, 0x91, 0x59, 0x3E, 0x10, 0x45, 0x9A, 0x3F, 0x9B, 0x58,
+	    0xC9, 0x1D, 0x28, 0x33, 0xB8, 0xF1, 0xD3, 0x40,
+	0xAB, 0xFB, 0xB1, 0xB0, 0x21, 0x2A, 0xA0, 0x09, 0x1C, 0x35, 0x2D, 0x30,
+	    0xA4, 0x80, 0x00, 0xF1, 0x97, 0x63, 0x1A, 0x8D,
+	0x77, 0xC0, 0x0E, 0x23, 0xB0, 0x76, 0xF1, 0x36, 0x50, 0x62, 0xD4, 0x41,
+	    0xA8, 0xAD, 0x51, 0x17, 0x78, 0xC1, 0x21, 0x0C,
+	0x98, 0xDE, 0xD5, 0xDB, 0x50, 0x8E, 0xB1, 0xB6, 0xAA, 0x83, 0x88, 0x38,
+	    0xC4, 0x84, 0xBE, 0xA4, 0x12, 0x59, 0xB0, 0xC3,
+	0x97, 0x86, 0x60, 0x14, 0xA5, 0x79, 0x9B, 0x2C, 0xA4, 0xE0, 0x5C, 0x34,
+	    0xA8, 0xE7, 0x01, 0x81, 0xCB, 0xC8, 0x3E, 0x86,
+	0xF0, 0x74, 0x69, 0x30, 0x04, 0xE1, 0x21, 0xE6, 0xE3, 0xF9, 0xA1, 0xA7,
+	    0xC0, 0xE5, 0x5D, 0xF4, 0xC9, 0xEC, 0xD6, 0xB1,
+	0xA3, 0x86, 0xBD, 0x95, 0x91, 0xE4, 0xB9, 0xD2, 0x41, 0x78, 0x39, 0xD6,
+	    0xE0, 0xEA, 0x76, 0x76, 0xBB, 0xED, 0xBA, 0x83,
+	0x02, 0x05, 0x50, 0x52, 0x5E, 0x85, 0x72, 0x4B, 0x51, 0xEE, 0xFE, 0xCA,
+	    0xAC, 0x08, 0x90, 0xAF, 0x18, 0x06, 0xAA, 0xBE,
+	0x32, 0xA5, 0xBE, 0xDC, 0x79, 0x64, 0x1B, 0xE4, 0x75, 0x06, 0x2F, 0x22,
+	    0x77, 0xEE, 0x51, 0x2A, 0xCD, 0xEA, 0xBF, 0x28,
+	0x7D, 0x62, 0x25, 0xE8, 0x09, 0x06, 0x0F, 0x7D, 0x62, 0x06, 0x84, 0x4B,
+	    0xC5, 0x13, 0xE2, 0xB4, 0x7A, 0xAA, 0xB2, 0x4F,
+	0x2E, 0xBD, 0xC7, 0xCA, 0x34, 0x56, 0xDE, 0x05, 0x94, 0x73, 0x0D, 0x9C,
+	    0x7F, 0xDC, 0x50, 0xA9, 0x2D, 0x20, 0x2A, 0xFA,
+	0x3C, 0x70, 0xE3, 0xD8, 0x6B, 0x30, 0xA2, 0x93, 0x6C, 0x59, 0xE7, 0x4F,
+	    0xB8, 0xB4, 0x18, 0x68, 0x3F, 0x51, 0xCA, 0xF1,
+	0x3D, 0x8C, 0xDC, 0x15, 0x07, 0xAC, 0x3B, 0x1C, 0x45, 0xC6, 0x93, 0x78,
+	    0x62, 0xA0, 0xBB, 0xDA, 0x44, 0x8D, 0x79, 0x67,
+	0x5F, 0x82, 0x7B, 0x87, 0x57, 0x90, 0xF4, 0x12, 0x7C, 0xF2, 0xF5, 0x52,
+	    0xC3, 0x61, 0xBE, 0xA4, 0xD7, 0xBE, 0x16, 0x0D,
+	0xDA, 0x1C, 0x6C, 0x6B, 0x5C, 0xF3, 0xA3, 0x52, 0x3D, 0x0D, 0xE3, 0xF4,
+	    0x46, 0x57, 0xE5, 0x67, 0x57, 0xFE, 0x7A, 0x67,
+	0x34, 0xD2, 0xF5, 0x02, 0xD3, 0xDF, 0x71, 0x83, 0x87, 0xD6, 0xCE, 0x11,
+	    0x25, 0x50, 0x77, 0x5A, 0xB3, 0x68, 0x06, 0xED,
+	0xB5, 0x58, 0x05, 0x59, 0xE5, 0xBE, 0x3E, 0x13, 0x85, 0x92, 0x74, 0x42,
+	    0x65, 0x65, 0xCF, 0x92, 0xE6, 0xCB, 0x34, 0x93,
+	0x60, 0xEF, 0x14, 0x72, 0xD8, 0x2A, 0x94, 0x54, 0xD1, 0x57, 0x1D, 0xD6,
+	    0x8E, 0xF6, 0xC6, 0x05, 0x1C, 0xEE, 0x6D, 0xAC,
+	0xC5, 0xB6, 0xDD, 0x45, 0x94, 0x86, 0x4B, 0xDA, 0x87, 0xD2, 0xB2, 0x17,
+	    0xFE, 0xB9, 0x0D, 0x93, 0x58, 0x9A, 0x2D, 0x0F,
+	0x9D, 0xBA, 0x5B, 0x96, 0x44, 0x52, 0xDF, 0x01, 0x72, 0x07, 0x5E, 0xAD,
+	    0xD1, 0x97, 0x45, 0x9F, 0x57, 0xF9, 0x5C, 0x96,
+	0x6A, 0xFB, 0x4B, 0x53, 0xFD, 0x23, 0x75, 0x98, 0x56, 0x9A, 0xD6, 0x1C,
+	    0xE0, 0xE6, 0x39, 0xB8, 0xCC, 0x25, 0x65, 0x85,
+	0x02, 0x21, 0xFC, 0x89, 0xD3, 0x89, 0xC7, 0xD0, 0x03, 0x47, 0xEE, 0xD0,
+	    0x4F, 0x05, 0x11, 0x2B, 0x93, 0xC8, 0xF2, 0x93,
+	0xA9, 0xA0, 0x90, 0x7D, 0x3F, 0x47, 0x84, 0xE4, 0xC9, 0xB7, 0xE4, 0x84,
+	    0x86, 0x25, 0x76, 0xA8, 0x95, 0x67, 0x86, 0x6E,
+	0x62, 0xB3, 0x28, 0x08, 0x6A, 0x59, 0xAF, 0xEC, 0x99, 0xB0, 0xE5, 0xB8,
+	    0x6E, 0x99, 0xFC, 0xDA, 0xBD, 0xBE, 0x06, 0x4A,
+	0x8B, 0x72, 0x58, 0x08, 0xFA, 0xFD, 0x67, 0xEF, 0x2C, 0xBA, 0x87, 0xCD,
+	    0xC7, 0xB3, 0xE7, 0x18, 0x6A, 0x73, 0xF4, 0xA9,
+	0xEC, 0xE5, 0x17, 0x5F, 0xD4, 0xD2, 0x2A, 0x3D, 0xBB, 0x64, 0xDB, 0x99,
+	    0xCB, 0xD9, 0x17, 0xFB, 0xDB, 0xBD, 0x1C, 0x68,
+	0x33, 0xE5, 0x07, 0xE6, 0x92, 0x28, 0x68, 0xA2, 0x41, 0xC7, 0x27, 0x25,
+	    0xDD, 0x66, 0x51, 0xB7, 0xA4, 0x6D, 0x37, 0xF6,
+	0x35, 0x8C, 0x60, 0x14, 0x72, 0x3D, 0xCC, 0x27, 0x8E, 0x22, 0xB9, 0xFE,
+	    0xA3, 0x52, 0xF0, 0x7B, 0x33, 0x47, 0xAA, 0xC3,
+	0x6C, 0xBF, 0x99, 0x13, 0x71, 0xCD, 0x6B, 0x81, 0x80, 0x93, 0x55, 0xA7,
+	    0x89, 0x33, 0xA1, 0x21, 0x66, 0x01, 0x79, 0x0A,
+	0x25, 0x40, 0xBF, 0xA6, 0xE3, 0x14, 0xE0, 0xB3, 0x36, 0xA9, 0x1B, 0x62,
+	    0x29, 0xFE, 0xA8, 0x43, 0x31, 0x9B, 0xF0, 0xBE,
+	0x13, 0x48, 0x30, 0xBC, 0xBD, 0x6A, 0x9C, 0x92, 0xC1, 0x02, 0x07, 0xD4,
+	    0x6C, 0x75, 0xB9, 0x65, 0xB1, 0x3A, 0x98, 0xF7,
+	0x35, 0x36, 0x51, 0x13, 0x40, 0x21, 0xA9, 0x41, 0xA5, 0x62, 0xB4, 0x6A,
+	    0xB0, 0x92, 0x61, 0x14, 0x97, 0x9C, 0xA6, 0x93,
+	0xE7, 0x4B, 0x86, 0xA4, 0xD7, 0xBC, 0x22, 0x1D, 0x3B, 0x6F, 0xE2, 0x0E,
+	    0x59, 0x25, 0x4F, 0x5E, 0x7B, 0x34, 0x25, 0x88,
+	0x7C, 0xE5, 0x8E, 0x9C, 0x76, 0x69, 0xEA, 0x1E, 0x58, 0x24, 0x12, 0x34,
+	    0x36, 0x69, 0xE4, 0x3A, 0xB8, 0xBA, 0xBB, 0x4E,
+	0x56, 0x02, 0x89, 0x1D, 0x3B, 0x6B, 0xAB, 0xEE, 0x0A, 0x5A, 0xE8, 0xB4,
+	    0x25, 0xDB, 0x9B, 0xE5, 0x81, 0x80, 0xC1, 0xF2,
+	0x3A, 0x69, 0xDB, 0x44, 0xDB, 0x09, 0xE5, 0x3A, 0x78, 0xFA, 0x9C, 0xB5,
+	    0xC9, 0xD7, 0xB8, 0x8A, 0x42, 0x6E, 0x6A, 0x2A,
+	0xC9, 0xE7, 0xAC, 0xEE, 0x5B, 0x0B, 0x14, 0x6A, 0x0F, 0x41, 0x11, 0x58,
+	    0x1F, 0xB6, 0x36, 0xBA, 0xC8, 0x43, 0x65, 0x9E,
+	0x7F, 0x6B, 0xA4, 0x4D, 0xE5, 0x3C, 0xC8, 0xA4, 0xE5, 0xE5, 0x3B, 0x61,
+	    0xCC, 0xB5, 0xEB, 0x92, 0x3B, 0x61, 0x2A, 0x57,
+	0x5B, 0x7B, 0x33, 0xDF, 0x9A, 0x57, 0x63, 0xDD, 0x49, 0x4C, 0x0D, 0x4D,
+	    0x3A, 0x60, 0xA4, 0xC2, 0xA3, 0xBB, 0x7F, 0x06,
+	0x31, 0xD5, 0x4B, 0x5C, 0xE2, 0x37, 0x54, 0x05, 0x47, 0xFB, 0x0C, 0x52,
+	    0xA2, 0x1F, 0x6B, 0xD4, 0x3D, 0x5F, 0xA3, 0x52,
+	0x67, 0x81, 0x8B, 0x30, 0x5B, 0x2A, 0x6D, 0x01, 0xA6, 0x03, 0xBD, 0xC2,
+	    0x66, 0x5E, 0xE6, 0xDF, 0x43, 0x37, 0x6A, 0x47,
+	0x93, 0x1F, 0xAD, 0x53, 0x2D, 0x1D, 0xAD, 0x94, 0x3C, 0x39, 0xB5, 0xD1,
+	    0xED, 0xA4, 0xA5, 0x25, 0x52, 0x32, 0x1D, 0xC2,
+	0xC5, 0x12, 0x54, 0xB6, 0x01, 0x16, 0x1E, 0x1B, 0xC1, 0x52, 0x7B, 0xC0,
+	    0x56, 0x36, 0x34, 0x16, 0x97, 0x54, 0xB4, 0x3C,
+	0x2D, 0x7A, 0x58, 0x12, 0x47, 0x17, 0xA7, 0xD0, 0x8E, 0xF4, 0x4D, 0x6E,
+	    0x01, 0x96, 0x3D, 0x47, 0x58, 0xBA, 0x59, 0x9A,
+	0x43, 0xDE, 0x5A, 0xB0, 0xF4, 0x3D, 0x77, 0xEC, 0x5C, 0x9A, 0x5D, 0x29,
+	    0x33, 0xCC, 0x46, 0x0B, 0x61, 0x53, 0x5B, 0x1D,
+	0x75, 0xB8, 0x7E, 0x4A, 0x89, 0x5B, 0xFE, 0xA8, 0x4F, 0x38, 0x92, 0xAD,
+	    0x6C, 0xE3, 0x56, 0x40, 0x64, 0x3A, 0x76, 0x1A,
+	0x28, 0x5E, 0x97, 0xDB, 0x5A, 0x2B, 0x8E, 0x3A, 0x4B, 0x4B, 0x1E, 0x45,
+	    0x19, 0x8E, 0x67, 0xC9, 0x06, 0x97, 0xDC, 0x8D,
+	0xBE, 0x81, 0x05, 0x2D, 0x9F, 0xCD, 0x14, 0xEB, 0xDB, 0x1A, 0x37, 0xC9,
+	    0xA1, 0x14, 0x68, 0x63, 0x44, 0x57, 0x4F, 0xA1,
+	0xF1, 0xD0, 0x9B, 0xB8, 0xFF, 0xA0, 0x14, 0x6C, 0xDD, 0xE1, 0xCF, 0x35,
+	    0x00, 0xA7, 0x5E, 0x8A, 0x88, 0x09, 0x46, 0x04,
+	0x6C, 0x31, 0xED, 0xDF, 0xD2, 0x12, 0x5E, 0x58, 0x14, 0x73, 0xCE, 0x7A,
+	    0xB6, 0xD2, 0xD6, 0x9B, 0x86, 0x72, 0x5D, 0xCC,
+	0x41, 0x5A, 0xC7, 0x49, 0x9D, 0xA1, 0xD3, 0x19, 0x15, 0x51, 0xD5, 0x0B,
+	    0xDE, 0x78, 0xDF, 0x9E, 0x5E, 0x96, 0x70, 0x2F,
+	0x9A, 0xBF, 0x65, 0x1B, 0x23, 0xD5, 0x4F, 0x79, 0x8C, 0x84, 0xA9, 0x3E,
+	    0x02, 0x1A, 0x7F, 0x85, 0x94, 0x2F, 0xBA, 0x51,
+	0xC3, 0x71, 0xCB, 0x5D, 0x77, 0xCF, 0x84, 0x89, 0x04, 0x01, 0xE2, 0xE8,
+	    0xB6, 0xC4, 0x06, 0xC3, 0x66, 0x83, 0xA8, 0x92,
+	0x57, 0x8F, 0x79, 0x61, 0x7F, 0x7F, 0xC1, 0x46, 0x6D, 0xAF, 0xA1, 0xA7,
+	    0xB7, 0xFC, 0x1E, 0x5D, 0x09, 0xA3, 0xAA, 0xAD,
+	0xC1, 0x7E, 0x91, 0xC7, 0x62, 0xAC, 0x67, 0xC2, 0x3A, 0x81, 0xE0, 0x88,
+	    0x70, 0x65, 0x47, 0xB3, 0x9A, 0xC4, 0xBA, 0x43,
+	0xB5, 0xA2, 0xF4, 0x10, 0xE5, 0xC7, 0x44, 0x96, 0xA9, 0xEB, 0x17, 0x76,
+	    0x88, 0x87, 0x78, 0x24, 0xE0, 0x78, 0xFC, 0x82,
+	0x4F, 0xCA, 0xB0, 0x66, 0x8A, 0x58, 0x89, 0xC9, 0xA4, 0x50, 0xE9, 0x0B,
+	    0x77, 0xA9, 0x8E, 0x98, 0x44, 0xC5, 0x61, 0x18,
+	0x5B, 0x50, 0xDE, 0x52, 0x0A, 0x8B, 0xFB, 0x57, 0x91, 0x6E, 0xE9, 0xF1,
+	    0x1A, 0x48, 0x56, 0x53, 0xF3, 0xAB, 0x78, 0x11,
+	0x78, 0xCA, 0x16, 0xFE, 0x40, 0xA7, 0xE8, 0x85, 0x4A, 0x33, 0xA1, 0xA6,
+	    0xF9, 0x61, 0xBA, 0x58, 0xAC, 0x85, 0xA0, 0x1A,
+	0xBE, 0xE8, 0x60, 0x3B, 0xEE, 0x8B, 0x3A, 0xF9, 0x79, 0x85, 0x68, 0x7A,
+	    0x2D, 0x75, 0xC3, 0x4E, 0x69, 0xA7, 0x2D, 0xA9,
+	0xC9, 0xAE, 0x93, 0xBD, 0x54, 0xE2, 0x53, 0x59, 0x01, 0x87, 0xCB, 0x5F,
+	    0x71, 0xA6, 0xE6, 0x5A, 0xE9, 0x89, 0x2B, 0xCF,
+	0x7A, 0x1A, 0x0A, 0x4A, 0x65, 0x68, 0x80, 0xF0, 0x22, 0x43, 0x28, 0x6B,
+	    0xED, 0x68, 0xFE, 0x29, 0x3D, 0xFC, 0x8A, 0x65,
+	0x2B, 0xC3, 0xF8, 0x66, 0x19, 0x64, 0x20, 0x87, 0x4F, 0x8C, 0x6A, 0x01,
+	    0xD0, 0x5B, 0x67, 0x4B, 0x0D, 0x80, 0x73, 0x3D,
+	0x69, 0x73, 0x39, 0xA7, 0xC8, 0xF5, 0x14, 0x87, 0x78, 0xA1, 0x2D, 0x29,
+	    0x64, 0x24, 0x89, 0xE1, 0x9D, 0x40, 0x1B, 0x3A,
+	0x3A, 0xC2, 0xF3, 0x6F, 0x02, 0x52, 0x1C, 0x52, 0x78, 0x18, 0x47, 0x46,
+	    0x3C, 0xF1, 0x55, 0x40, 0xC8, 0x5B, 0xC7, 0x82,
+	0x72, 0xAB, 0x5C, 0xEC, 0x86, 0xF4, 0x40, 0xE9, 0xEF, 0x6C, 0x66, 0x38,
+	    0xC6, 0xB4, 0xA4, 0xB3, 0x8B, 0x91, 0x15, 0x61,
+	0x26, 0x9A, 0x0A, 0xF9, 0x69, 0xF3, 0x55, 0x41, 0x64, 0x32, 0x30, 0x23,
+	    0xA0, 0xBE, 0x92, 0x71, 0x81, 0x95, 0xCE, 0xD7,
+	0xF9, 0x4E, 0x67, 0x33, 0x46, 0x94, 0x39, 0xB3, 0x82, 0x64, 0x44, 0x50,
+	    0xA6, 0x9E, 0x5B, 0x42, 0x28, 0x8C, 0xBD, 0x66,
+	0x5D, 0x5F, 0x74, 0xAE, 0x76, 0x0B, 0x93, 0xA0, 0xF1, 0x4A, 0x2C, 0x42,
+	    0x40, 0x17, 0x90, 0x69, 0x66, 0x55, 0x03, 0x09,
+	0x88, 0x0A, 0x64, 0x84, 0x47, 0x60, 0x75, 0x43, 0xD3, 0x6C, 0xAA, 0xE3,
+	    0xC2, 0x2B, 0x0A, 0x18, 0x09, 0x09, 0xFD, 0xF7,
+	0x46, 0x38, 0xA3, 0x06, 0xFC, 0xF6, 0xC2, 0x68, 0x18, 0x96, 0x02, 0x08,
+	    0x08, 0x08, 0x2E, 0x3D, 0xCD, 0x97, 0xC1, 0x71,
+	0xC9, 0x2E, 0x35, 0x8E, 0xEE, 0xD0, 0x76, 0x57, 0x1C, 0xB9, 0x64, 0x64,
+	    0x8E, 0x94, 0x49, 0x61, 0xCC, 0x6F, 0x36, 0x14,
+	0xCC, 0x53, 0x46, 0xCC, 0x4E, 0x3C, 0x47, 0xCB, 0x4A, 0x97, 0x5C, 0xAB,
+	    0x31, 0x07, 0xC2, 0xD9, 0x4F, 0xDC, 0xEE, 0x9D,
+	0x9F, 0x05, 0x65, 0x86, 0xEC, 0x93, 0x54, 0xBB, 0x32, 0xB9, 0xC4, 0x59,
+	    0x4C, 0x51, 0x47, 0x57, 0x49, 0x70, 0xBD, 0x39,
+	0x51, 0xD0, 0x26, 0xBA, 0x69, 0xFE, 0xDA, 0x91, 0xB0, 0x23, 0x09, 0x11,
+	    0x81, 0x03, 0x4E, 0x8A, 0x8E, 0x15, 0x5F, 0xF0,
+	0x1B, 0xBB, 0xDA, 0x95, 0x4E, 0x1D, 0x01, 0x01, 0x80, 0x02, 0x74, 0x8D,
+	    0xCC, 0x98, 0x25, 0x33, 0x8A, 0xEB, 0xE7, 0xF4,
+	0x6A, 0x0A, 0x08, 0x10, 0x01, 0x01, 0x4F, 0x39, 0x8B, 0x34, 0x39, 0xEB,
+	    0xDC, 0x5F, 0xBA, 0x80, 0x4C, 0xBA, 0x00, 0x00,
+	0xE5, 0x94, 0x80, 0x09, 0xDE, 0x40, 0x3B, 0xA1, 0xE7, 0xDD, 0x4E, 0xB6,
+	    0x98, 0xEB, 0xA8, 0xDB, 0xA5, 0x03, 0xBF, 0x11,
+	0x8C, 0x0D, 0x33, 0xA5, 0x1F, 0x8E, 0x7E, 0xC1, 0x83, 0xC1, 0xE6, 0xA4,
+	    0xA4, 0xC2, 0x87, 0xA5, 0x0F, 0x00, 0x97, 0x95,
+	0x7B, 0xA0, 0xF7, 0x67, 0x21, 0xED, 0x6A, 0x5A, 0xB8, 0xE0, 0x61, 0x6E,
+	    0xC2, 0x63, 0x4D, 0x17, 0x9F, 0x8E, 0x67, 0xAF,
+	0x2A, 0xB5, 0x5D, 0xC6, 0xDF, 0x67, 0xE8, 0xCA, 0xE9, 0x90, 0x20, 0x7B,
+	    0x36, 0x4A, 0x2E, 0xE1, 0xF7, 0xED, 0x8B, 0x64,
+	0x54, 0x34, 0xED, 0x44, 0x84, 0x13, 0xE0, 0x96, 0xCF, 0x27, 0xC9, 0xE5,
+	    0xAA, 0xC4, 0x27, 0x0A, 0x7D, 0xBA, 0x1F, 0x5A,
+	0x86, 0xAD, 0x81, 0x7A, 0x9A, 0x4A, 0x47, 0x81, 0xB2, 0xE2, 0xFE, 0x1A,
+	    0xBA, 0x6B, 0x19, 0xCF, 0x78, 0xA3, 0x99, 0x5D,
+	0xD3, 0xDC, 0x07, 0x93, 0xC7, 0xC2, 0x66, 0x45, 0x52, 0xC8, 0x1A, 0x05,
+	    0x6B, 0x68, 0xD4, 0x3D, 0xB9, 0xD7, 0x4C, 0xB3,
+	0x58, 0xE7, 0x56, 0x5F, 0x32, 0xC9, 0xF1, 0x47, 0x4A, 0x96, 0x35, 0x2D,
+	    0x5B, 0x86, 0x44, 0x0F, 0xC8, 0xE6, 0x4E, 0xC2,
+	0xA4, 0xC8, 0x94, 0xF6, 0x69, 0xD9, 0xBD, 0xBD, 0xB6, 0xF5, 0x70, 0xD8,
+	    0x2C, 0xFE, 0xAB, 0xD2, 0x31, 0xE9, 0xA4, 0xDB,
+	0x0A, 0x4D, 0xC9, 0x63, 0xF3, 0x49, 0x2D, 0xC8, 0x29, 0x0B, 0xD9, 0xCE,
+	    0x9B, 0xB6, 0xB5, 0xB7, 0xC2, 0xDB, 0xC2, 0x4E,
+	0x1E, 0xD7, 0xE1, 0x8A, 0x22, 0xCE, 0x17, 0x12, 0x38, 0x88, 0x6C, 0xE2,
+	    0xF8, 0x38, 0x4B, 0x4C, 0x64, 0x6D, 0x9E, 0x8B,
+	0x45, 0xB8, 0x6D, 0xFC, 0x2C, 0x6D, 0xB8, 0x5A, 0x70, 0xB1, 0xC7, 0x52,
+	    0x94, 0x2D, 0x2D, 0xF9, 0x3F, 0xED, 0xAD, 0xE1,
+	0x5A, 0xFC, 0x0A, 0x32, 0x04, 0x89, 0xEB, 0x59, 0xE4, 0x0F, 0x9A, 0x06,
+	    0xE5, 0xE9, 0xEC, 0x4D, 0xA8, 0x6F, 0x12, 0x78,
+	0x20, 0x52, 0x84, 0xBF, 0x58, 0xAB, 0xCB, 0xA1, 0xBC, 0x52, 0xCC, 0xA1,
+	    0x74, 0x30, 0x34, 0x6F, 0xD4, 0x72, 0x33, 0x7C,
+	0x35, 0x5D, 0x7A, 0x39, 0x62, 0x31, 0x48, 0x27, 0xD0, 0xAE, 0x84, 0xDA,
+	    0x5D, 0xB3, 0x85, 0x01, 0xA4, 0x8E, 0xC8, 0xA5,
+	0x5D, 0x3C, 0x6C, 0x9A, 0xE6, 0x8F, 0x22, 0xEE, 0x78, 0x8C, 0x59, 0xCB,
+	    0x9F, 0xEF, 0x9D, 0xB5, 0x16, 0xFE, 0x22, 0x84,
+	0x50, 0x8C, 0xE1, 0xD4, 0xA5, 0x02, 0x40, 0xC0, 0x3E, 0xC8, 0xEF, 0xF3,
+	    0x98, 0xE9, 0x00, 0x1A, 0x8F, 0xD5, 0x8A, 0x17,
+	0xE1, 0x15, 0x5B, 0x94, 0x3F, 0x75, 0xA1, 0x78, 0x75, 0x15, 0x8A, 0x78,
+	    0x98, 0x27, 0x15, 0xDC, 0xD3, 0xBB, 0xFB, 0x45,
+	0x3F, 0x90, 0x73, 0x5B, 0x13, 0xFD, 0x10, 0x16, 0xEC, 0xAB, 0x45, 0x61,
+	    0x4A, 0x56, 0xCB, 0x6D, 0x5A, 0x14, 0xDD, 0xD9,
+	0xF9, 0x17, 0x5D, 0xE5, 0xBC, 0xDA, 0x56, 0x80, 0x64, 0xA5, 0xEF, 0x67,
+	    0x50, 0xFA, 0xC6, 0x08, 0xC9, 0xF8, 0x2D, 0x09,
+	0x8F, 0x85, 0xDA, 0x62, 0xC0, 0xA8, 0xC8, 0x6F, 0x73, 0x9D, 0x9A, 0xCA,
+	    0x82, 0x0B, 0x25, 0x0D, 0x73, 0xD6, 0x11, 0xEB,
+	0x53, 0x87, 0xF9, 0x19, 0x4D, 0x99, 0x49, 0x25, 0xE0, 0x5E, 0x81, 0x29,
+	    0x13, 0x38, 0x25, 0x49, 0x0A, 0x93, 0xDF, 0x15,
+	0x9B, 0x4B, 0xA2, 0xC9, 0xED, 0x50, 0xDB, 0xAE, 0xCD, 0x99, 0x5E, 0x48,
+	    0xE2, 0x5E, 0x96, 0xAE, 0x30, 0x97, 0xD6, 0x71,
+	0x83, 0xBE, 0x96, 0xAB, 0xB0, 0x7F, 0x70, 0xA6, 0xE3, 0xE0, 0xAE, 0x2D,
+	    0x75, 0x1D, 0x4A, 0x8B, 0x4F, 0x54, 0xD2, 0x8F,
+	0x51, 0x7E, 0xE7, 0xDA, 0xA0, 0x7A, 0x81, 0x47, 0xD1, 0xFC, 0xBB, 0x7B,
+	    0xEA, 0x56, 0xDF, 0xE8, 0xFE, 0xDE, 0x37, 0x5D,
+	0xBF, 0xE1, 0x91, 0x55, 0x29, 0x94, 0x1F, 0xEA, 0xED, 0x1B, 0xE7, 0x7C,
+	    0x90, 0xDD, 0x97, 0x26, 0x22, 0xC0, 0xDE, 0x83,
+	0xFD, 0x43, 0x98, 0xA8, 0x94, 0x54, 0xE6, 0xA3, 0xBF, 0x82, 0x9F, 0x13,
+	    0x88, 0x8D, 0x7A, 0xB3, 0xE2, 0x5C, 0xB8, 0xF4,
+	0xD7, 0xC2, 0x47, 0x45, 0x33, 0x82, 0x21, 0x27, 0x0B, 0x80, 0xB7, 0x65,
+	    0x6B, 0x0F, 0x16, 0x38, 0xAF, 0xB6, 0x8F, 0x92,
+	0xBC, 0xEF, 0x41, 0xE2, 0x8F, 0x67, 0xBF, 0x87, 0x7E, 0x21, 0xDA, 0xC8,
+	    0xE7, 0xD3, 0x42, 0x48, 0xBD, 0x61, 0x60, 0x82,
+	0x0A, 0xC4, 0x47, 0xD6, 0x7D, 0xE6, 0x48, 0x9C, 0xBB, 0x65, 0x30, 0x6A,
+	    0x8F, 0x19, 0xD1, 0x95, 0xC5, 0x85, 0x8E, 0xD3,
+	0x14, 0xC5, 0x83, 0x0D, 0x2F, 0x47, 0x2C, 0x88, 0xAA, 0x64, 0xE1, 0x85,
+	    0x32, 0x27, 0x61, 0x34, 0x90, 0xC8, 0x49, 0x9C,
+	0x33, 0xA5, 0xE7, 0x05, 0x29, 0x3B, 0x21, 0x56, 0x83, 0xC7, 0x69, 0x46,
+	    0x9E, 0x0A, 0x07, 0xF7, 0x32, 0x64, 0xD1, 0x84,
+	0xC9, 0x3A, 0x7C, 0x8E, 0x8D, 0x23, 0x19, 0xBF, 0x12, 0x07, 0x30, 0xD7,
+	    0x4C, 0xCC, 0xCC, 0xBE, 0xA9, 0x4B, 0x02, 0x5C,
+	0x51, 0x7C, 0xE8, 0x9A, 0x19, 0x89, 0x7F, 0x9A, 0x59, 0x49, 0xFE, 0x2D,
+	    0x1F, 0xAB, 0xE7, 0x1C, 0xE7, 0x08, 0x67, 0xFC,
+	0x96, 0x0E, 0xB3, 0xD6, 0xC4, 0x3E, 0x77, 0xDC, 0xD2, 0x45, 0xBD, 0xE7,
+	    0x8D, 0x3E, 0x58, 0x20, 0xF1, 0x70, 0xE4, 0x3F,
+	0x4D, 0x8B, 0x13, 0x22, 0x34, 0xF9, 0xC9, 0xBB, 0xB1, 0xEC, 0x32, 0x2E,
+	    0x56, 0x07, 0xB6, 0x99, 0x44, 0x82, 0xA0, 0x79,
+	0xB5, 0xBE, 0x0B, 0xAB, 0xDF, 0x8D, 0xD0, 0xAD, 0x4D, 0x00, 0x2A, 0x90,
+	    0xB4, 0x69, 0x9C, 0x1C, 0xA8, 0x10, 0x3D, 0xA4,
+	0xAC, 0xC2, 0xA0, 0x4E, 0x1E, 0xCE, 0xF4, 0xCB, 0x18, 0x71, 0x44, 0xF7,
+	    0x23, 0x8D, 0x35, 0x40, 0x8B, 0x24, 0x2B, 0x2F,
+	0x9B, 0xA6, 0x8C, 0x04, 0x07, 0x18, 0xED, 0x1D, 0x20, 0x32, 0x25, 0x71,
+	    0xEE, 0x3B, 0xA5, 0x77, 0x3A, 0x54, 0x7F, 0x53,
+	0x2E, 0x64, 0x07, 0x37, 0x88, 0x32, 0x0B, 0x63, 0xC9, 0x9D, 0x79, 0x67,
+	    0x3B, 0x55, 0xAB, 0x3A, 0x47, 0xA1, 0x86, 0x45,
+	0xBF, 0x5A, 0x42, 0x8B, 0xCF, 0x57, 0xFB, 0x17, 0x35, 0xB6, 0x6B, 0x37,
+	    0x65, 0x76, 0x16, 0x31, 0x28, 0x14, 0x73, 0xA0,
+	0x25, 0x38, 0xF3, 0x07, 0x34, 0x1E, 0x6B, 0xC0, 0x8F, 0x7B, 0xDF, 0xB3,
+	    0x21, 0x25, 0x44, 0xDB, 0xEE, 0xD6, 0xA1, 0x64,
+	0xB6, 0x44, 0x52, 0x63, 0xEA, 0x79, 0x95, 0x17, 0x30, 0xFA, 0x52, 0xAC,
+	    0x84, 0xF0, 0x2E, 0x56, 0x5C, 0x57, 0xBC, 0xFE,
+	0xB8, 0xD1, 0xBD, 0x7C, 0x1C, 0xC7, 0xC5, 0xD0, 0xAC, 0xF2, 0xBB, 0x56,
+	    0x24, 0x1D, 0xCE, 0xF0, 0x1B, 0xD9, 0xAB, 0x72,
+	0xFE, 0x5D, 0x53, 0xAC, 0x04, 0x35, 0xE9, 0x26, 0xA5, 0xA1, 0x7A, 0xE0,
+	    0xE1, 0x93, 0x85, 0xF5, 0xAB, 0x5C, 0x14, 0x9A,
+	0xA9, 0x8E, 0xF0, 0xDF, 0x5E, 0xB3, 0x64, 0x4A, 0x3E, 0x2D, 0x11, 0x31,
+	    0x97, 0x4E, 0x70, 0x95, 0x7F, 0xD7, 0x99, 0xA3,
+	0xCE, 0xFB, 0x45, 0x3E, 0x79, 0x65, 0x0C, 0x4D, 0x91, 0x52, 0x04, 0x91,
+	    0x74, 0x2E, 0xE4, 0xB0, 0xDC, 0x65, 0x25, 0x55,
+	0x14, 0xD9, 0xE9, 0x35, 0xF8, 0x55, 0x4E, 0x3B, 0x7B, 0x24, 0x2E, 0xC4,
+	    0x40, 0x1A, 0x80, 0x8A, 0x4C, 0x24, 0x89, 0xB7,
+	0x16, 0x7E, 0xA0, 0xB9, 0x2C, 0x37, 0xB8, 0x47, 0x1C, 0xBF, 0x50, 0x6B,
+	    0xE2, 0x71, 0xB0, 0x64, 0x15, 0x3E, 0x16, 0xEB,
+	0x29, 0x32, 0xF8, 0x7E, 0xC0, 0x30, 0xC1, 0x18, 0x71, 0x9D, 0xA0, 0x76,
+	    0xED, 0x56, 0x1F, 0xCF, 0x4E, 0x4B, 0x62, 0xEB,
+	0x57, 0xBC, 0xCC, 0x09, 0x42, 0x73, 0xBF, 0x1E, 0xB0, 0xDE, 0xAF, 0xA5,
+	    0xC5, 0xBD, 0x3B, 0x21, 0x47, 0x3E, 0x7F, 0xAD,
+	0x6C, 0xD1, 0xBA, 0x1F, 0xDD, 0x8F, 0xC3, 0x3F, 0x02, 0xDB, 0xC7, 0xEA,
+	    0xA8, 0xD2, 0x2E, 0x0D, 0x20, 0x4A, 0xD8, 0x21,
+	0x54, 0x80, 0x08, 0x94, 0x15, 0xBD, 0x5C, 0x87, 0xB0, 0xFE, 0xE1, 0x7B,
+	    0xBC, 0x7D, 0xA6, 0x95, 0x73, 0x6C, 0x01, 0x3A,
+	0xE0, 0x99, 0x41, 0x09, 0x72, 0xDD, 0xEE, 0x53, 0xA2, 0x74, 0x86, 0x9E,
+	    0x90, 0x10, 0xB6, 0x20, 0x20, 0xFC, 0x36, 0x24,
+	0x30, 0xDC, 0xC4, 0x30, 0x41, 0x83, 0x1B, 0xC9, 0x43, 0x98, 0xE7, 0xD1,
+	    0xEB, 0x96, 0x7F, 0x75, 0x58, 0x8B, 0xF4, 0x02,
+	0xA9, 0x06, 0x7C, 0xE2, 0x42, 0x99, 0xE4, 0xF5, 0xD6, 0x66, 0xB6, 0xC4,
+	    0x70, 0x35, 0x6B, 0x41, 0xB2, 0x2B, 0xF8, 0x75,
+	0xDE, 0x23, 0xF2, 0xCC, 0xB1, 0x46, 0x87, 0x3B, 0xF8, 0xA4, 0xE5, 0x03,
+	    0x29, 0x24, 0x81, 0x13, 0xDE, 0x08, 0xE2, 0x9B,
+	0x38, 0x86, 0xDF, 0xC0, 0x78, 0xC5, 0x3B, 0x71, 0xC0, 0x27, 0x5C, 0x9D,
+	    0x60, 0x2A, 0xB9, 0xAD, 0xFF, 0xF5, 0x39, 0xA9,
+	0xEF, 0xD5, 0xCF, 0x29, 0x7F, 0x7E, 0xF2, 0x2E, 0x18, 0xB3, 0xB1, 0xA8,
+	    0xC5, 0xA6, 0x31, 0xAD, 0x53, 0x86, 0xBB, 0xA4,
+	0xD1, 0xBB, 0xD8, 0x23, 0x13, 0xC2, 0x11, 0x4B, 0x63, 0x78, 0x95, 0x99,
+	    0x73, 0xE8, 0x4E, 0xE9, 0x54, 0xF8, 0xF2, 0xD0,
+	0xDA, 0xBE, 0xCA, 0x1B, 0xA9, 0xA6, 0xCD, 0x62, 0xF1, 0x19, 0xAE, 0xA0,
+	    0x7D, 0x99, 0x59, 0x26, 0xB2, 0x89, 0x68, 0xBB,
+	0x44, 0xD1, 0xF8, 0xFD, 0x5C, 0x83, 0xD2, 0x7D, 0x72, 0xE8, 0x2D, 0xCC,
+	    0xB3, 0x0C, 0x74, 0xFC, 0x29, 0x00, 0xEC, 0xCC,
+	0x97, 0x20, 0xBC, 0x89, 0x81, 0x6D, 0x3A, 0x75, 0xA6, 0xE7, 0x11, 0x52,
+	    0x61, 0xCC, 0x01, 0x5E, 0xD0, 0x6A, 0x12, 0xFF,
+	0x02, 0x7C, 0x3F, 0x6F, 0xD2, 0x02, 0x5F, 0xF9, 0xDB, 0x1F, 0xB5, 0xD9,
+	    0x37, 0x22, 0x05, 0xEB, 0xC3, 0xEB, 0x18, 0x3A,
+	0xD5, 0xC0, 0x47, 0xFF, 0x0E, 0xB6, 0x92, 0x46, 0xB3, 0x76, 0xAF, 0x11,
+	    0x72, 0xFF, 0x5A, 0x1F, 0x74, 0x01, 0x34, 0x6F,
+	0xD4, 0x72, 0x3B, 0x95, 0xBC, 0x3D, 0x22, 0x31, 0xEE, 0xD7, 0x1E, 0x48,
+	    0xE3, 0x8A, 0x3D, 0x7F, 0x5D, 0xB3, 0x32, 0xA1,
+	0x3F, 0x30, 0x54, 0xB2, 0xD4, 0x70, 0xAB, 0x04, 0xD2, 0x7F, 0xF6, 0xEE,
+	    0xC9, 0x61, 0xE5, 0x8A, 0xB3, 0x87, 0x1D, 0xF1,
+	0x98, 0xF7, 0xF5, 0xB7, 0xB1, 0xA8, 0x04, 0xB3, 0x1E, 0x95, 0xCC, 0x3B,
+	    0x93, 0x35, 0x6A, 0x61, 0x42, 0x59, 0x03, 0x06,
+	0x0D, 0x74, 0x29, 0x3E, 0xBA, 0xE8, 0x3D, 0x3C, 0xD0, 0x78, 0x7F, 0xF0,
+	    0xAB, 0xB4, 0x87, 0xF4, 0xF1, 0x3D, 0x0D, 0x3E,
+	0x43, 0x95, 0xFD, 0xC0, 0xB6, 0x26, 0xD2, 0xA7, 0x70, 0xFD, 0x0E, 0xF1,
+	    0x89, 0x70, 0x60, 0x3C, 0xAB, 0x13, 0x8F, 0x35,
+	0xBF, 0x77, 0x7A, 0x00, 0x7F, 0x97, 0xCD, 0x97, 0x40, 0x12, 0x78, 0x05,
+	    0xDD, 0xBB, 0xC2, 0xF3, 0x58, 0x3A, 0xD4, 0xAE,
+	0xA0, 0xFA, 0xF7, 0x51, 0x7B, 0xAC, 0xDE, 0x38, 0x88, 0x38, 0xEB, 0x6F,
+	    0x2B, 0x3A, 0x26, 0x47, 0xD5, 0xBB, 0xDD, 0x82,
+	0x67, 0x62, 0xC6, 0x7A, 0xBE, 0xB7, 0xF9, 0x04, 0x59, 0xB9, 0xB3, 0xCB,
+	    0x1F, 0x3F, 0xD5, 0xB2, 0xB2, 0xD7, 0x5F, 0x81,
+	0xB9, 0x60, 0x8E, 0x8D, 0xC6, 0x3B, 0xAE, 0x31, 0x51, 0x69, 0x1F, 0xFA,
+	    0xD7, 0xA7, 0xC4, 0x25, 0x22, 0x47, 0xC7, 0xC9,
+	0x78, 0x37, 0xBE, 0x62, 0xEA, 0xEC, 0xEE, 0x07, 0xD6, 0x71, 0x09, 0xD6,
+	    0x7D, 0x29, 0xDC, 0xE8, 0x18, 0x5D, 0x5E, 0xEB,
+	0x07, 0xE9, 0x72, 0x78, 0x67, 0x7C, 0x22, 0x20, 0xA9, 0x6A, 0x43, 0xC9,
+	    0xAA, 0x1B, 0xFF, 0x63, 0x81, 0xCA, 0x2E, 0xCA,
+	0x5B, 0x01, 0x88, 0xF6, 0xF1, 0x4A, 0x4F, 0xD5, 0xD1, 0xBE, 0x01, 0xF6,
+	    0xA7, 0x11, 0x87, 0xED, 0x10, 0x4E, 0x60, 0x33,
+	0x78, 0x7F, 0xDE, 0x8F, 0xE1, 0x03, 0x05, 0xBF, 0x42, 0x90, 0x98, 0x24,
+	    0x3F, 0x57, 0x3A, 0xEA, 0x05, 0xC3, 0xEA, 0xE7,
+	0xB6, 0xE1, 0x00, 0xCC, 0xB8, 0x60, 0xE8, 0x54, 0x11, 0x3A, 0x1B, 0xA6,
+	    0x73, 0x37, 0xE0, 0xF4, 0x86, 0x0F, 0x43, 0xDC,
+	0xEA, 0x64, 0x35, 0xAA, 0x3D, 0xC1, 0xA8, 0x48, 0x78, 0x22, 0x9B, 0x29,
+	    0x36, 0x02, 0x01, 0xCC, 0x30, 0xA0, 0xD8, 0xCA,
+	0x77, 0xE7, 0xBD, 0x43, 0x31, 0xB2, 0x9E, 0xC3, 0x34, 0x72, 0xB0, 0xFC,
+	    0x8E, 0xA6, 0x64, 0xE4, 0xCC, 0xEE, 0x56, 0x7F,
+	0x67, 0x8F, 0x49, 0xCF, 0x13, 0x05, 0x42, 0x81, 0x95, 0x61, 0x10, 0x6E,
+	    0xD7, 0xA5, 0x3C, 0x83, 0x06, 0x56, 0x9E, 0xDF,
+	0x92, 0x66, 0x96, 0x92, 0x1C, 0xD6, 0xC9, 0xC7, 0x3B, 0x66, 0x96, 0x21,
+	    0xE5, 0xB1, 0xB2, 0x95, 0x14, 0xE1, 0xBB, 0x45,
+	0x0F, 0x25, 0x51, 0x6F, 0x55, 0xD1, 0x1A, 0xF5, 0xF9, 0xEB, 0x67, 0xFD,
+	    0x02, 0x75, 0xC9, 0x55, 0x24, 0x0A, 0xB0, 0xD2,
+	0xCE, 0x13, 0x54, 0x97, 0xF8, 0x0A, 0xEC, 0x9F, 0x9D, 0x3D, 0x7C, 0xC9,
+	    0x07, 0x34, 0xFC, 0xCF, 0x1B, 0x5D, 0xD8, 0x74,
+	0xEC, 0x86, 0xF5, 0x83, 0x77, 0xF8, 0x4D, 0xBF, 0x39, 0x69, 0xE3, 0x31,
+	    0x9E, 0x1E, 0x8D, 0xE8, 0x9B, 0x7E, 0xED, 0x9B,
+	0x99, 0xCB, 0x2D, 0xB2, 0x26, 0xF9, 0xE5, 0xAA, 0x1C, 0xEF, 0x9B, 0x01,
+	    0xF3, 0xB0, 0x55, 0x6A, 0x9F, 0xA1, 0xC4, 0x9B,
+	0xA6, 0xC8, 0xBA, 0x0C, 0x7C, 0x21, 0xCB, 0xC6, 0x97, 0x7F, 0xC2, 0x58,
+	    0x9E, 0xA3, 0x7B, 0x48, 0xA4, 0x48, 0x7A, 0x38,
+	0x4B, 0xEB, 0xBE, 0x4A, 0x12, 0x3C, 0xCB, 0xAD, 0x1F, 0xCA, 0x4D, 0x5A,
+	    0xA5, 0xC1, 0xF1, 0xA9, 0xCA, 0xEA, 0x4B, 0xC6,
+	0xAD, 0x1F, 0xB5, 0x9D, 0x8F, 0xA9, 0x45, 0xFB, 0xEC, 0x4D, 0x9E, 0xBF,
+	    0x7E, 0x65, 0x20, 0x6E, 0xBE, 0xAB, 0x84, 0x82,
+	0x4B, 0xF0, 0xF4, 0xAE, 0x8F, 0x6F, 0x60, 0xF8, 0xE7, 0xCF, 0xB9, 0xA2,
+	    0x26, 0x6E, 0x77, 0x96, 0xCD, 0x10, 0x86, 0xA1,
+	0x7B, 0x95, 0x07, 0x06, 0xAD, 0x5E, 0x6D, 0x81, 0xF0, 0x3F, 0x02, 0x0B,
+	    0x48, 0x53, 0x06, 0x41, 0xE2, 0xA2, 0xA7, 0xE5,
+	0x1F, 0x10, 0x17, 0x23, 0x3F, 0xCC, 0xF6, 0x97, 0xB3, 0xE3, 0x1B, 0x3F,
+	    0x69, 0x0E, 0x7F, 0xB5, 0xCD, 0x5E, 0xA7, 0xE9,
+	0x78, 0xD6, 0x8F, 0xA6, 0x3A, 0xF4, 0x15, 0x12, 0x6E, 0x75, 0xD4, 0xBF,
+	    0x09, 0xD4, 0x0A, 0xB0, 0xD0, 0x68, 0x54, 0x25,
+	0x07, 0xA7, 0x2A, 0x6E, 0x8C, 0x07, 0xA7, 0xF6, 0xF5, 0xBD, 0xE4, 0x71,
+	    0x59, 0xF5, 0xE4, 0x64, 0x85, 0xC9, 0xB2, 0x10,
+	0xB8, 0x5B, 0x2E, 0xF3, 0x8D, 0xF0, 0x7B, 0xB1, 0x58, 0x4A, 0x55, 0x24,
+	    0xDF, 0xA5, 0xC8, 0x6A, 0x50, 0xE2, 0xED, 0x95,
+	0x44, 0x92, 0x0B, 0xF5, 0xB5, 0xE3, 0x89, 0xF1, 0x54, 0xB5, 0x4E, 0x8D,
+	    0x91, 0xD7, 0xE2, 0x0E, 0xDD, 0x38, 0xED, 0x91,
+	0x73, 0x9D, 0xD0, 0x13, 0x46, 0x39, 0x40, 0x27, 0x8C, 0x7A, 0x9E, 0xAE,
+	    0x0A, 0xEF, 0x23, 0x84, 0xF6, 0xCE, 0xD9, 0x17,
+	0x49, 0xD9, 0x6D, 0xAA, 0x84, 0x28, 0x6C, 0x25, 0x83, 0xF5, 0xE8, 0x3B,
+	    0xFD, 0x99, 0x90, 0x58, 0x77, 0xE9, 0xFC, 0x48,
+	0xBB, 0xAE, 0x60, 0x5F, 0x29, 0x79, 0xB2, 0x34, 0xD3, 0x3D, 0x5E, 0x3D,
+	    0x46, 0xAE, 0xB1, 0x6E, 0x7A, 0x5B, 0xCE, 0x05,
+	0xD2, 0xF1, 0x38, 0x4A, 0xC4, 0x1F, 0xE9, 0xA1, 0x1D, 0x50, 0x85, 0x85,
+	    0x07, 0xD0, 0x52, 0x7A, 0x63, 0xFC, 0x21, 0x38,
+	0xE4, 0x43, 0x5F, 0x30, 0xB0, 0xF8, 0x88, 0x4E, 0x24, 0xD3, 0x0E, 0xC8,
+	    0x5F, 0x81, 0x49, 0x4A, 0x2B, 0x30, 0x6B, 0x18,
+	0x3F, 0x9F, 0x80, 0x85, 0xC1, 0x00, 0xA7, 0x5E, 0x94, 0xCE, 0x04, 0x02,
+	    0x70, 0x1B, 0xC4, 0x03, 0xB1, 0xFF, 0x28, 0x28,
+	0x88, 0x43, 0x52, 0x23, 0xB9, 0x6F, 0x49, 0x76, 0xEA, 0x02, 0x4C, 0x3A,
+	    0x53, 0x14, 0x38, 0xB0, 0x89, 0xB0, 0xC2, 0x30,
+	0x39, 0x83, 0xFC, 0x67, 0x6B, 0xF3, 0x35, 0x67, 0x6F, 0x57, 0x82, 0x81,
+	    0x90, 0x52, 0xE9, 0x02, 0x2D, 0x6D, 0x48, 0x77,
+	0x6A, 0x72, 0xCF, 0x91, 0x85, 0x8C, 0x8A, 0x91, 0x91, 0xE3, 0xE7, 0xA0,
+	    0x30, 0xC0, 0xBB, 0x32, 0x8C, 0x61, 0xF8, 0x60,
+	0x11, 0xE4, 0x70, 0xAE, 0xC0, 0x4C, 0x2F, 0x9A, 0x54, 0xD4, 0x02, 0x12,
+	    0x6B, 0x08, 0x8D, 0x70, 0xAD, 0xFA, 0x38, 0x30,
+	0x56, 0xC8, 0x18, 0x74, 0x17, 0x24, 0x59, 0x40, 0xD6, 0xFA, 0x67, 0xA7,
+	    0x8A, 0xCB, 0xDC, 0x91, 0xCE, 0x49, 0xC1, 0x17,
+	0x2D, 0xB9, 0x51, 0x7B, 0x82, 0x10, 0x4F, 0x32, 0x78, 0x28, 0x21, 0x02,
+	    0xC9, 0xEF, 0x35, 0xF5, 0x2F, 0x47, 0x43, 0x6E,
+	0xE3, 0x99, 0xFD, 0x36, 0xBB, 0x6A, 0x34, 0x10, 0x7C, 0x4C, 0x50, 0xDF,
+	    0x1E, 0xC8, 0x74, 0x2C, 0xE0, 0x78, 0x2A, 0x0F,
+	0x5F, 0x4D, 0x8D, 0x04, 0x81, 0x38, 0x1D, 0x7E, 0xDA, 0x67, 0x3D, 0x34,
+	    0xE0, 0x09, 0x06, 0x7B, 0x50, 0xC8, 0x12, 0x2B,
+	0xC4, 0xEE, 0xD3, 0x5E, 0xDA, 0xED, 0x1D, 0x21, 0x62, 0x8A, 0x30, 0xFF,
+	    0x35, 0xD6, 0x8A, 0xFF, 0xC9, 0x4F, 0x7B, 0x02,
+	0xFD, 0x27, 0x78, 0xCF, 0xA6, 0x53, 0xC7, 0x2B, 0x00, 0x6D, 0x12, 0x80,
+	    0x99, 0x47, 0x7E, 0x2E, 0xD9, 0xB8, 0x70, 0xDF,
+	0xA7, 0x11, 0xF0, 0xDB, 0xF0, 0x22, 0xDA, 0x88, 0x8D, 0x02, 0xBC, 0x78,
+	    0x30, 0xEB, 0x79, 0xCE, 0x26, 0x11, 0xE6, 0x4B,
+	0x0E, 0x4A, 0x51, 0x99, 0x22, 0x4A, 0x31, 0x72, 0x14, 0xC5, 0x65, 0x5F,
+	    0x1A, 0x53, 0x91, 0x5C, 0x15, 0x6E, 0x5A, 0x9F,
+	0x49, 0x47, 0x5B, 0x0F, 0x30, 0xB9, 0xDF, 0x81, 0xA0, 0x50, 0xFA, 0x10,
+	    0x78, 0x32, 0x7C, 0x42, 0xE3, 0x5D, 0xB4, 0xA5,
+	0xD7, 0x60, 0xB3, 0x30, 0xC4, 0x91, 0x0B, 0xD4, 0x9B, 0x4A, 0x18, 0xF7,
+	    0xE0, 0x5F, 0xA6, 0x33, 0xDD, 0x6E, 0xDE, 0x81,
+	0x74, 0x53, 0xBB, 0x05, 0x3D, 0xB4, 0xC5, 0x66, 0xE2, 0xA7, 0x7A, 0x57,
+	    0x70, 0x43, 0xD2, 0x90, 0x21, 0x53, 0x89, 0x79,
+	0x49, 0x08, 0x27, 0x4E, 0x08, 0x70, 0xD7, 0xA0, 0x91, 0xE3, 0x04, 0xB3,
+	    0x28, 0xBC, 0xA4, 0x80, 0x3E, 0xBF, 0xC4, 0x4F,
+	0x95, 0x14, 0xF3, 0xFA, 0xA2, 0xDF, 0x44, 0x55, 0x82, 0x9D, 0x4C, 0xB6,
+	    0x72, 0x75, 0xFD, 0xF7, 0x82, 0x33, 0x8C, 0x6A,
+	0x88, 0xD8, 0x05, 0x21, 0x05, 0x10, 0x42, 0x27, 0x30, 0x7E, 0xE9, 0xC5,
+	    0x7A, 0x12, 0x70, 0xE1, 0x75, 0x60, 0x4C, 0x33,
+	0x02, 0x9F, 0xB5, 0xB7, 0xF0, 0xE8, 0xCD, 0x8E, 0x3B, 0x58, 0xAB, 0xA4,
+	    0x11, 0x7C, 0xD9, 0x88, 0xF4, 0x3B, 0x9D, 0x7D,
+	0x7E, 0x8D, 0x46, 0xCA, 0x62, 0xF3, 0xBF, 0xEB, 0x56, 0xF4, 0x5E, 0xEB,
+	    0x69, 0xC2, 0xF0, 0x1C, 0x5A, 0x33, 0x7E, 0x49,
+	0x67, 0x79, 0xB7, 0xBB, 0x78, 0xF9, 0x5E, 0x67, 0x0D, 0xE5, 0xD9, 0x18,
+	    0xED, 0xB7, 0x53, 0x23, 0x83, 0x18, 0xDD, 0xB0,
+	0xB9, 0x7B, 0x0B, 0x9B, 0xAD, 0xC0, 0x99, 0x1D, 0x52, 0x7F, 0x41, 0x29,
+	    0x7B, 0xF0, 0xE5, 0x69, 0x79, 0x5B, 0x06, 0x2A,
+	0xA8, 0x14, 0xBE, 0x4E, 0x3F, 0xDC, 0x64, 0xC2, 0xC9, 0xA0, 0x54, 0x1C,
+	    0xAB, 0x23, 0x46, 0x94, 0x6B, 0x12, 0x46, 0xC8,
+	0x9A, 0xB5, 0xF5, 0xE3, 0xC8, 0xD8, 0x2D, 0xD3, 0x85, 0x81, 0xCA, 0xBB,
+	    0x09, 0x18, 0x9D, 0xD0, 0x19, 0x38, 0x74, 0x0B,
+	0x0A, 0x4F, 0x2A, 0xEF, 0xBA, 0x2B, 0x2F, 0x99, 0xB6, 0x12, 0x4F, 0x3F,
+	    0x1A, 0xB5, 0xCC, 0x07, 0xCF, 0xF3, 0x62, 0xA2,
+	0x2E, 0x22, 0x1E, 0x3F, 0x8B, 0x26, 0xD8, 0xF6, 0x10, 0x01, 0x70, 0xCB,
+	    0xA3, 0xF0, 0x07, 0xCE, 0xAB, 0x6D, 0xBF, 0x10,
+	0x01, 0x74, 0xFE, 0x97, 0xFE, 0x83, 0x3A, 0xBB, 0xE8, 0x48, 0x88, 0x69,
+	    0x3E, 0xD5, 0x71, 0x43, 0xC4, 0x77, 0x61, 0xF4,
+	0x92, 0x2F, 0x8D, 0x53, 0x8F, 0xC9, 0x4B, 0xED, 0x2F, 0x49, 0x79, 0x0C,
+	    0xE9, 0x98, 0xF3, 0x13, 0xFD, 0x01, 0x88, 0xD3,
+	0xC1, 0x8D, 0xB9, 0xC6, 0x5D, 0x1C, 0x4E, 0x45, 0x93, 0x8B, 0x5D, 0xD9,
+	    0xFD, 0xAB, 0xB4, 0x00, 0x05, 0x2B, 0x8E, 0xF9,
+	0x3D, 0x52, 0x41, 0x1C, 0xCE, 0xE1, 0xD5, 0xCD, 0x12, 0xAA, 0x00, 0xF0,
+	    0x46, 0x22, 0x4A, 0x85, 0xBB, 0x4E, 0xD5, 0x09,
+	0x4F, 0xC2, 0x58, 0xD9, 0x93, 0xA9, 0x09, 0x01, 0x85, 0x3B, 0xF0, 0x94,
+	    0x04, 0x49, 0xC0, 0x8C, 0x3E, 0x59, 0xD0, 0xCD,
+	0xDE, 0xA8, 0x23, 0x72, 0x64, 0xC1, 0xCF, 0x7B, 0x3C, 0x62, 0x5A, 0x78,
+	    0xAB, 0x8C, 0xDC, 0x9F, 0xFD, 0x0B, 0x36, 0xA8,
+	0x4D, 0x95, 0x32, 0x27, 0xA9, 0xA8, 0x54, 0xBF, 0x1F, 0xC4, 0x2A, 0x2F,
+	    0x53, 0x06, 0xC5, 0xC1, 0xCE, 0xC7, 0x0E, 0xD4,
+	0xBC, 0x8F, 0x78, 0xE3, 0x33, 0xC7, 0xE1, 0xFC, 0xDE, 0x21, 0x69, 0x2A,
+	    0x6F, 0xC9, 0x36, 0x8E, 0x3D, 0x8C, 0xD4, 0xBB,
+	0x60, 0x0B, 0x6D, 0x6D, 0xF7, 0x69, 0x53, 0x3D, 0x4E, 0xAF, 0x0F, 0x7F,
+	    0xD1, 0x24, 0xDC, 0x48, 0xF8, 0x27, 0x72, 0x08,
+	0xE2, 0x07, 0x7A, 0xC5, 0xED, 0x8D, 0x5A, 0xE4, 0xA7, 0x30, 0xBA, 0x29,
+	    0x05, 0x2F, 0x16, 0xAE, 0x17, 0xA2, 0xDA, 0x74,
+	0xC3, 0xC0, 0x56, 0xDB, 0x8A, 0x8E, 0x23, 0x4B, 0xE5, 0xAC, 0x92, 0x4E,
+	    0x1C, 0xA6, 0x86, 0x6A, 0x8A, 0xFA, 0xC8, 0x31,
+	0xED, 0x2E, 0x2F, 0xBB, 0x8B, 0x2D, 0x03, 0x75, 0x18, 0x5A, 0xEB, 0xBB,
+	    0xCB, 0x22, 0x50, 0xB5, 0x64, 0x40, 0x24, 0x9C,
+	0x02, 0x6D, 0x9E, 0x36, 0xAE, 0x1F, 0x72, 0x00, 0xE4, 0x20, 0x3E, 0x50,
+	    0xAB, 0x7D, 0x75, 0x79, 0x80, 0x3E, 0xCA, 0xF4,
+	0xC2, 0x4C, 0xFC, 0x32, 0x0E, 0xB3, 0xBE, 0xBE, 0x77, 0xF0, 0x6F, 0x1E,
+	    0x4F, 0x81, 0x01, 0xE5, 0x4B, 0xD1, 0x6B, 0x22,
+	0x76, 0x79, 0x95, 0xAA, 0xFC, 0xB2, 0xFF, 0x1B, 0x00, 0x3C, 0xBB, 0xF5,
+	    0x4A, 0x6E, 0x39, 0x42, 0xA7, 0xC5, 0xB5, 0xB5,
+	0x77, 0x43, 0x88, 0x50, 0x2E, 0x9E, 0x1F, 0x24, 0x30, 0x04, 0x0C, 0x08,
+	    0xCA, 0xD9, 0x5F, 0x24, 0xF5, 0xB2, 0x6C, 0x2F,
+	0x27, 0x4E, 0x7C, 0x52, 0x67, 0xF0, 0x05, 0x81, 0xE3, 0x77, 0x4B, 0xF7,
+	    0xFA, 0xF9, 0x22, 0x3A, 0x26, 0x0D, 0x60, 0xA7,
+	0xD6, 0xBD, 0x64, 0x01, 0x2F, 0xD9, 0x42, 0xC3, 0x79, 0xF4, 0x45, 0x57,
+	    0xBB, 0x03, 0x32, 0xDB, 0xB1, 0x27, 0xDD, 0x13,
+	0xE3, 0x75, 0x95, 0xE9, 0x00, 0x03, 0xF0, 0x62, 0xCB, 0xD5, 0x72, 0x70,
+	    0xC1, 0x89, 0x68, 0x3B, 0x4E, 0x73, 0x38, 0xDC,
+	0x0B, 0xD8, 0x50, 0x2B, 0x0F, 0x89, 0x6E, 0x92, 0xD6, 0x46, 0x25, 0xC8,
+	    0x86, 0xDB, 0x41, 0x6E, 0x03, 0xFA, 0x59, 0x3B,
+	0xBC, 0xD7, 0xDA, 0xF1, 0x8A, 0xE5, 0xF5, 0x90, 0x87, 0x38, 0x53, 0xCF,
+	    0x0E, 0x9F, 0xEE, 0xE8, 0x8B, 0x98, 0x89, 0x0A,
+	0x39, 0x1F, 0x19, 0x3F, 0x69, 0x7F, 0x81, 0xB6, 0xBE, 0x09, 0xD9, 0xFB,
+	    0x24, 0x33, 0xDE, 0xBC, 0x81, 0x03, 0xD2, 0x88,
+	0x5C, 0xD3, 0x09, 0x1F, 0xC1, 0xCF, 0x10, 0x5A, 0xAD, 0x95, 0xB8, 0xAC,
+	    0xC0, 0x62, 0x5B, 0xFC, 0xFB, 0xB9, 0x03, 0xEE,
+	0x14, 0x82, 0x23, 0xB5, 0xC4, 0x9C, 0x18, 0x31, 0xB8, 0x0E, 0xE7, 0x44,
+	    0xE6, 0x8E, 0xA7, 0x11, 0xF2, 0x55, 0xE2, 0xB9,
+	0xEF, 0x90, 0x2F, 0xC7, 0xD1, 0x32, 0x47, 0x08, 0x4C, 0xBA, 0x3F, 0x0E,
+	    0x40, 0x5D, 0x5E, 0xEF, 0x50, 0x03, 0x86, 0x04,
+	0x7B, 0xC4, 0x0E, 0x85, 0x63, 0x52, 0x90, 0x24, 0x50, 0x60, 0xC9, 0x0A,
+	    0xF6, 0xB5, 0x68, 0x2B, 0x35, 0x63, 0x98, 0x70,
+	0x4B, 0x03, 0x98, 0x34, 0x51, 0x61, 0x78, 0xFA, 0xEB, 0x7D, 0x85, 0x05,
+	    0x13, 0x2C, 0x2F, 0x89, 0x4D, 0xC4, 0x91, 0x25,
+	0xD0, 0x62, 0xF6, 0xE0, 0x3E, 0x30, 0x8A, 0xE3, 0x93, 0x23, 0x19, 0x05,
+	    0x41, 0xD3, 0x99, 0x35, 0xD1, 0x63, 0x40, 0x40,
+	0x02, 0x04, 0xC0, 0x44, 0x12, 0x24, 0x50, 0x60, 0x42, 0x44, 0xD0, 0x64,
+	    0x52, 0x64, 0x48, 0x50, 0x03, 0x05, 0xC8, 0x54,
+	0x13, 0x25, 0x58, 0x70, 0x43, 0x45, 0xD8, 0x74, 0x53, 0x65, 0x41, 0x41,
+	    0x82, 0x06, 0xC1, 0x45, 0x92, 0x26, 0x51, 0x61,
+	0xC2, 0x46, 0xD1, 0x65, 0xD2, 0x66, 0x49, 0x51, 0x83, 0x07, 0xC9, 0x55,
+	    0x93, 0x27, 0x59, 0x71, 0xC3, 0x47, 0xD9, 0x75,
+	0xD3, 0x67, 0x52, 0xF6, 0x04, 0xA3, 0x02, 0x0E, 0x14, 0x6A, 0xA5, 0x8D,
+	    0x4E, 0x28, 0x92, 0x2C, 0x58, 0x68, 0xCA, 0xE9,
+	0xB6, 0xAB, 0x0A, 0x1E, 0xBA, 0x6B, 0xCE, 0xBC, 0x59, 0xE5, 0x9A, 0x3C,
+	    0x59, 0x69, 0xFE, 0x19, 0xE3, 0x75, 0x80, 0xED,
+	0x9A, 0x0A, 0x97, 0x2B, 0x80, 0xBF, 0x93, 0x2D, 0xD8, 0x6A, 0x55, 0xF6,
+	    0xDD, 0x08, 0x0A, 0xB8, 0x19, 0x56, 0x42, 0xDB,
+	0xAA, 0x2B, 0x9B, 0x3D, 0xD9, 0x6B, 0x42, 0x48, 0x0A, 0x0C, 0xC2, 0x4C,
+	    0x1A, 0x2C, 0x52, 0x68, 0x4A, 0x4C, 0xD2, 0x6C,
+	0x5A, 0x6C, 0x4A, 0x58, 0x0B, 0x0D, 0xCA, 0x5C, 0x1B, 0x2D, 0x5A, 0x78,
+	    0x4B, 0x4D, 0xDA, 0x7C, 0x5B, 0x6D, 0x43, 0x49,
+	0x8A, 0x0E, 0xC3, 0x4D, 0x9A, 0x2E, 0x53, 0x69, 0xCA, 0x4E, 0xD3, 0x6D,
+	    0xDA, 0x6E, 0x4B, 0x59, 0x8B, 0x0F, 0xCB, 0x5D,
+	0x9B, 0x2F, 0x5B, 0x79, 0xCB, 0x4F, 0xDB, 0x7D, 0xDB, 0x6F, 0xA3, 0xD9,
+	    0x26, 0x80, 0x14, 0x06, 0x31, 0xCE, 0x84, 0x67,
+	0x62, 0xA5, 0x94, 0xA4, 0x70, 0x70, 0x2A, 0xC9, 0xA5, 0xB5, 0x9C, 0x94,
+	    0x31, 0x31, 0x7C, 0xF0, 0xBE, 0xDA, 0x9C, 0xB4,
+	0x71, 0x71, 0x29, 0xFE, 0x81, 0x4D, 0xBF, 0x67, 0x94, 0x12, 0x11, 0xE6,
+	    0x61, 0x5C, 0x95, 0xA5, 0xF0, 0x72, 0x06, 0x96,
+	0x00, 0x18, 0x8D, 0x95, 0xB1, 0x33, 0x1A, 0x53, 0x63, 0x5B, 0x9D, 0xB5,
+	    0xF1, 0x73, 0x44, 0xC0, 0x22, 0x14, 0xC4, 0xC4,
+	0x32, 0x34, 0x54, 0xE0, 0x62, 0x54, 0xD4, 0xE4, 0x72, 0x74, 0x4C, 0xD0,
+	    0x23, 0x15, 0xCC, 0xD4, 0x33, 0x35, 0x5C, 0xF0,
+	0x63, 0x55, 0xDC, 0xF4, 0x73, 0x75, 0x45, 0xC1, 0xA2, 0x16, 0xC5, 0xC5,
+	    0xB2, 0x36, 0x55, 0xE1, 0xE2, 0x56, 0xD5, 0xE5,
+	0xF2, 0x76, 0x4D, 0xD1, 0xA3, 0x17, 0xCD, 0xD5, 0xB3, 0x37, 0x5D, 0xF1,
+	    0xE3, 0x57, 0xDD, 0xF5, 0xF3, 0x77, 0x82, 0x4F,
+	0xA8, 0x38, 0x86, 0x8C, 0x38, 0x38, 0x69, 0xCA, 0x8A, 0xE8, 0x96, 0xAC,
+	    0x78, 0x78, 0x8D, 0x91, 0xE1, 0xA1, 0x8E, 0x9C,
+	0x39, 0x39, 0x9E, 0x45, 0x69, 0x57, 0x9E, 0xBC, 0x79, 0x79, 0xAB, 0x0F,
+	    0xFC, 0x19, 0x87, 0x8D, 0xB8, 0x3A, 0x15, 0x54,
+	0xE0, 0x5E, 0x97, 0xAD, 0xF8, 0x7A, 0xAF, 0x8A, 0xF8, 0x7F, 0x8F, 0x9D,
+	    0xB9, 0x3B, 0x77, 0x3F, 0x15, 0x1A, 0x9F, 0xBD,
+	0xF9, 0x7B, 0x46, 0xC8, 0x2A, 0x1C, 0xC6, 0xCC, 0x3A, 0x3C, 0x56, 0xE8,
+	    0x6A, 0x5C, 0xD6, 0xEC, 0x7A, 0x7C, 0x4E, 0xD8,
+	0x2B, 0x1D, 0xCE, 0xDC, 0x3B, 0x3D, 0x5E, 0xF8, 0x6B, 0x5D, 0xDE, 0xFC,
+	    0x7B, 0x7D, 0x47, 0xC9, 0xAA, 0x1E, 0xC7, 0xCD,
+	0xBA, 0x3E, 0x57, 0xE9, 0xEA, 0x5E, 0xD7, 0xED, 0xFA, 0x7E, 0x4F, 0xD9,
+	    0xAB, 0x1F, 0xCF, 0xDD, 0xBB, 0x3F, 0x5F, 0xF9,
+	0xEB, 0x5F, 0xDF, 0xFD, 0xFB, 0x7F, 0x59, 0xF9, 0x6F, 0xFF, 0x4C, 0x86,
+	    0xE8, 0x80, 0xC8, 0x06, 0xCB, 0xC2, 0xB0, 0x26,
+	0x54, 0xE0, 0x76, 0xFD, 0x27, 0x82, 0xF8, 0x74, 0x5D, 0x51, 0x30, 0x18,
+	    0xE4, 0x6E, 0xB8, 0x36, 0x55, 0xE1, 0x62, 0xF2,
+	0x3B, 0xE2, 0x0D, 0x45, 0x17, 0x5F, 0x86, 0x22, 0x49, 0xC4, 0xB1, 0x27,
+	    0xD4, 0xE2, 0x50, 0xE8, 0x71, 0x5C, 0x5E, 0x17,
+	0x9D, 0x73, 0x79, 0x20, 0x1E, 0xE1, 0xB9, 0x37, 0xD5, 0xE3, 0x60, 0x42,
+	    0x06, 0x84, 0xE0, 0x46, 0x16, 0xA4, 0x70, 0x62,
+	0x46, 0xC4, 0xF0, 0x66, 0x56, 0xE4, 0x68, 0x52, 0x07, 0x85, 0xE8, 0x56,
+	    0x17, 0xA5, 0x78, 0x72, 0x47, 0xC5, 0xF8, 0x76,
+	0x57, 0xE5, 0x61, 0x43, 0x86, 0x86, 0xE1, 0x47, 0x96, 0xA6, 0x71, 0x63,
+	    0xC6, 0xC6, 0xF1, 0x67, 0xD6, 0xE6, 0x69, 0x53,
+	0x87, 0x87, 0xE9, 0x57, 0x97, 0xA7, 0x79, 0x73, 0xC7, 0xC7, 0xF9, 0x77,
+	    0xD7, 0xE7, 0x95, 0xF5, 0x8F, 0x86, 0xCA, 0xCC,
+	0x9A, 0x5D, 0x14, 0xF4, 0x4A, 0x6C, 0xB2, 0x2E, 0x5C, 0xE8, 0x6A, 0x25,
+	    0x05, 0xE5, 0xAE, 0x59, 0x9C, 0xA7, 0x8D, 0xBF,
+	0xB9, 0x8B, 0xBA, 0x3E, 0x5D, 0xE9, 0xC3, 0x34, 0xA8, 0xE4, 0x33, 0xC8,
+	    0x9E, 0x5F, 0xDC, 0xAE, 0x4A, 0x3F, 0xB3, 0x2F,
+	0xDC, 0xEA, 0x03, 0xD9, 0x59, 0x13, 0xC3, 0xDD, 0x1B, 0x5E, 0x0C, 0xBA,
+	    0x3D, 0xC9, 0xBB, 0x3F, 0xDD, 0xEB, 0x62, 0x4A,
+	0x0E, 0x8C, 0xE2, 0x4E, 0x1E, 0xAC, 0x72, 0x6A, 0x4E, 0xCC, 0xF2, 0x6E,
+	    0x5E, 0xEC, 0x6A, 0x5A, 0x0F, 0x8D, 0xEA, 0x5E,
+	0x1F, 0xAD, 0x7A, 0x7A, 0x4F, 0xCD, 0xFA, 0x7E, 0x5F, 0xED, 0x63, 0x4B,
+	    0x8E, 0x8E, 0xE3, 0x4F, 0x9E, 0xAE, 0x73, 0x6B,
+	0xCE, 0xCE, 0xF3, 0x6F, 0xDE, 0xEE, 0x6B, 0x5B, 0x8F, 0x8F, 0xEB, 0x5F,
+	    0x9F, 0xAF, 0x7B, 0x7B, 0xCF, 0xCF, 0xFB, 0x7F,
+	0xDF, 0xEF, 0x7E, 0x83, 0x87, 0xD2, 0xA4, 0x86, 0x34, 0xB0, 0x54, 0xE2,
+	    0x88, 0xDD, 0xB4, 0xA6, 0x74, 0xF0, 0x16, 0x37,
+	0xDA, 0x9F, 0xAC, 0x96, 0x35, 0xB1, 0x04, 0xF5, 0xB3, 0xBD, 0xBC, 0xB6,
+	    0x75, 0xF1, 0x22, 0xC2, 0x00, 0x42, 0xA5, 0x87,
+	0xB4, 0xB2, 0xCE, 0x21, 0xE5, 0x37, 0xB5, 0xA7, 0xF4, 0xF2, 0x45, 0x15,
+	    0x59, 0xD2, 0xAD, 0x97, 0xB5, 0xB3, 0xDA, 0xF3,
+	0xE9, 0xBD, 0xBD, 0xB7, 0xF5, 0xF3, 0x64, 0xC2, 0x26, 0x94, 0xE4, 0xC6,
+	    0x36, 0xB4, 0x74, 0xE2, 0x66, 0xD4, 0xF4, 0xE6,
+	0x76, 0xF4, 0x6C, 0xD2, 0x27, 0x95, 0xEC, 0xD6, 0x37, 0xB5, 0x7C, 0xF2,
+	    0x67, 0xD5, 0xFC, 0xF6, 0x77, 0xF5, 0x65, 0xC3,
+	0xA6, 0x96, 0xE5, 0xC7, 0xB6, 0xB6, 0x75, 0xE3, 0xE6, 0xD6, 0xF5, 0xE7,
+	    0xF6, 0xF6, 0x6D, 0xD3, 0xA7, 0x97, 0xED, 0xD7,
+	0xB7, 0xB7, 0x7D, 0xF3, 0xE7, 0xD7, 0xFD, 0xF7, 0xF7, 0xF7, 0x76, 0x83,
+	    0x4C, 0x9B, 0xA6, 0x8E, 0x3C, 0xB8, 0x16, 0xAB,
+	0xE1, 0xD2, 0xB6, 0xAE, 0x7C, 0xF8, 0x99, 0x3F, 0x2B, 0x39, 0xAE, 0x9E,
+	    0x3D, 0xB9, 0x89, 0xBB, 0xE0, 0xD5, 0xBE, 0xBE,
+	0x7D, 0xF9, 0x20, 0x07, 0x54, 0x89, 0xA7, 0x8F, 0xBC, 0xBA, 0x4F, 0x8F,
+	    0x63, 0xD8, 0xB7, 0xAF, 0xFC, 0xFA, 0xA5, 0xE8,
+	0x9D, 0x19, 0xAF, 0x9F, 0xBD, 0xBB, 0x57, 0xC8, 0xCD, 0xD0, 0xBF, 0xBF,
+	    0xFD, 0xFB, 0x66, 0xCA, 0x2E, 0x9C, 0xE6, 0xCE,
+	0x3E, 0xBC, 0x76, 0xEA, 0x6E, 0xDC, 0xF6, 0xEE, 0x7E, 0xFC, 0x6E, 0xDA,
+	    0x2F, 0x9D, 0xEE, 0xDE, 0x3F, 0xBD, 0x7E, 0xFA,
+	0x6F, 0xDD, 0xFE, 0xFE, 0x7F, 0xFD, 0x67, 0xCB, 0xAE, 0x9E, 0xE7, 0xCF,
+	    0xBE, 0xBE, 0x77, 0xEB, 0xEE, 0xDE, 0xF7, 0xEF,
+	0xFE, 0xFE, 0x6F, 0xDB, 0xAF, 0x9F, 0xEF, 0xDF, 0xBF, 0xBF, 0x7F, 0xFB,
+	    0xEF, 0xDF, 0xFF, 0xFF, 0xC5, 0xA8
+};
+#endif
+#endif
diff --git a/drivers/input/touchscreen/gt9xx/gt9xx_update.c b/drivers/input/touchscreen/gt9xx/gt9xx_update.c
index af80eef..e9da3bc 100644
--- a/drivers/input/touchscreen/gt9xx/gt9xx_update.c
+++ b/drivers/input/touchscreen/gt9xx/gt9xx_update.c
@@ -1,7 +1,6 @@
 /* drivers/input/touchscreen/gt9xx_update.c
  *
  * 2010 - 2012 Goodix Technology.
- * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,7 +13,7 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * General Public License for more details.
  *
- * Latest Version:1.6
+ * Latest Version: 2.2
  * Author: andrew@goodix.com
  * Revision Record:
  *      V1.0:
@@ -30,28 +29,44 @@
  *          1. replace guitar_client with i2c_connect_client;
  *          2. support firmware header array update.
  *                          By Meta, 2013/03/11
+ *      V2.2:
+ *          1. multi-system supported
+ *          2. flashless update no pid vid compare
+ *                          By Meta, 2014/01/14
  */
+
+#include <linux/kthread.h>
 #include "gt9xx.h"
-#include <linux/firmware.h>
-#include <linux/workqueue.h>
-#include <linux/kernel.h>
 
-#define FIRMWARE_NAME_LEN_MAX		256
+#include <linux/namei.h>
+#include <linux/mount.h>
+#if ((GTP_AUTO_UPDATE && GTP_HEADER_FW_UPDATE) || GTP_COMPATIBLE_MODE)
+#include "gt9xx_firmware.h"
+#endif
 
 #define GUP_REG_HW_INFO             0x4220
 #define GUP_REG_FW_MSG              0x41E4
 #define GUP_REG_PID_VID             0x8140
 
-#define GOODIX_FIRMWARE_FILE_NAME	"_goodix_update_.bin"
-#define GOODIX_CONFIG_FILE_NAME		"_goodix_config_.cfg"
+#define GUP_SEARCH_FILE_TIMES       50
 
-#define FW_HEAD_LENGTH               14
-#define FW_SECTION_LENGTH            0x2000
-#define FW_DSP_ISP_LENGTH            0x1000
-#define FW_DSP_LENGTH                0x1000
-#define FW_BOOT_LENGTH               0x800
+#define UPDATE_FILE_PATH_1          "/data/_goodix_update_.bin"
+#define UPDATE_FILE_PATH_2          "/sdcard/_goodix_update_.bin"
+
+#define CONFIG_FILE_PATH_1          "/data/_goodix_config_.cfg"
+#define CONFIG_FILE_PATH_2          "/sdcard/_goodix_config_.cfg"
 
-#define PACK_SIZE                    256
+#define FW_HEAD_LENGTH               14
+#define FW_SECTION_LENGTH            0x2000	/* 8K */
+#define FW_DSP_ISP_LENGTH            0x1000	/* 4K */
+#define FW_DSP_LENGTH                0x1000	/* 4K */
+#define FW_BOOT_LENGTH               0x800	/* 2K */
+#define FW_SS51_LENGTH               (4 * FW_SECTION_LENGTH)	/* 32K */
+#define FW_BOOT_ISP_LENGTH           0x800	/* 2k */
+#define FW_GLINK_LENGTH              0x3000	/* 12k */
+#define FW_GWAKE_LENGTH              (4 * FW_SECTION_LENGTH)	/* 32k */
+
+#define PACK_SIZE                    250
 #define MAX_FRAME_CHECK_TIME         5
 
 #define _bRW_MISCTL__SRAM_BANK       0x4048
@@ -64,29 +79,45 @@
 #define _rRW_MISCTL__BOOT_OPT_B0_    0x4218
 #define _rRW_MISCTL__BOOT_CTL_       0x5094
 
-#define FAIL    0
-#define SUCCESS 1
+#define AUTO_SEARCH_BIN           0x01
+#define AUTO_SEARCH_CFG           0x02
+#define BIN_FILE_READY            0x80
+#define CFG_FILE_READY            0x08
+#define HEADER_FW_READY           0x00
 
+#pragma pack(1)
 struct st_fw_head {
-	u8  hw_info[4];		/* hardware info */
-	u8  pid[8];		/* product id   */
-	u16 vid;		/* version id   */
-} __packed;
+	u8 hw_info[4];		/* hardware info */
+	u8 pid[8];		/* product id  */
+	u16 vid;		/* version id  */
+};
+#pragma pack()
 
 struct st_update_msg {
 	u8 force_update;
 	u8 fw_flag;
-	bool need_free;
-	u8 *fw_data;
-	u32 fw_len;
-	struct st_fw_head  ic_fw_msg;
+	struct file *file;
+	struct file *cfg_file;
+	struct st_fw_head ic_fw_msg;
+	mm_segment_t old_fs;
+	u32 fw_total_len;
+	u32 fw_burned_len;
 };
 
-static struct st_update_msg update_msg;
+struct st_update_msg update_msg;
 u16 show_len;
 u16 total_len;
 u8 got_file_flag;
 u8 searching_file;
+
+static u8 gup_burn_fw_gwake_section(struct i2c_client *client, u8 *fw_section,
+				    u16 start_addr, u32 len, u8 bank_cmd);
+
+#define _CLOSE_FILE(p_file) do {\
+			if (p_file && !IS_ERR(p_file)) \
+				filp_close(p_file, NULL); \
+			} while (0)
+
 /*******************************************************
 Function:
     Read data from the i2c slave device.
@@ -97,26 +128,25 @@ Input:
     len:    GTP_ADDR_LENGTH + read bytes count
 Output:
     numbers of i2c_msgs to transfer:
-      2: succeed, otherwise: failed
+    2: succeed, otherwise: failed
 *********************************************************/
 static s32 gup_i2c_read(struct i2c_client *client, u8 *buf, s32 len)
 {
+	struct i2c_msg msgs[2];
 	s32 ret = -1;
-	u8 retries = 0;
-	struct i2c_msg msgs[2] = {
-		{
-			.flags = !I2C_M_RD,
-			.addr  = client->addr,
-			.len   = GTP_ADDR_LENGTH,
-			.buf   = &buf[0],
-		},
-		{
-			.flags = I2C_M_RD,
-			.addr  = client->addr,
-			.len   = len - GTP_ADDR_LENGTH,
-			.buf   = &buf[GTP_ADDR_LENGTH],
-		},
-	};
+	s32 retries = 0;
+
+	GTP_DEBUG_FUNC();
+
+	msgs[0].flags = !I2C_M_RD;
+	msgs[0].addr = client->addr;
+	msgs[0].len = GTP_ADDR_LENGTH;
+	msgs[0].buf = &buf[0];
+
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].addr = client->addr;
+	msgs[1].len = len - GTP_ADDR_LENGTH;
+	msgs[1].buf = &buf[GTP_ADDR_LENGTH];
 
 	while (retries < 5) {
 		ret = i2c_transfer(client->adapter, msgs, 2);
@@ -125,11 +155,6 @@ static s32 gup_i2c_read(struct i2c_client *client, u8 *buf, s32 len)
 		retries++;
 	}
 
-	if (retries == 5) {
-		dev_err(&client->dev, "I2C read retry limit over.\n");
-		ret = -EIO;
-	}
-
 	return ret;
 }
 
@@ -143,18 +168,20 @@ Input:
     len:    GTP_ADDR_LENGTH + write bytes count
 Output:
     numbers of i2c_msgs to transfer:
-	1: succeed, otherwise: failed
+    1: succeed, otherwise: failed
 *********************************************************/
-s32 gup_i2c_write(struct i2c_client *client, u8 *buf, s32 len)
+static s32 gup_i2c_write(struct i2c_client *client, u8 *buf, s32 len)
 {
+	struct i2c_msg msg;
 	s32 ret = -1;
-	u8 retries = 0;
-	struct i2c_msg msg = {
-		.flags = !I2C_M_RD,
-		.addr  = client->addr,
-		.len   = len,
-		.buf   = buf,
-	};
+	s32 retries = 0;
+
+	GTP_DEBUG_FUNC();
+
+	msg.flags = !I2C_M_RD;
+	msg.addr = client->addr;
+	msg.len = len;
+	msg.buf = buf;
 
 	while (retries < 5) {
 		ret = i2c_transfer(client->adapter, &msg, 1);
@@ -163,115 +190,124 @@ s32 gup_i2c_write(struct i2c_client *client, u8 *buf, s32 len)
 		retries++;
 	}
 
-	if (retries == 5) {
-		dev_err(&client->dev, "I2C write retry limit over.\n");
-		ret = -EIO;
-	}
-
 	return ret;
 }
 
 static s32 gup_init_panel(struct goodix_ts_data *ts)
 {
-	struct i2c_client *client = ts->client;
-	u8 *config_data;
 	s32 ret = 0;
 	s32 i = 0;
 	u8 check_sum = 0;
 	u8 opr_buf[16];
 	u8 sensor_id = 0;
+	u16 version = 0;
+
+	u8 cfg_info_group1[] = CTP_CFG_GROUP1;
+	u8 cfg_info_group2[] = CTP_CFG_GROUP2;
+	u8 cfg_info_group3[] = CTP_CFG_GROUP3;
+	u8 cfg_info_group4[] = CTP_CFG_GROUP4;
+	u8 cfg_info_group5[] = CTP_CFG_GROUP5;
+	u8 cfg_info_group6[] = CTP_CFG_GROUP6;
+	u8 *send_cfg_buf[] = {
+		cfg_info_group1, cfg_info_group2, cfg_info_group3,
+		cfg_info_group4, cfg_info_group5, cfg_info_group6
+	};
+	u8 cfg_info_len[] = { CFG_GROUP_LEN(cfg_info_group1),
+		CFG_GROUP_LEN(cfg_info_group2),
+		CFG_GROUP_LEN(cfg_info_group3),
+		CFG_GROUP_LEN(cfg_info_group4),
+		CFG_GROUP_LEN(cfg_info_group5),
+		CFG_GROUP_LEN(cfg_info_group6)
+	};
 
-	for (i = 0; i < GOODIX_MAX_CFG_GROUP; i++)
-		if (ts->pdata->config_data_len[i])
-			break;
-
-	if (i == GOODIX_MAX_CFG_GROUP) {
+	if ((!cfg_info_len[1]) && (!cfg_info_len[2]) &&
+	    (!cfg_info_len[3]) && (!cfg_info_len[4]) && (!cfg_info_len[5]))
 		sensor_id = 0;
-	} else {
-		ret = gtp_i2c_read_dbl_check(client, GTP_REG_SENSOR_ID,
-							&sensor_id, 1);
+	else {
+		ret =
+		    gtp_i2c_read_dbl_check(ts->client, GTP_REG_SENSOR_ID,
+					   &sensor_id, 1);
 		if (SUCCESS == ret) {
-			if (sensor_id >= GOODIX_MAX_CFG_GROUP) {
-				pr_err("Invalid sensor_id(0x%02X), No Config Sent!",
-					sensor_id);
+			if (sensor_id >= 0x06) {
+				GTP_ERROR
+				    ("Invalid id(0x%02X), No Config Sent!",
+				     sensor_id);
 				return -EINVAL;
 			}
 		} else {
-			pr_err("Failed to get sensor_id, No config sent!");
+			GTP_ERROR("Failed to get sensor_id, No config sent!");
 			return -EINVAL;
 		}
 	}
 
-	pr_debug("Sensor ID selected: %d", sensor_id);
+	GTP_DEBUG("Sensor_ID: %d", sensor_id);
 
-	if (ts->pdata->config_data_len[sensor_id] < GTP_CONFIG_MIN_LENGTH ||
-		!ts->pdata->config_data_len[sensor_id]) {
-		pr_err("Sensor_ID(%d) matches with NULL or INVALID CONFIG GROUP!",
-				sensor_id);
+	ts->gtp_cfg_len = cfg_info_len[sensor_id];
+	if (ts->gtp_cfg_len < GTP_CONFIG_MIN_LENGTH) {
+		GTP_ERROR
+		    ("Sensor_ID(%d) matches with NULL or INVALID CONFIG GROUP!",
+		     sensor_id);
 		return -EINVAL;
 	}
 
-	ret = gtp_i2c_read_dbl_check(client, GTP_REG_CONFIG_DATA,
+	ret = gtp_i2c_read_dbl_check(ts->client, GTP_REG_CONFIG_DATA,
 					&opr_buf[0], 1);
 	if (ret == SUCCESS) {
-		pr_debug("CFG_GROUP%d Config Version: %d, IC Config Version: %d",
-			sensor_id + 1,
-			ts->pdata->config_data[sensor_id][0],
-			opr_buf[0]);
-
-		ts->pdata->config_data[sensor_id][0] = opr_buf[0];
+		GTP_DEBUG
+		    ("CFG_GROUP%d Config Version: %d, IC Config Version: %d",
+		     sensor_id + 1, send_cfg_buf[sensor_id][0], opr_buf[0]);
+		send_cfg_buf[sensor_id][0] = opr_buf[0];
 		ts->fixed_cfg = 0;
 	} else {
-		pr_err("Failed to get ic config version!No config sent!");
+		GTP_ERROR("Failed to get ic config version!No config sent!");
 		return -EINVAL;
 	}
 
-	config_data = ts->pdata->config_data[sensor_id];
-	ts->config_data = ts->pdata->config_data[sensor_id];
-	ts->gtp_cfg_len = ts->pdata->config_data_len[sensor_id];
+	memset(&config[GTP_ADDR_LENGTH], 0, GTP_CONFIG_MAX_LENGTH);
+	memcpy(&config[GTP_ADDR_LENGTH], send_cfg_buf[sensor_id],
+	       ts->gtp_cfg_len);
 
-	pr_debug("X_MAX = %d, Y_MAX = %d, TRIGGER = 0x%02x",
-	ts->abs_x_max, ts->abs_y_max, ts->int_trigger_type);
+	GTP_DEBUG("X_MAX = %d, Y_MAX = %d, TRIGGER = 0x%02x",
+		  ts->abs_x_max, ts->abs_y_max, ts->int_trigger_type);
 
-	config_data[RESOLUTION_LOC]     = (u8)GTP_MAX_WIDTH;
-	config_data[RESOLUTION_LOC + 1] = (u8)(GTP_MAX_WIDTH>>8);
-	config_data[RESOLUTION_LOC + 2] = (u8)GTP_MAX_HEIGHT;
-	config_data[RESOLUTION_LOC + 3] = (u8)(GTP_MAX_HEIGHT>>8);
+	config[RESOLUTION_LOC] = (u8) GTP_MAX_WIDTH;
+	config[RESOLUTION_LOC + 1] = (u8) (GTP_MAX_WIDTH >> 8);
+	config[RESOLUTION_LOC + 2] = (u8) GTP_MAX_HEIGHT;
+	config[RESOLUTION_LOC + 3] = (u8) (GTP_MAX_HEIGHT >> 8);
 
-	if (GTP_INT_TRIGGER == 0)  /* RISING */
-		config_data[TRIGGER_LOC] &= 0xfe;
-	else if (GTP_INT_TRIGGER == 1)  /* FALLING */
-		config_data[TRIGGER_LOC] |= 0x01;
+	if (GTP_INT_TRIGGER == 0)	/* RISING */
+		config[TRIGGER_LOC] &= 0xfe;
+	else if (GTP_INT_TRIGGER == 1)	/* FALLING */
+		config[TRIGGER_LOC] |= 0x01;
 
 	check_sum = 0;
 	for (i = GTP_ADDR_LENGTH; i < ts->gtp_cfg_len; i++)
-		check_sum += config_data[i];
+		check_sum += config[i];
+	config[ts->gtp_cfg_len] = (~check_sum) + 1;
 
-	config_data[ts->gtp_cfg_len] = (~check_sum) + 1;
-
-	ret = gtp_send_cfg(ts);
+	GTP_DEBUG_FUNC();
+	ret = gtp_send_cfg(ts->client);
 	if (ret < 0)
-		pr_err("Send config error.");
-
-	ts->config_data = NULL;
-	ts->gtp_cfg_len = 0;
+		GTP_ERROR("Send config error.");
+	gtp_read_version(ts->client, &version);
 	msleep(20);
 	return 0;
 }
 
 static u8 gup_get_ic_msg(struct i2c_client *client, u16 addr, u8 *msg, s32 len)
 {
-	u8 i = 0;
+	s32 i = 0;
 
 	msg[0] = (addr >> 8) & 0xff;
 	msg[1] = addr & 0xff;
 
-	for (i = 0; i < 5; i++)
+	for (i = 0; i < 5; i++) {
 		if (gup_i2c_read(client, msg, GTP_ADDR_LENGTH + len) > 0)
 			break;
+	}
 
 	if (i >= 5) {
-		pr_err("Read data from 0x%02x%02x failed!", msg[0], msg[1]);
+		GTP_ERROR("Read data from 0x%02x%02x failed!", msg[0], msg[1]);
 		return FAIL;
 	}
 
@@ -280,19 +316,20 @@ static u8 gup_get_ic_msg(struct i2c_client *client, u16 addr, u8 *msg, s32 len)
 
 static u8 gup_set_ic_msg(struct i2c_client *client, u16 addr, u8 val)
 {
-	u8 i = 0;
-	u8 msg[3] = {
-		(addr >> 8) & 0xff,
-		addr & 0xff,
-		val,
-	};
+	s32 i = 0;
+	u8 msg[3];
+
+	msg[0] = (addr >> 8) & 0xff;
+	msg[1] = addr & 0xff;
+	msg[2] = val;
 
-	for (i = 0; i < 5; i++)
+	for (i = 0; i < 5; i++) {
 		if (gup_i2c_write(client, msg, GTP_ADDR_LENGTH + 1) > 0)
 			break;
+	}
 
 	if (i >= 5) {
-		pr_err("Set data to 0x%02x%02x failed!", msg[0], msg[1]);
+		GTP_ERROR("Set data to 0x%02x%02x failed!", msg[0], msg[1]);
 		return FAIL;
 	}
 
@@ -302,80 +339,79 @@ static u8 gup_set_ic_msg(struct i2c_client *client, u16 addr, u8 val)
 static u8 gup_get_ic_fw_msg(struct i2c_client *client)
 {
 	s32 ret = -1;
-	u8  retry = 0;
-	u8  buf[16];
-	u8  i;
+	u8 retry = 0;
+	u8 buf[16];
+	u8 i;
 
 	/* step1:get hardware info */
-	ret = gtp_i2c_read_dbl_check(client, GUP_REG_HW_INFO,
-					&buf[GTP_ADDR_LENGTH], 4);
-	if (ret == FAIL) {
-		pr_err("get hw_info failed,exit");
+	ret =
+	    gtp_i2c_read_dbl_check(client, GUP_REG_HW_INFO,
+				   &buf[GTP_ADDR_LENGTH], 4);
+	if (FAIL == ret) {
+		GTP_ERROR("[get_ic_fw_msg]get hw_info failed,exit");
 		return FAIL;
 	}
-
-	/*  buf[2~5]: 00 06 90 00 */
+	/* buf[2~5]: 00 06 90 00 */
 	/* hw_info: 00 90 06 00 */
 	for (i = 0; i < 4; i++)
 		update_msg.ic_fw_msg.hw_info[i] = buf[GTP_ADDR_LENGTH + 3 - i];
-
-	pr_debug("IC Hardware info:%02x%02x%02x%02x",
-		update_msg.ic_fw_msg.hw_info[0],
-		update_msg.ic_fw_msg.hw_info[1],
-		update_msg.ic_fw_msg.hw_info[2],
-		update_msg.ic_fw_msg.hw_info[3]);
-
+	GTP_DEBUG("IC Hardware info:%02x%02x%02x%02x",
+		  update_msg.ic_fw_msg.hw_info[0],
+		  update_msg.ic_fw_msg.hw_info[1],
+		  update_msg.ic_fw_msg.hw_info[2],
+		  update_msg.ic_fw_msg.hw_info[3]);
 	/* step2:get firmware message */
 	for (retry = 0; retry < 2; retry++) {
 		ret = gup_get_ic_msg(client, GUP_REG_FW_MSG, buf, 1);
-		if (ret == FAIL) {
-			pr_err("Read firmware message fail.");
+		if (FAIL == ret) {
+			GTP_ERROR("Read firmware message fail.");
 			return ret;
 		}
 
 		update_msg.force_update = buf[GTP_ADDR_LENGTH];
 		if ((0xBE != update_msg.force_update) && (!retry)) {
-			pr_info("The check sum in ic is error.");
-			pr_info("The IC will be updated by force.");
+			GTP_INFO("The check sum in ic is error.");
+			GTP_INFO("The IC will be updated by force.");
 			continue;
 		}
 		break;
 	}
-	pr_debug("IC force update flag:0x%x", update_msg.force_update);
+	GTP_DEBUG("IC force update flag:0x%x", update_msg.force_update);
 
-	/*  step3:get pid & vid */
-	ret = gtp_i2c_read_dbl_check(client, GUP_REG_PID_VID,
-						&buf[GTP_ADDR_LENGTH], 6);
-	if (ret == FAIL) {
-		pr_err("get pid & vid failed,exit");
+	/* step3:get pid & vid */
+	ret =
+	    gtp_i2c_read_dbl_check(client, GUP_REG_PID_VID,
+				   &buf[GTP_ADDR_LENGTH], 6);
+	if (FAIL == ret) {
+		GTP_ERROR("[get_ic_fw_msg]get pid & vid failed,exit");
 		return FAIL;
 	}
 
 	memset(update_msg.ic_fw_msg.pid, 0, sizeof(update_msg.ic_fw_msg.pid));
 	memcpy(update_msg.ic_fw_msg.pid, &buf[GTP_ADDR_LENGTH], 4);
-	pr_debug("IC Product id:%s", update_msg.ic_fw_msg.pid);
-
-	/* GT9XX PID MAPPING
-	|-----FLASH-----RAM-----|
-	|------918------918-----|
-	|------968------968-----|
-	|------913------913-----|
-	|------913P-----913P----|
-	|------927------927-----|
-	|------927P-----927P----|
-	|------9110-----9110----|
-	|------9110P----9111----|*/
+	GTP_DEBUG("IC Product id:%s", update_msg.ic_fw_msg.pid);
+
+	/* GT9XX PID MAPPING */
+	/*|-----FLASH-----RAM-----|
+	   |------918------918-----|
+	   |------968------968-----|
+	   |------913------913-----|
+	   |------913P-----913P----|
+	   |------927------927-----|
+	   |------927P-----927P----|
+	   |------9110-----9110----|
+	   |------9110P----9111----| */
 	if (update_msg.ic_fw_msg.pid[0] != 0) {
 		if (!memcmp(update_msg.ic_fw_msg.pid, "9111", 4)) {
-			pr_debug("IC Mapping Product id:%s",
-					update_msg.ic_fw_msg.pid);
+			GTP_DEBUG("IC Mapping Product id:%s",
+				  update_msg.ic_fw_msg.pid);
 			memcpy(update_msg.ic_fw_msg.pid, "9110P", 5);
 		}
 	}
 
-	update_msg.ic_fw_msg.vid = buf[GTP_ADDR_LENGTH + 4] +
-				(buf[GTP_ADDR_LENGTH + 5] << 8);
-	pr_debug("IC version id:%04x", update_msg.ic_fw_msg.vid);
+	update_msg.ic_fw_msg.vid =
+	    buf[GTP_ADDR_LENGTH + 4] + (buf[GTP_ADDR_LENGTH + 5] << 8);
+	GTP_DEBUG("IC version id:%04x", update_msg.ic_fw_msg.vid);
 
 	return SUCCESS;
 }
@@ -383,17 +419,16 @@ static u8 gup_get_ic_fw_msg(struct i2c_client *client)
 s32 gup_enter_update_mode(struct i2c_client *client)
 {
 	s32 ret = -1;
-	u8 retry = 0;
+	s32 retry = 0;
 	u8 rd_buf[3];
 	struct goodix_ts_data *ts = i2c_get_clientdata(client);
 
 	/* step1:RST output low last at least 2ms */
 	gpio_direction_output(ts->pdata->reset_gpio, 0);
-	usleep(20000);
+	msleep(20);
 
 	/* step2:select I2C slave addr,INT:0--0xBA;1--0x28. */
-	gpio_direction_output(ts->pdata->irq_gpio,
-			(client->addr == GTP_I2C_ADDRESS_HIGH));
+	gpio_direction_output(ts->pdata->irq_gpio, (client->addr == 0x14));
 	msleep(20);
 
 	/* step3:RST output high reset guitar */
@@ -405,28 +440,26 @@ s32 gup_enter_update_mode(struct i2c_client *client)
 		/* step4:Hold ss51 & dsp */
 		ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
 		if (ret <= 0) {
-			pr_debug("Hold ss51 & dsp I2C error,retry:%d", retry);
+			GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
 			continue;
 		}
-
 		/* step5:Confirm hold */
 		ret = gup_get_ic_msg(client, _rRW_MISCTL__SWRST_B0_, rd_buf, 1);
 		if (ret <= 0) {
-			pr_debug("Hold ss51 & dsp I2C error,retry:%d", retry);
+			GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
 			continue;
 		}
-		if (rd_buf[GTP_ADDR_LENGTH] == 0x0C) {
-			pr_debug("Hold ss51 & dsp confirm SUCCESS");
+		if (0x0C == rd_buf[GTP_ADDR_LENGTH]) {
+			GTP_DEBUG("Hold ss51 & dsp confirm SUCCESS");
 			break;
 		}
-		pr_debug("Hold ss51 & dsp confirm 0x4180 failed,value:%d",
-					rd_buf[GTP_ADDR_LENGTH]);
+		GTP_DEBUG("Hold ss51 & dsp confirm 0x4180 failed,value:%d",
+			  rd_buf[GTP_ADDR_LENGTH]);
 	}
 	if (retry >= 200) {
-		pr_err("Enter update Hold ss51 failed.");
+		GTP_ERROR("Enter update Hold ss51 failed.");
 		return FAIL;
 	}
-
 	/* step6:DSP_CK and DSP_ALU_CK PowerOn */
 	ret = gup_set_ic_msg(client, 0x4010, 0x00);
 
@@ -434,369 +467,518 @@ s32 gup_enter_update_mode(struct i2c_client *client)
 	return ret;
 }
 
-void gup_leave_update_mode(struct i2c_client *client)
+void gup_leave_update_mode(void)
 {
-	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+	struct goodix_ts_data *ts = i2c_get_clientdata(i2c_connect_client);
 
 	gpio_direction_input(ts->pdata->irq_gpio);
-	pr_debug("reset chip.");
-	gtp_reset_guitar(ts, 20);
+
+	GTP_DEBUG("[leave_update_mode]reset chip.");
+	gtp_reset_guitar(i2c_connect_client, 20);
 }
 
-/*	Get the correct nvram data
-	The correct conditions:
-	1. the hardware info is the same
-	2. the product id is the same
-	3. the firmware version in update file is greater than the firmware
-	version in ic or the check sum in ic is wrong
-
-	Update Conditions:
-	1. Same hardware info
-	2. Same PID
-	3. File PID > IC PID
-
-	Force Update Conditions:
-	1. Wrong ic firmware checksum
-	2. INVALID IC PID or VID
-	3. IC PID == 91XX || File PID == 91XX
+/* Get the correct nvram data
+  * The correct conditions:
+  * 1. the hardware info is the same
+  * 2. the product id is the same
+  * 3. the firmware version in update file is greater than
+  * the firmware version in ic or the check sum in ic is wrong
+ */
+/* Update Conditions:
+    1. Same hardware info
+    2. Same PID
+    3. File VID > IC VID
+   Force Update Conditions:
+    1. Wrong ic firmware checksum
+    2. INVALID IC PID or VID
+    3. (IC PID == 91XX || File PID == 91XX) && (File VID > IC VID)
 */
 
-static u8 gup_enter_update_judge(struct i2c_client *client,
-					struct st_fw_head *fw_head)
+static u8 gup_enter_update_judge(struct st_fw_head *fw_head)
 {
 	u16 u16_tmp;
 	s32 i = 0;
-
+	u32 fw_len = 0;
+	s32 pid_cmp_len = 0;
 	u16_tmp = fw_head->vid;
-	fw_head->vid = (u16)(u16_tmp>>8) + (u16)(u16_tmp<<8);
-
-	pr_debug("FILE HARDWARE INFO:%02x%02x%02x%02x", fw_head->hw_info[0],
-		fw_head->hw_info[1], fw_head->hw_info[2], fw_head->hw_info[3]);
-	pr_debug("FILE PID:%s", fw_head->pid);
-	pr_debug("FILE VID:%04x", fw_head->vid);
-
-	pr_debug("IC HARDWARE INFO:%02x%02x%02x%02x",
-		update_msg.ic_fw_msg.hw_info[0],
-		update_msg.ic_fw_msg.hw_info[1],
-		update_msg.ic_fw_msg.hw_info[2],
-		update_msg.ic_fw_msg.hw_info[3]);
-	pr_debug("IC PID:%s", update_msg.ic_fw_msg.pid);
-	pr_debug("IC VID:%04x", update_msg.ic_fw_msg.vid);
-
+	fw_head->vid = (u16) (u16_tmp >> 8) + (u16) (u16_tmp << 8);
+
+	GTP_INFO("FILE HARDWARE INFO:%02x%02x%02x%02x", fw_head->hw_info[0],
+		 fw_head->hw_info[1], fw_head->hw_info[2], fw_head->hw_info[3]);
+	GTP_INFO("FILE PID:%s", fw_head->pid);
+	GTP_INFO("FILE VID:%04x", fw_head->vid);
+	GTP_INFO("IC HARDWARE INFO:%02x%02x%02x%02x",
+		 update_msg.ic_fw_msg.hw_info[0],
+		 update_msg.ic_fw_msg.hw_info[1],
+		 update_msg.ic_fw_msg.hw_info[2],
+		 update_msg.ic_fw_msg.hw_info[3]);
+	GTP_INFO("IC PID:%s", update_msg.ic_fw_msg.pid);
+	GTP_INFO("IC VID:%04x", update_msg.ic_fw_msg.vid);
+
+	if (!memcmp(fw_head->pid, "9158", 4)
+	    && !memcmp(update_msg.ic_fw_msg.pid, "915S", 4)) {
+		GTP_INFO("Update GT915S to GT9158 directly!");
+		return SUCCESS;
+	}
 	/* First two conditions */
-	if (!memcmp(fw_head->hw_info, update_msg.ic_fw_msg.hw_info,
-			sizeof(update_msg.ic_fw_msg.hw_info))) {
-		pr_debug("Get the same hardware info.");
-		if (update_msg.force_update != 0xBE) {
-			pr_info("FW chksum error,need enter update.");
-			return SUCCESS;
-		}
+	if (!memcmp
+	    (fw_head->hw_info, update_msg.ic_fw_msg.hw_info,
+	     sizeof(update_msg.ic_fw_msg.hw_info)))
+		fw_len = 42 * 1024;
+	else {
+		fw_len = fw_head->hw_info[3];
+		fw_len += (((u32) fw_head->hw_info[2]) << 8);
+		fw_len += (((u32) fw_head->hw_info[1]) << 16);
+		fw_len += (((u32) fw_head->hw_info[0]) << 24);
+	}
+	if (update_msg.fw_total_len != fw_len) {
+		GTP_ERROR
+		    ("size error, Default size: %d(%dK), actual size: %d(%dK)",
+		     fw_len, fw_len / 1024, update_msg.fw_total_len,
+		     update_msg.fw_total_len / 1024);
+		return FAIL;
+	}
+	GTP_INFO("Firmware length:%d(%dK)", update_msg.fw_total_len,
+		 update_msg.fw_total_len / 1024);
 
-		/* 20130523 start */
-		if (strlen(update_msg.ic_fw_msg.pid) < 3) {
-			pr_info("Illegal IC pid, need enter update");
-			return SUCCESS;
-		} else {
-			for (i = 0; i < 3; i++) {
-				if ((update_msg.ic_fw_msg.pid[i] < 0x30) ||
-					(update_msg.ic_fw_msg.pid[i] > 0x39)) {
-					pr_info("Illegal IC pid, out of bound, need enter update");
-					return SUCCESS;
-				}
+	if (update_msg.force_update != 0xBE) {
+		GTP_INFO("FW chksum error,need enter update.");
+		return SUCCESS;
+	}
+	/* 20130523 start */
+	if (strlen(update_msg.ic_fw_msg.pid) < 3) {
+		GTP_INFO("Illegal IC pid, need enter update");
+		return SUCCESS;
+	} else {
+		for (i = 0; i < 3; i++) {
+			if ((update_msg.ic_fw_msg.pid[i] < 0x30)
+			    || (update_msg.ic_fw_msg.pid[i] > 0x39)) {
+				GTP_INFO
+				    ("Illegal IC pid, out of bound");
+				return SUCCESS;
 			}
 		}
-		/* 20130523 end */
+	}
+	/* 20130523 end */
 
-		if ((!memcmp(fw_head->pid, update_msg.ic_fw_msg.pid,
-		(strlen(fw_head->pid) < 3 ? 3 : strlen(fw_head->pid)))) ||
-		(!memcmp(update_msg.ic_fw_msg.pid, "91XX", 4)) ||
-		(!memcmp(fw_head->pid, "91XX", 4))) {
-			if (!memcmp(fw_head->pid, "91XX", 4))
-				pr_debug("Force none same pid update mode.");
-			else
-				pr_debug("Get the same pid.");
+	pid_cmp_len = strlen(fw_head->pid);
+	if (pid_cmp_len < strlen(update_msg.ic_fw_msg.pid))
+		pid_cmp_len = strlen(update_msg.ic_fw_msg.pid);
 
-			/* The third condition */
-			if (fw_head->vid > update_msg.ic_fw_msg.vid) {
-				pr_info("Need enter update.");
-				return SUCCESS;
-			}
-			pr_err("Don't meet the third condition.");
-			pr_err("File VID <= Ic VID, update aborted!");
-		} else {
-			pr_err("File PID != Ic PID, update aborted!");
+	if ((!memcmp(fw_head->pid, update_msg.ic_fw_msg.pid, pid_cmp_len)) ||
+	    (!memcmp(update_msg.ic_fw_msg.pid, "91XX", 4)) ||
+	    (!memcmp(fw_head->pid, "91XX", 4))) {
+		if (!memcmp(fw_head->pid, "91XX", 4))
+			GTP_DEBUG("Force none same pid update mode.");
+		else
+			GTP_DEBUG("Get the same pid.");
+
+		/* The third condition */
+		if (fw_head->vid > update_msg.ic_fw_msg.vid) {
+			GTP_INFO("Need enter update.");
+			return SUCCESS;
 		}
-	} else {
-		pr_err("Different Hardware, update aborted!");
-	}
+		GTP_ERROR("Don't meet the third condition.");
+		GTP_ERROR("File VID <= Ic VID, update aborted!");
+	} else
+		GTP_ERROR("File PID != Ic PID, update aborted!");
 
 	return FAIL;
 }
 
-static s8 gup_update_config(struct i2c_client *client,
-					const struct firmware *cfg)
+#if GTP_AUTO_UPDATE_CFG
+static u8 ascii2hex(u8 a)
+{
+	s8 value = 0;
+
+	if (a >= '0' && a <= '9')
+		value = a - '0';
+	else if (a >= 'A' && a <= 'F')
+		value = a - 'A' + 0x0A;
+	else if (a >= 'a' && a <= 'f')
+		value = a - 'a' + 0x0A;
+	else
+		value = 0xff;
+
+	return value;
+}
+
+static s8 gup_update_config(struct i2c_client *client)
 {
+	s32 file_len = 0;
 	s32 ret = 0;
 	s32 i = 0;
 	s32 file_cfg_len = 0;
-	u32 chip_cfg_len = 0;
+	s32 chip_cfg_len = 0;
 	s32 count = 0;
 	u8 *buf;
+	u8 *pre_buf;
 	u8 *file_config;
-	u8 pid[8];
-	u8 high, low;
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
 
-	if (!cfg || !cfg->data) {
-		pr_err("No need to upgrade config!");
+	if (NULL == update_msg.cfg_file) {
+		GTP_ERROR("[update_cfg]No need to upgrade config!");
 		return FAIL;
 	}
+	file_len =
+	    update_msg.cfg_file->f_op->llseek(update_msg.cfg_file, 0, SEEK_END);
 
-	ret = gup_get_ic_msg(client, GUP_REG_PID_VID, pid, 6);
-	if (ret == FAIL) {
-		pr_err("Read product id & version id fail.");
-		return FAIL;
-	}
-	pid[5] = '\0';
-	pr_debug("update cfg get pid:%s", &pid[GTP_ADDR_LENGTH]);
+	chip_cfg_len = ts->gtp_cfg_len;
 
-	chip_cfg_len = 186;
-	if (!memcmp(&pid[GTP_ADDR_LENGTH], "968", 3) ||
-		!memcmp(&pid[GTP_ADDR_LENGTH], "910", 3) ||
-		!memcmp(&pid[GTP_ADDR_LENGTH], "960", 3)) {
-		chip_cfg_len = 228;
-	}
-	pr_debug("config file ASCII len:%d", cfg->size);
-	pr_debug("need config binary len:%d", chip_cfg_len);
-	if ((cfg->size + 5) < chip_cfg_len * 5) {
-		pr_err("Config length error");
-		return -EINVAL;
+	GTP_DEBUG("[update_cfg]config file len:%d", file_len);
+	GTP_DEBUG("[update_cfg]need config len:%d", chip_cfg_len);
+	if ((file_len + 5) < chip_cfg_len * 5) {
+		GTP_ERROR("Config length error");
+		return FAIL;
 	}
 
-	buf = devm_kzalloc(&client->dev, cfg->size, GFP_KERNEL);
-	if (!buf) {
-		dev_err(&client->dev, "Memory allocation failed for buf.");
-		return -ENOMEM;
-	}
+	buf = kzalloc(file_len, GFP_KERNEL);
+	pre_buf = kzalloc(file_len, GFP_KERNEL);
+	file_config = kzalloc(chip_cfg_len + GTP_ADDR_LENGTH, GFP_KERNEL);
+	update_msg.cfg_file->f_op->llseek(update_msg.cfg_file, 0, SEEK_SET);
 
-	file_config = devm_kzalloc(&client->dev, chip_cfg_len + GTP_ADDR_LENGTH,
-								GFP_KERNEL);
-	if (!file_config) {
-		dev_err(&client->dev, "Memory allocation failed.");
-		return -ENOMEM;
+	GTP_DEBUG("[update_cfg]Read config from file.");
+	ret =
+	    update_msg.cfg_file->f_op->read(update_msg.cfg_file,
+					    (char *)pre_buf, file_len,
+					    &update_msg.cfg_file->f_pos);
+	if (ret < 0) {
+		GTP_ERROR("[update_cfg]Read config file failed.");
+		goto update_cfg_file_failed;
 	}
 
-	pr_debug("Delete illgal charactor.");
-	for (i = 0, count = 0; i < cfg->size; i++) {
-		if (cfg->data[i] == ' ' || cfg->data[i] == '\r'
-					|| cfg->data[i] == '\n')
+	GTP_DEBUG("[update_cfg]Delete illgal charactor.");
+	for (i = 0, count = 0; i < file_len; i++) {
+		if (pre_buf[i] == ' ' || pre_buf[i] == '\r'
+		    || pre_buf[i] == '\n')
 			continue;
-		buf[count++] = cfg->data[i];
+		buf[count++] = pre_buf[i];
 	}
 
-	pr_debug("Ascii to hex.");
+	GTP_DEBUG("[update_cfg]Ascii to hex.");
 	file_config[0] = GTP_REG_CONFIG_DATA >> 8;
 	file_config[1] = GTP_REG_CONFIG_DATA & 0xff;
-	for (i = 0, file_cfg_len = GTP_ADDR_LENGTH; i < count; i = i + 5) {
-		if ((buf[i] == '0') && ((buf[i + 1] == 'x') ||
-						(buf[i + 1] == 'X'))) {
-			ret = hex2bin(&high, &buf[i + 2], 1);
-			if (ret) {
-				pr_err("Failed to convert high address from hex2bin");
-				return ret;
-			}
-			ret = hex2bin(&low, &buf[i + 3], 1);
-			if (ret) {
-				pr_err("Failed to convert low address from hex2bin");
-				return ret;
-			}
+	for (i = 0, file_cfg_len = GTP_ADDR_LENGTH; i < count; i += 5) {
+		if ((buf[i] == '0')
+		    && ((buf[i + 1] == 'x') || (buf[i + 1] == 'X'))) {
+			u8 high, low;
+			high = ascii2hex(buf[i + 2]);
+			low = ascii2hex(buf[i + 3]);
 
 			if ((high == 0xFF) || (low == 0xFF)) {
 				ret = 0;
-				pr_err("Illegal config file.");
-				return ret;
+				GTP_ERROR("[update_cfg]Illegal config file.");
+				goto update_cfg_file_failed;
 			}
-			file_config[file_cfg_len++] = (high<<4) + low;
+			file_config[file_cfg_len++] = (high << 4) + low;
 		} else {
 			ret = 0;
-			pr_err("Illegal config file.");
-			return ret;
+			GTP_ERROR("[update_cfg]Illegal config file.");
+			goto update_cfg_file_failed;
 		}
 	}
 
+	GTP_DEBUG("config:");
+	GTP_DEBUG_ARRAY(file_config + 2, file_cfg_len);
+
 	i = 0;
 	while (i++ < 5) {
 		ret = gup_i2c_write(client, file_config, file_cfg_len);
 		if (ret > 0) {
-			pr_info("Send config SUCCESS.");
+			GTP_INFO("[update_cfg]Send config SUCCESS.");
 			break;
 		}
-		pr_err("Send config i2c error.");
+		GTP_ERROR("[update_cfg]Send config i2c error.");
 	}
 
+update_cfg_file_failed:
+	kfree(pre_buf);
+	kfree(buf);
+	kfree(file_config);
 	return ret;
 }
+#endif
 
-static s32 gup_get_firmware_file(struct i2c_client *client,
-		struct st_update_msg *msg, u8 *path)
-{
-	s32 ret;
-	const struct firmware *fw = NULL;
-
-	ret = request_firmware(&fw, path, &client->dev);
-	if (ret < 0) {
-		dev_info(&client->dev, "Cannot get firmware - %s (%d)\n",
-					path, ret);
-		return -EEXIST;
-	}
-
-	dev_dbg(&client->dev, "Config File: %s size=%d", path, fw->size);
-	msg->fw_data =
-		devm_kzalloc(&client->dev, fw->size, GFP_KERNEL);
-	if (!msg->fw_data) {
-		dev_err(&client->dev,
-			"Not enough memory for firmware data.");
-		release_firmware(fw);
-		return -ENOMEM;
-	}
-
-	memcpy(msg->fw_data, fw->data, fw->size);
-	msg->fw_len = fw->size;
-	msg->need_free = true;
-	release_firmware(fw);
-	return 0;
-}
-
-static u8 gup_check_firmware_name(struct i2c_client *client,
-					u8 **path_p)
+#if (GTP_AUTO_UPDATE && (!GTP_HEADER_FW_UPDATE || GTP_AUTO_UPDATE_CFG))
+static void gup_search_file(s32 search_type)
 {
-	u8 len;
-	u8 *fname;
+	s32 i = 0;
+	struct file *pfile = NULL;
+	struct filename name;
 
-	if (!(*path_p)) {
-		*path_p = GOODIX_FIRMWARE_FILE_NAME;
-		return 0;
-	}
+	got_file_flag = 0x00;
 
-	len = strnlen(*path_p, FIRMWARE_NAME_LEN_MAX);
-	if (len >= FIRMWARE_NAME_LEN_MAX) {
-		dev_err(&client->dev, "firmware name too long!");
-		return -EINVAL;
-	}
+	searching_file = 1;
+	for (i = 0; i < GUP_SEARCH_FILE_TIMES; ++i) {
+		if (0 == searching_file) {
+			GTP_INFO("Force exiting file searching");
+			got_file_flag = 0x00;
+			return;
+		}
 
-	fname = strrchr(*path_p, '/');
-	if (fname) {
-		fname = fname + 1;
-		*path_p = fname;
+		if (search_type & AUTO_SEARCH_BIN) {
+			GTP_DEBUG("Search for %s, %s for fw update.(%d/%d)",
+				  UPDATE_FILE_PATH_1, UPDATE_FILE_PATH_2, i + 1,
+				  GUP_SEARCH_FILE_TIMES);
+			name.name = UPDATE_FILE_PATH_1;
+			pfile = file_open_name(&name, O_RDONLY, 0);
+			if (IS_ERR(pfile)) {
+				name.name = UPDATE_FILE_PATH_2;
+				pfile = file_open_name(&name, O_RDONLY, 0);
+				if (!IS_ERR(pfile)) {
+					GTP_INFO("Bin file: %s for fw update.",
+						 UPDATE_FILE_PATH_2);
+					got_file_flag |= BIN_FILE_READY;
+					update_msg.file = pfile;
+				}
+			} else {
+				GTP_INFO("Bin file: %s for fw update.",
+					 UPDATE_FILE_PATH_1);
+				got_file_flag |= BIN_FILE_READY;
+				update_msg.file = pfile;
+			}
+			if (got_file_flag & BIN_FILE_READY) {
+#if GTP_AUTO_UPDATE_CFG
+				if (search_type & AUTO_SEARCH_CFG)
+					i = GUP_SEARCH_FILE_TIMES;
+				else
+#endif
+				{
+					searching_file = 0;
+					return;
+				}
+			}
+		}
+#if GTP_AUTO_UPDATE_CFG
+		if ((search_type & AUTO_SEARCH_CFG)
+		    && !(got_file_flag & CFG_FILE_READY)) {
+			GTP_DEBUG("Search for %s, %s for config update.(%d/%d)",
+				  CONFIG_FILE_PATH_1, CONFIG_FILE_PATH_2, i + 1,
+				  GUP_SEARCH_FILE_TIMES);
+			name.name = CONFIG_FILE_PATH_1;
+			pfile = file_open_name(&name, O_RDONLY, 0);
+			if (IS_ERR(pfile)) {
+				name.name = CONFIG_FILE_PATH_2;
+				pfile = file_open_name(&name, O_RDONLY, 0);
+				if (!IS_ERR(pfile)) {
+					GTP_INFO
+					    ("Cfg file: %s for config update.",
+					     CONFIG_FILE_PATH_2);
+					got_file_flag |= CFG_FILE_READY;
+					update_msg.cfg_file = pfile;
+				}
+			} else {
+				GTP_INFO("Cfg file: %s for config update.",
+					 CONFIG_FILE_PATH_1);
+				got_file_flag |= CFG_FILE_READY;
+				update_msg.cfg_file = pfile;
+			}
+			if (got_file_flag & CFG_FILE_READY) {
+				searching_file = 0;
+				return;
+			}
+		}
+#endif
+		msleep(3000);
 	}
-	return 0;
+	searching_file = 0;
 }
+#endif
 
 static u8 gup_check_update_file(struct i2c_client *client,
-			struct st_fw_head *fw_head, u8 *path)
+				struct st_fw_head *fw_head, u8 *path)
 {
 	s32 ret = 0;
 	s32 i = 0;
 	s32 fw_checksum = 0;
-	u16 temp;
-	const struct firmware *fw = NULL;
-
-	ret = request_firmware(&fw, GOODIX_CONFIG_FILE_NAME, &client->dev);
-	if (ret < 0) {
-		dev_info(&client->dev, "Cannot get config file - %s (%d)\n",
-						GOODIX_CONFIG_FILE_NAME, ret);
+	u8 buf[FW_HEAD_LENGTH];
+	struct filename name = {.name = path};
+
+	got_file_flag = 0x00;
+	if (path) {
+		GTP_DEBUG("Update File path:%s, %d", path, strlen(path));
+		update_msg.file = file_open_name(&name, O_RDONLY, 0);
+		if (IS_ERR(update_msg.file)) {
+			GTP_ERROR("Open update file(%s) error!", path);
+			return FAIL;
+		}
+		got_file_flag = BIN_FILE_READY;
 	} else {
-		dev_dbg(&client->dev,
-			"Update config File: %s", GOODIX_CONFIG_FILE_NAME);
-		ret = gup_update_config(client, fw);
-		if (ret <= 0)
-			dev_err(&client->dev, "Update config failed.");
-		release_firmware(fw);
+#if GTP_AUTO_UPDATE
+#if GTP_HEADER_FW_UPDATE
+		GTP_INFO("Update by default firmware array");
+		update_msg.fw_total_len =
+		    sizeof(gtp_default_FW) - FW_HEAD_LENGTH;
+		if (sizeof(gtp_default_FW) <
+		    (FW_HEAD_LENGTH + FW_SECTION_LENGTH * 4 +
+		     FW_DSP_ISP_LENGTH + FW_DSP_LENGTH + FW_BOOT_LENGTH)) {
+			GTP_ERROR
+			    ("INVALID gtp_default_FW, check gt9xx_firmware.h!");
+			return FAIL;
+		}
+		GTP_DEBUG("Firmware actual size: %d(%dK)",
+			  update_msg.fw_total_len,
+			  update_msg.fw_total_len / 1024);
+		memcpy(fw_head, &gtp_default_FW[0], FW_HEAD_LENGTH);
+
+		/* check firmware legality */
+		fw_checksum = 0;
+		for (i = 0; i < update_msg.fw_total_len; i += 2)
+			fw_checksum +=
+			    (gtp_default_FW[FW_HEAD_LENGTH + i] << 8) +
+			    gtp_default_FW[FW_HEAD_LENGTH + i + 1];
+
+		GTP_DEBUG("firmware checksum:%x", fw_checksum & 0xFFFF);
+		if (fw_checksum & 0xFFFF) {
+			GTP_ERROR("Illegal firmware file.");
+			return FAIL;
+		}
+		got_file_flag = HEADER_FW_READY;
+		return SUCCESS;
+#else
+
+#if GTP_AUTO_UPDATE_CFG
+		gup_search_file(AUTO_SEARCH_BIN | AUTO_SEARCH_CFG);
+		if (got_file_flag & CFG_FILE_READY) {
+			ret = gup_update_config(i2c_connect_client);
+			if (ret <= 0)
+				GTP_ERROR("Update config failed.");
+			_CLOSE_FILE(update_msg.cfg_file);
+			/* waiting config to be stored in FLASH. */
+			msleep(500);
+		}
+#else
+		gup_search_file(AUTO_SEARCH_BIN);
+#endif
+
+		if (!(got_file_flag & BIN_FILE_READY)) {
+			GTP_ERROR("No bin file for fw update");
+			return FAIL;
+		}
+#endif
+
+#else
+		{
+			GTP_ERROR("NULL file for firmware update");
+			return FAIL;
+		}
+#endif
+	}
+
+	update_msg.old_fs = get_fs();
+	set_fs(KERNEL_DS);
+
+	update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_SET);
+	update_msg.fw_total_len =
+	    update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_END);
+	if (update_msg.fw_total_len <
+	    (FW_HEAD_LENGTH + FW_SECTION_LENGTH * 4 + FW_DSP_ISP_LENGTH +
+	     FW_DSP_LENGTH + FW_BOOT_LENGTH)) {
+		GTP_ERROR("INVALID bin file(size: %d), update aborted.",
+			  update_msg.fw_total_len);
+		return FAIL;
 	}
 
-	update_msg.need_free = false;
-	update_msg.fw_len = 0;
+	update_msg.fw_total_len -= FW_HEAD_LENGTH;
 
-	if (gup_check_firmware_name(client, &path))
-		goto load_failed;
+	GTP_DEBUG("Bin firmware actual size: %d(%dK)", update_msg.fw_total_len,
+		  update_msg.fw_total_len / 1024);
 
-	if (gup_get_firmware_file(client, &update_msg, path))
-		goto load_failed;
+	update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_SET);
+	ret =
+	    update_msg.file->f_op->read(update_msg.file, (char *)buf,
+					FW_HEAD_LENGTH,
+					&update_msg.file->f_pos);
+	if (ret < 0) {
+		GTP_ERROR("Read firmware head in update file error.");
+		return FAIL;
+	}
 
-	memcpy(fw_head, update_msg.fw_data, FW_HEAD_LENGTH);
+	memcpy(fw_head, buf, FW_HEAD_LENGTH);
 
 	/* check firmware legality */
 	fw_checksum = 0;
-	for (i = 0; i < FW_SECTION_LENGTH * 4 + FW_DSP_ISP_LENGTH +
-			FW_DSP_LENGTH + FW_BOOT_LENGTH; i += 2) {
-		temp = (update_msg.fw_data[FW_HEAD_LENGTH + i] << 8) +
-			update_msg.fw_data[FW_HEAD_LENGTH + i + 1];
+	for (i = 0; i < update_msg.fw_total_len; i += 2) {
+		u16 temp;
+		ret =
+		    update_msg.file->f_op->read(update_msg.file, (char *)buf, 2,
+						&update_msg.file->f_pos);
+		if (ret < 0) {
+			GTP_ERROR("Read firmware file error.");
+			return FAIL;
+		}
+		temp = (buf[0] << 8) + buf[1];
 		fw_checksum += temp;
 	}
 
-	pr_debug("firmware checksum:%x", fw_checksum & 0xFFFF);
+	GTP_DEBUG("firmware checksum:%x", fw_checksum & 0xFFFF);
 	if (fw_checksum & 0xFFFF) {
-		dev_err(&client->dev, "Illegal firmware file.");
-		goto load_failed;
+		GTP_ERROR("Illegal firmware file.");
+		return FAIL;
 	}
 
 	return SUCCESS;
-
-load_failed:
-	if (update_msg.need_free) {
-		devm_kfree(&client->dev, update_msg.fw_data);
-		update_msg.need_free = false;
-	}
-	return FAIL;
 }
 
-static u8 gup_burn_proc(struct i2c_client *client, u8 *burn_buf, u16 start_addr,
-							u16 total_length)
+static u8 gup_burn_proc(struct i2c_client *client, u8 *burn_buf,
+			u16 start_addr, u16 total_length)
 {
 	s32 ret = 0;
 	u16 burn_addr = start_addr;
 	u16 frame_length = 0;
 	u16 burn_length = 0;
-	u8  wr_buf[PACK_SIZE + GTP_ADDR_LENGTH];
-	u8  rd_buf[PACK_SIZE + GTP_ADDR_LENGTH];
-	u8  retry = 0;
+	u8 wr_buf[PACK_SIZE + GTP_ADDR_LENGTH];
+	u8 rd_buf[PACK_SIZE + GTP_ADDR_LENGTH];
+	u8 retry = 0;
 
-	pr_debug("Begin burn %dk data to addr 0x%x", (total_length / 1024),
-								start_addr);
+	GTP_DEBUG("Begin burn %dk data to addr 0x%x", (total_length / 1024),
+		  start_addr);
 	while (burn_length < total_length) {
-		pr_debug("B/T:%04d/%04d", burn_length, total_length);
-		frame_length = ((total_length - burn_length) > PACK_SIZE)
-				? PACK_SIZE : (total_length - burn_length);
-		wr_buf[0] = (u8)(burn_addr>>8);
+		GTP_DEBUG("B/T:%04d/%04d", burn_length, total_length);
+		frame_length =
+		    ((total_length - burn_length) >
+		     PACK_SIZE) ? PACK_SIZE : (total_length - burn_length);
+		wr_buf[0] = (u8) (burn_addr >> 8);
 		rd_buf[0] = wr_buf[0];
-		wr_buf[1] = (u8)burn_addr;
+		wr_buf[1] = (u8) burn_addr;
 		rd_buf[1] = wr_buf[1];
 		memcpy(&wr_buf[GTP_ADDR_LENGTH], &burn_buf[burn_length],
-								frame_length);
+		       frame_length);
 
 		for (retry = 0; retry < MAX_FRAME_CHECK_TIME; retry++) {
-			ret = gup_i2c_write(client, wr_buf,
-					GTP_ADDR_LENGTH + frame_length);
+			ret =
+			    gup_i2c_write(client, wr_buf,
+					  GTP_ADDR_LENGTH + frame_length);
 			if (ret <= 0) {
-				pr_err("Write frame data i2c error.");
+				GTP_ERROR("Write frame data i2c error.");
 				continue;
 			}
-			ret = gup_i2c_read(client, rd_buf, GTP_ADDR_LENGTH +
-							frame_length);
+			ret =
+			    gup_i2c_read(client, rd_buf,
+					 GTP_ADDR_LENGTH + frame_length);
 			if (ret <= 0) {
-				pr_err("Read back frame data i2c error.");
+				GTP_ERROR("Read back frame data i2c error.");
 				continue;
 			}
 
-			if (memcmp(&wr_buf[GTP_ADDR_LENGTH],
-				&rd_buf[GTP_ADDR_LENGTH], frame_length)) {
-				pr_err("Check frame data fail,not equal.");
+			if (memcmp
+			    (&wr_buf[GTP_ADDR_LENGTH], &rd_buf[GTP_ADDR_LENGTH],
+			     frame_length)) {
+				GTP_ERROR("Check frame data fail,not equal.");
+				GTP_DEBUG("write array:");
+				GTP_DEBUG_ARRAY(&wr_buf[GTP_ADDR_LENGTH],
+						frame_length);
+				GTP_DEBUG("read array:");
+				GTP_DEBUG_ARRAY(&rd_buf[GTP_ADDR_LENGTH],
+						frame_length);
 				continue;
 			} else {
+				/* GTP_DEBUG("Check frame data success."); */
 				break;
 			}
 		}
 		if (retry >= MAX_FRAME_CHECK_TIME) {
-			pr_err("Burn frame data time out,exit.");
+			GTP_ERROR("Burn frame data time out,exit.");
 			return FAIL;
 		}
 		burn_length += frame_length;
@@ -805,149 +987,178 @@ static u8 gup_burn_proc(struct i2c_client *client, u8 *burn_buf, u16 start_addr,
 	return SUCCESS;
 }
 
-static u8 gup_load_section_file(u8 *buf, u16 offset, u16 length)
+static u8 gup_load_section_file(u8 *buf, u32 offset, u16 length, u8 set_or_end)
 {
-	if (!update_msg.fw_data ||
-		update_msg.fw_len < FW_HEAD_LENGTH + offset + length) {
-		pr_err(
-			"<<-GTP->> cannot load section data. fw_len=%d read end=%d\n",
-			update_msg.fw_len ,
-			FW_HEAD_LENGTH + offset + length);
-		return FAIL;
+#if (GTP_AUTO_UPDATE && GTP_HEADER_FW_UPDATE)
+	if (got_file_flag == HEADER_FW_READY) {
+		if (SEEK_SET == set_or_end)
+			memcpy(buf, &gtp_default_FW[FW_HEAD_LENGTH + offset],
+			       length);
+		else
+			memcpy(buf,
+			       &gtp_default_FW[update_msg.fw_total_len +
+					       FW_HEAD_LENGTH - offset],
+			       length);
+		return SUCCESS;
 	}
-	memcpy(buf, &update_msg.fw_data[FW_HEAD_LENGTH + offset], length);
+#endif
+	{
+		s32 ret = 0;
 
-	return SUCCESS;
+		if ((update_msg.file == NULL) || IS_ERR(update_msg.file)) {
+			GTP_ERROR
+			    ("cannot find update file,load section file fail.");
+			return FAIL;
+		}
+
+		if (SEEK_SET == set_or_end)
+			update_msg.file->f_pos = FW_HEAD_LENGTH + offset;
+		else
+			update_msg.file->f_pos =
+			    update_msg.fw_total_len + FW_HEAD_LENGTH - offset;
+
+		ret =
+		    update_msg.file->f_op->read(update_msg.file, (char *)buf,
+						length,
+						&update_msg.file->f_pos);
+		if (ret < 0) {
+			GTP_ERROR("Read update file fail.");
+			return FAIL;
+		}
+
+		return SUCCESS;
+	}
 }
 
 static u8 gup_recall_check(struct i2c_client *client, u8 *chk_src,
-					u16 start_rd_addr, u16 chk_length)
+			   u16 start_rd_addr, u16 chk_length)
 {
-	u8  rd_buf[PACK_SIZE + GTP_ADDR_LENGTH];
+	u8 rd_buf[PACK_SIZE + GTP_ADDR_LENGTH];
 	s32 ret = 0;
 	u16 recall_addr = start_rd_addr;
 	u16 recall_length = 0;
 	u16 frame_length = 0;
 
 	while (recall_length < chk_length) {
-		frame_length = ((chk_length - recall_length) > PACK_SIZE)
-				? PACK_SIZE : (chk_length - recall_length);
+		frame_length =
+		    ((chk_length - recall_length) >
+		     PACK_SIZE) ? PACK_SIZE : (chk_length - recall_length);
 		ret = gup_get_ic_msg(client, recall_addr, rd_buf, frame_length);
 		if (ret <= 0) {
-			pr_err("recall i2c error,exit");
+			GTP_ERROR("recall i2c error,exit");
 			return FAIL;
 		}
 
-		if (memcmp(&rd_buf[GTP_ADDR_LENGTH], &chk_src[recall_length],
-			frame_length)) {
-			pr_err("Recall frame data fail,not equal.");
+		if (memcmp
+		    (&rd_buf[GTP_ADDR_LENGTH], &chk_src[recall_length],
+		     frame_length)) {
+			GTP_ERROR("Recall frame data fail,not equal.");
+			GTP_DEBUG("chk_src array:");
+			GTP_DEBUG_ARRAY(&chk_src[recall_length], frame_length);
+			GTP_DEBUG("recall array:");
+			GTP_DEBUG_ARRAY(&rd_buf[GTP_ADDR_LENGTH], frame_length);
 			return FAIL;
 		}
 
 		recall_length += frame_length;
 		recall_addr += frame_length;
 	}
-	pr_debug("Recall check %dk firmware success.", (chk_length/1024));
+	GTP_DEBUG("Recall check %dk firmware success.", (chk_length / 1024));
 
 	return SUCCESS;
 }
 
 static u8 gup_burn_fw_section(struct i2c_client *client, u8 *fw_section,
-					u16 start_addr, u8 bank_cmd)
+			      u16 start_addr, u8 bank_cmd)
 {
 	s32 ret = 0;
-	u8  rd_buf[5];
+	u8 rd_buf[5];
 
 	/* step1:hold ss51 & dsp */
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
 	if (ret <= 0) {
-		pr_err("hold ss51 & dsp fail.");
+		GTP_ERROR("[burn_fw_section]hold ss51 & dsp fail.");
 		return FAIL;
 	}
-
-	 /* step2:set scramble */
+	/* step2:set scramble */
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
 	if (ret <= 0) {
-		pr_err("set scramble fail.");
+		GTP_ERROR("[burn_fw_section]set scramble fail.");
 		return FAIL;
 	}
-
 	/* step3:select bank */
-	ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK,
-						(bank_cmd >> 4)&0x0F);
+	ret =
+	    gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK,
+			   (bank_cmd >> 4) & 0x0F);
 	if (ret <= 0) {
-		pr_err("select bank %d fail.",
-					(bank_cmd >> 4)&0x0F);
+		GTP_ERROR("[burn_fw_section]select bank %d fail.",
+			  (bank_cmd >> 4) & 0x0F);
 		return FAIL;
 	}
-
 	/* step4:enable accessing code */
 	ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x01);
 	if (ret <= 0) {
-		pr_err("enable accessing code fail.");
+		GTP_ERROR("[burn_fw_section]enable accessing code fail.");
 		return FAIL;
 	}
-
 	/* step5:burn 8k fw section */
 	ret = gup_burn_proc(client, fw_section, start_addr, FW_SECTION_LENGTH);
-	if (ret == FAIL)  {
-		pr_err("burn fw_section fail.");
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_section]burn fw_section fail.");
 		return FAIL;
 	}
-
 	/* step6:hold ss51 & release dsp */
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);
 	if (ret <= 0) {
-		pr_err("hold ss51 & release dsp fail.");
+		GTP_ERROR("[burn_fw_section]hold ss51 & release dsp fail.");
 		return FAIL;
 	}
 	/* must delay */
 	msleep(20);
 
 	/* step7:send burn cmd to move data to flash from sram */
-	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, bank_cmd&0x0f);
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, bank_cmd & 0x0f);
 	if (ret <= 0) {
-		pr_err("send burn cmd fail.");
+		GTP_ERROR("[burn_fw_section]send burn cmd fail.");
 		return FAIL;
 	}
-	pr_debug("Wait for the burn is complete.");
+	GTP_DEBUG("[burn_fw_section]Wait for the burn is complete......");
 	do {
 		ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
 		if (ret <= 0) {
-			pr_err("Get burn state fail");
+			GTP_ERROR("[burn_fw_section]Get burn state fail");
 			return FAIL;
 		}
 		msleep(20);
 	} while (rd_buf[GTP_ADDR_LENGTH]);
 
 	/* step8:select bank */
-	ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK,
-							(bank_cmd >> 4)&0x0F);
+	ret =
+	    gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK,
+			   (bank_cmd >> 4) & 0x0F);
 	if (ret <= 0) {
-		pr_err("select bank %d fail.",
-							(bank_cmd >> 4)&0x0F);
+		GTP_ERROR("[burn_fw_section]select bank %d fail.",
+			  (bank_cmd >> 4) & 0x0F);
 		return FAIL;
 	}
-
 	/* step9:enable accessing code */
 	ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x01);
 	if (ret <= 0) {
-		pr_err("enable accessing code fail.");
+		GTP_ERROR("[burn_fw_section]enable accessing code fail.");
 		return FAIL;
 	}
-
 	/* step10:recall 8k fw section */
-	ret = gup_recall_check(client, fw_section, start_addr,
-							FW_SECTION_LENGTH);
-	if (ret == FAIL) {
-		pr_err("recall check 8k firmware fail.");
+	ret =
+	    gup_recall_check(client, fw_section, start_addr, FW_SECTION_LENGTH);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_section]recall check %dk firmware fail.",
+			  FW_SECTION_LENGTH / 1024);
 		return FAIL;
 	}
-
 	/* step11:disable accessing code */
 	ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x00);
 	if (ret <= 0) {
-		pr_err("disable accessing code fail.");
+		GTP_ERROR("[burn_fw_section]disable accessing code fail.");
 		return FAIL;
 	}
 
@@ -958,489 +1169,958 @@ static u8 gup_burn_dsp_isp(struct i2c_client *client)
 {
 	s32 ret = 0;
 	u8 *fw_dsp_isp = NULL;
-	u8  retry = 0;
+	u8 retry = 0;
 
-	pr_debug("Begin burn dsp isp.");
+	GTP_INFO("[burn_dsp_isp]Begin burn dsp isp---->>");
 
 	/* step1:alloc memory */
-	pr_debug("step1:alloc memory");
+	GTP_DEBUG("[burn_dsp_isp]step1:alloc memory");
 	while (retry++ < 5) {
-		fw_dsp_isp = devm_kzalloc(&client->dev, FW_DSP_ISP_LENGTH,
-								GFP_KERNEL);
-		if (fw_dsp_isp == NULL) {
+		fw_dsp_isp = kzalloc(FW_DSP_ISP_LENGTH, GFP_KERNEL);
+		if (fw_dsp_isp == NULL)
 			continue;
-		} else {
-			pr_info("Alloc %dk byte memory success.",
-					(FW_DSP_ISP_LENGTH/1024));
+		else {
+			GTP_INFO("[burn_dsp_isp]Alloc %dk byte memory success.",
+				 (FW_DSP_ISP_LENGTH / 1024));
 			break;
 		}
 	}
-	if (retry == 5) {
-		pr_err("Alloc memory fail,exit.");
+	if (retry >= 5) {
+		GTP_ERROR("[burn_dsp_isp]Alloc memory fail,exit.");
 		return FAIL;
 	}
-
 	/* step2:load dsp isp file data */
-	pr_debug("step2:load dsp isp file data");
-	ret = gup_load_section_file(fw_dsp_isp, (4 * FW_SECTION_LENGTH +
-		FW_DSP_LENGTH + FW_BOOT_LENGTH), FW_DSP_ISP_LENGTH);
-	if (ret == FAIL) {
-		pr_err("load firmware dsp_isp fail.");
-		return FAIL;
+	GTP_DEBUG("[burn_dsp_isp]step2:load dsp isp file data");
+	ret =
+	    gup_load_section_file(fw_dsp_isp, FW_DSP_ISP_LENGTH,
+				  FW_DSP_ISP_LENGTH, SEEK_END);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_dsp_isp]load firmware dsp_isp fail.");
+		goto exit_burn_dsp_isp;
 	}
-
 	/* step3:disable wdt,clear cache enable */
-	pr_debug("step3:disable wdt,clear cache enable");
+	GTP_DEBUG("[burn_dsp_isp]step3:disable wdt,clear cache enable");
 	ret = gup_set_ic_msg(client, _bRW_MISCTL__TMR0_EN, 0x00);
 	if (ret <= 0) {
-		pr_err("disable wdt fail.");
-		return FAIL;
+		GTP_ERROR("[burn_dsp_isp]disable wdt fail.");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
 	}
 	ret = gup_set_ic_msg(client, _bRW_MISCTL__CACHE_EN, 0x00);
 	if (ret <= 0) {
-		pr_err("clear cache enable fail.");
-		return FAIL;
+		GTP_ERROR("[burn_dsp_isp]clear cache enable fail.");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
 	}
-
 	/* step4:hold ss51 & dsp */
-	pr_debug("step4:hold ss51 & dsp");
+	GTP_DEBUG("[burn_dsp_isp]step4:hold ss51 & dsp");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
 	if (ret <= 0) {
-		pr_err("hold ss51 & dsp fail.");
-		return FAIL;
+		GTP_ERROR("[burn_dsp_isp]hold ss51 & dsp fail.");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
 	}
-
 	/* step5:set boot from sram */
-	pr_debug("step5:set boot from sram");
+	GTP_DEBUG("[burn_dsp_isp]step5:set boot from sram");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOTCTL_B0_, 0x02);
 	if (ret <= 0) {
-		pr_err("set boot from sram fail.");
-		return FAIL;
+		GTP_ERROR("[burn_dsp_isp]set boot from sram fail.");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
 	}
-
 	/* step6:software reboot */
-	pr_debug("step6:software reboot");
+	GTP_DEBUG("[burn_dsp_isp]step6:software reboot");
 	ret = gup_set_ic_msg(client, _bWO_MISCTL__CPU_SWRST_PULSE, 0x01);
 	if (ret <= 0) {
-		pr_err("software reboot fail.");
-		return FAIL;
+		GTP_ERROR("[burn_dsp_isp]software reboot fail.");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
 	}
-
 	/* step7:select bank2 */
-	pr_debug("step7:select bank2");
+	GTP_DEBUG("[burn_dsp_isp]step7:select bank2");
 	ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x02);
 	if (ret <= 0) {
-		pr_err("select bank2 fail.");
-		return FAIL;
+		GTP_ERROR("[burn_dsp_isp]select bank2 fail.");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
 	}
-
 	/* step8:enable accessing code */
-	pr_debug("step8:enable accessing code");
+	GTP_DEBUG("[burn_dsp_isp]step8:enable accessing code");
 	ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x01);
 	if (ret <= 0) {
-		pr_err("enable accessing code fail.");
-		return FAIL;
+		GTP_ERROR("[burn_dsp_isp]enable accessing code fail.");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
 	}
-
 	/* step9:burn 4k dsp_isp */
-	pr_debug("step9:burn 4k dsp_isp");
+	GTP_DEBUG("[burn_dsp_isp]step9:burn 4k dsp_isp");
 	ret = gup_burn_proc(client, fw_dsp_isp, 0xC000, FW_DSP_ISP_LENGTH);
-	if (ret == FAIL) {
-		pr_err("burn dsp_isp fail.");
-		return FAIL;
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_dsp_isp]burn dsp_isp fail.");
+		goto exit_burn_dsp_isp;
 	}
-
 	/* step10:set scramble */
-	pr_debug("step10:set scramble");
+	GTP_DEBUG("[burn_dsp_isp]step10:set scramble");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
 	if (ret <= 0) {
-		pr_err("set scramble fail.");
-		return FAIL;
+		GTP_ERROR("[burn_dsp_isp]set scramble fail.");
+		ret = FAIL;
+		goto exit_burn_dsp_isp;
 	}
+	update_msg.fw_burned_len += FW_DSP_ISP_LENGTH;
+	GTP_DEBUG("[burn_dsp_isp]Burned length:%d", update_msg.fw_burned_len);
+	ret = SUCCESS;
 
-	return SUCCESS;
+exit_burn_dsp_isp:
+	kfree(fw_dsp_isp);
+	return ret;
 }
 
 static u8 gup_burn_fw_ss51(struct i2c_client *client)
 {
 	u8 *fw_ss51 = NULL;
-	u8  retry = 0;
+	u8 retry = 0;
 	s32 ret = 0;
 
-	pr_debug("Begin burn ss51 firmware.");
+	GTP_INFO("[burn_fw_ss51]Begin burn ss51 firmware---->>");
 
 	/* step1:alloc memory */
-	pr_debug("step1:alloc memory");
+	GTP_DEBUG("[burn_fw_ss51]step1:alloc memory");
 	while (retry++ < 5) {
-		fw_ss51 = devm_kzalloc(&client->dev, FW_SECTION_LENGTH,
-							GFP_KERNEL);
-		if (fw_ss51 == NULL) {
+		fw_ss51 = kzalloc(FW_SECTION_LENGTH, GFP_KERNEL);
+		if (fw_ss51 == NULL)
 			continue;
-		} else {
-			pr_info("Alloc %dk byte memory success.",
-						(FW_SECTION_LENGTH/1024));
+		else {
+			GTP_DEBUG
+			    ("[burn_fw_ss51]Alloc %dk byte memory success.",
+			     (FW_SECTION_LENGTH / 1024));
 			break;
 		}
 	}
-	if (retry == 5) {
-		pr_err("Alloc memory fail,exit.");
+	if (retry >= 5) {
+		GTP_ERROR("[burn_fw_ss51]Alloc memory fail,exit.");
 		return FAIL;
 	}
-
 	/* step2:load ss51 firmware section 1 file data */
-	pr_debug("step2:load ss51 firmware section 1 file data");
-	ret = gup_load_section_file(fw_ss51, 0, FW_SECTION_LENGTH);
-	if (ret == FAIL) {
-		pr_err("load ss51 firmware section 1 fail.");
-		return FAIL;
-	}
+	/*
+	GTP_DEBUG("[burn_fw_ss51]step2:load ss51 firmware section 1 file data");
+	ret = gup_load_section_file(fw_ss51, 0, FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+	GTP_ERROR("[burn_fw_ss51]load ss51 firmware section 1 fail.");
+	goto exit_burn_fw_ss51;
+	} */
+
+	GTP_INFO("[burn_fw_ss51]Reset first 8K of ss51 to 0xFF.");
+	GTP_DEBUG("[burn_fw_ss51]step2: reset bank0 0xC000~0xD000");
+	memset(fw_ss51, 0xFF, FW_SECTION_LENGTH);
 
 	/* step3:clear control flag */
-	pr_debug("step3:clear control flag");
+	GTP_DEBUG("[burn_fw_ss51]step3:clear control flag");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x00);
 	if (ret <= 0) {
-		pr_err("clear control flag fail.");
-		return FAIL;
+		GTP_ERROR("[burn_fw_ss51]clear control flag fail.");
+		ret = FAIL;
+		goto exit_burn_fw_ss51;
 	}
-
 	/* step4:burn ss51 firmware section 1 */
-	pr_debug("step4:burn ss51 firmware section 1");
+	GTP_DEBUG("[burn_fw_ss51]step4:burn ss51 firmware section 1");
 	ret = gup_burn_fw_section(client, fw_ss51, 0xC000, 0x01);
-	if (ret == FAIL) {
-		pr_err("burn ss51 firmware section 1 fail.");
-		return FAIL;
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_ss51]burn ss51 firmware section 1 fail.");
+		goto exit_burn_fw_ss51;
 	}
-
 	/* step5:load ss51 firmware section 2 file data */
-	pr_debug("step5:load ss51 firmware section 2 file data");
-	ret = gup_load_section_file(fw_ss51, FW_SECTION_LENGTH,
-							FW_SECTION_LENGTH);
-	if (ret == FAIL) {
-		pr_err("[burn_fw_ss51]load ss51 firmware section 2 fail.");
-		return FAIL;
+	GTP_DEBUG("[burn_fw_ss51]step5:load ss51 firmware section 2 file data");
+	ret =
+	    gup_load_section_file(fw_ss51, FW_SECTION_LENGTH, FW_SECTION_LENGTH,
+				  SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_ss51]load ss51 firmware section 2 fail.");
+		goto exit_burn_fw_ss51;
 	}
-
 	/* step6:burn ss51 firmware section 2 */
-	pr_debug("step6:burn ss51 firmware section 2");
+	GTP_DEBUG("[burn_fw_ss51]step6:burn ss51 firmware section 2");
 	ret = gup_burn_fw_section(client, fw_ss51, 0xE000, 0x02);
-	if (ret == FAIL) {
-		pr_err("burn ss51 firmware section 2 fail.");
-		return FAIL;
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_ss51]burn ss51 firmware section 2 fail.");
+		goto exit_burn_fw_ss51;
 	}
-
 	/* step7:load ss51 firmware section 3 file data */
-	pr_debug("step7:load ss51 firmware section 3 file data");
-	ret = gup_load_section_file(fw_ss51, 2*FW_SECTION_LENGTH,
-							FW_SECTION_LENGTH);
-	if (ret == FAIL) {
-		pr_err("load ss51 firmware section 3 fail.");
-		return FAIL;
+	GTP_DEBUG("[burn_fw_ss51]step7:load ss51 firmware section 3 file data");
+	ret =
+	    gup_load_section_file(fw_ss51, 2 * FW_SECTION_LENGTH,
+				  FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_ss51]load ss51 firmware section 3 fail.");
+		goto exit_burn_fw_ss51;
 	}
-
 	/* step8:burn ss51 firmware section 3 */
-	pr_debug("step8:burn ss51 firmware section 3");
+	GTP_DEBUG("[burn_fw_ss51]step8:burn ss51 firmware section 3");
 	ret = gup_burn_fw_section(client, fw_ss51, 0xC000, 0x13);
-	if (ret == FAIL) {
-		pr_err("burn ss51 firmware section 3 fail.");
-		return FAIL;
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_ss51]burn ss51 firmware section 3 fail.");
+		goto exit_burn_fw_ss51;
 	}
-
 	/* step9:load ss51 firmware section 4 file data */
-	pr_debug("step9:load ss51 firmware section 4 file data");
-	ret = gup_load_section_file(fw_ss51, 3*FW_SECTION_LENGTH,
-							FW_SECTION_LENGTH);
-	if (ret == FAIL) {
-		pr_err("load ss51 firmware section 4 fail.");
-		return FAIL;
+	GTP_DEBUG("[burn_fw_ss51]step9:load ss51 firmware section 4 file data");
+	ret =
+	    gup_load_section_file(fw_ss51, 3 * FW_SECTION_LENGTH,
+				  FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_ss51]load ss51 firmware section 4 fail.");
+		goto exit_burn_fw_ss51;
 	}
-
 	/* step10:burn ss51 firmware section 4 */
-	pr_debug("step10:burn ss51 firmware section 4");
+	GTP_DEBUG("[burn_fw_ss51]step10:burn ss51 firmware section 4");
 	ret = gup_burn_fw_section(client, fw_ss51, 0xE000, 0x14);
-	if (ret == FAIL) {
-		pr_err("burn ss51 firmware section 4 fail.");
-		return FAIL;
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_ss51]burn ss51 firmware section 4 fail.");
+		goto exit_burn_fw_ss51;
 	}
 
-	return SUCCESS;
+	update_msg.fw_burned_len += (FW_SECTION_LENGTH * 4);
+	GTP_DEBUG("[burn_fw_ss51]Burned length:%d", update_msg.fw_burned_len);
+	ret = SUCCESS;
+
+exit_burn_fw_ss51:
+	kfree(fw_ss51);
+	return ret;
 }
 
 static u8 gup_burn_fw_dsp(struct i2c_client *client)
 {
 	s32 ret = 0;
 	u8 *fw_dsp = NULL;
-	u8  retry = 0;
-	u8  rd_buf[5];
+	u8 retry = 0;
+	u8 rd_buf[5];
 
-	pr_debug("Begin burn dsp firmware.");
+	GTP_INFO("[burn_fw_dsp]Begin burn dsp firmware---->>");
 	/* step1:alloc memory */
-	pr_debug("step1:alloc memory");
+	GTP_DEBUG("[burn_fw_dsp]step1:alloc memory");
 	while (retry++ < 5) {
-		fw_dsp = devm_kzalloc(&client->dev, FW_DSP_LENGTH,
-							GFP_KERNEL);
-		if (fw_dsp == NULL) {
+		fw_dsp = kzalloc(FW_DSP_LENGTH, GFP_KERNEL);
+		if (fw_dsp == NULL)
 			continue;
-		} else  {
-			pr_info("Alloc %dk byte memory success.",
-					(FW_SECTION_LENGTH/1024));
+		else {
+			GTP_DEBUG("[burn_fw_dsp]Alloc %dk byte memory success.",
+				  (FW_SECTION_LENGTH / 1024));
 			break;
 		}
 	}
-	if (retry == 5) {
-		pr_err("Alloc memory fail,exit.");
+	if (retry >= 5) {
+		GTP_ERROR("[burn_fw_dsp]Alloc memory fail,exit.");
 		return FAIL;
 	}
-
 	/* step2:load firmware dsp */
-	pr_debug("step2:load firmware dsp");
-	ret = gup_load_section_file(fw_dsp, 4*FW_SECTION_LENGTH, FW_DSP_LENGTH);
-	if (ret == FAIL) {
-		pr_err("load firmware dsp fail.");
-		return ret;
+	GTP_DEBUG("[burn_fw_dsp]step2:load firmware dsp");
+	ret =
+	    gup_load_section_file(fw_dsp, 4 * FW_SECTION_LENGTH, FW_DSP_LENGTH,
+				  SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_dsp]load firmware dsp fail.");
+		goto exit_burn_fw_dsp;
 	}
-
 	/* step3:select bank3 */
-	pr_debug("step3:select bank3");
+	GTP_DEBUG("[burn_fw_dsp]step3:select bank3");
 	ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x03);
 	if (ret <= 0) {
-		pr_err("select bank3 fail.");
-		return FAIL;
+		GTP_ERROR("[burn_fw_dsp]select bank3 fail.");
+		ret = FAIL;
+		goto exit_burn_fw_dsp;
 	}
-
-	/* Step4:hold ss51 & dsp */
-	pr_debug("step4:hold ss51 & dsp");
+	/* step4:hold ss51 & dsp */
+	GTP_DEBUG("[burn_fw_dsp]step4:hold ss51 & dsp");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
 	if (ret <= 0) {
-		pr_err("hold ss51 & dsp fail.");
-		return FAIL;
+		GTP_ERROR("[burn_fw_dsp]hold ss51 & dsp fail.");
+		ret = FAIL;
+		goto exit_burn_fw_dsp;
 	}
-
 	/* step5:set scramble */
-	pr_debug("step5:set scramble");
+	GTP_DEBUG("[burn_fw_dsp]step5:set scramble");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
 	if (ret <= 0) {
-		pr_err("set scramble fail.");
-		return FAIL;
+		GTP_ERROR("[burn_fw_dsp]set scramble fail.");
+		ret = FAIL;
+		goto exit_burn_fw_dsp;
 	}
-
 	/* step6:release ss51 & dsp */
-	pr_debug("step6:release ss51 & dsp");
+	GTP_DEBUG("[burn_fw_dsp]step6:release ss51 & dsp");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);
 	if (ret <= 0) {
-		pr_err("release ss51 & dsp fail.");
-		return FAIL;
+		GTP_ERROR("[burn_fw_dsp]release ss51 & dsp fail.");
+		ret = FAIL;
+		goto exit_burn_fw_dsp;
 	}
 	/* must delay */
 	msleep(20);
 
 	/* step7:burn 4k dsp firmware */
-	pr_debug("step7:burn 4k dsp firmware");
+	GTP_DEBUG("[burn_fw_dsp]step7:burn 4k dsp firmware");
 	ret = gup_burn_proc(client, fw_dsp, 0x9000, FW_DSP_LENGTH);
-	if (ret == FAIL) {
-		pr_err("[burn_fw_dsp]burn fw_section fail.");
-		return ret;
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_dsp]burn fw_section fail.");
+		goto exit_burn_fw_dsp;
 	}
-
 	/* step8:send burn cmd to move data to flash from sram */
-	pr_debug("step8:send burn cmd to move data to flash from sram");
+	GTP_DEBUG
+	    ("[burn_fw_dsp]step8: move data to flash from sram");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x05);
 	if (ret <= 0) {
-		pr_err("send burn cmd fail.");
-		return ret;
+		GTP_ERROR("[burn_fw_dsp]send burn cmd fail.");
+		goto exit_burn_fw_dsp;
 	}
-	pr_debug("Wait for the burn is complete.");
+	GTP_DEBUG("[burn_fw_dsp]Wait for the burn is complete......");
 	do {
 		ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
 		if (ret <= 0) {
-			pr_err("Get burn state fail");
-			return ret;
+			GTP_ERROR("[burn_fw_dsp]Get burn state fail");
+			goto exit_burn_fw_dsp;
 		}
 		msleep(20);
 	} while (rd_buf[GTP_ADDR_LENGTH]);
 
 	/* step9:recall check 4k dsp firmware */
-	pr_debug("step9:recall check 4k dsp firmware");
+	GTP_DEBUG("[burn_fw_dsp]step9:recall check 4k dsp firmware");
 	ret = gup_recall_check(client, fw_dsp, 0x9000, FW_DSP_LENGTH);
-	if (ret == FAIL) {
-		pr_err("recall check 4k dsp firmware fail.");
-		return ret;
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_dsp]recall check 4k dsp firmware fail.");
+		goto exit_burn_fw_dsp;
 	}
 
-	return SUCCESS;
+	update_msg.fw_burned_len += FW_DSP_LENGTH;
+	GTP_DEBUG("[burn_fw_dsp]Burned length:%d", update_msg.fw_burned_len);
+	ret = SUCCESS;
+
+exit_burn_fw_dsp:
+	kfree(fw_dsp);
+	return ret;
 }
 
 static u8 gup_burn_fw_boot(struct i2c_client *client)
 {
 	s32 ret = 0;
 	u8 *fw_boot = NULL;
-	u8  retry = 0;
-	u8  rd_buf[5];
+	u8 retry = 0;
+	u8 rd_buf[5];
 
-	pr_debug("Begin burn bootloader firmware.");
+	GTP_INFO("[burn_fw_boot]Begin burn bootloader firmware---->>");
 
 	/* step1:Alloc memory */
-	pr_debug("step1:Alloc memory");
+	GTP_DEBUG("[burn_fw_boot]step1:Alloc memory");
 	while (retry++ < 5) {
-		fw_boot = devm_kzalloc(&client->dev, FW_BOOT_LENGTH,
-							GFP_KERNEL);
-		if (fw_boot == NULL) {
+		fw_boot = kzalloc(FW_BOOT_LENGTH, GFP_KERNEL);
+		if (fw_boot == NULL)
 			continue;
-		} else {
-			pr_info("Alloc %dk byte memory success.",
-						(FW_BOOT_LENGTH/1024));
+		else {
+			GTP_DEBUG
+			    ("[burn_fw_boot]Alloc %dk byte memory success.",
+			     (FW_BOOT_LENGTH / 1024));
 			break;
 		}
 	}
-	if (retry == 5) {
-		pr_err("Alloc memory fail,exit.");
+	if (retry >= 5) {
+		GTP_ERROR("[burn_fw_boot]Alloc memory fail,exit.");
 		return FAIL;
 	}
-
 	/* step2:load firmware bootloader */
-	pr_debug("step2:load firmware bootloader");
-	ret = gup_load_section_file(fw_boot, (4 * FW_SECTION_LENGTH +
-				FW_DSP_LENGTH), FW_BOOT_LENGTH);
-	if (ret == FAIL) {
-		pr_err("load firmware dsp fail.");
-		return ret;
+	GTP_DEBUG("[burn_fw_boot]step2:load firmware bootloader");
+	ret =
+	    gup_load_section_file(fw_boot,
+				  (4 * FW_SECTION_LENGTH + FW_DSP_LENGTH),
+				  FW_BOOT_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_boot]load firmware bootcode fail.");
+		goto exit_burn_fw_boot;
 	}
-
 	/* step3:hold ss51 & dsp */
-	pr_debug("step3:hold ss51 & dsp");
+	GTP_DEBUG("[burn_fw_boot]step3:hold ss51 & dsp");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
 	if (ret <= 0) {
-		pr_err("hold ss51 & dsp fail.");
-		return FAIL;
+		GTP_ERROR("[burn_fw_boot]hold ss51 & dsp fail.");
+		ret = FAIL;
+		goto exit_burn_fw_boot;
 	}
-
 	/* step4:set scramble */
-	pr_debug("step4:set scramble");
+	GTP_DEBUG("[burn_fw_boot]step4:set scramble");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
 	if (ret <= 0) {
-		pr_err("set scramble fail.");
-		return FAIL;
+		GTP_ERROR("[burn_fw_boot]set scramble fail.");
+		ret = FAIL;
+		goto exit_burn_fw_boot;
 	}
-
-	/* step5:release ss51 & dsp */
-	pr_debug("step5:release ss51 & dsp");
+	/* step5:hold ss51 & release dsp */
+	GTP_DEBUG("[burn_fw_boot]step5:hold ss51 & release dsp");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);
 	if (ret <= 0) {
-		pr_err("release ss51 & dsp fail.");
-		return FAIL;
+		GTP_ERROR("[burn_fw_boot]release ss51 & dsp fail.");
+		ret = FAIL;
+		goto exit_burn_fw_boot;
 	}
 	/* must delay */
 	msleep(20);
 
 	/* step6:select bank3 */
-	pr_debug("step6:select bank3");
+	GTP_DEBUG("[burn_fw_boot]step6:select bank3");
 	ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x03);
 	if (ret <= 0) {
-		pr_err("select bank3 fail.");
-		return FAIL;
+		GTP_ERROR("[burn_fw_boot]select bank3 fail.");
+		ret = FAIL;
+		goto exit_burn_fw_boot;
 	}
-
-	/* step7:burn 2k bootloader firmware */
-	pr_debug("step7:burn 2k bootloader firmware");
+	/* step6:burn 2k bootloader firmware */
+	GTP_DEBUG("[burn_fw_boot]step6:burn 2k bootloader firmware");
 	ret = gup_burn_proc(client, fw_boot, 0x9000, FW_BOOT_LENGTH);
-	if (ret == FAIL) {
-		pr_err("burn fw_section fail.");
-		return ret;
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_boot]burn fw_boot fail.");
+		goto exit_burn_fw_boot;
 	}
-
 	/* step7:send burn cmd to move data to flash from sram */
-	pr_debug("step7:send burn cmd to flash data from sram");
+	GTP_DEBUG
+	    ("[burn_fw_boot]step7: move data to flash from sram");
 	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x06);
 	if (ret <= 0) {
-		pr_err("send burn cmd fail.");
-		return ret;
+		GTP_ERROR("[burn_fw_boot]send burn cmd fail.");
+		goto exit_burn_fw_boot;
 	}
-	pr_debug("Wait for the burn is complete.");
+	GTP_DEBUG("[burn_fw_boot]Wait for the burn is complete......");
 	do {
 		ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
 		if (ret <= 0) {
-			pr_err("Get burn state fail");
-			return ret;
+			GTP_ERROR("[burn_fw_boot]Get burn state fail");
+			goto exit_burn_fw_boot;
 		}
 		msleep(20);
 	} while (rd_buf[GTP_ADDR_LENGTH]);
 
 	/* step8:recall check 2k bootloader firmware */
-	pr_debug("step8:recall check 2k bootloader firmware");
+	GTP_DEBUG("[burn_fw_boot]step8:recall check 2k bootloader firmware");
 	ret = gup_recall_check(client, fw_boot, 0x9000, FW_BOOT_LENGTH);
-	if (ret == FAIL) {
-		pr_err("recall check 4k dsp firmware fail.");
-		return ret;
+	if (FAIL == ret) {
+		GTP_ERROR
+		    ("[burn_fw_boot]recall check 2k bootcode firmware fail.");
+		goto exit_burn_fw_boot;
 	}
 
-	/* step9:enable download DSP code  */
-	pr_debug("step9:enable download DSP code ");
-	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x99);
+	update_msg.fw_burned_len += FW_BOOT_LENGTH;
+	GTP_DEBUG("[burn_fw_boot]Burned length:%d", update_msg.fw_burned_len);
+	ret = SUCCESS;
+
+exit_burn_fw_boot:
+	kfree(fw_boot);
+	return ret;
+}
+
+static u8 gup_burn_fw_boot_isp(struct i2c_client *client)
+{
+	s32 ret = 0;
+	u8 *fw_boot_isp = NULL;
+	u8 retry = 0;
+	u8 rd_buf[5];
+
+	if (update_msg.fw_burned_len >= update_msg.fw_total_len) {
+		GTP_DEBUG("No need to upgrade the boot_isp code!");
+		return SUCCESS;
+	}
+	GTP_INFO("[burn_fw_boot_isp]Begin burn boot_isp firmware---->>");
+
+	/* step1:Alloc memory */
+	GTP_DEBUG("[burn_fw_boot_isp]step1:Alloc memory");
+	while (retry++ < 5) {
+		fw_boot_isp = kzalloc(FW_BOOT_ISP_LENGTH, GFP_KERNEL);
+		if (fw_boot_isp == NULL)
+			continue;
+		else {
+			GTP_DEBUG
+			    ("[burn_fw_boot_isp]Alloc %dk byte memory success.",
+			     (FW_BOOT_ISP_LENGTH / 1024));
+			break;
+		}
+	}
+	if (retry >= 5) {
+		GTP_ERROR("[burn_fw_boot_isp]Alloc memory fail,exit.");
+		return FAIL;
+	}
+	/* step2:load firmware bootloader */
+	GTP_DEBUG("[burn_fw_boot_isp]step2:load firmware bootloader isp");
+	ret =
+	    gup_load_section_file(fw_boot_isp,
+				  (update_msg.fw_burned_len -
+				   FW_DSP_ISP_LENGTH), FW_BOOT_ISP_LENGTH,
+				  SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_boot_isp]load firmware boot_isp fail.");
+		goto exit_burn_fw_boot_isp;
+	}
+	/* step3:hold ss51 & dsp */
+	GTP_DEBUG("[burn_fw_boot_isp]step3:hold ss51 & dsp");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
+	if (ret <= 0) {
+		GTP_ERROR("[burn_fw_boot_isp]hold ss51 & dsp fail.");
+		ret = FAIL;
+		goto exit_burn_fw_boot_isp;
+	}
+	/* step4:set scramble */
+	GTP_DEBUG("[burn_fw_boot_isp]step4:set scramble");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
+	if (ret <= 0) {
+		GTP_ERROR("[burn_fw_boot_isp]set scramble fail.");
+		ret = FAIL;
+		goto exit_burn_fw_boot_isp;
+	}
+	/* step5:hold ss51 & release dsp */
+	GTP_DEBUG("[burn_fw_boot_isp]step5:hold ss51 & release dsp");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);
+	if (ret <= 0) {
+		GTP_ERROR("[burn_fw_boot_isp]release ss51 & dsp fail.");
+		ret = FAIL;
+		goto exit_burn_fw_boot_isp;
+	}
+	/* must delay */
+	msleep(20);
+
+	/* step6:select bank3 */
+	GTP_DEBUG("[burn_fw_boot_isp]step6:select bank3");
+	ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x03);
+	if (ret <= 0) {
+		GTP_ERROR("[burn_fw_boot_isp]select bank3 fail.");
+		ret = FAIL;
+		goto exit_burn_fw_boot_isp;
+	}
+	/* step7:burn 2k bootload_isp firmware */
+	GTP_DEBUG("[burn_fw_boot_isp]step7:burn 2k bootloader firmware");
+	ret = gup_burn_proc(client, fw_boot_isp, 0x9000, FW_BOOT_ISP_LENGTH);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_boot_isp]burn fw_section fail.");
+		goto exit_burn_fw_boot_isp;
+	}
+	/* step7:send burn cmd to move data to flash from sram */
+	GTP_DEBUG("[burn_fw_boot_isp]step8: move data to flash from sram");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x07);
+	if (ret <= 0) {
+		GTP_ERROR("[burn_fw_boot_isp]send burn cmd fail.");
+		goto exit_burn_fw_boot_isp;
+	}
+	GTP_DEBUG("[burn_fw_boot_isp]Wait for the burn is complete......");
+	do {
+		ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
+		if (ret <= 0) {
+			GTP_ERROR("[burn_fw_boot_isp]Get burn state fail");
+			goto exit_burn_fw_boot_isp;
+		}
+		msleep(20);
+	} while (rd_buf[GTP_ADDR_LENGTH]);
+
+	/* step8:recall check 2k bootload_isp firmware */
+	GTP_DEBUG
+	    ("[burn_fw_boot_isp]step9:recall check 2k bootloader firmware");
+	ret = gup_recall_check(client, fw_boot_isp, 0x9000, FW_BOOT_ISP_LENGTH);
+	if (FAIL == ret) {
+		GTP_ERROR
+		    ("[burn_fw_boot_isp]check bootcode_isp firmware fail.");
+		goto exit_burn_fw_boot_isp;
+	}
+
+	update_msg.fw_burned_len += FW_BOOT_ISP_LENGTH;
+	GTP_DEBUG("[burn_fw_boot_isp]Burned length:%d",
+		  update_msg.fw_burned_len);
+	ret = SUCCESS;
+
+exit_burn_fw_boot_isp:
+	kfree(fw_boot_isp);
+	return ret;
+}
+
+static u8 gup_burn_fw_link(struct i2c_client *client)
+{
+	s32 ret = 0;
+	u8 *fw_link = NULL;
+	u8 retry = 0;
+	u32 offset;
+
+	if (update_msg.fw_burned_len >= update_msg.fw_total_len) {
+		GTP_DEBUG("No need to upgrade the link code!");
+		return SUCCESS;
+	}
+	GTP_INFO("[burn_fw_link]Begin burn link firmware---->>");
+
+	/* step1:Alloc memory */
+	GTP_DEBUG("[burn_fw_link]step1:Alloc memory");
+	while (retry++ < 5) {
+		fw_link = kzalloc(FW_SECTION_LENGTH, GFP_KERNEL);
+		if (fw_link == NULL)
+			continue;
+		else {
+			GTP_DEBUG
+			    ("[burn_fw_link]Alloc %dk byte memory success.",
+			     (FW_SECTION_LENGTH / 1024));
+			break;
+		}
+	}
+	if (retry >= 5) {
+		GTP_ERROR("[burn_fw_link]Alloc memory fail,exit.");
+		return FAIL;
+	}
+	/* step2:load firmware link section 1 */
+	GTP_DEBUG("[burn_fw_link]step2:load firmware link section 1");
+	offset = update_msg.fw_burned_len - FW_DSP_ISP_LENGTH;
+	ret =
+	    gup_load_section_file(fw_link, offset, FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_link]load firmware link section 1 fail.");
+		goto exit_burn_fw_link;
+	}
+	/* step3:burn link firmware section 1 */
+	GTP_DEBUG("[burn_fw_link]step3:burn link firmware section 1");
+	ret =
+	    gup_burn_fw_gwake_section(client, fw_link, 0x9000,
+				      FW_SECTION_LENGTH, 0x38);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_link]burn link firmware section 1 fail.");
+		goto exit_burn_fw_link;
+	}
+	/* step4:load link firmware section 2 file data */
+	GTP_DEBUG("[burn_fw_link]step4:load link firmware section 2 file data");
+	offset += FW_SECTION_LENGTH;
+	ret =
+	    gup_load_section_file(fw_link, offset,
+				  FW_GLINK_LENGTH - FW_SECTION_LENGTH,
+				  SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_link]load link firmware section 2 fail.");
+		goto exit_burn_fw_link;
+	}
+	/* step5:burn link firmware section 2 */
+	GTP_DEBUG("[burn_fw_link]step4:burn link firmware section 2");
+	ret =
+	    gup_burn_fw_gwake_section(client, fw_link, 0x9000,
+				      FW_GLINK_LENGTH - FW_SECTION_LENGTH,
+				      0x39);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_link]burn link firmware section 2 fail.");
+		goto exit_burn_fw_link;
+	}
+
+	update_msg.fw_burned_len += FW_GLINK_LENGTH;
+	GTP_DEBUG("[burn_fw_link]Burned length:%d", update_msg.fw_burned_len);
+	ret = SUCCESS;
+
+exit_burn_fw_link:
+	kfree(fw_link);
+	return ret;
+}
+
+static u8 gup_burn_fw_gwake_section(struct i2c_client *client, u8 *fw_section,
+				    u16 start_addr, u32 len, u8 bank_cmd)
+{
+	s32 ret = 0;
+	u8 rd_buf[5];
+
+	/* step1:hold ss51 & dsp */
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
+	if (ret <= 0) {
+		GTP_ERROR("[burn_fw_app_section]hold ss51 & dsp fail.");
+		return FAIL;
+	}
+	/* step2:set scramble */
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
+	if (ret <= 0) {
+		GTP_ERROR("[burn_fw_app_section]set scramble fail.");
+		return FAIL;
+	}
+	/* step3:hold ss51 & release dsp */
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x04);
 	if (ret <= 0) {
-		pr_err("enable download DSP code fail.");
+		GTP_ERROR("[burn_fw_app_section]hold ss51 & release dsp fail.");
 		return FAIL;
 	}
+	/* must delay */
+	msleep(20);
 
-	/* step10:release ss51 & hold dsp */
-	pr_debug("step10:release ss51 & hold dsp");
-	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x08);
+	/* step4:select bank */
+	ret =
+	    gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK,
+			   (bank_cmd >> 4) & 0x0F);
 	if (ret <= 0) {
-		pr_err("release ss51 & hold dsp fail.");
+		GTP_ERROR("[burn_fw_section]select bank %d fail.",
+			  (bank_cmd >> 4) & 0x0F);
+		return FAIL;
+	}
+	/* step5:burn fw section */
+	ret = gup_burn_proc(client, fw_section, start_addr, len);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_app_section]burn fw_section fail.");
+		return FAIL;
+	}
+	/* step6:send burn cmd to move data to flash from sram */
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, bank_cmd & 0x0F);
+	if (ret <= 0) {
+		GTP_ERROR("[burn_fw_app_section]send burn cmd fail.");
+		return FAIL;
+	}
+	GTP_DEBUG("[burn_fw_section]Wait for the burn is complete......");
+	do {
+		ret = gup_get_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, rd_buf, 1);
+		if (ret <= 0) {
+			GTP_ERROR("[burn_fw_app_section]Get burn state fail");
+			return FAIL;
+		}
+		msleep(20);
+	} while (rd_buf[GTP_ADDR_LENGTH]);
+
+	/* step7:recall fw section */
+	ret = gup_recall_check(client, fw_section, start_addr, len);
+	if (FAIL == ret) {
+		GTP_ERROR
+		    ("[burn_fw_app_section]recall check %dk firmware fail.",
+		     len / 1024);
 		return FAIL;
 	}
 
 	return SUCCESS;
 }
 
-s32 gup_update_proc(void *dir)
+static u8 gup_burn_fw_gwake(struct i2c_client *client)
 {
+	u8 *fw_gwake = NULL;
+	u8 retry = 0;
 	s32 ret = 0;
+	u16 start_index;
+
+	if (update_msg.fw_burned_len >= update_msg.fw_total_len) {
+		GTP_DEBUG("No need to upgrade the gwake code!");
+		return SUCCESS;
+	}
+	start_index = update_msg.fw_burned_len - FW_DSP_ISP_LENGTH;
+	GTP_INFO("[burn_fw_gwake]Begin burn gwake firmware---->>");
+
+	/* step1:alloc memory */
+	GTP_DEBUG("[burn_fw_gwake]step1:alloc memory");
+	while (retry++ < 5) {
+		fw_gwake = kzalloc(FW_SECTION_LENGTH, GFP_KERNEL);
+		if (fw_gwake == NULL)
+			continue;
+		else {
+			GTP_DEBUG
+			    ("[burn_fw_gwake]Alloc %dk byte memory success.",
+			     (FW_SECTION_LENGTH / 1024));
+			break;
+		}
+	}
+	if (retry >= 5) {
+		GTP_ERROR("[burn_fw_gwake]Alloc memory fail,exit.");
+		return FAIL;
+	}
+	/* step2:load app_code firmware section 1 file data */
+	GTP_DEBUG
+	    ("[burn_fw_gwake]step2:load app_code firmware section 1 file data");
+	ret =
+	    gup_load_section_file(fw_gwake, start_index, FW_SECTION_LENGTH,
+				  SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR
+		    ("[burn_fw_gwake]load app_code firmware section 1 fail.");
+		goto exit_burn_fw_gwake;
+	}
+	/* step3:burn app_code firmware section 1 */
+	GTP_DEBUG("[burn_fw_gwake]step3:burn app_code firmware section 1");
+	ret =
+	    gup_burn_fw_gwake_section(client, fw_gwake, 0x9000,
+				      FW_SECTION_LENGTH, 0x3A);
+	if (FAIL == ret) {
+		GTP_ERROR
+		    ("[burn_fw_gwake]burn app_code firmware section 1 fail.");
+		goto exit_burn_fw_gwake;
+	}
+	/* step5:load app_code firmware section 2 file data */
+	GTP_DEBUG
+	    ("[burn_fw_gwake]step5:load app_code firmware section 2 file data");
+	ret =
+	    gup_load_section_file(fw_gwake, start_index + FW_SECTION_LENGTH,
+				  FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR
+		    ("[burn_fw_gwake]load app_code firmware section 2 fail.");
+		goto exit_burn_fw_gwake;
+	}
+	/* step6:burn app_code firmware section 2 */
+	GTP_DEBUG("[burn_fw_gwake]step6:burn app_code firmware section 2");
+	ret =
+	    gup_burn_fw_gwake_section(client, fw_gwake, 0x9000,
+				      FW_SECTION_LENGTH, 0x3B);
+	if (FAIL == ret) {
+		GTP_ERROR
+		    ("[burn_fw_gwake]burn app_code firmware section 2 fail.");
+		goto exit_burn_fw_gwake;
+	}
+	/* step7:load app_code firmware section 3 file data */
+	GTP_DEBUG
+	    ("[burn_fw_gwake]step7:load app_code firmware section 3 file data");
+	ret =
+	    gup_load_section_file(fw_gwake, start_index + 2 * FW_SECTION_LENGTH,
+				  FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR
+		    ("[burn_fw_gwake]load app_code firmware section 3 fail.");
+		goto exit_burn_fw_gwake;
+	}
+	/* step8:burn app_code firmware section 3 */
+	GTP_DEBUG("[burn_fw_gwake]step8:burn app_code firmware section 3");
+	ret =
+	    gup_burn_fw_gwake_section(client, fw_gwake, 0x9000,
+				      FW_SECTION_LENGTH, 0x3C);
+	if (FAIL == ret) {
+		GTP_ERROR
+		    ("[burn_fw_gwake]burn app_code firmware section 3 fail.");
+		goto exit_burn_fw_gwake;
+	}
+	/* step9:load app_code firmware section 4 file data */
+	GTP_DEBUG
+	    ("[burn_fw_gwake]step9:load app_code firmware section 4 file data");
+	ret =
+	    gup_load_section_file(fw_gwake, start_index + 3 * FW_SECTION_LENGTH,
+				  FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR
+		    ("[burn_fw_gwake]load app_code firmware section 4 fail.");
+		goto exit_burn_fw_gwake;
+	}
+	/* step10:burn app_code firmware section 4 */
+	GTP_DEBUG("[burn_fw_gwake]step10:burn app_code firmware section 4");
+	ret =
+	    gup_burn_fw_gwake_section(client, fw_gwake, 0x9000,
+				      FW_SECTION_LENGTH, 0x3D);
+	if (FAIL == ret) {
+		GTP_ERROR
+		    ("[burn_fw_gwake]burn app_code firmware section 4 fail.");
+		goto exit_burn_fw_gwake;
+	}
+
+	update_msg.fw_burned_len += FW_GWAKE_LENGTH;
+	GTP_DEBUG("[burn_fw_gwake]Burned length:%d", update_msg.fw_burned_len);
+	ret = SUCCESS;
+
+exit_burn_fw_gwake:
+	kfree(fw_gwake);
+	return ret;
+}
+
+static u8 gup_burn_fw_finish(struct i2c_client *client)
+{
+	u8 *fw_ss51 = NULL;
 	u8 retry = 0;
-	struct st_fw_head fw_head;
-	struct goodix_ts_data *ts = NULL;
+	s32 ret = 0;
+
+	GTP_INFO("[burn_fw_finish]burn first 8K of ss51 and finish update.");
+	/* step1:alloc memory */
+	GTP_DEBUG("[burn_fw_finish]step1:alloc memory");
+	while (retry++ < 5) {
+		fw_ss51 = kzalloc(FW_SECTION_LENGTH, GFP_KERNEL);
+		if (fw_ss51 == NULL)
+			continue;
+		else {
+			GTP_DEBUG
+			    ("[burn_fw_finish]Alloc %dk byte memory success.",
+			     (FW_SECTION_LENGTH / 1024));
+			break;
+		}
+	}
+	if (retry >= 5) {
+		GTP_ERROR("[burn_fw_finish]Alloc memory fail,exit.");
+		return FAIL;
+	}
 
-	pr_debug("Begin update.");
+	GTP_DEBUG("[burn_fw_finish]step2: burn ss51 first 8K.");
+	ret = gup_load_section_file(fw_ss51, 0, FW_SECTION_LENGTH, SEEK_SET);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_finish]load ss51 firmware section 1 fail.");
+		goto exit_burn_fw_finish;
+	}
 
-	if (!i2c_connect_client) {
-		pr_err("No i2c connect client for %s\n", __func__);
-		return -EIO;
+	GTP_DEBUG("[burn_fw_finish]step3:clear control flag");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x00);
+	if (ret <= 0) {
+		GTP_ERROR("[burn_fw_finish]clear control flag fail.");
+		goto exit_burn_fw_finish;
 	}
 
-	show_len = 1;
-	total_len = 100;
+	GTP_DEBUG("[burn_fw_finish]step4:burn ss51 firmware section 1");
+	ret = gup_burn_fw_section(client, fw_ss51, 0xC000, 0x01);
+	if (FAIL == ret) {
+		GTP_ERROR("[burn_fw_finish]burn ss51 firmware section 1 fail.");
+		goto exit_burn_fw_finish;
+	}
+	/* step11:enable download DSP code */
+	GTP_DEBUG("[burn_fw_finish]step5:enable download DSP code ");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x99);
+	if (ret <= 0) {
+		GTP_ERROR("[burn_fw_finish]enable download DSP code fail.");
+		goto exit_burn_fw_finish;
+	}
+	/* step12:release ss51 & hold dsp */
+	GTP_DEBUG("[burn_fw_finish]step6:release ss51 & hold dsp");
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x08);
+	if (ret <= 0) {
+		GTP_ERROR("[burn_fw_finish]release ss51 & hold dsp fail.");
+		goto exit_burn_fw_finish;
+	}
+
+	kfree(fw_ss51);
+	return SUCCESS;
+
+exit_burn_fw_finish:
+	kfree(fw_ss51);
+	return FAIL;
+}
+
+s32 gup_update_proc(void *dir)
+{
+	s32 ret = 0;
+	s32 update_ret = FAIL;
+	u8 retry = 0;
+	struct st_fw_head fw_head;
+	struct goodix_ts_data *ts = NULL;
+
+	GTP_DEBUG("[update_proc]Begin update ......");
 
 	ts = i2c_get_clientdata(i2c_connect_client);
 
+#if GTP_AUTO_UPDATE
 	if (searching_file) {
-		/* exit .bin update file searching  */
-		searching_file = 0;
-		pr_info("Exiting searching .bin update file.");
-		/* wait for auto update quitted completely */
-		while ((show_len != 200) && (show_len != 100))
+		u8 timeout = 0;
+		searching_file = 0;	/* exit .bin update file searching */
+		GTP_INFO("Exiting searching .bin update file...");
+		while ((show_len != 200) && (show_len != 100)
+			&& (timeout++ < 100))
 			msleep(100);
 	}
+#endif
 
-	ret = gup_check_update_file(i2c_connect_client, &fw_head, (u8 *)dir);
-	if (ret == FAIL) {
-		pr_err("check update file fail.");
+	show_len = 1;
+	total_len = 100;
+
+#if GTP_COMPATIBLE_MODE
+	if (CHIP_TYPE_GT9F == ts->chip_type)
+		return gup_fw_download_proc(dir, GTP_FL_FW_BURN);
+#endif
+
+	update_msg.file = NULL;
+	ret = gup_check_update_file(i2c_connect_client, &fw_head, (u8 *) dir);
+	if (FAIL == ret) {
+		GTP_ERROR("[update_proc]check update file fail.");
 		goto file_fail;
 	}
 
-	/* gtp_reset_guitar(i2c_connect_client, 20); */
 	ret = gup_get_ic_fw_msg(i2c_connect_client);
-	if (ret == FAIL) {
-		pr_err("get ic message fail.");
+	if (FAIL == ret) {
+		GTP_ERROR("[update_proc]get ic message fail.");
 		goto file_fail;
 	}
 
-	if (ts->force_update) {
-		dev_dbg(&ts->client->dev, "Enter force update.");
-	} else {
-		ret = gup_enter_update_judge(ts->client, &fw_head);
-		if (ret == FAIL) {
-			dev_err(&ts->client->dev,
-					"Check *.bin file fail.");
-			goto file_fail;
-		}
+	ret = gup_enter_update_judge(&fw_head);
+	if (FAIL == ret) {
+		GTP_ERROR("[update_proc]Check *.bin file fail.");
+		goto file_fail;
 	}
 
 	ts->enter_update = 1;
@@ -1449,104 +2129,1107 @@ s32 gup_update_proc(void *dir)
 	gtp_esd_switch(ts->client, SWITCH_OFF);
 #endif
 	ret = gup_enter_update_mode(i2c_connect_client);
-	if (ret == FAIL) {
-		pr_err("enter update mode fail.");
+	if (FAIL == ret) {
+		GTP_ERROR("[update_proc]enter update mode fail.");
 		goto update_fail;
 	}
 
 	while (retry++ < 5) {
 		show_len = 10;
 		total_len = 100;
+		update_msg.fw_burned_len = 0;
 		ret = gup_burn_dsp_isp(i2c_connect_client);
-		if (ret == FAIL) {
-			pr_err("burn dsp isp fail.");
+		if (FAIL == ret) {
+			GTP_ERROR("[update_proc]burn dsp isp fail.");
 			continue;
 		}
 
-		show_len += 10;
+		show_len = 20;
 		ret = gup_burn_fw_ss51(i2c_connect_client);
-		if (ret == FAIL) {
-			pr_err("burn ss51 firmware fail.");
+		if (FAIL == ret) {
+			GTP_ERROR("[update_proc]burn ss51 firmware fail.");
 			continue;
 		}
 
-		show_len += 40;
+		show_len = 30;
 		ret = gup_burn_fw_dsp(i2c_connect_client);
-		if (ret == FAIL) {
-			pr_err("burn dsp firmware fail.");
+		if (FAIL == ret) {
+			GTP_ERROR("[update_proc]burn dsp firmware fail.");
 			continue;
 		}
 
-		show_len += 20;
+		show_len = 40;
 		ret = gup_burn_fw_boot(i2c_connect_client);
-		if (ret == FAIL) {
-			pr_err("burn bootloader fw fail.");
+		if (FAIL == ret) {
+			GTP_ERROR
+			    ("[update_proc]burn bootloader firmware fail.");
+			continue;
+		}
+		show_len = 50;
+
+		ret = gup_burn_fw_boot_isp(i2c_connect_client);
+		if (FAIL == ret) {
+			GTP_ERROR("[update_proc]burn boot_isp firmware fail.");
+			continue;
+		}
+
+		show_len = 60;
+		ret = gup_burn_fw_link(i2c_connect_client);
+		if (FAIL == ret) {
+			GTP_ERROR("[update_proc]burn link firmware fail.");
+			continue;
+		}
+
+		show_len = 70;
+		ret = gup_burn_fw_gwake(i2c_connect_client);
+		if (FAIL == ret) {
+			GTP_ERROR("[update_proc]burn app_code firmware fail.");
+			continue;
+		}
+		show_len = 80;
+
+		ret = gup_burn_fw_finish(i2c_connect_client);
+		if (FAIL == ret) {
+			GTP_ERROR("[update_proc]burn finish fail.");
 			continue;
 		}
-		show_len += 10;
-		pr_info("UPDATE SUCCESS.");
+		show_len = 90;
+		GTP_INFO("[update_proc]UPDATE SUCCESS.");
+		retry = 0;
 		break;
 	}
+
 	if (retry >= 5) {
-		pr_err("retry timeout,UPDATE FAIL.");
-		goto update_fail;
-	}
+		GTP_ERROR("[update_proc]retry timeout,UPDATE FAIL.");
+		update_ret = FAIL;
+	} else
+		update_ret = SUCCESS;
 
-	pr_debug("leave update mode.");
-	gup_leave_update_mode(i2c_connect_client);
+update_fail:
+	GTP_DEBUG("[update_proc]leave update mode.");
+	gup_leave_update_mode();
 
 	msleep(100);
 
-	if (ts->fw_error) {
-		pr_info("firmware error auto update, resent config!");
-		gup_init_panel(ts);
+	if (SUCCESS == update_ret) {
+		if (ts->fw_error) {
+			GTP_INFO("firmware error auto update, resent config!");
+			gup_init_panel(ts);
+		} else {
+			GTP_DEBUG("[update_proc]send config.");
+			ret = gtp_send_cfg(i2c_connect_client);
+			if (ret < 0)
+				GTP_ERROR("[update_proc]send config fail.");
+			else
+				msleep(100);
+		}
 	}
-	show_len = 100;
-	total_len = 100;
 	ts->enter_update = 0;
 	gtp_irq_enable(ts);
 
 #if GTP_ESD_PROTECT
 	gtp_esd_switch(ts->client, SWITCH_ON);
 #endif
-	if (update_msg.need_free) {
-		devm_kfree(&ts->client->dev, update_msg.fw_data);
-		update_msg.need_free = false;
-	}
-
-	return SUCCESS;
-
-update_fail:
-	ts->enter_update = 0;
-	gtp_irq_enable(ts);
 
-#if GTP_ESD_PROTECT
-	gtp_esd_switch(ts->client, SWITCH_ON);
+file_fail:
+	if (update_msg.file && !IS_ERR(update_msg.file)) {
+		if (update_msg.old_fs)
+			set_fs(update_msg.old_fs);
+		filp_close(update_msg.file, NULL);
+	}
+#if (GTP_AUTO_UPDATE && GTP_AUTO_UPDATE_CFG && GTP_HEADER_FW_UPDATE)
+	if (NULL == dir) {
+		gup_search_file(AUTO_SEARCH_CFG);
+		if (got_file_flag & CFG_FILE_READY) {
+			ret = gup_update_config(i2c_connect_client);
+			if (ret <= 0)
+				GTP_ERROR("Update config failed.");
+			_CLOSE_FILE(update_msg.cfg_file);
+			msleep(500);
+		}
+	}
 #endif
 
-file_fail:
-	show_len = 200;
 	total_len = 100;
-	if (update_msg.need_free) {
-		devm_kfree(&ts->client->dev, update_msg.fw_data);
-		update_msg.need_free = false;
+	if (SUCCESS == update_ret) {
+		show_len = 100;
+		return SUCCESS;
+	} else {
+		show_len = 200;
+		return FAIL;
 	}
-	return FAIL;
 }
 
-static void gup_update_work(struct work_struct *work)
+#if GTP_AUTO_UPDATE
+u8 gup_init_update_proc(struct goodix_ts_data *ts)
 {
-	if (gup_update_proc(NULL) == FAIL)
-		pr_err("Goodix update work fail!\n");
+	struct task_struct *thread = NULL;
+
+	GTP_INFO("Ready to run update thread.");
+
+#if GTP_COMPATIBLE_MODE
+	if (CHIP_TYPE_GT9F == ts->chip_type)
+		thread = kthread_run(gup_update_proc, "update", "fl update");
+	else
+#endif
+		thread =
+		    kthread_run(gup_update_proc, (void *)NULL, "guitar_update");
+	if (IS_ERR(thread)) {
+		GTP_ERROR("Failed to create update thread.\n");
+		return -EINVAL;
+	}
+
+	return 0;
 }
+#endif
 
-u8 gup_init_update_proc(struct goodix_ts_data *ts)
+/************************** For GT9XXF Start ***********************/
+#define FW_DOWNLOAD_LENGTH           0x4000
+#define FW_SS51_SECTION_LEN          0x2000	/* 4 section, each 8k */
+#define FL_PACK_SIZE                 250
+#define GUP_FW_CHK_SIZE              FL_PACK_SIZE
+
+#define FL_UPDATE_PATH              "/data/_fl_update_.bin"
+#define FL_UPDATE_PATH_SD           "/sdcard/_fl_update_.bin"
+/* for clk cal */
+#define PULSE_LENGTH      (200)
+#define INIT_CLK_DAC      (50)
+#define MAX_CLK_DAC       (120)
+#define CLK_AVG_TIME      (1)
+#define MILLION           1000000
+
+#define _wRW_MISCTL__RG_DMY                       0x4282
+#define _bRW_MISCTL__RG_OSC_CALIB                 0x4268
+#define _fRW_MISCTL__GIO0                         0x41e9
+#define _fRW_MISCTL__GIO1                         0x41ed
+#define _fRW_MISCTL__GIO2                         0x41f1
+#define _fRW_MISCTL__GIO3                         0x41f5
+#define _fRW_MISCTL__GIO4                         0x41f9
+#define _fRW_MISCTL__GIO5                         0x41fd
+#define _fRW_MISCTL__GIO6                         0x4201
+#define _fRW_MISCTL__GIO7                         0x4205
+#define _fRW_MISCTL__GIO8                         0x4209
+#define _fRW_MISCTL__GIO9                         0x420d
+#define _fRW_MISCTL__MEA                          0x41a0
+#define _bRW_MISCTL__MEA_MODE                     0x41a1
+#define _wRW_MISCTL__MEA_MAX_NUM                  0x41a4
+#define _dRO_MISCTL__MEA_VAL                      0x41b0
+#define _bRW_MISCTL__MEA_SRCSEL                   0x41a3
+#define _bRO_MISCTL__MEA_RDY                      0x41a8
+#define _rRW_MISCTL__ANA_RXADC_B0_                0x4250
+#define _bRW_MISCTL__RG_LDO_A18_PWD               0x426f
+#define _bRW_MISCTL__RG_BG_PWD                    0x426a
+#define _bRW_MISCTL__RG_CLKGEN_PWD                0x4269
+#define _fRW_MISCTL__RG_RXADC_PWD                 0x426a
+#define _bRW_MISCTL__OSC_CK_SEL                   0x4030
+#define _rRW_MISCTL_RG_DMY83                      0x4283
+#define _rRW_MISCTL__GIO1CTL_B2_                  0x41ee
+#define _rRW_MISCTL__GIO1CTL_B1_                  0x41ed
+
+#if GTP_COMPATIBLE_MODE
+
+u8 i2c_opr_buf[GTP_ADDR_LENGTH + FL_PACK_SIZE] = { 0 };
+u8 chk_cmp_buf[FL_PACK_SIZE] = { 0 };
+
+static u8 gup_download_fw_dsp(struct i2c_client *client, u8 dwn_mode);
+static s32 gup_burn_fw_proc(struct i2c_client *client, u16 start_addr,
+			    s32 start_index, s32 burn_len);
+static s32 gup_check_and_repair(struct i2c_client *client, u16 start_addr,
+				s32 start_index, s32 chk_len);
+
+u8 gup_check_fs_mounted(char *path_name)
 {
-	dev_dbg(&ts->client->dev, "Ready to run update work.");
+	struct path root_path;
+	struct path path;
+	int err;
+
+	err = kern_path("/", LOOKUP_FOLLOW, &root_path);
+	if (err) {
+		GTP_DEBUG("\"/\" NOT Mounted: %d", err);
+		return FAIL;
+	}
 
-	INIT_DELAYED_WORK(&ts->goodix_update_work, gup_update_work);
-	schedule_delayed_work(&ts->goodix_update_work,
-		msecs_to_jiffies(3000));
+	err = kern_path(path_name, LOOKUP_FOLLOW, &path);
+	if (err) {
+		GTP_DEBUG("%s NOT Mounted: %d", path_name, err);
+		return FAIL;
+	}
 
-	return 0;
+	path_put(&path);
+	return SUCCESS;
+}
+
+s32 i2c_write_bytes(struct i2c_client *client, u16 addr, u8 *buf, s32 len)
+{
+	s32 ret = 0;
+	s32 write_bytes = 0;
+	s32 retry = 0;
+	u8 *tx_buf = buf;
+
+	while (len > 0) {
+		i2c_opr_buf[0] = (u8) (addr >> 8);
+		i2c_opr_buf[1] = (u8) (addr & 0xFF);
+		if (len > FL_PACK_SIZE)
+			write_bytes = FL_PACK_SIZE;
+		else
+			write_bytes = len;
+		memcpy(i2c_opr_buf + 2, tx_buf, write_bytes);
+		for (retry = 0; retry < 5; ++retry) {
+			ret =
+			    gup_i2c_write(client, i2c_opr_buf,
+					  write_bytes + GTP_ADDR_LENGTH);
+			if (ret == 1)
+				break;
+		}
+		if (retry >= 5) {
+			GTP_ERROR
+			    ("retry timeout, I2C write 0x%04X %d bytes failed!",
+			     addr, write_bytes);
+			return ret;
+		}
+		addr += write_bytes;
+		len -= write_bytes;
+		tx_buf += write_bytes;
+	}
+
+	return ret;
 }
+
+s32 i2c_read_bytes(struct i2c_client *client, u16 addr, u8 *buf, s32 len)
+{
+	s32 ret = 0;
+	s32 read_bytes = 0;
+	s32 retry = 0;
+	u8 *tx_buf = buf;
+
+	while (len > 0) {
+		i2c_opr_buf[0] = (u8) (addr >> 8);
+		i2c_opr_buf[1] = (u8) (addr & 0xFF);
+		if (len > FL_PACK_SIZE)
+			read_bytes = FL_PACK_SIZE;
+		else
+			read_bytes = len;
+		for (retry = 0; retry < 5; ++retry) {
+			ret =
+			    gup_i2c_read(client, i2c_opr_buf,
+					 read_bytes + GTP_ADDR_LENGTH);
+			if (ret == 2)
+				break;
+		}
+		if (retry >= 5) {
+			GTP_ERROR
+			    ("retry timeout, I2C read 0x%04X %d bytes failed!",
+			     addr, read_bytes);
+			return ret;
+		}
+		memcpy(tx_buf, i2c_opr_buf + 2, read_bytes);
+		addr += read_bytes;
+		len -= read_bytes;
+		tx_buf += read_bytes;
+	}
+	return ret;
+}
+
+/* main clock calibration
+  * bit: 0~7, val: 0/1
+ */
+static void gup_bit_write(s32 addr, s32 bit, s32 val)
+{
+	u8 buf;
+	i2c_read_bytes(i2c_connect_client, addr, &buf, 1);
+	buf = (buf & (~((u8) 1 << bit))) | ((u8) val << bit);
+	i2c_write_bytes(i2c_connect_client, addr, &buf, 1);
+}
+
+static void gup_clk_count_init(s32 bCh, s32 bCNT)
+{
+	u8 buf;
+
+	gup_bit_write(_fRW_MISCTL__MEA, 0, 0);
+	gup_bit_write(_fRW_MISCTL__MEA, 1, 1);
+	buf = 0;
+	i2c_write_bytes(i2c_connect_client, _bRW_MISCTL__MEA_MODE, &buf, 1);
+	buf = 8 + bCh;
+	i2c_write_bytes(i2c_connect_client, _bRW_MISCTL__MEA_SRCSEL, &buf, 1);
+	buf = bCNT;
+	i2c_write_bytes(i2c_connect_client, _wRW_MISCTL__MEA_MAX_NUM, &buf, 1);
+	gup_bit_write(_fRW_MISCTL__MEA, 1, 0);
+	gup_bit_write(_fRW_MISCTL__MEA, 0, 1);
+}
+
+static u32 gup_clk_count_get(void)
+{
+	s32 ready = 0;
+	s32 temp;
+	s8 buf[4];
+
+	while ((ready == 0)) {
+		i2c_read_bytes(i2c_connect_client, _bRO_MISCTL__MEA_RDY, buf,
+			       1);
+		ready = buf[0];
+	}
+
+	msleep(50);
+
+	gup_bit_write(_fRW_MISCTL__MEA, 0, 0);
+	i2c_read_bytes(i2c_connect_client, _dRO_MISCTL__MEA_VAL, buf, 4);
+	GTP_DEBUG("Clk_count 0: %2X", buf[0]);
+	GTP_DEBUG("Clk_count 1: %2X", buf[1]);
+	GTP_DEBUG("Clk_count 2: %2X", buf[2]);
+	GTP_DEBUG("Clk_count 3: %2X", buf[3]);
+
+	temp =
+	    (s32) buf[0] + ((s32) buf[1] << 8) + ((s32) buf[2] << 16) +
+	    ((s32) buf[3] << 24);
+	GTP_INFO("Clk_count : %d", temp);
+	return temp;
+}
+
+static u8 gup_clk_dac_setting(int dac)
+{
+	s8 buf1, buf2;
+
+	i2c_read_bytes(i2c_connect_client, _wRW_MISCTL__RG_DMY, &buf1, 1);
+	i2c_read_bytes(i2c_connect_client, _bRW_MISCTL__RG_OSC_CALIB, &buf2, 1);
+
+	buf1 = (buf1 & 0xFFCF) | ((dac & 0x03) << 4);
+	buf2 = (dac >> 2) & 0x3f;
+
+	i2c_write_bytes(i2c_connect_client, _wRW_MISCTL__RG_DMY, &buf1, 1);
+	i2c_write_bytes(i2c_connect_client, _bRW_MISCTL__RG_OSC_CALIB, &buf2,
+			1);
+
+	return 0;
+}
+
+static u8 gup_clk_calibration_pin_select(s32 bCh)
+{
+	s32 i2c_addr;
+
+	switch (bCh) {
+	case 0:
+		i2c_addr = _fRW_MISCTL__GIO0;
+		break;
+
+	case 1:
+		i2c_addr = _fRW_MISCTL__GIO1;
+		break;
+
+	case 2:
+		i2c_addr = _fRW_MISCTL__GIO2;
+		break;
+
+	case 3:
+		i2c_addr = _fRW_MISCTL__GIO3;
+		break;
+
+	case 4:
+		i2c_addr = _fRW_MISCTL__GIO4;
+		break;
+
+	case 5:
+		i2c_addr = _fRW_MISCTL__GIO5;
+		break;
+
+	case 6:
+		i2c_addr = _fRW_MISCTL__GIO6;
+		break;
+
+	case 7:
+		i2c_addr = _fRW_MISCTL__GIO7;
+		break;
+
+	case 8:
+		i2c_addr = _fRW_MISCTL__GIO8;
+		break;
+
+	case 9:
+		i2c_addr = _fRW_MISCTL__GIO9;
+		break;
+
+	default:
+		break;
+	}
+
+	gup_bit_write(i2c_addr, 1, 0);
+
+	return 0;
+}
+
+static void gup_sys_clk_init(void)
+{
+	u8 buf;
+
+	gup_bit_write(_rRW_MISCTL__ANA_RXADC_B0_, 5, 0);
+	buf = 0;
+	i2c_write_bytes(i2c_connect_client, _bRW_MISCTL__RG_LDO_A18_PWD, &buf,
+			1);
+	buf = 0;
+	i2c_write_bytes(i2c_connect_client, _bRW_MISCTL__RG_BG_PWD, &buf, 1);
+	buf = 0;
+	i2c_write_bytes(i2c_connect_client, _bRW_MISCTL__RG_CLKGEN_PWD, &buf,
+			1);
+	gup_bit_write(_rRW_MISCTL__ANA_RXADC_B0_, 0, 0);
+	gup_bit_write(_rRW_MISCTL__ANA_RXADC_B0_, 1, 0);
+	buf = 1;
+	i2c_write_bytes(i2c_connect_client, _bRW_MISCTL__OSC_CK_SEL, &buf, 1);
+}
+
+s32 gup_clk_calibration(void)
+{
+	u8 buf;
+	s32 i;
+	struct timeval start, end;
+	s32 count;
+	s32 count_ref;
+	s32 sec;
+	s32 usec;
+	struct goodix_ts_data *ts = i2c_get_clientdata(i2c_connect_client);
+
+	buf = 0x0C;
+	i2c_write_bytes(i2c_connect_client, _rRW_MISCTL__SWRST_B0_, &buf, 1);
+
+	gup_bit_write(_rRW_MISCTL_RG_DMY83, 7, 0);
+
+	gup_bit_write(_rRW_MISCTL__GIO1CTL_B2_, 0, 0);
+
+	gup_bit_write(_rRW_MISCTL__GIO1CTL_B1_, 1, 0);
+
+	GTP_INFO("CLK calibration GO");
+	gup_sys_clk_init();
+	/* use GIO1 to do the calibration */
+	gup_clk_calibration_pin_select(1);
+
+	gpio_direction_output(ts->pdata->irq_gpio, 0);
+
+	for (i = INIT_CLK_DAC; i < MAX_CLK_DAC; i++) {
+		GTP_INFO("CLK calibration DAC %d", i);
+
+		if (ts->gtp_is_suspend) {
+			/* 80; if sleeping while calibrating main clock,
+			  * set it default 72
+			  */
+			i = 72;
+			break;
+		}
+
+		gup_clk_dac_setting(i);
+		gup_clk_count_init(1, CLK_AVG_TIME);
+
+		gpio_direction_output(ts->pdata->irq_gpio, 0);
+
+		do_gettimeofday(&start);
+		gpio_direction_output(ts->pdata->irq_gpio, 1);
+
+		msleep(20);
+		gpio_direction_output(ts->pdata->irq_gpio, 0);
+		msleep(20);
+
+		do_gettimeofday(&end);
+		gpio_direction_output(ts->pdata->irq_gpio, 1);
+
+		count = gup_clk_count_get();
+		msleep(20);
+		gpio_direction_output(ts->pdata->irq_gpio, 0);
+
+		usec = end.tv_usec - start.tv_usec;
+		sec = end.tv_sec - start.tv_sec;
+		count_ref = 60 * (usec + sec * MILLION);
+
+		GTP_DEBUG("== time %d, %d, %d", sec, usec, count_ref);
+
+		if (count > count_ref) {
+			GTP_DEBUG("== count_diff %d", count - count_ref);
+			break;
+		}
+	}
+
+	gtp_reset_guitar(i2c_connect_client, 20);
+
+	gpio_direction_input(ts->pdata->irq_gpio);
+	return i;
+}
+
+static s32 gup_hold_ss51_dsp(struct i2c_client *client)
+{
+	s32 ret = -1;
+	s32 retry = 0;
+	u8 rd_buf[3];
+
+	while (retry++ < 200) {
+		/* step4:Hold ss51 & dsp */
+		ret = gup_set_ic_msg(client, _rRW_MISCTL__SWRST_B0_, 0x0C);
+		if (ret <= 0) {
+			GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
+			continue;
+		}
+		/* step5:Confirm hold */
+		ret = gup_get_ic_msg(client, _rRW_MISCTL__SWRST_B0_, rd_buf, 1);
+		if (ret <= 0) {
+			GTP_DEBUG("Hold ss51 & dsp I2C error,retry:%d", retry);
+			continue;
+		}
+		if (0x0C == rd_buf[GTP_ADDR_LENGTH]) {
+			GTP_DEBUG
+			    ("[enter_update_mode]Hold ss51 & dsp SUCCESS");
+			break;
+		}
+		GTP_DEBUG("Hold ss51 & dsp confirm 0x4180 failed,value:%d",
+			  rd_buf[GTP_ADDR_LENGTH]);
+	}
+	if (retry >= 200) {
+		GTP_ERROR("Enter update Hold ss51 failed.");
+		return FAIL;
+	}
+	/* DSP_CK and DSP_ALU_CK PowerOn */
+	ret = gup_set_ic_msg(client, 0x4010, 0x00);
+	if (ret <= 0) {
+		GTP_ERROR
+		    ("[enter_update_mode]DSP_CK and DSP_ALU_CK PowerOn fail.");
+		return FAIL;
+	}
+	/* disable wdt */
+	ret = gup_set_ic_msg(client, _bRW_MISCTL__TMR0_EN, 0x00);
+	if (ret <= 0) {
+		GTP_ERROR("[enter_update_mode]disable wdt fail.");
+		return FAIL;
+	}
+	/* clear cache enable */
+	ret = gup_set_ic_msg(client, _bRW_MISCTL__CACHE_EN, 0x00);
+	if (ret <= 0) {
+		GTP_ERROR("[enter_update_mode]clear cache enable fail.");
+		return FAIL;
+	}
+	/* set boot from sram */
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOTCTL_B0_, 0x02);
+	if (ret <= 0) {
+		GTP_ERROR("[enter_update_mode]set boot from sram fail.");
+		return FAIL;
+	}
+	/* software reboot */
+	ret = gup_set_ic_msg(client, _bWO_MISCTL__CPU_SWRST_PULSE, 0x01);
+	if (ret <= 0) {
+		GTP_ERROR("[enter_update_mode]software reboot fail.");
+		return FAIL;
+	}
+
+	return SUCCESS;
+}
+
+static s32 gup_enter_update_mode_fl(struct i2c_client *client)
+{
+	s32 ret = -1;
+	struct goodix_ts_data *ts = i2c_get_clientdata(client);
+
+	/* step1:RST output low last at least 2ms */
+	gpio_direction_output(ts->pdata->reset_gpio, 0);
+	msleep(20);
+
+	/* step2:select I2C slave addr,INT:0--0xBA;1--0x28. */
+	gpio_direction_output(ts->pdata->irq_gpio, (client->addr == 0x14));
+	msleep(20);
+
+	/* step3:RST output high reset guitar */
+	gpio_direction_output(ts->pdata->reset_gpio, 1);
+
+	msleep(20);
+
+	/* select addr & hold ss51_dsp */
+	ret = gup_hold_ss51_dsp(client);
+	if (ret <= 0) {
+		GTP_ERROR("[enter_update_mode]hold ss51 & dsp failed.");
+		return FAIL;
+	}
+	/* clear control flag */
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_CTL_, 0x00);
+	if (ret <= 0) {
+		GTP_ERROR("[enter_update_mode]clear control flag fail.");
+		return FAIL;
+	}
+	/* set scramble */
+	ret = gup_set_ic_msg(client, _rRW_MISCTL__BOOT_OPT_B0_, 0x00);
+	if (ret <= 0) {
+		GTP_ERROR("[enter_update_mode]set scramble fail.");
+		return FAIL;
+	}
+	/* enable accessing code */
+	ret = gup_set_ic_msg(client, _bRW_MISCTL__MEM_CD_EN, 0x01);
+	if (ret <= 0) {
+		GTP_ERROR("[enter_update_mode]enable accessing code fail.");
+		return FAIL;
+	}
+
+	return SUCCESS;
+}
+
+static u8 gup_download_fw_dsp(struct i2c_client *client, u8 dwn_mode)
+{
+	s32 ret = 0;
+
+	/* step1:select bank2 */
+	GTP_DEBUG("[download_fw_dsp]step1:select bank2");
+	ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, 0x02);
+	if (ret == FAIL) {
+		GTP_ERROR("select bank 2 fail");
+		return FAIL;
+	}
+
+	if (GTP_FL_FW_BURN == dwn_mode) {
+		GTP_INFO("[download_fw_dsp]Begin download dsp fw---->>");
+
+		if (ret <= 0) {
+			GTP_ERROR("[download_fw_dsp]select bank2 fail.");
+			return FAIL;
+		}
+		GTP_DEBUG("burn fw dsp");
+		/* write the second ban */
+		ret = gup_burn_fw_proc(client, 0xC000,
+				2 * FW_DOWNLOAD_LENGTH, FW_DSP_LENGTH);
+		if (FAIL == ret) {
+			GTP_ERROR("[download_fw_dsp]download FW dsp fail.");
+			return FAIL;
+		}
+		GTP_INFO("check firmware dsp");
+		ret =
+		    gup_check_and_repair(client, 0xC000, 2 * FW_DOWNLOAD_LENGTH,
+					 FW_DSP_LENGTH);
+		if (FAIL == ret) {
+			GTP_ERROR("check fw dsp failed!");
+			return FAIL;
+		}
+	} else if (GTP_FL_ESD_RECOVERY == dwn_mode) {
+		GTP_INFO("[download_fw_dsp]Begin esd check dsp fw---->>");
+		/*GTP_INFO("esd recovery: check fw dsp");
+		ret = gup_check_and_repair(client, 0xC000,
+				2 * FW_DOWNLOAD_LENGTH, FW_DSP_LENGTH);
+		if (FAIL == ret)
+		*/
+		{
+			GTP_INFO("esd recovery redownload firmware dsp code");
+			ret =
+			    gup_burn_fw_proc(client, 0xC000,
+					     2 * FW_DOWNLOAD_LENGTH,
+					     FW_DSP_LENGTH);
+			if (FAIL == ret) {
+				GTP_ERROR("redownload fw dsp failed!");
+				return FAIL;
+			}
+		}
+	} else {
+		GTP_INFO("check firmware dsp");
+		ret =
+		    gup_check_and_repair(client, 0xC000, 2 * FW_DOWNLOAD_LENGTH,
+					 FW_DSP_LENGTH);
+		if (FAIL == ret) {
+			GTP_ERROR("check fw dsp failed!");
+			return FAIL;
+		}
+	}
+	return SUCCESS;
+}
+
+static s32 gup_burn_fw_proc(struct i2c_client *client, u16 start_addr,
+			    s32 start_index, s32 burn_len)
+{
+	s32 ret = 0;
+
+	GTP_DEBUG("burn firmware: 0x%04X, %d bytes, start_index: 0x%04X",
+		  start_addr, burn_len, start_index);
+
+	ret =
+	    i2c_write_bytes(client, start_addr,
+			    (u8 *)&gtp_default_FW_fl[FW_HEAD_LENGTH +
+						       start_index], burn_len);
+	if (ret < 0) {
+		GTP_ERROR("burn 0x%04X, %d bytes failed!", start_addr,
+			  burn_len);
+		return FAIL;
+	}
+	return SUCCESS;
+}
+
+static s32 gup_check_and_repair(struct i2c_client *client, u16 start_addr,
+				s32 start_index, s32 chk_len)
+{
+	s32 ret = 0;
+	s32 cmp_len = 0;
+	u16 cmp_addr = start_addr;
+	s32 i = 0;
+	s32 chked_times = 0;
+	u8 chk_fail = 0;
+
+	GTP_DEBUG("check firmware: start 0x%04X, %d bytes", start_addr,
+		  chk_len);
+	while ((chk_len > 0) && (chked_times < GTP_CHK_FW_MAX)) {
+		if (chk_len >= GUP_FW_CHK_SIZE)
+			cmp_len = GUP_FW_CHK_SIZE;
+		else
+			cmp_len = chk_len;
+		ret = i2c_read_bytes(client, cmp_addr, chk_cmp_buf, cmp_len);
+		if (ret < 0) {
+			chk_fail = 1;
+			break;
+		}
+		for (i = 0; i < cmp_len; ++i) {
+			if (chk_cmp_buf[i] !=
+			    gtp_default_FW_fl[FW_HEAD_LENGTH + start_index +
+					      i]) {
+				chk_fail = 1;
+				i2c_write_bytes(client, cmp_addr + i,
+						&gtp_default_FW_fl
+						[FW_HEAD_LENGTH + start_index +
+						 i], cmp_len - i);
+				GTP_ERROR
+				    ("Check failed index: %d(%d != %d)",
+				     i, chk_cmp_buf[i],
+				     gtp_default_FW_fl[FW_HEAD_LENGTH +
+						       start_index + i]);
+				break;
+			}
+		}
+		if (chk_fail == 1) {
+			chk_fail = 0;
+			chked_times++;
+		} else {
+			cmp_addr += cmp_len;
+			start_index += cmp_len;
+			chk_len -= cmp_len;
+		}
+	}
+	if (chk_len > 0) {
+		GTP_ERROR
+		    ("cmp_addr: 0x%04X, start_index: 0x%02X, chk_len: 0x%04X",
+		     cmp_addr, start_index, chk_len);
+		return FAIL;
+	}
+	return SUCCESS;
+}
+
+static u8 gup_download_fw_ss51(struct i2c_client *client, u8 dwn_mode)
+{
+	s32 section = 0;
+	s32 ret = 0;
+	s32 start_index = 0;
+	u8 bank = 0;
+	u16 burn_addr = 0xC000;
+
+	if (GTP_FL_FW_BURN == dwn_mode)
+		GTP_INFO("download firmware ss51");
+	else
+		GTP_INFO("check firmware ss51");
+	for (section = 1; section <= 4; section += 2) {
+		switch (section) {
+		case 1:
+			bank = 0x00;
+			burn_addr =
+			    (section - 1) * FW_SS51_SECTION_LEN + 0xC000;
+			break;
+		case 3:
+			bank = 0x01;
+			burn_addr =
+			    (section - 3) * FW_SS51_SECTION_LEN + 0xC000;
+			break;
+		}
+		start_index = (section - 1) * FW_SS51_SECTION_LEN;
+
+		GTP_DEBUG("download firmware ss51: select bank%d", bank);
+		ret = gup_set_ic_msg(client, _bRW_MISCTL__SRAM_BANK, bank);
+		if (GTP_FL_FW_BURN == dwn_mode) {
+			GTP_INFO("download firmware ss51 section%d & %d",
+				 section, section + 1);
+			ret =
+			    gup_burn_fw_proc(client, burn_addr, start_index,
+					     2 * FW_SS51_SECTION_LEN);
+			if (ret == FAIL) {
+				GTP_ERROR
+				    ("download fw ss51 section%d & %d failed!",
+				     section, section + 1);
+				return FAIL;
+			}
+			GTP_INFO("check firmware ss51 section%d & %d", section,
+				 section + 1);
+			ret =
+			    gup_check_and_repair(client, burn_addr, start_index,
+						 2 * FW_SS51_SECTION_LEN);
+			if (ret == FAIL) {
+				GTP_ERROR("check ss51 section%d & %d failed!",
+					  section, section + 1);
+				return FAIL;
+			}
+		} else if (GTP_FL_ESD_RECOVERY == dwn_mode) {
+			/*GTP_INFO("esd recovery check ss51 section%d & %d",
+						section, section + 1);
+			ret = gup_check_and_repair(client, burn_addr,
+					start_index, FW_SS51_SECTION_LEN);
+			if (ret == FAIL)
+			*/
+			{
+				GTP_INFO
+				    ("esd redownload ss51 section%d & %d",
+				     section, section + 1);
+				ret = gup_burn_fw_proc(client, burn_addr,
+						     start_index,
+						     2 * FW_SS51_SECTION_LEN);
+				if (ret == FAIL) {
+					GTP_ERROR
+					    ("download ss51 section%d failed!",
+					     section);
+					return FAIL;
+				}
+			}
+		} else {
+			GTP_INFO("check firmware ss51 section%d & %d", section,
+				 section + 1);
+			ret =
+			    gup_check_and_repair(client, burn_addr, start_index,
+						 2 * FW_SS51_SECTION_LEN);
+			if (ret == FAIL) {
+				GTP_ERROR("check ss51 section%d & %d failed!",
+					  section, section + 1);
+				return FAIL;
+			}
+		}
+	}
+
+	return SUCCESS;
+}
+
+static s32 gup_prepare_fl_fw(char *path, struct st_fw_head *fw_head)
+{
+	s32 ret = 0;
+	s32 i = 0;
+	s32 timeout = 0;
+	struct filename name = {.name = FL_UPDATE_PATH};
+	struct goodix_ts_data *ts = i2c_get_clientdata(i2c_connect_client);
+
+	if (!memcmp(path, "update", 6)) {
+		GTP_INFO("Search for GT9XXF firmware file to update");
+
+		searching_file = 1;
+		for (i = 0; i < GUP_SEARCH_FILE_TIMES; ++i) {
+			if (0 == searching_file) {
+				GTP_INFO
+				    ("Force terminate auto update for GT9XXF");
+				return FAIL;
+			}
+			GTP_DEBUG("Search for %s, %s for fw update.(%d/%d)",
+				  FL_UPDATE_PATH, FL_UPDATE_PATH_SD, i + 1,
+				  GUP_SEARCH_FILE_TIMES);
+			update_msg.file = file_open_name(&name, O_RDONLY, 0);
+			if (IS_ERR(update_msg.file)) {
+				name.name = FL_UPDATE_PATH_SD;
+				update_msg.file =
+					file_open_name(&name, O_RDONLY, 0);
+				if (IS_ERR(update_msg.file)) {
+					msleep(3000);
+					continue;
+				} else {
+					path = FL_UPDATE_PATH_SD;
+					break;
+				}
+			} else {
+				path = FL_UPDATE_PATH;
+				break;
+			}
+		}
+		searching_file = 0;
+		if (i == 50) {
+			GTP_INFO("Search timeout, update aborted");
+			return FAIL;
+		} else {
+			GTP_INFO("GT9XXF firmware file %s found!", path);
+			_CLOSE_FILE(update_msg.file);
+		}
+		while (ts->rqst_processing && (timeout++ < 5)) {
+			GTP_DEBUG
+			    ("request processing, waiting for accomplishment");
+			msleep(1000);
+		}
+	}
+	GTP_INFO("Firmware update file path: %s", path);
+
+	name.name = path;
+	update_msg.file = file_open_name(&name, O_RDONLY, 0);
+	if (IS_ERR(update_msg.file)) {
+		GTP_ERROR("Open update file(%s) error!", path);
+		return FAIL;
+	}
+
+	update_msg.old_fs = get_fs();
+	set_fs(KERNEL_DS);
+
+	update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_SET);
+	update_msg.fw_total_len =
+	    update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_END);
+
+	update_msg.force_update = 0xBE;	/* GT9XXF ignore the 0xBE */
+	if (update_msg.fw_total_len != sizeof(gtp_default_FW_fl)) {
+		GTP_ERROR
+		    ("fw size error: default size: %d(%dK), file size: %d(%dK)",
+		     sizeof(gtp_default_FW_fl),
+		     sizeof(gtp_default_FW_fl) / 1024, update_msg.fw_total_len,
+		     update_msg.fw_total_len / 1024);
+		set_fs(update_msg.old_fs);
+		_CLOSE_FILE(update_msg.file);
+		return FAIL;
+	}
+
+	update_msg.fw_total_len -= FW_HEAD_LENGTH;
+	GTP_DEBUG("Fimrware size: %d(%dK)", update_msg.fw_total_len,
+		  update_msg.fw_total_len / 1024);
+
+	update_msg.file->f_op->llseek(update_msg.file, 0, SEEK_SET);
+	ret =
+	    update_msg.file->f_op->read(update_msg.file,
+					(char *)gtp_default_FW_fl,
+					update_msg.fw_total_len +
+					FW_HEAD_LENGTH,
+					&update_msg.file->f_pos);
+	set_fs(update_msg.old_fs);
+	_CLOSE_FILE(update_msg.file);
+
+	if (ret < 0) {
+		GTP_ERROR("read %s failed, err-code: %d", path, ret);
+		return FAIL;
+	}
+	return SUCCESS;
+}
+
+static u8 gup_check_update_file_fl(struct i2c_client *client,
+				   struct st_fw_head *fw_head, char *path)
+{
+	s32 ret = 0;
+	s32 i = 0;
+	s32 fw_checksum = 0;
+
+	if (NULL != path) {
+		ret = gup_prepare_fl_fw(path, fw_head);
+		if (FAIL == ret)
+			return FAIL;
+	}
+
+	memcpy(fw_head, gtp_default_FW_fl, FW_HEAD_LENGTH);
+	GTP_INFO("FILE HARDWARE INFO: %02x%02x%02x%02x", fw_head->hw_info[0],
+		 fw_head->hw_info[1], fw_head->hw_info[2], fw_head->hw_info[3]);
+	GTP_INFO("FILE PID: %s", fw_head->pid);
+	fw_head->vid =
+	    ((fw_head->vid & 0xFF00) >> 8) + ((fw_head->vid & 0x00FF) << 8);
+	GTP_INFO("FILE VID: %04x", fw_head->vid);
+
+	/* check firmware legality */
+	fw_checksum = 0;
+	for (i = FW_HEAD_LENGTH; i < (FW_HEAD_LENGTH + update_msg.fw_total_len);
+	     i += 2)
+		fw_checksum +=
+		    (gtp_default_FW_fl[i] << 8) + gtp_default_FW_fl[i + 1];
+	ret = SUCCESS;
+
+	GTP_DEBUG("firmware checksum: %x", fw_checksum & 0xFFFF);
+	if (fw_checksum & 0xFFFF) {
+		GTP_ERROR("Illegal firmware file.");
+		ret = FAIL;
+	}
+
+	return ret;
+}
+
+s32 gup_fw_download_proc(void *dir, u8 dwn_mode)
+{
+	s32 ret = 0;
+	u8 retry = 0;
+	struct st_fw_head fw_head;
+	struct goodix_ts_data *ts;
+
+	ts = i2c_get_clientdata(i2c_connect_client);
+	if (NULL == dir) {
+		if (GTP_FL_FW_BURN == dwn_mode)	/* GT9XXF firmware burn mode */
+			GTP_INFO("[fw_download_proc]Begin fw download ...");
+		else if (GTP_FL_ESD_RECOVERY == dwn_mode)
+			GTP_INFO
+			    ("[fw_download_proc]Begin fw esd recovery check");
+		else
+			GTP_INFO
+			    ("[fw_download_proc]Being fw repair check...");
+	} else
+		GTP_INFO("[fw_download_proc]Begin firmware update by bin file");
+
+	total_len = 100;
+	show_len = 0;
+
+	ret = gup_check_update_file_fl(i2c_connect_client,
+					&fw_head, (char *)dir);
+	show_len = 10;
+	if (FAIL == ret) {
+		GTP_ERROR("[fw_download_proc]check update file fail.");
+		goto file_fail;
+	}
+
+	if (!memcmp(fw_head.pid, "950", 3)) {
+		ts->is_950 = 1;
+		GTP_DEBUG("GT9XXF Ic Type: gt950");
+	} else
+		ts->is_950 = 0;
+
+	if (NULL != dir) {
+		gtp_irq_disable(ts);
+#if GTP_ESD_PROTECT
+		gtp_esd_switch(ts->client, SWITCH_OFF);
+#endif
+	}
+
+	ret = gup_enter_update_mode_fl(i2c_connect_client);
+	show_len = 20;
+	if (FAIL == ret) {
+		GTP_ERROR("[fw_download_proc]enter update mode fail.");
+		goto download_fail;
+	}
+
+	while (retry++ < 5) {
+		ret = gup_download_fw_ss51(i2c_connect_client, dwn_mode);
+		show_len = 60;
+		if (FAIL == ret) {
+			GTP_ERROR("[fw_download_proc]burn ss51 firmware fail.");
+			continue;
+		}
+
+		ret = gup_download_fw_dsp(i2c_connect_client, dwn_mode);
+		show_len = 80;
+		if (FAIL == ret) {
+			GTP_ERROR("[fw_download_proc]burn dsp firmware fail.");
+			continue;
+		}
+
+		GTP_INFO("[fw_download_proc]UPDATE SUCCESS.");
+		break;
+	}
+
+	if (retry >= 5) {
+		GTP_ERROR("[fw_download_proc]retry timeout,UPDATE FAIL.");
+		goto download_fail;
+	}
+
+	if (NULL != dir) {
+		gtp_irq_enable(ts);
+		gtp_fw_startup(ts->client);
+#if GTP_ESD_PROTECT
+		gtp_esd_switch(ts->client, SWITCH_ON);
+#endif
+	}
+	show_len = 100;
+	return SUCCESS;
+
+download_fail:
+	if (NULL != dir) {
+		gtp_irq_enable(ts);
+		gtp_fw_startup(ts->client);
+#if GTP_ESD_PROTECT
+		gtp_esd_switch(ts->client, SWITCH_ON);
+#endif
+	}
+file_fail:
+	show_len = 200;
+	return FAIL;
+}
+#endif
+
+/**************** For GT9XXF End ********************/
-- 
1.9.1

