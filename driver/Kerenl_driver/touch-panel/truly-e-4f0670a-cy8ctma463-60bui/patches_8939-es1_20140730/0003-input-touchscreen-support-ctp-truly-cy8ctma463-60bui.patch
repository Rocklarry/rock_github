From 96a05a5329c46a0760530f1d2d08860878fd1c57 Mon Sep 17 00:00:00 2001
From: yangzh <yangzh0324@thundersoft.com>
Date: Fri, 18 Jul 2014 14:49:26 +0800
Subject: [PATCH 3/3] input:touchscreen: support ctp truly cy8ctma463-60bui

Add CTP truly cy8ctma463-60bui driver

Signed-off-by: yangzh <yagnzh0324@thundersoft.com>

Change-Id: I053ced67695871f8a8cf73398d886a94c9336f5c
---
 drivers/input/touchscreen/Kconfig                  |   12 +
 drivers/input/touchscreen/Makefile                 |    1 +
 drivers/input/touchscreen/cypress/Kconfig          |  289 ++
 drivers/input/touchscreen/cypress/Makefile         |   62 +
 drivers/input/touchscreen/cypress/cyttsp4_btn.c    |  527 +++
 drivers/input/touchscreen/cypress/cyttsp4_bus.c    |  761 ++++
 drivers/input/touchscreen/cypress/cyttsp4_core.c   | 4314 ++++++++++++++++++++
 drivers/input/touchscreen/cypress/cyttsp4_debug.c  |  608 +++
 .../touchscreen/cypress/cyttsp4_device_access.c    | 2208 ++++++++++
 .../touchscreen/cypress/cyttsp4_device_access.h    |   67 +
 .../input/touchscreen/cypress/cyttsp4_devtree.c    |  770 ++++
 .../input/touchscreen/cypress/cyttsp4_devtree.h    |   36 +
 drivers/input/touchscreen/cypress/cyttsp4_i2c.c    |  300 ++
 drivers/input/touchscreen/cypress/cyttsp4_i2c.h    |   35 +
 drivers/input/touchscreen/cypress/cyttsp4_loader.c | 1899 +++++++++
 .../input/touchscreen/cypress/cyttsp4_mt_common.c  |  693 ++++
 .../input/touchscreen/cypress/cyttsp4_mt_common.h  |   86 +
 drivers/input/touchscreen/cypress/cyttsp4_mta.c    |  108 +
 drivers/input/touchscreen/cypress/cyttsp4_mtb.c    |  115 +
 .../input/touchscreen/cypress/cyttsp4_platform.c   |  360 ++
 .../input/touchscreen/cypress/cyttsp4_proximity.c  |  585 +++
 drivers/input/touchscreen/cypress/cyttsp4_regs.h   |  578 +++
 drivers/input/touchscreen/cypress/cyttsp4_spi.c    |  462 +++
 drivers/input/touchscreen/cypress/cyttsp4_spi.h    |   37 +
 .../cypress/cyttsp4_test_device_access_api.c       |  196 +
 include/linux/cyttsp4_btn.h                        |   39 +
 include/linux/cyttsp4_bus.h                        |  346 ++
 include/linux/cyttsp4_core.h                       |  152 +
 include/linux/cyttsp4_device_access-api.h          |   56 +
 include/linux/cyttsp4_mt.h                         |   84 +
 include/linux/cyttsp4_platform.h                   |   61 +
 include/linux/cyttsp4_proximity.h                  |   42 +
 32 files changed, 15889 insertions(+)
 create mode 100644 drivers/input/touchscreen/cypress/Kconfig
 create mode 100644 drivers/input/touchscreen/cypress/Makefile
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_btn.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_bus.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_core.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_debug.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_device_access.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_device_access.h
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_devtree.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_devtree.h
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_i2c.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_i2c.h
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_loader.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_mt_common.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_mt_common.h
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_mta.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_mtb.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_platform.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_proximity.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_regs.h
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_spi.c
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_spi.h
 create mode 100644 drivers/input/touchscreen/cypress/cyttsp4_test_device_access_api.c
 create mode 100644 include/linux/cyttsp4_btn.h
 create mode 100644 include/linux/cyttsp4_bus.h
 create mode 100644 include/linux/cyttsp4_core.h
 create mode 100644 include/linux/cyttsp4_device_access-api.h
 create mode 100644 include/linux/cyttsp4_mt.h
 create mode 100644 include/linux/cyttsp4_platform.h
 create mode 100644 include/linux/cyttsp4_proximity.h

diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 0366f29..188b8c7 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -999,6 +999,17 @@ config SECURE_TOUCH
 
 	  If unsure, say N.
 
+config TOUCHSCREEN_CYPRESS_CYTTSP4
+	tristate "Cypress TMA463 touchscreen"
+	depends on I2C
+	help
+	  Say Y here if you have a Cypress TMA463  touchscreen.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called synaptics_dsx_fw_update.
+
 config TOUCHSCREEN_GT9XX
 	bool "Goodix touchpanel GT9xx series"
 	depends on I2C
@@ -1010,5 +1021,6 @@ config TOUCHSCREEN_GT9XX
           If unsure, say N.
 
 source "drivers/input/touchscreen/gt9xx/Kconfig"
+source "drivers/input/touchscreen/cypress/Kconfig"
 
 endif
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 486cd42..0c1c45c 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -80,3 +80,4 @@ obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI4_DEV)	+= synaptics_rmi_dev.o
 obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_FW_UPDATE) 	+= synaptics_fw_update.o
 obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4)		+= synaptics_i2c_rmi4.o
 obj-$(CONFIG_TOUCHSCREEN_GT9XX)		+= gt9xx/
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4)		+= cypress/
diff --git a/drivers/input/touchscreen/cypress/Kconfig b/drivers/input/touchscreen/cypress/Kconfig
new file mode 100644
index 0000000..4cea504
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/Kconfig
@@ -0,0 +1,289 @@
+#
+# Touchscreen driver configuration
+#
+config CYPRESS_CYTTSP4_BUS
+	bool "Cypress TTSP core bus"
+	default n
+	help
+	  This option enables support Cypress TTSP core bus.
+	  This support is needed for various device and drivers
+	  using Cypress TrueTouch(TM) Standard Product
+	  protocol.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4
+	tristate "Cypress TrueTouch Gen4 Touchscreen Driver"
+	default y
+	select CYPRESS_CYTTSP4_BUS
+	help
+	  Core driver for Cypress TrueTouch(tm) Standard Product
+	  Geneartion4 touchscreen controllers.
+
+	  Say Y here if you have a Cypress Gen4 touchscreen.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICETREE_SUPPORT
+	bool "Enable Device Tree support"
+	default n
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4 && OF
+	help
+	  This option enables support for device tree.
+	  Reduce board file.
+
+	  Say Y here to enable device tree support.
+
+	  If unsure, say N.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_DEBUG
+	bool "Enable debug output"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default n
+	help
+	  Enable Debug output for Cypress TrueTouch(tm)
+	  Standard Product Generation4 drivers set.
+
+	  Say Y here to enable debug output.
+
+	  If unsure, say N.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_VDEBUG
+	bool "Enable verbose debug output"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_DEBUG
+	default n
+	help
+	  Enable Verbose Debug output for Cypress TrueTouch(tm)
+	  Standard Product Generation4 drivers set.
+
+	  Say Y here to enable verbose debug output.
+
+	  If unsure, say N.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_I2C
+	tristate "Cypress TrueTouch Gen4 I2C"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	select I2C
+	default y
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  I2C bus interface.
+
+	  Say Y here to enable I2C bus interface to TTSP
+	  touchscreen controller.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called input.
+
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_SPI
+	tristate "Cypress TrueTouch Gen4 SPI"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	select SPI
+	default m
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  SPI bus interface.
+
+	  Say Y here to enable SPI bus interface to TTSP
+	  touchscreen controller.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called input.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_MT_A
+	tristate "Cypress TrueTouch Gen4 MultiTouch Protocol A"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default m
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  MutliTouch Protocol A support.
+
+	  Say Y here to enable MutiTouch touch reporting
+	  using protocol A.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called input.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_MT_B
+	tristate "Cypress TrueTouch Gen4 MultiTouch Protocol B"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default y
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  MutliTouch Protocol B support.
+
+	  Say Y here to enable MutiTouch touch reporting
+	  using protocol B.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called input.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_BUTTON
+	tristate "Cypress TrueTouch Gen4 MultiTouch CapSense Button"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default y
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  CapSense driver.
+
+	  Say Y here to enable CapSense reporting.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called input.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_PROXIMITY
+	tristate "Cypress TrueTouch Gen4 Proximity"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default m
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  Proximity driver.
+
+	  Say Y here to enable proximity reporting.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called input.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS
+	tristate "Cypress TrueTouch Gen4 MultiTouch Device Access"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default m
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  Device access module.
+
+	  This modules adds an interface to access touchscreen
+	  controller using driver sysfs nodes.
+
+	  Say Y here to enable multtitouch device access.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called input.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS_API
+	bool "Enable Device Access kernel API"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS
+	default n
+	help
+	  Say Y here to enable Device access kernel API.
+	  Cypress TrueTouch(R) Standard Product Device
+	  Access Driver
+
+	  If unsure, say N.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_TEST_DEVICE_ACCESS_API
+	tristate "Simple Test module for Device Access kernel API"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS_API
+	default n
+	help
+	  Say Y here to enable test module for Device access kernel API.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called input.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_LOADER
+	tristate "Cypress TrueTouch Gen4 MultiTouch Loader"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default y
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  FW Loader module.
+
+	  This module enables support for Firmware upgrade.
+
+	  Say Y here to enable multtitouch Loader.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called input.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+	bool "FW upgrade from header file"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_LOADER
+	default n
+	help
+	  Include Cypress TrueTouch(tm) Standard Product
+	  Generation4 device Firmware into driver.
+
+	  Need proper header file for this.
+
+	  Say Y here to enable header file.
+
+	  If unsure, say N.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+	bool "FW upgrade from binary file"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_LOADER
+	default n
+	help
+	  Include Cypress TrueTouch(tm) Standard Product
+	  Generation4 device Firmware into kernel itself.
+
+	  This should be enabled for manual FW upgrade.
+
+	  Say Y here to enable binary file.
+
+	  If unsure, say N.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_TTCONFIG_UPGRADE
+	bool "TT Configuration upgrade from header file"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_LOADER
+	default n
+	help
+	  Include Cypress TrueTouch(tm) Standard Product
+	  Generation4 device TrueTouch Configuration into
+	  kernel itself.
+
+	  Need proper header file for this.
+
+	  Say Y here to enable header file.
+
+	  If unsure, say N.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE
+	bool "TT Configuration upgrade via SysFs"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4_LOADER
+	default n
+	help
+	  Provides a SysFs interface to upgrade TrueTouch
+	  Configuration with a binary configuration file.
+
+	  Say Y here to enable cyttsp4 loader.
+
+	  If unsure, say N.
+
+config TOUCHSCREEN_CYPRESS_CYTTSP4_DEBUG_MODULE
+	tristate "Cypress TrueTouch Gen4 MultiTouch Debug Module"
+	depends on TOUCHSCREEN_CYPRESS_CYTTSP4
+	default m
+	help
+	  Cypress TrueTouch(tm) Standard Product Generation4
+	  Debug module.
+
+	  This module adds support for verbose printing touch
+	  information.
+	  Say Y here to enable cyttsp4 loader.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called input.
diff --git a/drivers/input/touchscreen/cypress/Makefile b/drivers/input/touchscreen/cypress/Makefile
new file mode 100644
index 0000000..b09c450
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/Makefile
@@ -0,0 +1,62 @@
+#
+# Makefile for the touchscreen drivers.
+#
+
+# Each configuration option enables a list of files.
+
+obj-$(CONFIG_CYPRESS_CYTTSP4_BUS) += cyttsp4_bus.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4)	+= cyttsp4_core.o
+ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4
+obj-y += cyttsp4_platform.o
+endif
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_I2C)	+= cyttsp4_i2c.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_SPI)	+= cyttsp4_spi.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MT_A)	+= cyttsp4_mt_a.o
+cyttsp4_mt_a-y := cyttsp4_mta.o cyttsp4_mt_common.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MT_B)	+= cyttsp4_mt_b.o
+cyttsp4_mt_b-y := cyttsp4_mtb.o cyttsp4_mt_common.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BUTTON)	+= cyttsp4_btn.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PROXIMITY)	+= cyttsp4_proximity.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS)	+= cyttsp4_device_access.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_TEST_DEVICE_ACCESS_API)	+= cyttsp4_test_device_access_api.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_LOADER)	+= cyttsp4_loader.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEBUG_MODULE)	+= cyttsp4_debug.o
+obj-$(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICETREE_SUPPORT)	+= cyttsp4_devtree.o
+ifeq ($(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEBUG),y)
+CFLAGS_cyttsp4_bus.o += -DDEBUG
+CFLAGS_cyttsp4_core.o += -DDEBUG
+CFLAGS_cyttsp4_i2c.o += -DDEBUG
+CFLAGS_cyttsp4_spi.o += -DDEBUG
+CFLAGS_cyttsp4_mta.o += -DDEBUG
+CFLAGS_cyttsp4_mtb.o += -DDEBUG
+CFLAGS_cyttsp4_mt_a.o += -DDEBUG
+CFLAGS_cyttsp4_mt_b.o += -DDEBUG
+CFLAGS_cyttsp4_mt_common.o += -DDEBUG
+CFLAGS_cyttsp4_btn.o += -DDEBUG
+CFLAGS_cyttsp4_proximity.o += -DDEBUG
+CFLAGS_cyttsp4_device_access.o += -DDEBUG
+CFLAGS_cyttsp4_loader.o += -DDEBUG
+CFLAGS_cyttsp4_debug.o += -DDEBUG
+CFLAGS_cyttsp4_devtree.o += -DDEBUG
+CFLAGS_cyttsp4_platform.o += -DDEBUG
+endif
+
+ifeq ($(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_VDEBUG),y)
+CFLAGS_cyttsp4_bus.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_core.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_i2c.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_spi.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_mta.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_mtb.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_mt_a.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_mt_b.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_mt_common.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_btn.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_proximity.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_device_access.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_loader.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_debug.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_devtree.o += -DVERBOSE_DEBUG
+CFLAGS_cyttsp4_platform.o += -DVERBOSE_DEBUG
+endif
+
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_btn.c b/drivers/input/touchscreen/cypress/cyttsp4_btn.c
new file mode 100644
index 0000000..a0e498e
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_btn.c
@@ -0,0 +1,527 @@
+/*
+ * cyttsp4_btn.c
+ * Cypress TrueTouch(TM) Standard Product V4 CapSense touch reports module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ * Copyright (C) 2014 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/cyttsp4_bus.h>
+
+#include <linux/delay.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/limits.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+
+#include <linux/cyttsp4_btn.h>
+#include <linux/cyttsp4_core.h>
+#include "cyttsp4_regs.h"
+
+struct cyttsp4_btn_data {
+	struct cyttsp4_device *ttsp;
+	struct cyttsp4_btn_platform_data *pdata;
+	struct cyttsp4_sysinfo *si;
+	struct input_dev *input;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend es;
+#endif
+	struct mutex report_lock;
+	bool is_suspended;
+	bool input_device_registered;
+	char phys[NAME_MAX];
+	u8 pr_buf[CY_MAX_PRBUF_SIZE];
+};
+
+
+static inline void cyttsp4_btn_key_action(struct cyttsp4_btn_data *bd,
+	int btn_no, int btn_state)
+{
+	struct device *dev = &bd->ttsp->dev;
+	struct cyttsp4_sysinfo *si = bd->si;
+
+	if (!si->btn[btn_no].enabled ||
+			si->btn[btn_no].state == btn_state)
+		return;
+
+	si->btn[btn_no].state = btn_state;
+	input_report_key(bd->input, si->btn[btn_no].key_code, btn_state);
+	input_sync(bd->input);
+
+	dev_dbg(dev, "%s: btn=%d key_code=%d %s\n", __func__,
+		btn_no, si->btn[btn_no].key_code,
+		btn_state == CY_BTN_PRESSED ?
+			"PRESSED" : "RELEASED");
+}
+
+static void cyttsp4_get_btn_touches(struct cyttsp4_btn_data *bd)
+{
+	struct cyttsp4_sysinfo *si = bd->si;
+	int num_btn_regs = si->si_ofs.num_btn_regs;
+	int num_btns = si->si_ofs.num_btns;
+	int cur_reg;
+	int cur_reg_val;
+	int cur_btn;
+	int cur_btn_state;
+	int i;
+
+	for (cur_btn = 0, cur_reg = 0; cur_reg < num_btn_regs; cur_reg++) {
+		cur_reg_val = si->xy_mode[si->si_ofs.rep_ofs + 2 + cur_reg];
+
+		for (i = 0; i < CY_NUM_BTN_PER_REG && cur_btn < num_btns;
+				i++, cur_btn++) {
+			/* Get current button state */
+			cur_btn_state = cur_reg_val &
+					((1 << CY_BITS_PER_BTN) - 1);
+			/* Shift reg value for next iteration */
+			cur_reg_val >>= CY_BITS_PER_BTN;
+
+			cyttsp4_btn_key_action(bd, cur_btn, cur_btn_state);
+		}
+	}
+}
+
+static void cyttsp4_btn_lift_all(struct cyttsp4_btn_data *bd)
+{
+	struct cyttsp4_sysinfo *si = bd->si;
+	int i;
+
+	if (!si || si->si_ofs.num_btns == 0)
+		return;
+
+	for (i = 0; i < si->si_ofs.num_btns; i++)
+		cyttsp4_btn_key_action(bd, i, CY_BTN_RELEASED);
+}
+
+#ifdef VERBOSE_DEBUG
+static void cyttsp4_log_btn_data(struct cyttsp4_btn_data *bd)
+{
+	struct device *dev = &bd->ttsp->dev;
+	struct cyttsp4_sysinfo *si = bd->si;
+	int cur;
+	int t;
+
+	for (cur = 0; cur < si->si_ofs.num_btns; cur++) {
+		bd->pr_buf[0] = 0;
+		snprintf(bd->pr_buf, CY_MAX_PRBUF_SIZE, "btn_rec[%d]=0x", cur);
+		for (t = 0; t < si->si_ofs.btn_rec_size; t++)
+			snprintf(bd->pr_buf, CY_MAX_PRBUF_SIZE, "%s%02X",
+				bd->pr_buf, si->btn_rec_data
+				[(cur * si->si_ofs.btn_rec_size) + t]);
+
+		dev_vdbg(dev, "%s: %s\n", __func__, bd->pr_buf);
+	}
+	return;
+}
+#endif
+
+/* read xy_data for all current CapSense button touches */
+static int cyttsp4_xy_worker(struct cyttsp4_btn_data *bd)
+{
+	struct device *dev = &bd->ttsp->dev;
+	struct cyttsp4_sysinfo *si = bd->si;
+	u8 rep_stat = si->xy_mode[si->si_ofs.rep_ofs + 1];
+#ifdef VERBOSE_DEBUG
+	int rc;
+#endif
+
+	/* rep_data for bad packet check */
+	if (IS_BAD_PKT(rep_stat)) {
+		dev_dbg(dev, "%s: Invalid buffer detected\n", __func__);
+		return 0;
+	}
+
+	/* extract button press/release touch information */
+	if (si->si_ofs.num_btns > 0) {
+		cyttsp4_get_btn_touches(bd);
+#ifdef VERBOSE_DEBUG
+		/* read button diff data */
+		rc = cyttsp4_read(bd->ttsp, CY_MODE_OPERATIONAL,
+				si->si_ofs.tt_stat_ofs + 1 +
+				si->si_ofs.max_tchs * si->si_ofs.tch_rec_size,
+				si->btn_rec_data,
+				si->si_ofs.num_btns * si->si_ofs.btn_rec_size);
+		if (rc < 0) {
+			dev_err(dev, "%s: read fail on button regs r=%d\n",
+					__func__, rc);
+			return 0;
+		}
+
+		/* log button press/release touch information */
+		cyttsp4_log_btn_data(bd);
+#endif
+	}
+
+	dev_vdbg(dev, "%s: done\n", __func__);
+
+	return 0;
+}
+
+static int cyttsp4_btn_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_btn_data *bd = dev_get_drvdata(dev);
+	int rc = 0;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	mutex_lock(&bd->report_lock);
+	if (!bd->is_suspended) {
+		/* core handles handshake */
+		rc = cyttsp4_xy_worker(bd);
+	} else {
+		dev_vdbg(dev, "%s: Ignoring report while suspended\n",
+			__func__);
+	}
+	mutex_unlock(&bd->report_lock);
+	if (rc < 0)
+		dev_err(dev, "%s: xy_worker error r=%d\n", __func__, rc);
+
+	return rc;
+}
+
+static int cyttsp4_startup_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_btn_data *bd = dev_get_drvdata(dev);
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	mutex_lock(&bd->report_lock);
+	cyttsp4_btn_lift_all(bd);
+	mutex_unlock(&bd->report_lock);
+
+	return 0;
+}
+
+static int cyttsp4_btn_open(struct input_dev *input)
+{
+	struct device *dev = input->dev.parent;
+	struct cyttsp4_device *ttsp =
+		container_of(dev, struct cyttsp4_device, dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	pm_runtime_get(dev);
+
+	dev_vdbg(dev, "%s: setup subscriptions\n", __func__);
+
+	/* set up touch call back */
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_btn_attention, CY_MODE_OPERATIONAL);
+
+	/* set up startup call back */
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_startup_attention, 0);
+
+	return 0;
+}
+
+static void cyttsp4_btn_close(struct input_dev *input)
+{
+	struct device *dev = input->dev.parent;
+	struct cyttsp4_device *ttsp =
+		container_of(dev, struct cyttsp4_device, dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_btn_attention, CY_MODE_OPERATIONAL);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_startup_attention, 0);
+
+	pm_runtime_put(dev);
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void cyttsp4_btn_early_suspend(struct early_suspend *h)
+{
+	struct cyttsp4_btn_data *bd =
+		container_of(h, struct cyttsp4_btn_data, es);
+	struct device *dev = &bd->ttsp->dev;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+#ifndef CONFIG_PM_RUNTIME
+	mutex_lock(&bd->report_lock);
+	bd->is_suspended = true;
+	cyttsp4_btn_lift_all(bd);
+	mutex_unlock(&bd->report_lock);
+#endif
+
+	pm_runtime_put(dev);
+}
+
+static void cyttsp4_btn_late_resume(struct early_suspend *h)
+{
+	struct cyttsp4_btn_data *bd =
+		container_of(h, struct cyttsp4_btn_data, es);
+	struct device *dev = &bd->ttsp->dev;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+#ifndef CONFIG_PM_RUNTIME
+	mutex_lock(&bd->report_lock);
+	bd->is_suspended = false;
+	mutex_unlock(&bd->report_lock);
+#endif
+
+	pm_runtime_get(dev);
+}
+#endif
+
+#ifdef CONFIG_PM_RUNTIME
+static int cyttsp4_btn_suspend(struct device *dev)
+{
+	struct cyttsp4_btn_data *bd = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&bd->report_lock);
+	bd->is_suspended = true;
+	cyttsp4_btn_lift_all(bd);
+	mutex_unlock(&bd->report_lock);
+
+	return 0;
+}
+
+static int cyttsp4_btn_resume(struct device *dev)
+{
+	struct cyttsp4_btn_data *bd = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&bd->report_lock);
+	bd->is_suspended = false;
+	mutex_unlock(&bd->report_lock);
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops cyttsp4_btn_pm_ops = {
+	SET_RUNTIME_PM_OPS(cyttsp4_btn_suspend, cyttsp4_btn_resume, NULL)
+};
+
+static int cyttsp4_setup_input_device(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_btn_data *bd = dev_get_drvdata(dev);
+	int i;
+	int rc;
+
+	dev_vdbg(dev, "%s: Initialize event signals\n", __func__);
+	__set_bit(EV_KEY, bd->input->evbit);
+	for (i = 0; i < bd->si->si_ofs.num_btns; i++)
+		__set_bit(bd->si->btn[i].key_code, bd->input->keybit);
+
+	rc = input_register_device(bd->input);
+	if (rc < 0)
+		dev_err(dev, "%s: Error, failed register input device r=%d\n",
+			__func__, rc);
+	else
+		bd->input_device_registered = true;
+
+	return rc;
+}
+
+static int cyttsp4_setup_input_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_btn_data *bd = dev_get_drvdata(dev);
+	int rc;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	bd->si = cyttsp4_request_sysinfo(ttsp);
+	if (!bd->si)
+		return -EPERM;
+
+	rc = cyttsp4_setup_input_device(ttsp);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_setup_input_attention, 0);
+
+	return rc;
+}
+
+static int cyttsp4_btn_probe(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_btn_data *bd;
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_btn_platform_data *pdata = dev_get_platdata(dev);
+	int rc = 0;
+
+	dev_info(dev, "%s\n", __func__);
+	dev_dbg(dev, "%s: debug on\n", __func__);
+	dev_vdbg(dev, "%s: verbose debug on\n", __func__);
+
+	if (pdata == NULL) {
+		dev_err(dev, "%s: Missing platform data\n", __func__);
+		rc = -ENODEV;
+		goto error_no_pdata;
+	}
+
+	bd = kzalloc(sizeof(*bd), GFP_KERNEL);
+	if (bd == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto error_alloc_data_failed;
+	}
+
+	mutex_init(&bd->report_lock);
+	bd->ttsp = ttsp;
+	bd->pdata = pdata;
+	dev_set_drvdata(dev, bd);
+	/* Create the input device and register it. */
+	dev_vdbg(dev, "%s: Create the input device and register it\n",
+		__func__);
+	bd->input = input_allocate_device();
+	if (bd->input == NULL) {
+		dev_err(dev, "%s: Error, failed to allocate input device\n",
+			__func__);
+		rc = -ENOSYS;
+		goto error_alloc_failed;
+	}
+
+	bd->input->name = ttsp->name;
+	scnprintf(bd->phys, sizeof(bd->phys)-1, "%s", dev_name(dev));
+	bd->input->phys = bd->phys;
+	bd->input->dev.parent = &bd->ttsp->dev;
+	bd->input->open = cyttsp4_btn_open;
+	bd->input->close = cyttsp4_btn_close;
+	input_set_drvdata(bd->input, bd);
+
+	pm_runtime_enable(dev);
+
+	/* get sysinfo */
+	bd->si = cyttsp4_request_sysinfo(ttsp);
+	if (bd->si) {
+		rc = cyttsp4_setup_input_device(ttsp);
+		if (rc)
+			goto error_init_input;
+	} else {
+		dev_err(dev, "%s: Fail get sysinfo pointer from core p=%p\n",
+			__func__, bd->si);
+		cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_input_attention, 0);
+	}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	bd->es.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	bd->es.suspend = cyttsp4_btn_early_suspend;
+	bd->es.resume = cyttsp4_btn_late_resume;
+	register_early_suspend(&bd->es);
+#endif
+
+	dev_dbg(dev, "%s: ok\n", __func__);
+	return 0;
+
+error_init_input:
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+	input_free_device(bd->input);
+error_alloc_failed:
+	dev_set_drvdata(dev, NULL);
+	kfree(bd);
+error_alloc_data_failed:
+error_no_pdata:
+	dev_err(dev, "%s failed.\n", __func__);
+	return rc;
+}
+
+static int cyttsp4_btn_release(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_btn_data *bd = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	/*
+	 * This check is to prevent pm_runtime usage_count drop below zero
+	 * because of removing the module while in suspended state
+	 */
+	if (bd->is_suspended)
+		pm_runtime_get_noresume(dev);
+
+	unregister_early_suspend(&bd->es);
+#endif
+
+	if (bd->input_device_registered) {
+		input_unregister_device(bd->input);
+	} else {
+		input_free_device(bd->input);
+		cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_input_attention, 0);
+	}
+
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+
+	dev_set_drvdata(dev, NULL);
+	kfree(bd);
+	return 0;
+}
+
+static struct cyttsp4_driver cyttsp4_btn_driver = {
+	.probe = cyttsp4_btn_probe,
+	.remove = cyttsp4_btn_release,
+	.driver = {
+		.name = CYTTSP4_BTN_NAME,
+		.bus = &cyttsp4_bus_type,
+		.owner = THIS_MODULE,
+		.pm = &cyttsp4_btn_pm_ops,
+	},
+};
+
+static int __init cyttsp4_btn_init(void)
+{
+	int rc = 0;
+	rc = cyttsp4_register_driver(&cyttsp4_btn_driver);
+	pr_info("%s: Cypress TTSP MT v4 CapSense BTN (Built %s), rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return rc;
+}
+module_init(cyttsp4_btn_init);
+
+static void __exit cyttsp4_btn_exit(void)
+{
+	cyttsp4_unregister_driver(&cyttsp4_btn_driver);
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_btn_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TTSP 2D multi-touch CapSense BTN driver");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_bus.c b/drivers/input/touchscreen/cypress/cyttsp4_bus.c
new file mode 100644
index 0000000..2aa483c
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_bus.c
@@ -0,0 +1,761 @@
+/*
+ * cyttsp4_bus.c
+ * Cypress TrueTouch(TM) Standard Product V4 Bus Driver.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ * Copyright (C) 2014 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov aleksej.makarov@sonyericsson.com
+ * Modified by: Cypress Semiconductor for complete set of TTSP Bus interfaces.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/cyttsp4_bus.h>
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/limits.h>
+
+static DEFINE_MUTEX(core_lock);
+static LIST_HEAD(adapter_list);
+static LIST_HEAD(core_dev_list);
+static LIST_HEAD(cyttsp4_dev_list);
+
+struct bus_type cyttsp4_bus_type;
+
+static void cyttsp4_dev_release(struct device *dev)
+{
+	dev_vdbg(dev, "%s: Enter\n", __func__);
+	put_device(dev->parent);
+}
+
+static struct device_type cyttsp4_dev_type = {
+	.release = cyttsp4_dev_release
+};
+
+static struct device_type cyttsp4_core_type = {
+	.release = cyttsp4_dev_release
+};
+
+static int cyttsp4_match_dev(struct device *dev, void *data)
+{
+	return dev == (struct device *)data;
+}
+
+static void cyttsp4_initialize_device(struct cyttsp4_device *dev,
+		struct cyttsp4_device_info const *dev_info)
+{
+	dev->name = dev_info->name;
+	dev->core_id = dev_info->core_id;
+	dev->dev.platform_data = dev_info->platform_data;
+}
+
+static void _cyttsp4_reinitialize_device(struct cyttsp4_device *dev)
+{
+	void *platform_data = dev->dev.platform_data;
+
+	memset(&dev->dev, 0, sizeof(dev->dev));
+	dev->dev.platform_data = platform_data;
+	dev->core = NULL;
+}
+
+static void cyttsp4_initialize_core(struct cyttsp4_core *core,
+		struct cyttsp4_core_info const *core_info)
+{
+	core->name = core_info->name;
+	core->id = core_info->id;
+	core->adap_id = core_info->adap_id;
+	core->dev.platform_data = core_info->platform_data;
+}
+
+static void _cyttsp4_reinitialize_core(struct cyttsp4_core *core)
+{
+	void *platform_data = core->dev.platform_data;
+
+	memset(&core->dev, 0, sizeof(core->dev));
+	core->dev.platform_data = platform_data;
+	core->adap = NULL;
+}
+
+static int _cyttsp4_register_dev(struct cyttsp4_device *pdev,
+		struct cyttsp4_core *core)
+{
+	int ret;
+
+	/* Check if the device is registered with the system */
+	if (bus_find_device(&cyttsp4_bus_type, NULL, &pdev->dev,
+			cyttsp4_match_dev)) {
+		put_device(&pdev->dev);
+		return -EEXIST;
+	}
+
+	pdev->core = core;
+	pdev->dev.parent = get_device(&core->dev);
+	pdev->dev.bus = &cyttsp4_bus_type;
+	pdev->dev.type = &cyttsp4_dev_type;
+	dev_set_name(&pdev->dev, "%s.%s", pdev->name,  core->id);
+
+	ret = device_register(&pdev->dev);
+	dev_dbg(&pdev->dev,
+		"%s: Registering device '%s'. Parent at '%s', err = %d\n",
+		 __func__, dev_name(&pdev->dev),
+		 dev_name(pdev->dev.parent), ret);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to register device, err %d\n",
+			__func__, ret);
+		pdev->core = NULL;
+	}
+	return ret;
+}
+
+static void _cyttsp4_unregister_dev(struct cyttsp4_device *pdev)
+{
+	/* Check if the device is registered with the system */
+	if (!bus_find_device(&cyttsp4_bus_type, NULL, &pdev->dev,
+			cyttsp4_match_dev))
+		return;
+
+	dev_dbg(&pdev->dev, "%s: Unregistering device '%s'.\n",
+		__func__, dev_name(&pdev->dev));
+	/* Put reference taken by bus_find_device() */
+	put_device(&pdev->dev);
+	device_unregister(&pdev->dev);
+}
+
+static int _cyttsp4_register_core(struct cyttsp4_core *pdev,
+		struct cyttsp4_adapter *adap)
+{
+	int ret;
+
+	/* Check if the device is registered with the system */
+	if (bus_find_device(&cyttsp4_bus_type, NULL, &pdev->dev,
+			cyttsp4_match_dev)) {
+		put_device(&pdev->dev);
+		return -EEXIST;
+	}
+
+	pdev->adap = adap;
+	pdev->dev.parent = get_device(adap->dev);
+	pdev->dev.bus = &cyttsp4_bus_type;
+	pdev->dev.type = &cyttsp4_core_type;
+	dev_set_name(&pdev->dev, "%s.%s", pdev->id,  adap->id);
+
+	ret = device_register(&pdev->dev);
+	dev_dbg(&pdev->dev,
+		"%s: Registering device '%s'. Parent at '%s', err = %d\n",
+		 __func__, dev_name(&pdev->dev),
+		 dev_name(pdev->dev.parent), ret);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to register device, err %d\n",
+			__func__, ret);
+		pdev->adap = NULL;
+	}
+	return ret;
+}
+
+static void _cyttsp4_unregister_core(struct cyttsp4_core *pdev)
+{
+	/* Check if the core is registered with the system */
+	if (!bus_find_device(&cyttsp4_bus_type, NULL, &pdev->dev,
+			cyttsp4_match_dev))
+		return;
+
+	dev_dbg(&pdev->dev, "%s: Unregistering core '%s'.\n",
+		__func__, dev_name(&pdev->dev));
+	/* Put reference taken by bus_find_device() */
+	put_device(&pdev->dev);
+	device_unregister(&pdev->dev);
+}
+
+static void _cyttsp4_unregister_and_reinitialize_devices(
+		struct cyttsp4_core *core)
+{
+	struct cyttsp4_device *dev;
+
+	list_for_each_entry(dev, &cyttsp4_dev_list, node)
+		if (dev->core == core) {
+			_cyttsp4_unregister_dev(dev);
+			_cyttsp4_reinitialize_device(dev);
+		}
+}
+
+static struct cyttsp4_adapter *find_adapter(char const *adap_id)
+{
+	struct cyttsp4_adapter *a;
+
+	list_for_each_entry(a, &adapter_list, node)
+		if (!strncmp(a->id, adap_id, NAME_MAX))
+			return a;
+	return NULL;
+}
+
+static struct cyttsp4_core *find_core(char const *core_id)
+{
+	struct cyttsp4_core *d;
+
+	list_for_each_entry(d, &core_dev_list, node)
+		if (!strncmp(d->id, core_id, NAME_MAX))
+			return d;
+	return NULL;
+}
+
+static struct cyttsp4_core *find_core_with_driver(char const *core_id)
+{
+	struct cyttsp4_core *d;
+
+	d = find_core(core_id);
+	if (d && d->dev.driver)
+		return d;
+	return NULL;
+}
+
+static struct cyttsp4_device *find_device(char const *name,
+		char const *core_id)
+{
+	struct cyttsp4_device *d;
+
+	list_for_each_entry(d, &cyttsp4_dev_list, node)
+		if (!strncmp(d->name, name, NAME_MAX) &&
+				!strncmp(d->core_id, core_id, NAME_MAX))
+			return d;
+	return NULL;
+}
+
+static void rescan_devices(struct cyttsp4_core *core)
+{
+	struct cyttsp4_device *d;
+
+	list_for_each_entry(d, &cyttsp4_dev_list, node)
+		if (!d->core && !strncmp(core->id, d->core_id, NAME_MAX))
+			_cyttsp4_register_dev(d, core);
+}
+
+static void rescan_cores(struct cyttsp4_adapter *adap)
+{
+	struct cyttsp4_core *d;
+
+	list_for_each_entry(d, &core_dev_list, node)
+		if (!d->adap && !strncmp(adap->id, d->adap_id, NAME_MAX))
+			_cyttsp4_register_core(d, adap);
+}
+
+static int cyttsp4_check_device_info(
+	struct cyttsp4_device_info const *dev_info)
+{
+	int len;
+
+	if (!dev_info->name)
+		return -EINVAL;
+	if (!dev_info->core_id)
+		return -EINVAL;
+
+	len = strnlen(dev_info->name, NAME_MAX);
+	if (len == 0 || len == NAME_MAX)
+		return -EINVAL;
+
+	len = strnlen(dev_info->core_id, NAME_MAX);
+	if (len == 0 || len == NAME_MAX)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int cyttsp4_check_core_info(
+	struct cyttsp4_core_info const *core_info)
+{
+	int len;
+
+	if (!core_info->name)
+		return -EINVAL;
+	if (!core_info->id)
+		return -EINVAL;
+	if (!core_info->adap_id)
+		return -EINVAL;
+
+	len = strnlen(core_info->name, NAME_MAX);
+	if (len == 0 || len == NAME_MAX)
+		return -EINVAL;
+
+	len = strnlen(core_info->id, NAME_MAX);
+	if (len == 0 || len == NAME_MAX)
+		return -EINVAL;
+
+	len = strnlen(core_info->adap_id, NAME_MAX);
+	if (len == 0 || len == NAME_MAX)
+		return -EINVAL;
+
+	return 0;
+}
+
+int cyttsp4_register_device(struct cyttsp4_device_info const *dev_info)
+{
+	struct cyttsp4_device *dev;
+	struct cyttsp4_core *core;
+	int ret;
+
+	if (!dev_info) {
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	ret = cyttsp4_check_device_info(dev_info);
+	if (ret) {
+		pr_debug("%s: dev_info is invalid\n", __func__);
+		goto fail;
+	}
+
+	mutex_lock(&core_lock);
+	if (find_device(dev_info->name, dev_info->core_id)) {
+		pr_debug("%s: device '%s' with core id '%s' already exists\n",
+			__func__, dev_info->name, dev_info->core_id);
+		ret = -EEXIST;
+		goto fail_unlock;
+	}
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev) {
+		pr_err("%s: failed to allocate device '%s'\n",
+			__func__, dev_info->name);
+		ret = -ENOMEM;
+		goto fail_unlock;
+	}
+	cyttsp4_initialize_device(dev, dev_info);
+	list_add(&dev->node, &cyttsp4_dev_list);
+	pr_debug("%s: '%s' added to cyttsp4_dev_list\n", __func__, dev->name);
+	core = find_core_with_driver(dev->core_id);
+	if (core)
+		ret = _cyttsp4_register_dev(dev, core);
+fail_unlock:
+	mutex_unlock(&core_lock);
+fail:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_register_device);
+
+int cyttsp4_unregister_device(char const *name, char const *core_id)
+{
+	struct cyttsp4_device *dev;
+	int ret = 0;
+
+	if (!name || !core_id) {
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	mutex_lock(&core_lock);
+	dev = find_device(name, core_id);
+	if (!dev) {
+		pr_err("%s: device '%s' could not be found\n", __func__, name);
+		ret = -ENODEV;
+		goto fail_unlock;
+	}
+	_cyttsp4_unregister_dev(dev);
+	list_del(&dev->node);
+	pr_debug("%s: '%s' removed from cyttsp4_dev_list\n", __func__,
+		dev->name);
+	kfree(dev);
+fail_unlock:
+	mutex_unlock(&core_lock);
+fail:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_unregister_device);
+
+int cyttsp4_register_core_device(struct cyttsp4_core_info const *core_info)
+{
+	struct cyttsp4_core *core;
+	struct cyttsp4_adapter *adap;
+	int ret;
+
+	if (!core_info) {
+		ret = -EINVAL;
+		goto fail;
+	}
+
+	ret = cyttsp4_check_core_info(core_info);
+	if (ret) {
+		pr_debug("%s: core_info is invalid\n", __func__);
+		goto fail;
+	}
+
+	mutex_lock(&core_lock);
+	if (find_core(core_info->id)) {
+		pr_debug("%s: core id '%s' already exists\n",
+				__func__, core_info->id);
+		ret = -EEXIST;
+		goto fail_unlock;
+	}
+	core = kzalloc(sizeof(*core), GFP_KERNEL);
+	if (!core) {
+		pr_err("%s: failed to allocate core device '%s'\n",
+			__func__, core_info->name);
+		ret = -ENOMEM;
+		goto fail_unlock;
+	}
+	cyttsp4_initialize_core(core, core_info);
+	list_add(&core->node, &core_dev_list);
+	pr_debug("%s: '%s' added to core_dev_list\n", __func__, core->name);
+	adap = find_adapter(core->adap_id);
+	if (adap) {
+		pr_debug("%s: adapter for '%s' is '%s'\n", __func__,
+				core->id, dev_name(adap->dev));
+		ret = _cyttsp4_register_core(core, adap);
+		if (!ret)
+			rescan_devices(core);
+	}
+fail_unlock:
+	mutex_unlock(&core_lock);
+fail:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_register_core_device);
+
+int cyttsp4_add_adapter(char const *id, struct cyttsp4_ops const *ops,
+		struct device *parent)
+{
+	int rc = 0;
+	struct cyttsp4_adapter *a;
+
+	if (!parent) {
+		dev_err(parent, "%s: need parent for '%s'\n", __func__, id);
+		return -EINVAL;
+	}
+	mutex_lock(&core_lock);
+	if (find_adapter(id)) {
+		dev_err(parent, "%s: adapter '%s' already exists\n",
+				__func__, id);
+		rc = -EEXIST;
+		goto fail;
+	}
+	a = kzalloc(sizeof(*a), GFP_KERNEL);
+	if (!a) {
+		dev_err(parent, "%s: failed to allocate adapter '%s'\n",
+				__func__, id);
+		rc = -ENOMEM;
+		goto fail;
+	}
+	memcpy(a->id, id, sizeof(a->id));
+	a->id[sizeof(a->id) - 1] = 0;
+	a->read = ops->read;
+	a->write = ops->write;
+	a->dev = parent;
+	list_add(&a->node, &adapter_list);
+	dev_dbg(parent, "%s: '%s' added to adapter_list\n", __func__, id);
+	rescan_cores(a);
+fail:
+	mutex_unlock(&core_lock);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_add_adapter);
+
+int cyttsp4_del_adapter(char const *id)
+{
+	int rc = 0;
+	struct cyttsp4_adapter *adap;
+	struct cyttsp4_core *core;
+
+	mutex_lock(&core_lock);
+	adap = find_adapter(id);
+	if (!adap) {
+		pr_err("%s: adapter '%s' does not exist\n",
+			__func__, id);
+		rc = -ENODEV;
+		goto fail;
+	}
+
+	/* Unregister core and devices linked to this adapter
+	 * This is to prevent core and devices get probed until
+	 * their corresponding adapter is re-added
+	 */
+	list_for_each_entry(core, &core_dev_list, node) {
+		if (core->adap != adap)
+			continue;
+		_cyttsp4_unregister_and_reinitialize_devices(core);
+		_cyttsp4_unregister_core(core);
+		_cyttsp4_reinitialize_core(core);
+	}
+
+	list_del(&adap->node);
+	kfree(adap);
+	pr_debug("%s: '%s' removed from adapter_list\n", __func__, id);
+fail:
+	mutex_unlock(&core_lock);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_del_adapter);
+
+static struct cyttsp4_device *verify_device_type(struct device *dev)
+{
+	return dev->type == &cyttsp4_dev_type ? to_cyttsp4_device(dev) : NULL;
+}
+
+static struct cyttsp4_core *verify_core_type(struct device *dev)
+{
+	return dev->type == &cyttsp4_core_type ? to_cyttsp4_core(dev) : NULL;
+}
+
+static int cyttsp4_device_match(struct device *dev, struct device_driver *drv)
+{
+	struct cyttsp4_device *cyttsp4_dev = verify_device_type(dev);
+	struct cyttsp4_core *cyttsp4_core;
+	int match;
+
+	if (cyttsp4_dev) {
+		match = strncmp(cyttsp4_dev->name, drv->name, NAME_MAX) == 0;
+		goto exit;
+	}
+	cyttsp4_core = verify_core_type(dev);
+	if (cyttsp4_core) {
+		match = strncmp(cyttsp4_core->name, drv->name, NAME_MAX) == 0;
+		goto exit;
+	}
+	match = 0;
+exit:
+	dev_dbg(dev, "%s: %s matching '%s' driver\n", __func__,
+			match ? "is" : "isn't", drv->name);
+	return match;
+}
+
+static ssize_t modalias_show(struct device *dev, struct device_attribute *a,
+			     char *buf)
+{
+	struct cyttsp4_device *cyttsp4_dev = verify_device_type(dev);
+	struct cyttsp4_core *cyttsp4_core;
+
+	char const *name;
+	int len;
+
+	if (cyttsp4_dev) {
+		name = cyttsp4_dev->name;
+		goto exit;
+	}
+	cyttsp4_core = verify_core_type(dev);
+	if (cyttsp4_core) {
+		name = cyttsp4_core->id;
+		goto exit;
+	}
+	name = "none";
+exit:
+	len = snprintf(buf, PAGE_SIZE, "ttsp4:%s\n", name);
+	return (len >= PAGE_SIZE) ? (PAGE_SIZE - 1) : len;
+}
+
+static struct device_attribute cyttsp4_dev_attrs[] = {
+	__ATTR_RO(modalias),
+	__ATTR_NULL,
+};
+
+#ifdef CONFIG_SUSPEND
+static int cyttsp4_pm_suspend(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+
+	dev_dbg(dev, "%s\n", __func__);
+	if (drv && drv->pm && drv->pm->suspend)
+		return drv->pm->suspend(dev);
+	return 0;
+}
+
+static int cyttsp4_pm_resume(struct device *dev)
+{
+	struct device_driver *drv = dev->driver;
+
+	dev_dbg(dev, "%s\n", __func__);
+	if (drv && drv->pm && drv->pm->resume)
+		return drv->pm->resume(dev);
+	return 0;
+}
+#else /* !CONFIG_SUSPEND */
+#define cyttsp4_pm_suspend		NULL
+#define cyttsp4_pm_resume		NULL
+#endif /* !CONFIG_SUSPEND */
+
+#ifdef CONFIG_PM_RUNTIME
+#define cyttsp4_pm_rt_suspend		pm_generic_runtime_suspend
+#define cyytsp4_pm_rt_resume		pm_generic_runtime_resume
+#define cyytsp4_pm_rt_idle		pm_generic_runtime_idle
+#else /* !CONFIG_PM_RUNTIME */
+#define cyttsp4_pm_rt_suspend		NULL
+#define cyytsp4_pm_rt_resume		NULL
+#define cyytsp4_pm_rt_idle		NULL
+#endif /* !CONFIG_PM_RUNTIME */
+
+static const struct dev_pm_ops cyttsp4_dev_pm_ops = {
+	.suspend = cyttsp4_pm_suspend,
+	.resume = cyttsp4_pm_resume,
+	.runtime_suspend = cyttsp4_pm_rt_suspend,
+	.runtime_resume = cyytsp4_pm_rt_resume,
+	.runtime_idle = cyytsp4_pm_rt_idle,
+};
+
+struct bus_type cyttsp4_bus_type = {
+	.name		= "ttsp4",
+	.dev_attrs	= cyttsp4_dev_attrs,
+	.match		= cyttsp4_device_match,
+	.uevent		= NULL,
+	.pm		= &cyttsp4_dev_pm_ops,
+};
+EXPORT_SYMBOL_GPL(cyttsp4_bus_type);
+
+static int cyttsp4_drv_remove(struct device *_dev)
+{
+	struct cyttsp4_driver *drv = to_cyttsp4_driver(_dev->driver);
+	struct cyttsp4_device *dev = to_cyttsp4_device(_dev);
+	struct cyttsp4_core *core = dev->core;
+	int ret;
+
+	ret = drv->remove(dev);
+	/* Decrease usage count of the core driver */
+	module_put(core->dev.driver->owner);
+	return ret;
+}
+
+static int cyttsp4_core_drv_remove(struct device *_dev)
+{
+	struct cyttsp4_core_driver *drv = to_cyttsp4_core_driver(_dev->driver);
+	struct cyttsp4_core *core = to_cyttsp4_core(_dev);
+	struct cyttsp4_adapter *adap = core->adap;
+	int ret;
+
+	ret = drv->remove(core);
+	/* Decrease usage count of the adapter driver */
+	module_put(adap->dev->driver->owner);
+
+	mutex_lock(&core_lock);
+	/* Unregister devices linked to this core
+	 * This is to prevent devices get probed until
+	 * their corresponding core driver is re-added
+	 */
+	_cyttsp4_unregister_and_reinitialize_devices(core);
+	mutex_unlock(&core_lock);
+
+	return ret;
+}
+
+static int cyttsp4_drv_probe(struct device *_dev)
+{
+	struct cyttsp4_driver *drv = to_cyttsp4_driver(_dev->driver);
+	struct cyttsp4_device *dev = to_cyttsp4_device(_dev);
+	struct cyttsp4_core *core = dev->core;
+	int rc;
+
+	if (!core || !core->dev.driver)
+		return -ENODEV;
+
+	/* Increase usage count of the core driver*/
+	__module_get(core->dev.driver->owner);
+
+	rc = drv->probe(dev);
+	if (rc)
+		module_put(core->dev.driver->owner);
+	dev_dbg(_dev, "%s: for %s = %d\n", __func__, dev->name, rc);
+	return rc;
+}
+
+static int cyttsp4_core_drv_probe(struct device *_dev)
+{
+	struct cyttsp4_core_driver *drv = to_cyttsp4_core_driver(_dev->driver);
+	struct cyttsp4_core *dev = to_cyttsp4_core(_dev);
+	struct cyttsp4_adapter *adap = dev->adap;
+	int rc;
+
+	if (!adap || !adap->dev->driver)
+		return -ENODEV;
+
+	/* Increase usage count of the adapter driver*/
+	__module_get(adap->dev->driver->owner);
+
+	rc = drv->probe(dev);
+	dev_dbg(_dev, "%s: for %s = %d\n", __func__, dev->name, rc);
+	if (!rc)
+		rescan_devices(dev);
+	else
+		module_put(adap->dev->driver->owner);
+	return rc;
+}
+
+int cyttsp4_register_driver(struct cyttsp4_driver *drv)
+{
+	int ret;
+
+	drv->driver.bus = &cyttsp4_bus_type;
+	if (drv->probe)
+		drv->driver.probe = cyttsp4_drv_probe;
+	if (drv->remove)
+		drv->driver.remove = cyttsp4_drv_remove;
+	ret = driver_register(&drv->driver);
+	pr_debug("%s: '%s' returned %d\n", __func__, drv->driver.name, ret);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_register_driver);
+
+int cyttsp4_register_core_driver(struct cyttsp4_core_driver *drv)
+{
+	int ret;
+
+	drv->driver.bus = &cyttsp4_bus_type;
+	if (drv->probe)
+		drv->driver.probe = cyttsp4_core_drv_probe;
+	if (drv->remove)
+		drv->driver.remove = cyttsp4_core_drv_remove;
+	ret = driver_register(&drv->driver);
+	pr_debug("%s: '%s' returned %d\n", __func__, drv->driver.name, ret);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_register_core_driver);
+
+void cyttsp4_unregister_driver(struct cyttsp4_driver *drv)
+{
+	driver_unregister(&drv->driver);
+}
+EXPORT_SYMBOL_GPL(cyttsp4_unregister_driver);
+
+void cyttsp4_unregister_core_driver(struct cyttsp4_core_driver *drv)
+{
+	driver_unregister(&drv->driver);
+}
+EXPORT_SYMBOL_GPL(cyttsp4_unregister_core_driver);
+
+static int __init cyttsp4_bus_init(void)
+{
+	int error;
+	error =  bus_register(&cyttsp4_bus_type);
+	if (error)
+		pr_err("%s: error %d\n", __func__, error);
+	else
+		pr_debug("%s: ok\n", __func__);
+	return error;
+}
+
+static void __exit cyttsp4_bus_exit(void)
+{
+	pr_debug("%s: ok\n", __func__);
+}
+
+subsys_initcall(cyttsp4_bus_init);
+module_exit(cyttsp4_bus_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Aleksej Makarov <aleksej.makarov@sonyericsson.com>");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_core.c b/drivers/input/touchscreen/cypress/cyttsp4_core.c
new file mode 100644
index 0000000..e9e38fc
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_core.c
@@ -0,0 +1,4314 @@
+/*
+ * cyttsp4_core.c
+ * Cypress TrueTouch(TM) Standard Product V4 Core driver module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ * Copyright (C) 2014 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ * Modified by: Cypress Semiconductor to add device functions
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/cyttsp4_bus.h>
+
+#include <asm/unaligned.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/limits.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <linux/cyttsp4_core.h>
+#include "cyttsp4_regs.h"
+
+#include <linux/debugfs.h>
+#ifdef CONFIG_FB
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#endif
+
+#define CY_DEBUG_DIR_NAME	"ts_debug"
+#define CY_INFO_MAX_LEN		512
+/* CHECK_PANEL_ID used for check panel id,
+ * if you do not want to use, please disable.
+ */
+#define CHECK_PANEL_ID		1
+#ifdef CHECK_PANEL_ID
+#define CY_IC_ID_ADDR		0x10
+#endif
+
+/* Timeout in ms. */
+#define CY_CORE_REQUEST_EXCLUSIVE_TIMEOUT	500
+#define CY_CORE_SLEEP_REQUEST_EXCLUSIVE_TIMEOUT	5000
+#define CY_CORE_WAIT_SYSINFO_MODE_TIMEOUT	2000
+#define CY_CORE_MODE_CHANGE_TIMEOUT		1000
+#define CY_CORE_RESET_AND_WAIT_TIMEOUT		500
+#define CY_CORE_WAKEUP_TIMEOUT			50
+
+#define CY_CORE_STARTUP_RETRY_COUNT		3
+
+#define IS_DEEP_SLEEP_CONFIGURED(x) \
+		((x) == 0 || (x) == 0xFF)
+
+#define IS_TMO(t)	((t) == 0)
+
+#define PUT_FIELD16(si, val, addr) \
+do { \
+	if (IS_LITTLEENDIAN((si)->si_ptrs.cydata->device_info)) \
+		put_unaligned_le16(val, addr); \
+	else \
+		put_unaligned_be16(val, addr); \
+} while (0)
+
+#define GET_FIELD16(si, addr) \
+({ \
+	u16 __val; \
+	if (IS_LITTLEENDIAN((si)->si_ptrs.cydata->device_info)) \
+		__val = get_unaligned_le16(addr); \
+	else \
+		__val = get_unaligned_be16(addr); \
+	__val; \
+})
+
+#define RETRY_OR_EXIT(retry_cnt, retry_label, exit_label) \
+do { \
+	if (retry_cnt) \
+		goto retry_label; \
+	goto exit_label; \
+} while (0)
+
+static const u8 security_key[] = {
+	0xA5, 0x01, 0x02, 0x03, 0xFF, 0xFE, 0xFD, 0x5A
+};
+
+static const u8 ldr_exit[] = {
+	0xFF, 0x01, 0x3B, 0x00, 0x00, 0x4F, 0x6D, 0x17
+};
+
+static const u8 ldr_err_app[] = {
+	0x01, 0x02, 0x00, 0x00, 0x55, 0xDD, 0x17
+};
+
+MODULE_FIRMWARE(CY_FW_FILE_NAME);
+
+const char *cy_driver_core_name = CYTTSP4_CORE_NAME;
+const char *cy_driver_core_version = CY_DRIVER_VERSION;
+const char *cy_driver_core_date = CY_DRIVER_DATE;
+
+enum cyttsp4_sleep_state {
+	SS_SLEEP_OFF,
+	SS_SLEEP_ON,
+	SS_SLEEPING,
+	SS_WAKING,
+};
+
+enum cyttsp4_startup_state {
+	STARTUP_NONE,
+	STARTUP_QUEUED,
+	STARTUP_RUNNING,
+};
+
+struct cyttsp4_core_data {
+	struct device *dev;
+	struct cyttsp4_core *core;
+	struct list_head atten_list[CY_ATTEN_NUM_ATTEN];
+	struct mutex system_lock;
+	struct mutex adap_lock;
+	enum cyttsp4_mode mode;
+	enum cyttsp4_sleep_state sleep_state;
+	enum cyttsp4_startup_state startup_state;
+	int int_status;
+	int cmd_toggle;
+	spinlock_t spinlock;
+	struct cyttsp4_core_platform_data *pdata;
+	wait_queue_head_t wait_q;
+	int irq;
+	struct work_struct startup_work;
+	struct cyttsp4_sysinfo sysinfo;
+	struct dentry *dir;
+	void *exclusive_dev;
+	int exclusive_waits;
+	atomic_t ignore_irq;
+	u8 enable;
+	bool irq_enabled;
+	bool irq_wake;
+	bool wake_initiated_by_device;
+	bool invalid_touch_app;
+	int max_xfer;
+	int apa_mc_en;
+	int glove_en;
+	int stylus_en;
+	int proximity_en;
+	u8 default_scantype;
+	u8 easy_wakeup_gesture;
+	unsigned int active_refresh_cycle_ms;
+	u8 heartbeat_count;
+#ifdef VERBOSE_DEBUG
+	u8 pr_buf[CY_MAX_PRBUF_SIZE];
+#endif
+	struct work_struct watchdog_work;
+	struct timer_list watchdog_timer;
+#ifdef CONFIG_FB
+	struct notifier_block fb_notif;
+#endif
+	u16 addr;
+	char *ts_info;
+	bool suspended;
+};
+
+struct atten_node {
+	struct list_head node;
+	int (*func)(struct cyttsp4_device *);
+	struct cyttsp4_device *ttsp;
+	int mode;
+};
+
+static int _cyttsp4_put_device_into_deep_sleep(struct cyttsp4_core_data *cd,
+		u8 hst_mode_reg);
+
+static inline size_t merge_bytes(u8 high, u8 low)
+{
+	return (high << 8) + low;
+}
+
+#ifdef VERBOSE_DEBUG
+void cyttsp4_pr_buf(struct device *dev, u8 *pr_buf, u8 *dptr, int size,
+		const char *data_name)
+{
+	int i, k;
+	const char fmt[] = "%02X ";
+	int max;
+
+	if (!size)
+		return;
+
+	max = (CY_MAX_PRBUF_SIZE - 1) - sizeof(CY_PR_TRUNCATED);
+
+	pr_buf[0] = 0;
+	for (i = k = 0; i < size && k < max; i++, k += 3)
+		scnprintf(pr_buf + k, CY_MAX_PRBUF_SIZE, fmt, dptr[i]);
+
+	dev_vdbg(dev, "%s:  %s[0..%d]=%s%s\n", __func__, data_name, size - 1,
+			pr_buf, size <= max ? "" : CY_PR_TRUNCATED);
+}
+EXPORT_SYMBOL_GPL(cyttsp4_pr_buf);
+#endif
+
+static inline int cyttsp4_adap_read(struct cyttsp4_core_data *cd, u16 addr,
+		void *buf, int size)
+{
+	return cd->core->adap->read(cd->core->adap, addr, buf, size,
+			cd->max_xfer);
+}
+
+static inline int cyttsp4_adap_write(struct cyttsp4_core_data *cd, u16 addr,
+		const void *buf, int size)
+{
+	return cd->core->adap->write(cd->core->adap, addr, buf, size,
+			cd->max_xfer);
+}
+
+/* cyttsp4_platform_detect_read()
+ *
+ * This function is passed to platform detect
+ * function to perform a read operation
+ */
+static int cyttsp4_platform_detect_read(struct device *dev, u16 addr,
+		void *buf, int size)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	return cd->core->adap->read(cd->core->adap, addr, buf, size,
+			cd->max_xfer);
+}
+
+static u16 cyttsp4_calc_partial_app_crc(const u8 *data, int size, u16 crc)
+{
+	int i, j;
+
+	for (i = 0; i < size; i++) {
+		crc ^= ((u16)data[i] << 8);
+		for (j = 8; j > 0; j--)
+			if (crc & 0x8000)
+				crc = (crc << 1) ^ 0x1021;
+			else
+				crc <<= 1;
+	}
+
+	return crc;
+}
+
+static inline u16 cyttsp4_calc_app_crc(const u8 *data, int size)
+{
+	return cyttsp4_calc_partial_app_crc(data, size, 0xFFFF);
+}
+
+static const u8 *cyttsp4_get_security_key_(struct cyttsp4_device *ttsp,
+		int *size)
+{
+	if (size)
+		*size = sizeof(security_key);
+
+	return security_key;
+}
+
+static inline void cyttsp4_get_touch_axis(struct cyttsp4_core_data *cd,
+		int *axis, int size, int max, u8 *xy_data, int bofs)
+{
+	int nbyte;
+	int next;
+
+	for (nbyte = 0, *axis = 0, next = 0; nbyte < size; nbyte++) {
+		dev_vdbg(cd->dev,
+			"%s: *axis=%02X(%d) size=%d max=%08X xy_data=%p"
+			" xy_data[%d]=%02X(%d) bofs=%d\n",
+			__func__, *axis, *axis, size, max, xy_data, next,
+			xy_data[next], xy_data[next], bofs);
+		*axis = (*axis * 256) + (xy_data[next] >> bofs);
+		next++;
+	}
+
+	*axis &= max - 1;
+
+	dev_vdbg(cd->dev,
+		"%s: *axis=%02X(%d) size=%d max=%08X xy_data=%p"
+		" xy_data[%d]=%02X(%d)\n",
+		__func__, *axis, *axis, size, max, xy_data, next,
+		xy_data[next], xy_data[next]);
+}
+
+/*
+ * cyttsp4_get_touch_record_()
+ *
+ * Fills touch info for a touch record specified by rec_no
+ * Should only be called in Operational mode IRQ attention and
+ * rec_no should be less than the number of current touch records
+ */
+static void cyttsp4_get_touch_record_(struct cyttsp4_device *ttsp,
+		int rec_no, int *rec_abs)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	struct device *dev = cd->dev;
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	u8 *xy_data = si->xy_data + (rec_no * si->si_ofs.tch_rec_size);
+	enum cyttsp4_tch_abs abs;
+
+	memset(rec_abs, 0, CY_TCH_NUM_ABS * sizeof(int));
+	for (abs = CY_TCH_X; abs < CY_TCH_NUM_ABS; abs++) {
+		cyttsp4_get_touch_axis(cd, &rec_abs[abs],
+			si->si_ofs.tch_abs[abs].size,
+			si->si_ofs.tch_abs[abs].max,
+			xy_data + si->si_ofs.tch_abs[abs].ofs,
+			si->si_ofs.tch_abs[abs].bofs);
+		dev_vdbg(dev, "%s: get %s=%04X(%d)\n", __func__,
+			cyttsp4_tch_abs_string[abs],
+			rec_abs[abs], rec_abs[abs]);
+	}
+}
+
+static int cyttsp4_load_status_and_touch_regs(struct cyttsp4_core_data *cd,
+		bool optimize)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	struct device *dev = cd->dev;
+	int first_read_len;
+	int second_read_off;
+	int num_read_rec;
+	u8 num_cur_rec;
+	u8 hst_mode;
+	u8 rep_len;
+	u8 rep_stat;
+	u8 tt_stat;
+	int rc;
+
+	if (!si->xy_mode) {
+		dev_err(cd->dev, "%s: NULL xy_mode pointer\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	first_read_len = si->si_ofs.rep_hdr_size;
+	/* Read one touch record additionally */
+	if (optimize)
+		first_read_len += si->si_ofs.tch_rec_size;
+
+	rc = cyttsp4_adap_read(cd, si->si_ofs.rep_ofs,
+			&si->xy_mode[si->si_ofs.rep_ofs], first_read_len);
+	if (rc < 0) {
+		dev_err(dev, "%s: fail read mode regs r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	/* print xy data */
+	cyttsp4_pr_buf(dev, cd->pr_buf, si->xy_mode,
+		si->si_ofs.mode_size, "xy_mode");
+
+	hst_mode = si->xy_mode[CY_REG_BASE];
+	rep_len = si->xy_mode[si->si_ofs.rep_ofs];
+	rep_stat = si->xy_mode[si->si_ofs.rep_ofs + 1];
+	tt_stat = si->xy_mode[si->si_ofs.tt_stat_ofs];
+	dev_vdbg(dev, "%s: %s%02X %s%d %s%02X %s%02X\n", __func__,
+		"hst_mode=", hst_mode, "rep_len=", rep_len,
+		"rep_stat=", rep_stat, "tt_stat=", tt_stat);
+
+	num_cur_rec = GET_NUM_TOUCH_RECORDS(tt_stat);
+	dev_vdbg(dev, "%s: num_cur_rec=%d\n", __func__, num_cur_rec);
+
+	if (rep_len == 0 && num_cur_rec > 0) {
+		dev_err(dev, "%s: report length error rep_len=%d num_rec=%d\n",
+			__func__, rep_len, num_cur_rec);
+		return -EIO;
+	}
+
+	num_read_rec = num_cur_rec;
+	second_read_off = si->si_ofs.tt_stat_ofs + 1;
+	if (optimize) {
+		num_read_rec--;
+		second_read_off += si->si_ofs.tch_rec_size;
+	}
+
+	if (num_read_rec <= 0)
+		goto exit_print;
+
+	rc = cyttsp4_adap_read(cd, second_read_off,
+			&si->xy_mode[second_read_off],
+			num_read_rec * si->si_ofs.tch_rec_size);
+	if (rc < 0) {
+		dev_err(dev, "%s: read fail on touch regs r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+exit_print:
+	/* print xy data */
+	cyttsp4_pr_buf(dev, cd->pr_buf, si->xy_data,
+		num_cur_rec * si->si_ofs.tch_rec_size, "xy_data");
+
+	return 0;
+}
+
+static int cyttsp4_handshake(struct cyttsp4_core_data *cd, u8 mode)
+{
+	u8 cmd = mode ^ CY_HST_TOGGLE;
+	int rc;
+
+	if (mode & CY_HST_MODE_CHANGE) {
+		dev_err(cd->dev, "%s: Host mode change bit set, NO handshake\n",
+				__func__);
+		return 0;
+	}
+
+	rc = cyttsp4_adap_write(cd, CY_REG_BASE, &cmd, sizeof(cmd));
+	if (rc < 0)
+		dev_err(cd->dev, "%s: bus write fail on handshake (ret=%d)\n",
+				__func__, rc);
+
+	return rc;
+}
+
+static int cyttsp4_toggle_low_power_(struct cyttsp4_core_data *cd, u8 mode)
+{
+	u8 cmd = mode ^ CY_HST_LOWPOW;
+
+	int rc = cyttsp4_adap_write(cd, CY_REG_BASE, &cmd, sizeof(cmd));
+	if (rc < 0)
+		dev_err(cd->dev,
+			"%s: bus write fail on toggle low power (ret=%d)\n",
+			__func__, rc);
+	return rc;
+}
+
+static int cyttsp4_toggle_low_power(struct cyttsp4_core_data *cd, u8 mode)
+{
+	int rc;
+
+	mutex_lock(&cd->system_lock);
+	rc = cyttsp4_toggle_low_power_(cd, mode);
+	mutex_unlock(&cd->system_lock);
+
+	return rc;
+}
+
+static int cyttsp4_hw_soft_reset_(struct cyttsp4_core_data *cd)
+{
+	u8 cmd = CY_HST_RESET;
+
+	int rc = cyttsp4_adap_write(cd, CY_REG_BASE, &cmd, sizeof(cmd));
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: FAILED to execute SOFT reset\n",
+				__func__);
+		return rc;
+	}
+	dev_dbg(cd->dev, "%s: execute SOFT reset\n", __func__);
+	return 0;
+}
+
+static int cyttsp4_hw_soft_reset(struct cyttsp4_core_data *cd)
+{
+	int rc;
+
+	mutex_lock(&cd->system_lock);
+	rc = cyttsp4_hw_soft_reset_(cd);
+	mutex_unlock(&cd->system_lock);
+
+	return rc;
+}
+
+static int cyttsp4_hw_hard_reset_(struct cyttsp4_core_data *cd)
+{
+	if (cd->pdata->xres) {
+		cd->pdata->xres(cd->pdata, cd->dev);
+		dev_dbg(cd->dev, "%s: execute HARD reset\n", __func__);
+		return 0;
+	}
+	dev_err(cd->dev, "%s: FAILED to execute HARD reset\n", __func__);
+	return -ENOSYS;
+}
+
+static int cyttsp4_hw_hard_reset(struct cyttsp4_core_data *cd)
+{
+	int rc;
+
+	mutex_lock(&cd->system_lock);
+	rc = cyttsp4_hw_hard_reset_(cd);
+	mutex_unlock(&cd->system_lock);
+
+	return rc;
+}
+
+static int cyttsp4_hw_reset_(struct cyttsp4_core_data *cd)
+{
+	int rc = cyttsp4_hw_hard_reset_(cd);
+	if (rc == -ENOSYS)
+		rc = cyttsp4_hw_soft_reset_(cd);
+	return rc;
+}
+
+static inline int cyttsp4_bits_2_bytes(int nbits, int *max)
+{
+	*max = 1 << nbits;
+	return (nbits + 7) / 8;
+}
+
+static int cyttsp4_si_data_offsets(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	int rc = cyttsp4_adap_read(cd, CY_REG_BASE, &si->si_data,
+				   sizeof(si->si_data));
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail read sysinfo data offsets r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	/* Print sysinfo data offsets */
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf, (u8 *)&si->si_data,
+		       sizeof(si->si_data), "sysinfo_data_offsets");
+
+	/* convert sysinfo data offset bytes into integers */
+
+	si->si_ofs.map_sz = merge_bytes(si->si_data.map_szh,
+			si->si_data.map_szl);
+	si->si_ofs.map_sz = merge_bytes(si->si_data.map_szh,
+			si->si_data.map_szl);
+	si->si_ofs.cydata_ofs = merge_bytes(si->si_data.cydata_ofsh,
+			si->si_data.cydata_ofsl);
+	si->si_ofs.test_ofs = merge_bytes(si->si_data.test_ofsh,
+			si->si_data.test_ofsl);
+	si->si_ofs.pcfg_ofs = merge_bytes(si->si_data.pcfg_ofsh,
+			si->si_data.pcfg_ofsl);
+	si->si_ofs.opcfg_ofs = merge_bytes(si->si_data.opcfg_ofsh,
+			si->si_data.opcfg_ofsl);
+	si->si_ofs.ddata_ofs = merge_bytes(si->si_data.ddata_ofsh,
+			si->si_data.ddata_ofsl);
+	si->si_ofs.mdata_ofs = merge_bytes(si->si_data.mdata_ofsh,
+			si->si_data.mdata_ofsl);
+	return rc;
+}
+
+static int cyttsp4_si_get_cydata(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	int read_offset;
+	int mfgid_sz, calc_mfgid_sz;
+	void *p;
+	int rc;
+
+	si->si_ofs.cydata_size = si->si_ofs.test_ofs - si->si_ofs.cydata_ofs;
+	dev_dbg(cd->dev, "%s: cydata size: %d\n", __func__,
+			si->si_ofs.cydata_size);
+
+	if (si->si_ofs.cydata_size <= 0)
+		return -EINVAL;
+
+	p = krealloc(si->si_ptrs.cydata, si->si_ofs.cydata_size, GFP_KERNEL);
+	if (p == NULL) {
+		dev_err(cd->dev, "%s: fail alloc cydata memory\n", __func__);
+		return -ENOMEM;
+	}
+	si->si_ptrs.cydata = p;
+
+	read_offset = si->si_ofs.cydata_ofs;
+
+	/* Read the CYDA registers up to MFGID field */
+	rc = cyttsp4_adap_read(cd, read_offset, si->si_ptrs.cydata,
+			offsetof(struct cyttsp4_cydata, mfgid_sz)
+			+ sizeof(si->si_ptrs.cydata->mfgid_sz));
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail read cydata r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	/* Check MFGID size */
+	mfgid_sz = si->si_ptrs.cydata->mfgid_sz;
+	calc_mfgid_sz = si->si_ofs.cydata_size - sizeof(struct cyttsp4_cydata);
+	if (mfgid_sz != calc_mfgid_sz) {
+		dev_err(cd->dev, "%s: mismatch in MFGID size, reported:%d calculated:%d\n",
+			__func__, mfgid_sz, calc_mfgid_sz);
+		return -EINVAL;
+	}
+
+	read_offset += offsetof(struct cyttsp4_cydata, mfgid_sz)
+			+ sizeof(si->si_ptrs.cydata->mfgid_sz);
+
+	/* Read the CYDA registers for MFGID field */
+	rc = cyttsp4_adap_read(cd, read_offset, si->si_ptrs.cydata->mfg_id,
+			si->si_ptrs.cydata->mfgid_sz);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail read cydata r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	read_offset += si->si_ptrs.cydata->mfgid_sz;
+
+	/* Read the rest of the CYDA registers */
+	rc = cyttsp4_adap_read(cd, read_offset, &si->si_ptrs.cydata->cyito_idh,
+			sizeof(struct cyttsp4_cydata)
+			- offsetof(struct cyttsp4_cydata, cyito_idh));
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail read cydata r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf, (u8 *)si->si_ptrs.cydata,
+		si->si_ofs.cydata_size - mfgid_sz, "sysinfo_cydata");
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf, si->si_ptrs.cydata->mfg_id,
+		mfgid_sz, "sysinfo_cydata_mfgid");
+	return rc;
+}
+
+static int cyttsp4_si_get_test_data(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	void *p;
+	int rc;
+
+	si->si_ofs.test_size = si->si_ofs.pcfg_ofs - si->si_ofs.test_ofs;
+
+	if (si->si_ofs.test_size <= 0)
+		return -EINVAL;
+
+	p = krealloc(si->si_ptrs.test, si->si_ofs.test_size, GFP_KERNEL);
+	if (p == NULL) {
+		dev_err(cd->dev, "%s: fail alloc test memory\n", __func__);
+		return -ENOMEM;
+	}
+	si->si_ptrs.test = p;
+
+	rc = cyttsp4_adap_read(cd, si->si_ofs.test_ofs, si->si_ptrs.test,
+			si->si_ofs.test_size);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail read test data r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf,
+		       (u8 *)si->si_ptrs.test, si->si_ofs.test_size,
+		       "sysinfo_test_data");
+	if (si->si_ptrs.test->post_codel &
+	    CY_POST_CODEL_WDG_RST)
+		dev_info(cd->dev, "%s: %s codel=%02X\n",
+			 __func__, "Reset was a WATCHDOG RESET",
+			 si->si_ptrs.test->post_codel);
+
+	if (!(si->si_ptrs.test->post_codel &
+	      CY_POST_CODEL_CFG_DATA_CRC_FAIL))
+		dev_info(cd->dev, "%s: %s codel=%02X\n", __func__,
+			 "Config Data CRC FAIL",
+			 si->si_ptrs.test->post_codel);
+
+	if (!(si->si_ptrs.test->post_codel &
+	      CY_POST_CODEL_PANEL_TEST_FAIL))
+		dev_info(cd->dev, "%s: %s codel=%02X\n",
+			 __func__, "PANEL TEST FAIL",
+			 si->si_ptrs.test->post_codel);
+
+	dev_info(cd->dev, "%s: SCANNING is %s codel=%02X\n",
+		 __func__, si->si_ptrs.test->post_codel & 0x08 ?
+		 "ENABLED" : "DISABLED",
+		 si->si_ptrs.test->post_codel);
+	return rc;
+}
+
+static int cyttsp4_si_get_pcfg_data(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	void *p;
+	int rc;
+
+	dev_vdbg(cd->dev, "%s: get pcfg data\n", __func__);
+	si->si_ofs.pcfg_size = si->si_ofs.opcfg_ofs - si->si_ofs.pcfg_ofs;
+
+	if (si->si_ofs.pcfg_size <= 0)
+		return -EINVAL;
+
+	p = krealloc(si->si_ptrs.pcfg, si->si_ofs.pcfg_size, GFP_KERNEL);
+	if (p == NULL) {
+		rc = -ENOMEM;
+		dev_err(cd->dev, "%s: fail alloc pcfg memory r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+	si->si_ptrs.pcfg = p;
+
+	rc = cyttsp4_adap_read(cd, si->si_ofs.pcfg_ofs, si->si_ptrs.pcfg,
+			si->si_ofs.pcfg_size);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail read pcfg data r=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	si->si_ofs.max_x = merge_bytes((si->si_ptrs.pcfg->res_xh
+			& CY_PCFG_RESOLUTION_X_MASK), si->si_ptrs.pcfg->res_xl);
+	si->si_ofs.x_origin = !!(si->si_ptrs.pcfg->res_xh
+			& CY_PCFG_ORIGIN_X_MASK);
+	si->si_ofs.max_y = merge_bytes((si->si_ptrs.pcfg->res_yh
+			& CY_PCFG_RESOLUTION_Y_MASK), si->si_ptrs.pcfg->res_yl);
+	si->si_ofs.y_origin = !!(si->si_ptrs.pcfg->res_yh
+			& CY_PCFG_ORIGIN_Y_MASK);
+	si->si_ofs.max_p = merge_bytes(si->si_ptrs.pcfg->max_zh,
+			si->si_ptrs.pcfg->max_zl);
+
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf,
+		       (u8 *)si->si_ptrs.pcfg,
+		       si->si_ofs.pcfg_size, "sysinfo_pcfg_data");
+	return rc;
+}
+
+static int cyttsp4_si_get_opcfg_data(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	int i;
+	enum cyttsp4_tch_abs abs;
+	void *p;
+	int rc;
+
+	dev_vdbg(cd->dev, "%s: get opcfg data\n", __func__);
+	si->si_ofs.opcfg_size = si->si_ofs.ddata_ofs - si->si_ofs.opcfg_ofs;
+
+	if (si->si_ofs.opcfg_size <= 0)
+		return -EINVAL;
+
+	p = krealloc(si->si_ptrs.opcfg, si->si_ofs.opcfg_size, GFP_KERNEL);
+	if (p == NULL) {
+		dev_err(cd->dev, "%s: fail alloc opcfg memory\n", __func__);
+		rc = -ENOMEM;
+		goto cyttsp4_si_get_opcfg_data_exit;
+	}
+	si->si_ptrs.opcfg = p;
+
+	rc = cyttsp4_adap_read(cd, si->si_ofs.opcfg_ofs, si->si_ptrs.opcfg,
+			si->si_ofs.opcfg_size);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail read opcfg data r=%d\n",
+			__func__, rc);
+		goto cyttsp4_si_get_opcfg_data_exit;
+	}
+	si->si_ofs.cmd_ofs = si->si_ptrs.opcfg->cmd_ofs;
+	si->si_ofs.rep_ofs = si->si_ptrs.opcfg->rep_ofs;
+	si->si_ofs.rep_sz = (si->si_ptrs.opcfg->rep_szh * 256) +
+		si->si_ptrs.opcfg->rep_szl;
+	si->si_ofs.num_btns = si->si_ptrs.opcfg->num_btns;
+	si->si_ofs.num_btn_regs = (si->si_ofs.num_btns +
+		CY_NUM_BTN_PER_REG - 1) / CY_NUM_BTN_PER_REG;
+	si->si_ofs.tt_stat_ofs = si->si_ptrs.opcfg->tt_stat_ofs;
+	si->si_ofs.obj_cfg0 = si->si_ptrs.opcfg->obj_cfg0;
+	si->si_ofs.max_tchs = si->si_ptrs.opcfg->max_tchs &
+		CY_BYTE_OFS_MASK;
+	si->si_ofs.tch_rec_size = si->si_ptrs.opcfg->tch_rec_size &
+		CY_BYTE_OFS_MASK;
+
+	/* Get the old touch fields */
+	for (abs = CY_TCH_X; abs < CY_NUM_TCH_FIELDS; abs++) {
+		si->si_ofs.tch_abs[abs].ofs =
+			si->si_ptrs.opcfg->tch_rec_old[abs].loc &
+			CY_BYTE_OFS_MASK;
+		si->si_ofs.tch_abs[abs].size =
+			cyttsp4_bits_2_bytes
+			(si->si_ptrs.opcfg->tch_rec_old[abs].size,
+			&si->si_ofs.tch_abs[abs].max);
+		si->si_ofs.tch_abs[abs].bofs =
+			(si->si_ptrs.opcfg->tch_rec_old[abs].loc &
+			CY_BOFS_MASK) >> CY_BOFS_SHIFT;
+	}
+
+	/* button fields */
+	si->si_ofs.btn_rec_size = si->si_ptrs.opcfg->btn_rec_size;
+	si->si_ofs.btn_diff_ofs = si->si_ptrs.opcfg->btn_diff_ofs;
+	si->si_ofs.btn_diff_size = si->si_ptrs.opcfg->btn_diff_size;
+
+	if (IS_TTSP_VER_GE(si, 2, 3)) {
+		/* Get the extended touch fields */
+		for (i = 0; i < CY_NUM_EXT_TCH_FIELDS; abs++, i++) {
+			si->si_ofs.tch_abs[abs].ofs =
+				si->si_ptrs.opcfg->tch_rec_new[i].loc &
+				CY_BYTE_OFS_MASK;
+			si->si_ofs.tch_abs[abs].size =
+				cyttsp4_bits_2_bytes
+				(si->si_ptrs.opcfg->tch_rec_new[i].size,
+				&si->si_ofs.tch_abs[abs].max);
+			si->si_ofs.tch_abs[abs].bofs =
+				(si->si_ptrs.opcfg->tch_rec_new[i].loc
+				& CY_BOFS_MASK) >> CY_BOFS_SHIFT;
+		}
+	}
+
+	if (IS_TTSP_VER_GE(si, 2, 4)) {
+		si->si_ofs.noise_data_ofs = si->si_ptrs.opcfg->noise_data_ofs;
+		si->si_ofs.noise_data_sz = si->si_ptrs.opcfg->noise_data_sz;
+	}
+
+	for (abs = 0; abs < CY_TCH_NUM_ABS; abs++) {
+		dev_dbg(cd->dev, "%s: tch_rec_%s\n", __func__,
+			cyttsp4_tch_abs_string[abs]);
+		dev_dbg(cd->dev, "%s:     ofs =%2d\n", __func__,
+			si->si_ofs.tch_abs[abs].ofs);
+		dev_dbg(cd->dev, "%s:     siz =%2d\n", __func__,
+			si->si_ofs.tch_abs[abs].size);
+		dev_dbg(cd->dev, "%s:     max =%2d\n", __func__,
+			si->si_ofs.tch_abs[abs].max);
+		dev_dbg(cd->dev, "%s:     bofs=%2d\n", __func__,
+			si->si_ofs.tch_abs[abs].bofs);
+	}
+
+	si->si_ofs.mode_size = si->si_ofs.tt_stat_ofs + 1;
+	si->si_ofs.data_size = si->si_ofs.max_tchs *
+		si->si_ptrs.opcfg->tch_rec_size;
+	si->si_ofs.rep_hdr_size = si->si_ofs.mode_size - si->si_ofs.rep_ofs;
+
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf, (u8 *)si->si_ptrs.opcfg,
+		si->si_ofs.opcfg_size, "sysinfo_opcfg_data");
+
+cyttsp4_si_get_opcfg_data_exit:
+	return rc;
+}
+
+static int cyttsp4_si_get_ddata(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	void *p;
+	int rc;
+
+	dev_vdbg(cd->dev, "%s: get ddata data\n", __func__);
+	si->si_ofs.ddata_size = si->si_ofs.mdata_ofs - si->si_ofs.ddata_ofs;
+
+	if (si->si_ofs.ddata_size <= 0)
+		return -EINVAL;
+
+	p = krealloc(si->si_ptrs.ddata, si->si_ofs.ddata_size, GFP_KERNEL);
+	if (p == NULL) {
+		dev_err(cd->dev, "%s: fail alloc ddata memory\n", __func__);
+		return -ENOMEM;
+	}
+	si->si_ptrs.ddata = p;
+
+	rc = cyttsp4_adap_read(cd, si->si_ofs.ddata_ofs, si->si_ptrs.ddata,
+			si->si_ofs.ddata_size);
+	if (rc < 0)
+		dev_err(cd->dev, "%s: fail read ddata data r=%d\n",
+			__func__, rc);
+	else
+		cyttsp4_pr_buf(cd->dev, cd->pr_buf,
+			       (u8 *)si->si_ptrs.ddata,
+			       si->si_ofs.ddata_size, "sysinfo_ddata");
+	return rc;
+}
+
+static int cyttsp4_si_get_mdata(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	void *p;
+	int rc;
+
+	dev_vdbg(cd->dev, "%s: get mdata data\n", __func__);
+	si->si_ofs.mdata_size = si->si_ofs.map_sz - si->si_ofs.mdata_ofs;
+
+	if (si->si_ofs.mdata_size <= 0)
+		return -EINVAL;
+
+	p = krealloc(si->si_ptrs.mdata, si->si_ofs.mdata_size, GFP_KERNEL);
+	if (p == NULL) {
+		dev_err(cd->dev, "%s: fail alloc mdata memory\n", __func__);
+		return -ENOMEM;
+	}
+	si->si_ptrs.mdata = p;
+
+	rc = cyttsp4_adap_read(cd, si->si_ofs.mdata_ofs, si->si_ptrs.mdata,
+			si->si_ofs.mdata_size);
+	if (rc < 0)
+		dev_err(cd->dev, "%s: fail read mdata data r=%d\n",
+			__func__, rc);
+	else
+		cyttsp4_pr_buf(cd->dev, cd->pr_buf,
+			       (u8 *)si->si_ptrs.mdata,
+			       si->si_ofs.mdata_size, "sysinfo_mdata");
+	return rc;
+}
+
+static int cyttsp4_si_get_btn_data(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	int btn;
+	int num_defined_keys;
+	u16 *key_table;
+	void *p;
+	int rc = 0;
+
+	dev_vdbg(cd->dev, "%s: get btn data\n", __func__);
+
+	if (!si->si_ofs.num_btns) {
+		si->si_ofs.btn_keys_size = 0;
+		kfree(si->btn);
+		si->btn = NULL;
+		return rc;
+	}
+
+	si->si_ofs.btn_keys_size = si->si_ofs.num_btns *
+		sizeof(struct cyttsp4_btn);
+
+	if (si->si_ofs.btn_keys_size <= 0)
+		return -EINVAL;
+
+	p = krealloc(si->btn, si->si_ofs.btn_keys_size, GFP_KERNEL|__GFP_ZERO);
+	if (p == NULL) {
+		dev_err(cd->dev, "%s: %s\n", __func__,
+			"fail alloc btn_keys memory");
+		return -ENOMEM;
+	}
+	si->btn = p;
+
+	if (cd->pdata->sett[CY_IC_GRPNUM_BTN_KEYS] == NULL)
+		num_defined_keys = 0;
+	else if (cd->pdata->sett[CY_IC_GRPNUM_BTN_KEYS]->data == NULL)
+		num_defined_keys = 0;
+	else
+		num_defined_keys = cd->pdata->sett[CY_IC_GRPNUM_BTN_KEYS]->size;
+
+	for (btn = 0; btn < si->si_ofs.num_btns
+			&& btn < num_defined_keys; btn++) {
+		key_table = (u16 *)cd->pdata->sett[CY_IC_GRPNUM_BTN_KEYS]->data;
+		si->btn[btn].key_code = key_table[btn];
+		si->btn[btn].state = CY_BTN_RELEASED;
+		si->btn[btn].enabled = true;
+	}
+	for (; btn < si->si_ofs.num_btns; btn++) {
+		si->btn[btn].key_code = KEY_RESERVED;
+		si->btn[btn].state = CY_BTN_RELEASED;
+		si->btn[btn].enabled = true;
+	}
+
+	return rc;
+}
+
+static int cyttsp4_si_get_op_data_ptrs(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	void *p;
+	int size;
+
+	p = krealloc(si->xy_mode, si->si_ofs.mode_size +
+			si->si_ofs.data_size, GFP_KERNEL|__GFP_ZERO);
+	if (p == NULL)
+		return -ENOMEM;
+	si->xy_mode = p;
+	si->xy_data = &si->xy_mode[si->si_ofs.tt_stat_ofs + 1];
+
+	size = si->si_ofs.btn_rec_size * si->si_ofs.num_btns;
+	if (!size)
+		return 0;
+
+	p = krealloc(si->btn_rec_data, size, GFP_KERNEL|__GFP_ZERO);
+	if (p == NULL)
+		return -ENOMEM;
+	si->btn_rec_data = p;
+
+	return 0;
+}
+
+static void cyttsp4_si_put_log_data(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	dev_dbg(cd->dev, "%s: cydata_ofs =%4d siz=%4d\n", __func__,
+		si->si_ofs.cydata_ofs, si->si_ofs.cydata_size);
+	dev_dbg(cd->dev, "%s: test_ofs   =%4d siz=%4d\n", __func__,
+		si->si_ofs.test_ofs, si->si_ofs.test_size);
+	dev_dbg(cd->dev, "%s: pcfg_ofs   =%4d siz=%4d\n", __func__,
+		si->si_ofs.pcfg_ofs, si->si_ofs.pcfg_size);
+	dev_dbg(cd->dev, "%s: opcfg_ofs  =%4d siz=%4d\n", __func__,
+		si->si_ofs.opcfg_ofs, si->si_ofs.opcfg_size);
+	dev_dbg(cd->dev, "%s: ddata_ofs  =%4d siz=%4d\n", __func__,
+		si->si_ofs.ddata_ofs, si->si_ofs.ddata_size);
+	dev_dbg(cd->dev, "%s: mdata_ofs  =%4d siz=%4d\n", __func__,
+		si->si_ofs.mdata_ofs, si->si_ofs.mdata_size);
+
+	dev_dbg(cd->dev, "%s: cmd_ofs       =%4d\n", __func__,
+		si->si_ofs.cmd_ofs);
+	dev_dbg(cd->dev, "%s: rep_ofs       =%4d\n", __func__,
+		si->si_ofs.rep_ofs);
+	dev_dbg(cd->dev, "%s: rep_sz        =%4d\n", __func__,
+		si->si_ofs.rep_sz);
+	dev_dbg(cd->dev, "%s: num_btns      =%4d\n", __func__,
+		si->si_ofs.num_btns);
+	dev_dbg(cd->dev, "%s: num_btn_regs  =%4d\n", __func__,
+		si->si_ofs.num_btn_regs);
+	dev_dbg(cd->dev, "%s: tt_stat_ofs   =%4d\n", __func__,
+		si->si_ofs.tt_stat_ofs);
+	dev_dbg(cd->dev, "%s: tch_rec_size   =%4d\n", __func__,
+		si->si_ofs.tch_rec_size);
+	dev_dbg(cd->dev, "%s: max_tchs      =%4d\n", __func__,
+		si->si_ofs.max_tchs);
+	dev_dbg(cd->dev, "%s: mode_size     =%4d\n", __func__,
+		si->si_ofs.mode_size);
+	dev_dbg(cd->dev, "%s: data_size     =%4d\n", __func__,
+		si->si_ofs.data_size);
+	dev_dbg(cd->dev, "%s: rep_hdr_size  =%4d\n", __func__,
+		si->si_ofs.rep_hdr_size);
+	dev_dbg(cd->dev, "%s: map_sz        =%4d\n", __func__,
+		si->si_ofs.map_sz);
+
+	dev_dbg(cd->dev, "%s: btn_rec_size   =%2d\n", __func__,
+		si->si_ofs.btn_rec_size);
+	dev_dbg(cd->dev, "%s: btn_diff_ofs  =%2d\n", __func__,
+		si->si_ofs.btn_diff_ofs);
+	dev_dbg(cd->dev, "%s: btn_diff_size  =%2d\n", __func__,
+		si->si_ofs.btn_diff_size);
+
+	dev_dbg(cd->dev, "%s: max_x    = 0x%04X (%d)\n", __func__,
+		si->si_ofs.max_x, si->si_ofs.max_x);
+	dev_dbg(cd->dev, "%s: x_origin = %d (%s)\n", __func__,
+		si->si_ofs.x_origin,
+		si->si_ofs.x_origin == CY_NORMAL_ORIGIN ?
+		"left corner" : "right corner");
+	dev_dbg(cd->dev, "%s: max_y    = 0x%04X (%d)\n", __func__,
+		si->si_ofs.max_y, si->si_ofs.max_y);
+	dev_dbg(cd->dev, "%s: y_origin = %d (%s)\n", __func__,
+		si->si_ofs.y_origin,
+		si->si_ofs.y_origin == CY_NORMAL_ORIGIN ?
+		"upper corner" : "lower corner");
+	dev_dbg(cd->dev, "%s: max_p    = 0x%04X (%d)\n", __func__,
+		si->si_ofs.max_p, si->si_ofs.max_p);
+
+	dev_dbg(cd->dev, "%s: xy_mode=%p xy_data=%p\n", __func__,
+		si->xy_mode, si->xy_data);
+}
+
+static int cyttsp4_get_sysinfo_regs(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	int rc;
+
+	rc = cyttsp4_si_data_offsets(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_cydata(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_test_data(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_pcfg_data(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_opcfg_data(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_ddata(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_mdata(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_btn_data(cd);
+	if (rc < 0)
+		return rc;
+
+	rc = cyttsp4_si_get_op_data_ptrs(cd);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get_op_data\n",
+			__func__);
+		return rc;
+	}
+
+	cyttsp4_si_put_log_data(cd);
+
+	/* provide flow control handshake */
+	rc = cyttsp4_handshake(cd, si->si_data.hst_mode);
+	if (rc < 0)
+		dev_err(cd->dev, "%s: handshake fail on sysinfo reg\n",
+			__func__);
+
+	mutex_lock(&cd->system_lock);
+	si->ready = true;
+	mutex_unlock(&cd->system_lock);
+	return rc;
+}
+
+static void cyttsp4_queue_startup_(struct cyttsp4_core_data *cd)
+{
+	if (cd->startup_state == STARTUP_NONE) {
+		cd->startup_state = STARTUP_QUEUED;
+		schedule_work(&cd->startup_work);
+		dev_info(cd->dev, "%s: cyttsp4_startup queued\n", __func__);
+	} else {
+		dev_dbg(cd->dev, "%s: startup_state = %d\n", __func__,
+			cd->startup_state);
+	}
+}
+
+static void cyttsp4_queue_startup(struct cyttsp4_core_data *cd)
+{
+	dev_vdbg(cd->dev, "%s: enter\n", __func__);
+	mutex_lock(&cd->system_lock);
+	cyttsp4_queue_startup_(cd);
+	mutex_unlock(&cd->system_lock);
+}
+
+static void call_atten_cb(struct cyttsp4_core_data *cd,
+		enum cyttsp4_atten_type type, int mode)
+{
+	struct atten_node *atten, *atten_n;
+
+	dev_vdbg(cd->dev, "%s: check list type=%d mode=%d\n",
+		__func__, type, mode);
+	spin_lock(&cd->spinlock);
+	list_for_each_entry_safe(atten, atten_n,
+			&cd->atten_list[type], node) {
+		if (!mode || atten->mode & mode) {
+			spin_unlock(&cd->spinlock);
+			dev_vdbg(cd->dev, "%s: attention for '%s'", __func__,
+				dev_name(&atten->ttsp->dev));
+			atten->func(atten->ttsp);
+			spin_lock(&cd->spinlock);
+		}
+	}
+	spin_unlock(&cd->spinlock);
+}
+
+static irqreturn_t cyttsp4_hard_irq(int irq, void *handle)
+{
+	struct cyttsp4_core_data *cd = handle;
+
+	/*
+	 * Check whether this IRQ should be ignored (external)
+	 * This should be the very first thing to check since
+	 * ignore_irq may be set for a very short period of time
+	 */
+	if (atomic_read(&cd->ignore_irq)) {
+		dev_vdbg(cd->dev, "%s: Ignoring IRQ\n", __func__);
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t cyttsp4_irq(int irq, void *handle)
+{
+	struct cyttsp4_core_data *cd = handle;
+	struct device *dev = cd->dev;
+	enum cyttsp4_mode cur_mode;
+	u8 cmd_ofs = cd->sysinfo.si_ofs.cmd_ofs;
+	bool command_complete = false;
+	u8 mode[3];
+	int rc;
+	u8 cat_masked_cmd;
+
+	dev_dbg(dev, "%s int:0x%x\n", __func__, cd->int_status);
+
+	mutex_lock(&cd->system_lock);
+
+	rc = cyttsp4_adap_read(cd, CY_REG_BASE, mode, sizeof(mode));
+	if (rc) {
+		dev_err(cd->dev, "%s: Fail read adapter r=%d\n", __func__, rc);
+		goto cyttsp4_irq_exit;
+	}
+	dev_vdbg(dev, "%s mode[0-2]:0x%X 0x%X 0x%X\n", __func__,
+			mode[0], mode[1], mode[2]);
+
+	if (IS_BOOTLOADER(mode[0], mode[1])) {
+		cur_mode = CY_MODE_BOOTLOADER;
+		dev_vdbg(dev, "%s: bl running\n", __func__);
+		call_atten_cb(cd, CY_ATTEN_IRQ, cur_mode);
+
+		/* switch to bootloader */
+		if (cd->mode != CY_MODE_BOOTLOADER)
+			dev_dbg(dev, "%s: restart switch to bl m=%d -> m=%d\n",
+			__func__, cd->mode, cur_mode);
+
+		/* catch operation->bl glitch */
+		if (cd->mode != CY_MODE_BOOTLOADER
+				&& cd->mode != CY_MODE_UNKNOWN) {
+			/* Incase startup_state do not let startup_() */
+			cd->mode = CY_MODE_UNKNOWN;
+			cyttsp4_queue_startup_(cd);
+			goto cyttsp4_irq_exit;
+		}
+
+		/* Recover if stuck in bootloader idle mode */
+		if (cd->mode == CY_MODE_BOOTLOADER) {
+			if (IS_BOOTLOADER_IDLE(mode[0], mode[1])) {
+				if (cd->heartbeat_count > 3) {
+					cd->heartbeat_count = 0;
+					cyttsp4_queue_startup_(cd);
+					goto cyttsp4_irq_exit;
+				}
+				cd->heartbeat_count++;
+			}
+		}
+
+		cd->mode = cur_mode;
+		/* Signal bootloader heartbeat heard */
+		wake_up(&cd->wait_q);
+		goto cyttsp4_irq_exit;
+	}
+
+	switch (mode[0] & CY_HST_DEVICE_MODE) {
+	case CY_HST_OPERATE:
+		cur_mode = CY_MODE_OPERATIONAL;
+		dev_vdbg(dev, "%s: operational\n", __func__);
+		break;
+	case CY_HST_CAT:
+		cur_mode = CY_MODE_CAT;
+		/* set the start sensor mode state. */
+		cat_masked_cmd = mode[2] & CY_CMD_MASK;
+
+		/* Get the Debug info for the interrupt. */
+		if (cat_masked_cmd != CY_CMD_CAT_NULL &&
+				cat_masked_cmd !=
+					CY_CMD_CAT_RETRIEVE_PANEL_SCAN &&
+				cat_masked_cmd != CY_CMD_CAT_EXEC_PANEL_SCAN)
+			dev_info(cd->dev,
+				"%s: cyttsp4_CaT_IRQ=%02X %02X %02X\n",
+				__func__, mode[0], mode[1], mode[2]);
+		dev_vdbg(dev, "%s: CaT\n", __func__);
+		break;
+	case CY_HST_SYSINFO:
+		cur_mode = CY_MODE_SYSINFO;
+		dev_vdbg(dev, "%s: sysinfo\n", __func__);
+		break;
+	default:
+		cur_mode = CY_MODE_UNKNOWN;
+		dev_err(dev, "%s: unknown HST mode 0x%02X\n", __func__,
+			mode[0]);
+		break;
+	}
+
+	/* Check whether this IRQ should be ignored (internal) */
+	if (cd->int_status & CY_INT_IGNORE) {
+		if (IS_DEEP_SLEEP_CONFIGURED(cd->easy_wakeup_gesture)) {
+			/* Put device back to sleep on premature wakeup */
+			dev_dbg(dev, "%s: Put device back to sleep\n",
+				__func__);
+			_cyttsp4_put_device_into_deep_sleep(cd, mode[0]);
+			goto cyttsp4_irq_exit;
+		}
+		/* Check for Wait for Event command */
+		if ((mode[cmd_ofs] & CY_CMD_MASK) == CY_CMD_OP_WAIT_FOR_EVENT
+				&& mode[cmd_ofs] & CY_CMD_COMPLETE) {
+			cd->wake_initiated_by_device = 1;
+			call_atten_cb(cd, CY_ATTEN_WAKE, 0);
+			goto cyttsp4_irq_handshake;
+		}
+	}
+
+	/* Check for wake up interrupt */
+	if (cd->int_status & CY_INT_AWAKE) {
+		cd->int_status &= ~CY_INT_AWAKE;
+		wake_up(&cd->wait_q);
+		dev_vdbg(dev, "%s: Received wake up interrupt\n", __func__);
+		goto cyttsp4_irq_handshake;
+	}
+
+	/* Expecting mode change interrupt */
+	if ((cd->int_status & CY_INT_MODE_CHANGE)
+			&& (mode[0] & CY_HST_MODE_CHANGE) == 0) {
+		cd->int_status &= ~CY_INT_MODE_CHANGE;
+		dev_dbg(dev, "%s: finish mode switch m=%d -> m=%d\n",
+				__func__, cd->mode, cur_mode);
+		cd->mode = cur_mode;
+		wake_up(&cd->wait_q);
+		goto cyttsp4_irq_handshake;
+	}
+
+	/* compare current core mode to current device mode */
+	dev_vdbg(dev, "%s: cd->mode=%d cur_mode=%d\n",
+			__func__, cd->mode, cur_mode);
+	if ((mode[0] & CY_HST_MODE_CHANGE) == 0 && cd->mode != cur_mode) {
+		/* Unexpected mode change occurred */
+		dev_err(dev, "%s %d->%d 0x%x\n", __func__, cd->mode,
+				cur_mode, cd->int_status);
+		dev_vdbg(dev, "%s: Unexpected mode change, startup\n",
+				__func__);
+		cyttsp4_queue_startup_(cd);
+		goto cyttsp4_irq_exit;
+	}
+
+	/* Expecting command complete interrupt */
+	dev_vdbg(dev, "%s: command byte:0x%x, toggle:0x%x\n",
+			__func__, mode[cmd_ofs], cd->cmd_toggle);
+	if ((cd->int_status & CY_INT_EXEC_CMD)
+			&& mode[cmd_ofs] & CY_CMD_COMPLETE) {
+		command_complete = true;
+		cd->int_status &= ~CY_INT_EXEC_CMD;
+		dev_vdbg(dev, "%s: Received command complete interrupt\n",
+				__func__);
+		wake_up(&cd->wait_q);
+		/*
+		 * It is possible to receive a single interrupt for
+		 * command complete and touch/button status report.
+		 * Continue processing for a possible status report.
+		 */
+	}
+
+	/* Copy the mode registers */
+	if (cd->sysinfo.xy_mode)
+		memcpy(cd->sysinfo.xy_mode, mode, sizeof(mode));
+
+	/* This should be status report, read status and touch regs */
+	if (cd->mode == CY_MODE_OPERATIONAL) {
+		dev_vdbg(dev, "%s: Read status and touch registers\n",
+			__func__);
+		rc = cyttsp4_load_status_and_touch_regs(cd, !command_complete);
+		if (rc < 0)
+			dev_err(dev, "%s: fail read mode/touch regs r=%d\n",
+				__func__, rc);
+	}
+
+	/* attention IRQ */
+	call_atten_cb(cd, CY_ATTEN_IRQ, cd->mode);
+
+cyttsp4_irq_handshake:
+	/* handshake the event */
+	dev_vdbg(dev, "%s: Handshake mode=0x%02X r=%d\n",
+			__func__, mode[0], rc);
+	rc = cyttsp4_handshake(cd, mode[0]);
+	if (rc < 0)
+		dev_err(dev, "%s: Fail handshake mode=0x%02X r=%d\n",
+				__func__, mode[0], rc);
+
+	/*
+	 * a non-zero udelay period is required for using
+	 * IRQF_TRIGGER_LOW in order to delay until the
+	 * device completes isr deassert
+	 */
+	udelay(cd->pdata->level_irq_udelay);
+
+cyttsp4_irq_exit:
+	mutex_unlock(&cd->system_lock);
+	dev_vdbg(dev, "%s: irq done\n", __func__);
+	return IRQ_HANDLED;
+}
+
+static void cyttsp4_start_wd_timer(struct cyttsp4_core_data *cd)
+{
+	if (!CY_WATCHDOG_TIMEOUT)
+		return;
+
+	mod_timer(&cd->watchdog_timer, jiffies +
+			msecs_to_jiffies(CY_WATCHDOG_TIMEOUT));
+}
+
+static void cyttsp4_stop_wd_timer(struct cyttsp4_core_data *cd)
+{
+	if (!CY_WATCHDOG_TIMEOUT)
+		return;
+
+	/*
+	 * Ensure we wait until the watchdog timer
+	 * running on a different CPU finishes
+	 */
+	del_timer_sync(&cd->watchdog_timer);
+	cancel_work_sync(&cd->watchdog_work);
+	del_timer_sync(&cd->watchdog_timer);
+}
+
+static void cyttsp4_watchdog_timer(unsigned long handle)
+{
+	struct cyttsp4_core_data *cd = (struct cyttsp4_core_data *)handle;
+
+	dev_vdbg(cd->dev, "%s: Timer triggered\n", __func__);
+
+	if (!cd)
+		return;
+
+	if (!work_pending(&cd->watchdog_work))
+		schedule_work(&cd->watchdog_work);
+
+	return;
+}
+
+static int cyttsp4_write_(struct cyttsp4_device *ttsp, int mode, u16 addr,
+	const void *buf, int size)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	int rc = 0;
+
+	mutex_lock(&cd->adap_lock);
+	if (mode != cd->mode) {
+		dev_dbg(dev, "%s: %s (having %x while %x requested)\n",
+			__func__, "attempt to write in missing mode",
+			cd->mode, mode);
+		rc = -EACCES;
+		goto exit;
+	}
+	rc = cyttsp4_adap_write(cd, addr, buf, size);
+exit:
+	mutex_unlock(&cd->adap_lock);
+	return rc;
+}
+
+static int cyttsp4_read_(struct cyttsp4_device *ttsp, int mode, u16 addr,
+	void *buf, int size)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	int rc = 0;
+
+	mutex_lock(&cd->adap_lock);
+	if (mode != cd->mode) {
+		dev_dbg(dev, "%s: %s (having %x while %x requested)\n",
+			__func__, "attempt to read in missing mode",
+			cd->mode, mode);
+		rc = -EACCES;
+		goto exit;
+	}
+	rc = cyttsp4_adap_read(cd, addr, buf, size);
+exit:
+	mutex_unlock(&cd->adap_lock);
+	return rc;
+}
+
+static int cyttsp4_subscribe_attention_(struct cyttsp4_device *ttsp,
+	enum cyttsp4_atten_type type,
+	int (*func)(struct cyttsp4_device *), int mode)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	struct atten_node *atten, *atten_new;
+
+	atten_new = kzalloc(sizeof(*atten_new), GFP_KERNEL);
+	if (!atten_new) {
+		dev_err(cd->dev, "%s: Fail alloc atten node\n", __func__);
+		return -ENOMEM;
+	}
+
+	dev_dbg(cd->dev, "%s from '%s'\n", __func__, dev_name(cd->dev));
+
+	spin_lock(&cd->spinlock);
+	list_for_each_entry(atten, &cd->atten_list[type], node) {
+		if (atten->ttsp == ttsp && atten->mode == mode) {
+			spin_unlock(&cd->spinlock);
+			kfree(atten_new);
+			dev_vdbg(cd->dev, "%s: %s=%p %s=%d\n",
+				 __func__,
+				 "already subscribed attention",
+				 ttsp, "mode", mode);
+
+			return 0;
+		}
+	}
+
+	atten_new->ttsp = ttsp;
+	atten_new->mode = mode;
+	atten_new->func = func;
+
+	list_add(&atten_new->node, &cd->atten_list[type]);
+	spin_unlock(&cd->spinlock);
+
+	return 0;
+}
+
+static int cyttsp4_unsubscribe_attention_(struct cyttsp4_device *ttsp,
+	enum cyttsp4_atten_type type, int (*func)(struct cyttsp4_device *),
+	int mode)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	struct atten_node *atten, *atten_n;
+
+	spin_lock(&cd->spinlock);
+	list_for_each_entry_safe(atten, atten_n, &cd->atten_list[type], node) {
+		if (atten->ttsp == ttsp && atten->mode == mode) {
+			list_del(&atten->node);
+			spin_unlock(&cd->spinlock);
+			kfree(atten);
+			dev_vdbg(cd->dev, "%s: %s=%p %s=%d\n",
+				__func__,
+				"unsub for atten->ttsp", atten->ttsp,
+				"atten->mode", atten->mode);
+			return 0;
+		}
+	}
+	spin_unlock(&cd->spinlock);
+
+	return -ENODEV;
+}
+
+static int request_exclusive(struct cyttsp4_core_data *cd, void *ownptr,
+		int timeout_ms)
+{
+	int t = msecs_to_jiffies(timeout_ms);
+	bool with_timeout = (timeout_ms != 0);
+
+	mutex_lock(&cd->system_lock);
+	if (!cd->exclusive_dev && cd->exclusive_waits == 0) {
+		cd->exclusive_dev = ownptr;
+		goto exit;
+	}
+
+	cd->exclusive_waits++;
+wait:
+	mutex_unlock(&cd->system_lock);
+	if (with_timeout) {
+		t = wait_event_timeout(cd->wait_q, !cd->exclusive_dev, t);
+		if (IS_TMO(t)) {
+			dev_err(cd->dev, "%s: tmo waiting exclusive access\n",
+				__func__);
+			mutex_lock(&cd->system_lock);
+			cd->exclusive_waits--;
+			mutex_unlock(&cd->system_lock);
+			return -ETIME;
+		}
+	} else {
+		wait_event(cd->wait_q, !cd->exclusive_dev);
+	}
+	mutex_lock(&cd->system_lock);
+	if (cd->exclusive_dev)
+		goto wait;
+	cd->exclusive_dev = ownptr;
+	cd->exclusive_waits--;
+exit:
+	mutex_unlock(&cd->system_lock);
+	dev_vdbg(cd->dev, "%s: request_exclusive ok=%p\n",
+		__func__, ownptr);
+
+	return 0;
+}
+
+static int cyttsp4_request_exclusive_(struct cyttsp4_device *ttsp,
+		int timeout_ms)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	return request_exclusive(cd, (void *)ttsp, timeout_ms);
+}
+
+/*
+ * returns error if was not owned
+ */
+static int release_exclusive(struct cyttsp4_core_data *cd, void *ownptr)
+{
+	mutex_lock(&cd->system_lock);
+	if (cd->exclusive_dev != ownptr) {
+		mutex_unlock(&cd->system_lock);
+		return -EINVAL;
+	}
+
+	dev_vdbg(cd->dev, "%s: exclusive_dev %p freed\n",
+		__func__, cd->exclusive_dev);
+	cd->exclusive_dev = NULL;
+	wake_up(&cd->wait_q);
+	mutex_unlock(&cd->system_lock);
+	return 0;
+}
+
+static int cyttsp4_release_exclusive_(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	return release_exclusive(cd, (void *)ttsp);
+}
+
+static int cyttsp4_wait_bl_heartbeat(struct cyttsp4_core_data *cd)
+{
+	long t;
+	int rc = 0;
+
+	/* wait heartbeat */
+	dev_vdbg(cd->dev, "%s: wait heartbeat...\n", __func__);
+	t = wait_event_timeout(cd->wait_q, cd->mode == CY_MODE_BOOTLOADER,
+			msecs_to_jiffies(CY_CORE_RESET_AND_WAIT_TIMEOUT));
+	if (IS_TMO(t)) {
+		dev_err(cd->dev, "%s: tmo waiting bl heartbeat cd->mode=%d\n",
+			__func__, cd->mode);
+		rc = -ETIME;
+	}
+
+	return rc;
+}
+
+static int cyttsp4_wait_sysinfo_mode(struct cyttsp4_core_data *cd)
+{
+	long t;
+
+	dev_vdbg(cd->dev, "%s: wait sysinfo...\n", __func__);
+
+	t = wait_event_timeout(cd->wait_q, cd->mode == CY_MODE_SYSINFO,
+			msecs_to_jiffies(CY_CORE_WAIT_SYSINFO_MODE_TIMEOUT));
+	if (IS_TMO(t)) {
+		dev_err(cd->dev, "%s: tmo waiting exit bl cd->mode=%d\n",
+			__func__, cd->mode);
+		mutex_lock(&cd->system_lock);
+		cd->int_status &= ~CY_INT_MODE_CHANGE;
+		mutex_unlock(&cd->system_lock);
+		return -ETIME;
+	}
+
+	return 0;
+}
+
+static int cyttsp4_reset_and_wait(struct cyttsp4_core_data *cd)
+{
+	int rc;
+
+	/* reset hardware */
+	mutex_lock(&cd->system_lock);
+	dev_dbg(cd->dev, "%s: reset hw...\n", __func__);
+	rc = cyttsp4_hw_reset_(cd);
+	cd->mode = CY_MODE_UNKNOWN;
+	mutex_unlock(&cd->system_lock);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: %s adap='%s' r=%d\n", __func__,
+			"Fail hw reset", cd->core->adap->id, rc);
+		return rc;
+	}
+
+	return cyttsp4_wait_bl_heartbeat(cd);
+}
+
+/*
+ * returns err if refused or timeout; block until mode change complete
+ * bit is set (mode change interrupt)
+ */
+static int set_mode(struct cyttsp4_core_data *cd, int new_mode)
+{
+	u8 new_dev_mode;
+	u8 mode;
+	long t;
+	int rc;
+
+	switch (new_mode) {
+	case CY_MODE_OPERATIONAL:
+		new_dev_mode = CY_HST_OPERATE;
+		break;
+	case CY_MODE_SYSINFO:
+		new_dev_mode = CY_HST_SYSINFO;
+		break;
+	case CY_MODE_CAT:
+		new_dev_mode = CY_HST_CAT;
+		break;
+	default:
+		dev_err(cd->dev, "%s: invalid mode: %02X(%d)\n",
+			__func__, new_mode, new_mode);
+		return -EINVAL;
+	}
+
+	/* change mode */
+	dev_dbg(cd->dev, "%s: %s=%p new_dev_mode=%02X new_mode=%d\n",
+			__func__, "have exclusive", cd->exclusive_dev,
+			new_dev_mode, new_mode);
+
+	mutex_lock(&cd->system_lock);
+	rc = cyttsp4_adap_read(cd, CY_REG_BASE, &mode, sizeof(mode));
+	if (rc < 0) {
+		mutex_unlock(&cd->system_lock);
+		dev_err(cd->dev, "%s: Fail read mode r=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+	/* Clear device mode bits and set to new mode */
+	mode &= ~CY_HST_DEVICE_MODE;
+	mode |= new_dev_mode | CY_HST_MODE_CHANGE;
+
+	cd->int_status |= CY_INT_MODE_CHANGE;
+	rc = cyttsp4_adap_write(cd, CY_REG_BASE, &mode, sizeof(mode));
+	mutex_unlock(&cd->system_lock);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: Fail write mode change r=%d\n",
+				__func__, rc);
+		goto exit;
+	}
+
+	/* wait for mode change done interrupt */
+	t = wait_event_timeout(cd->wait_q,
+			(cd->int_status & CY_INT_MODE_CHANGE) == 0,
+			msecs_to_jiffies(CY_CORE_MODE_CHANGE_TIMEOUT));
+	dev_dbg(cd->dev, "%s: back from wait t=%ld cd->mode=%d\n",
+			__func__, t, cd->mode);
+
+	if (IS_TMO(t)) {
+		dev_err(cd->dev, "%s: %s\n", __func__,
+				"tmo waiting mode change");
+		mutex_lock(&cd->system_lock);
+		cd->int_status &= ~CY_INT_MODE_CHANGE;
+		mutex_unlock(&cd->system_lock);
+		rc = -EINVAL;
+	}
+
+exit:
+	return rc;
+}
+
+/*
+ * returns err if refused or timeout(core uses fixed timeout period) occurs;
+ * blocks until ISR occurs
+ */
+static int cyttsp4_request_reset_(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	int rc;
+
+	mutex_lock(&cd->system_lock);
+	cd->sysinfo.ready = false;
+	mutex_unlock(&cd->system_lock);
+
+	rc = cyttsp4_reset_and_wait(cd);
+	if (rc < 0)
+		dev_err(cd->dev, "%s: Error on h/w reset r=%d\n",
+			__func__, rc);
+
+	return rc;
+}
+
+/*
+ * returns err if refused ; if no error then restart has completed
+ * and system is in normal operating mode
+ */
+static int cyttsp4_request_restart_(struct cyttsp4_device *ttsp, bool wait)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+
+	mutex_lock(&cd->system_lock);
+	cd->sysinfo.ready = false;
+	mutex_unlock(&cd->system_lock);
+
+	cyttsp4_queue_startup(cd);
+
+	if (wait)
+		wait_event(cd->wait_q, cd->startup_state == STARTUP_NONE);
+
+	return 0;
+}
+
+static int cyttsp4_request_set_mode_(struct cyttsp4_device *ttsp, int mode)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	int rc;
+
+	rc = set_mode(cd, mode);
+	if (rc < 0)
+		dev_err(cd->dev, "%s: fail set_mode=%02X(%d)\n",
+			__func__, cd->mode, cd->mode);
+
+	return rc;
+}
+
+/*
+ * returns NULL if sysinfo has not been acquired from the device yet
+ */
+static struct cyttsp4_sysinfo *cyttsp4_request_sysinfo_(
+		struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	bool ready;
+
+	mutex_lock(&cd->system_lock);
+	ready = cd->sysinfo.ready;
+	mutex_unlock(&cd->system_lock);
+	if (ready)
+		return &cd->sysinfo;
+
+	return NULL;
+}
+
+static struct cyttsp4_loader_platform_data *cyttsp4_request_loader_pdata_(
+		struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	return cd->pdata->loader_pdata;
+}
+
+static int cyttsp4_request_handshake_(struct cyttsp4_device *ttsp, u8 mode)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	int rc;
+
+	rc = cyttsp4_handshake(cd, mode);
+	if (rc < 0)
+		dev_err(&core->dev, "%s: Fail handshake r=%d\n", __func__, rc);
+
+	return rc;
+}
+
+static int cyttsp4_request_toggle_lowpower_(struct cyttsp4_device *ttsp,
+		u8 mode)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	int rc = cyttsp4_toggle_low_power(cd, mode);
+	if (rc < 0)
+		dev_err(&core->dev, "%s: Fail toggle low power r=%d\n",
+				__func__, rc);
+	return rc;
+}
+
+static int _cyttsp4_wait_cmd_exec(struct cyttsp4_core_data *cd, int timeout_ms)
+{
+	struct device *dev = cd->dev;
+	int rc;
+
+	rc = wait_event_timeout(cd->wait_q,
+			(cd->int_status & CY_INT_EXEC_CMD) == 0,
+			msecs_to_jiffies(timeout_ms));
+	if (IS_TMO(rc)) {
+		dev_err(dev, "%s: Command execution timed out\n",
+				__func__);
+		cd->int_status &= ~CY_INT_EXEC_CMD;
+		return -ETIME;
+	}
+	return 0;
+}
+
+static int _get_cmd_offs(struct cyttsp4_core_data *cd, u8 mode)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	struct device *dev = cd->dev;
+	int cmd_ofs;
+
+	switch (mode) {
+	case CY_MODE_CAT:
+		cmd_ofs = CY_REG_CAT_CMD;
+		break;
+	case CY_MODE_OPERATIONAL:
+		cmd_ofs = si->si_ofs.cmd_ofs;
+		break;
+	default:
+		dev_err(dev, "%s: Unsupported mode %x for exec cmd\n",
+				__func__, mode);
+		return -EACCES;
+	}
+
+	return cmd_ofs;
+}
+
+/*
+ * Send command to device for CAT and OP modes
+ * return negative value on error, 0 on success
+ */
+static int _cyttsp4_exec_cmd(struct cyttsp4_core_data *cd, u8 mode,
+		u8 *cmd_buf, size_t cmd_size)
+{
+	struct device *dev = cd->dev;
+	int cmd_ofs;
+	int cmd_param_ofs;
+	u8 command;
+	u8 *cmd_param_buf;
+	size_t cmd_param_size;
+	int rc;
+
+	if (mode != cd->mode) {
+		dev_err(dev, "%s: %s (having %x while %x requested)\n",
+				__func__, "attempt to exec cmd in missing mode",
+				cd->mode, mode);
+		return -EACCES;
+	}
+
+	cmd_ofs = _get_cmd_offs(cd, mode);
+	if (cmd_ofs < 0)
+		return -EACCES;
+
+	cmd_param_ofs = cmd_ofs + 1;
+	cmd_param_buf = cmd_buf + 1;
+	cmd_param_size = cmd_size - 1;
+
+	/* Check if complete is set, so write new command */
+	rc = cyttsp4_adap_read(cd, cmd_ofs, &command, 1);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on read r=%d\n", __func__, rc);
+		return rc;
+	}
+
+	cd->cmd_toggle = GET_TOGGLE(command);
+	cd->int_status |= CY_INT_EXEC_CMD;
+
+	if ((command & CY_CMD_COMPLETE_MASK) == 0)
+		return -EBUSY;
+
+	/*
+	 * Write new command
+	 * Only update command bits 0:5
+	 * Clear command complete bit & toggle bit
+	 */
+	cmd_buf[0] = cmd_buf[0] & CY_CMD_MASK;
+	/* Write command parameters first */
+	if (cmd_size > 1) {
+		rc = cyttsp4_adap_write(cd, cmd_param_ofs, cmd_param_buf,
+				cmd_param_size);
+		if (rc < 0) {
+			dev_err(dev, "%s: Error on write command parameters r=%d\n",
+				__func__, rc);
+			return rc;
+		}
+	}
+	/* Write the command */
+	rc = cyttsp4_adap_write(cd, cmd_ofs, cmd_buf, 1);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on write command r=%d\n",
+				__func__, rc);
+		return rc;
+	}
+
+	return 0;
+}
+
+static int cyttsp4_exec_cmd(struct cyttsp4_core_data *cd, u8 mode,
+		u8 *cmd_buf, size_t cmd_size, u8 *return_buf,
+		size_t return_buf_size, int timeout_ms)
+{
+	struct device *dev = cd->dev;
+	int cmd_ofs;
+	int cmd_return_ofs;
+	int rc;
+
+	mutex_lock(&cd->system_lock);
+	rc = _cyttsp4_exec_cmd(cd, mode, cmd_buf, cmd_size);
+	mutex_unlock(&cd->system_lock);
+
+	if (rc == -EBUSY) {
+		rc = _cyttsp4_wait_cmd_exec(cd, CY_COMMAND_COMPLETE_TIMEOUT);
+		if (rc)
+			return rc;
+		mutex_lock(&cd->system_lock);
+		rc = _cyttsp4_exec_cmd(cd, mode, cmd_buf, cmd_size);
+		mutex_unlock(&cd->system_lock);
+	}
+
+	if (rc < 0)
+		return rc;
+
+	if (timeout_ms == 0)
+		return 0;
+
+	/*
+	 * Wait command to be completed
+	 */
+	rc = _cyttsp4_wait_cmd_exec(cd, timeout_ms);
+	if (rc < 0)
+		return rc;
+
+	if (return_buf_size == 0 || return_buf == NULL)
+		return 0;
+
+	mutex_lock(&cd->system_lock);
+	cmd_ofs = _get_cmd_offs(cd, mode);
+	mutex_unlock(&cd->system_lock);
+	if (cmd_ofs < 0)
+		return -EACCES;
+
+	cmd_return_ofs = cmd_ofs + 1;
+
+	rc = cyttsp4_adap_read(cd, cmd_return_ofs, return_buf, return_buf_size);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on read 3 r=%d\n", __func__, rc);
+		return rc;
+	}
+
+	return 0;
+}
+
+static int cyttsp4_request_exec_cmd_(struct cyttsp4_device *ttsp, u8 mode,
+		u8 *cmd_buf, size_t cmd_size, u8 *return_buf,
+		size_t return_buf_size, int timeout_ms)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	return cyttsp4_exec_cmd(cd, mode, cmd_buf, cmd_size,
+			return_buf, return_buf_size, timeout_ms);
+}
+
+static int cyttsp4_get_parameter(struct cyttsp4_core_data *cd, u8 param_id,
+		u32 *param_value)
+{
+	u8 command_buf[CY_CMD_OP_GET_PARAM_CMD_SZ];
+	u8 return_buf[CY_CMD_OP_GET_PARAM_RET_SZ];
+	u8 param_size;
+	u8 *value_buf;
+	int rc;
+
+	command_buf[0] = CY_CMD_OP_GET_PARAM;
+	command_buf[1] = param_id;
+	rc = cyttsp4_exec_cmd(cd, CY_MODE_OPERATIONAL,
+			command_buf, CY_CMD_OP_GET_PARAM_CMD_SZ,
+			return_buf, CY_CMD_OP_GET_PARAM_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: Unable to execute get parameter command.\n",
+			__func__);
+		return rc;
+	}
+
+	if (return_buf[0] != param_id) {
+		dev_err(cd->dev, "%s: Fail to execute get parameter command.\n",
+			__func__);
+		return -EIO;
+	}
+
+	param_size = return_buf[1];
+	value_buf = &return_buf[2];
+
+	*param_value = 0;
+	while (param_size--)
+		*param_value += *(value_buf++) << (8 * param_size);
+
+	return 0;
+}
+
+static int cyttsp4_set_parameter(struct cyttsp4_core_data *cd, u8 param_id,
+		u8 param_size, u32 param_value)
+{
+	u8 command_buf[CY_CMD_OP_SET_PARAM_CMD_SZ];
+	u8 return_buf[CY_CMD_OP_SET_PARAM_RET_SZ];
+	int rc;
+
+	command_buf[0] = CY_CMD_OP_SET_PARAM;
+	command_buf[1] = param_id;
+	command_buf[2] = param_size;
+
+	if (param_size == 1) {
+		command_buf[3] = (u8)param_value;
+	} else if (param_size == 2) {
+		command_buf[3] = (u8)(param_value >> 8);
+		command_buf[4] = (u8)param_value;
+	} else if (param_size == 4) {
+		command_buf[3] = (u8)(param_value >> 24);
+		command_buf[4] = (u8)(param_value >> 16);
+		command_buf[5] = (u8)(param_value >> 8);
+		command_buf[6] = (u8)param_value;
+	} else {
+		dev_err(cd->dev, "%s: Invalid parameter size %d\n",
+			__func__, param_size);
+		return -EINVAL;
+	}
+
+	rc = cyttsp4_exec_cmd(cd, CY_MODE_OPERATIONAL,
+			command_buf, 3 + param_size,
+			return_buf, CY_CMD_OP_SET_PARAM_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: Unable to execute set parameter command.\n",
+			__func__);
+		return rc;
+	}
+
+	if (return_buf[0] != param_id || return_buf[1] != param_size) {
+		dev_err(cd->dev, "%s: Fail to execute set parameter command.\n",
+			__func__);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int cyttsp4_get_scantype(struct cyttsp4_core_data *cd, u8 *scantype)
+{
+	int rc;
+	u32 value;
+
+	rc = cyttsp4_get_parameter(cd, CY_RAM_ID_SCAN_TYPE, &value);
+	if (!rc)
+		*scantype = (u8)value;
+
+	return rc;
+}
+
+static int cyttsp4_set_scantype(struct cyttsp4_core_data *cd, u8 scantype)
+{
+	int rc;
+
+	rc = cyttsp4_set_parameter(cd, CY_RAM_ID_SCAN_TYPE, 1, scantype);
+
+	return rc;
+}
+
+static u8 _cyttsp4_generate_new_scantype(struct cyttsp4_core_data *cd)
+{
+	u8 new_scantype = cd->default_scantype;
+
+	if (cd->apa_mc_en)
+		new_scantype |= CY_SCAN_TYPE_APA_MC;
+	if (cd->glove_en)
+		new_scantype |= CY_SCAN_TYPE_GLOVE;
+	if (cd->stylus_en)
+		new_scantype |= CY_SCAN_TYPE_STYLUS;
+	if (cd->proximity_en)
+		new_scantype |= CY_SCAN_TYPE_PROXIMITY;
+
+	return new_scantype;
+}
+
+static int cyttsp4_set_new_scan_type(struct cyttsp4_core_data *cd,
+		u8 scan_type, bool enable)
+{
+	int inc = enable ? 1 : -1;
+	int *en;
+	int rc;
+	u8 new_scantype;
+
+	switch (scan_type) {
+	case CY_ST_GLOVE:
+		en = &cd->glove_en;
+		break;
+	case CY_ST_STYLUS:
+		en = &cd->stylus_en;
+		break;
+	case CY_ST_PROXIMITY:
+		en = &cd->proximity_en;
+		break;
+	case CY_ST_APA_MC:
+		en = &cd->apa_mc_en;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	*en += inc;
+
+	new_scantype = _cyttsp4_generate_new_scantype(cd);
+
+	rc = cyttsp4_set_scantype(cd, new_scantype);
+	if (rc)
+		*en -= inc;
+
+	return rc;
+}
+
+static int cyttsp4_request_enable_scan_type_(struct cyttsp4_device *ttsp,
+		u8 scan_type)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+
+	return cyttsp4_set_new_scan_type(cd, scan_type, true);
+}
+
+static int cyttsp4_request_disable_scan_type_(struct cyttsp4_device *ttsp,
+		u8 scan_type)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+
+	return cyttsp4_set_new_scan_type(cd, scan_type, false);
+}
+
+static int cyttsp4_read_config_block(struct cyttsp4_core_data *cd, u8 ebid,
+		u16 row, u8 *data, u16 length)
+{
+	u8 command_buf[CY_CMD_CAT_READ_CFG_BLK_CMD_SZ];
+	u8 *return_buf;
+	int return_buf_sz;
+	u16 crc;
+	int rc;
+
+	/* Allocate buffer for read config block command response
+	 * Header(5) + Data(length) + CRC(2)
+	 */
+	return_buf_sz = CY_CMD_CAT_READ_CFG_BLK_RET_SZ + length;
+	return_buf = kmalloc(return_buf_sz, GFP_KERNEL);
+	if (!return_buf) {
+		dev_err(cd->dev, "%s: Cannot allocate buffer\n",
+			__func__);
+		rc = -ENOMEM;
+		goto exit;
+	}
+
+	command_buf[0] = CY_CMD_CAT_READ_CFG_BLK;
+	command_buf[1] = HI_BYTE(row);
+	command_buf[2] = LO_BYTE(row);
+	command_buf[3] = HI_BYTE(length);
+	command_buf[4] = LO_BYTE(length);
+	command_buf[5] = ebid;
+
+	rc = cyttsp4_exec_cmd(cd, CY_MODE_CAT,
+			command_buf, CY_CMD_CAT_READ_CFG_BLK_CMD_SZ,
+			return_buf, return_buf_sz,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error executing command r=%d\n",
+			__func__, rc);
+		goto free_buffer;
+	}
+
+	crc = cyttsp4_calc_app_crc(
+		&return_buf[CY_CMD_CAT_READ_CFG_BLK_RET_HDR_SZ], length);
+
+	/* Validate response */
+	if (return_buf[0] != CY_CMD_STATUS_SUCCESS
+			|| return_buf[1] != ebid
+			|| return_buf[2] != HI_BYTE(length)
+			|| return_buf[3] != LO_BYTE(length)
+			|| return_buf[CY_CMD_CAT_READ_CFG_BLK_RET_HDR_SZ
+				+ length] != HI_BYTE(crc)
+			|| return_buf[CY_CMD_CAT_READ_CFG_BLK_RET_HDR_SZ
+				+ length + 1] != LO_BYTE(crc)) {
+		dev_err(cd->dev, "%s: Fail executing command\n",
+				__func__);
+		rc = -EINVAL;
+		goto free_buffer;
+	}
+
+	memcpy(data, &return_buf[CY_CMD_CAT_READ_CFG_BLK_RET_HDR_SZ], length);
+
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf, data, length, "read_config_block");
+
+free_buffer:
+	kfree(return_buf);
+exit:
+	return rc;
+}
+
+static int cyttsp4_write_config_block(struct cyttsp4_core_data *cd, u8 ebid,
+		u16 row, const u8 *data, u16 length)
+{
+	u8 return_buf[CY_CMD_CAT_WRITE_CFG_BLK_RET_SZ];
+	u8 *command_buf;
+	int command_buf_sz;
+	u16 crc;
+	int rc;
+
+	/* Allocate buffer for write config block command
+	 * Header(6) + Data(length) + Security Key(8) + CRC(2)
+	 */
+	command_buf_sz = CY_CMD_CAT_WRITE_CFG_BLK_CMD_SZ + length
+		+ sizeof(security_key);
+	command_buf = kmalloc(command_buf_sz, GFP_KERNEL);
+	if (!command_buf) {
+		dev_err(cd->dev, "%s: Cannot allocate buffer\n",
+			__func__);
+		rc = -ENOMEM;
+		goto exit;
+	}
+
+	crc = cyttsp4_calc_app_crc(data, length);
+
+	command_buf[0] = CY_CMD_CAT_WRITE_CFG_BLK;
+	command_buf[1] = HI_BYTE(row);
+	command_buf[2] = LO_BYTE(row);
+	command_buf[3] = HI_BYTE(length);
+	command_buf[4] = LO_BYTE(length);
+	command_buf[5] = ebid;
+
+	command_buf[CY_CMD_CAT_WRITE_CFG_BLK_CMD_HDR_SZ + length
+		+ sizeof(security_key)] = HI_BYTE(crc);
+	command_buf[CY_CMD_CAT_WRITE_CFG_BLK_CMD_HDR_SZ + 1 + length
+		+ sizeof(security_key)] = LO_BYTE(crc);
+
+	memcpy(&command_buf[CY_CMD_CAT_WRITE_CFG_BLK_CMD_HDR_SZ], data,
+		length);
+	memcpy(&command_buf[CY_CMD_CAT_WRITE_CFG_BLK_CMD_HDR_SZ + length],
+		security_key, sizeof(security_key));
+
+	cyttsp4_pr_buf(cd->dev, cd->pr_buf, command_buf, command_buf_sz,
+		"write_config_block");
+
+	rc = cyttsp4_exec_cmd(cd, CY_MODE_CAT,
+			command_buf, command_buf_sz,
+			return_buf, CY_CMD_CAT_WRITE_CFG_BLK_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error executing command r=%d\n",
+			__func__, rc);
+		goto free_buffer;
+	}
+
+	/* Validate response */
+	if (return_buf[0] != CY_CMD_STATUS_SUCCESS
+			|| return_buf[1] != ebid
+			|| return_buf[2] != HI_BYTE(length)
+			|| return_buf[3] != LO_BYTE(length)) {
+		dev_err(cd->dev, "%s: Fail executing command\n",
+				__func__);
+		rc = -EINVAL;
+		goto free_buffer;
+	}
+
+free_buffer:
+	kfree(command_buf);
+exit:
+	return rc;
+}
+
+static int cyttsp4_get_config_row_size(struct cyttsp4_core_data *cd,
+		u16 *config_row_size)
+{
+	u8 command_buf[CY_CMD_CAT_GET_CFG_ROW_SIZE_CMD_SZ];
+	u8 return_buf[CY_CMD_CAT_GET_CFG_ROW_SIZE_RET_SZ];
+	int rc;
+
+	command_buf[0] = CY_CMD_CAT_GET_CFG_ROW_SZ;
+
+	rc = cyttsp4_exec_cmd(cd, CY_MODE_CAT,
+			command_buf, CY_CMD_CAT_GET_CFG_ROW_SIZE_CMD_SZ,
+			return_buf, CY_CMD_CAT_GET_CFG_ROW_SIZE_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error executing command r=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+	*config_row_size = get_unaligned_be16(&return_buf[0]);
+
+exit:
+	return rc;
+}
+
+static int cyttsp4_request_config_row_size_(struct cyttsp4_device *ttsp,
+		u16 *config_row_size)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+
+	return cyttsp4_get_config_row_size(cd, config_row_size);
+}
+
+static int cyttsp4_verify_config_block_crc(struct cyttsp4_core_data *cd,
+		u8 ebid, u16 *calc_crc, u16 *stored_crc, bool *match)
+{
+	u8 command_buf[CY_CMD_CAT_VERIFY_CFG_BLK_CRC_CMD_SZ];
+	u8 return_buf[CY_CMD_CAT_VERIFY_CFG_BLK_CRC_RET_SZ];
+	int rc;
+
+	command_buf[0] = CY_CMD_CAT_VERIFY_CFG_BLK_CRC;
+	command_buf[1] = ebid;
+
+	rc = cyttsp4_exec_cmd(cd, CY_MODE_CAT,
+			command_buf, CY_CMD_CAT_VERIFY_CFG_BLK_CRC_CMD_SZ,
+			return_buf, CY_CMD_CAT_VERIFY_CFG_BLK_CRC_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error executing command r=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+	*calc_crc = get_unaligned_be16(&return_buf[1]);
+	*stored_crc = get_unaligned_be16(&return_buf[3]);
+	if (match)
+		*match = !return_buf[0];
+exit:
+	return rc;
+}
+
+static int cyttsp4_get_config_block_crc(struct cyttsp4_core_data *cd,
+		u8 ebid, u16 *crc)
+{
+	u8 command_buf[CY_CMD_OP_GET_CFG_BLK_CRC_CMD_SZ];
+	u8 return_buf[CY_CMD_OP_GET_CFG_BLK_CRC_RET_SZ];
+	int rc;
+
+	command_buf[0] = CY_CMD_OP_GET_CRC;
+	command_buf[1] = ebid;
+
+	rc = cyttsp4_exec_cmd(cd, CY_MODE_OPERATIONAL,
+			command_buf, CY_CMD_OP_GET_CFG_BLK_CRC_CMD_SZ,
+			return_buf, CY_CMD_OP_GET_CFG_BLK_CRC_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error executing command r=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+	/* Validate response */
+	if (return_buf[0] != CY_CMD_STATUS_SUCCESS) {
+		dev_err(cd->dev, "%s: Fail executing command\n",
+				__func__);
+		rc = -EINVAL;
+		goto exit;
+	}
+
+	*crc = get_unaligned_be16(&return_buf[1]);
+
+exit:
+	return rc;
+}
+
+static int cyttsp4_get_ttconfig_version(struct cyttsp4_core_data *cd,
+		u16 *version)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	u8 data[CY_TTCONFIG_VERSION_OFFSET + CY_TTCONFIG_VERSION_SIZE];
+	int rc;
+	bool ready;
+
+	mutex_lock(&cd->system_lock);
+	ready = si->ready;
+	mutex_unlock(&cd->system_lock);
+
+	if (!ready) {
+		rc  = -ENODEV;
+		goto exit;
+	}
+
+	rc = cyttsp4_read_config_block(cd, CY_TCH_PARM_EBID,
+			CY_TTCONFIG_VERSION_ROW, data, sizeof(data));
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on read config block\n",
+			__func__);
+		goto exit;
+	}
+
+	*version = GET_FIELD16(si, &data[CY_TTCONFIG_VERSION_OFFSET]);
+
+exit:
+	return rc;
+}
+
+static int cyttsp4_get_config_length(struct cyttsp4_core_data *cd, u8 ebid,
+		u16 *length, u16 *max_length)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	u8 data[CY_CONFIG_LENGTH_INFO_SIZE];
+	int rc;
+	bool ready;
+
+	mutex_lock(&cd->system_lock);
+	ready = si->ready;
+	mutex_unlock(&cd->system_lock);
+
+	if (!ready) {
+		rc  = -ENODEV;
+		goto exit;
+	}
+
+	rc = cyttsp4_read_config_block(cd, ebid, CY_CONFIG_LENGTH_INFO_OFFSET,
+			data, sizeof(data));
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on read config block\n",
+			__func__);
+		goto exit;
+	}
+
+	*length = GET_FIELD16(si, &data[CY_CONFIG_LENGTH_OFFSET]);
+	*max_length = GET_FIELD16(si, &data[CY_CONFIG_MAXLENGTH_OFFSET]);
+
+exit:
+	return rc;
+}
+
+static int cyttsp4_write_config_common(struct cyttsp4_core_data *cd, u8 ebid,
+		u16 offset, u8 *data, u16 length)
+{
+	u16 cur_block, cur_off, end_block, end_off;
+	int copy_len;
+	u16 config_row_size = 0;
+	u8 *row_data = NULL;
+	int rc;
+
+	rc = cyttsp4_get_config_row_size(cd, &config_row_size);
+	if (rc) {
+		dev_err(cd->dev, "%s: Cannot get config row size\n",
+			__func__);
+		goto exit;
+	}
+
+	cur_block = offset / config_row_size;
+	cur_off = offset % config_row_size;
+
+	end_block = (offset + length) / config_row_size;
+	end_off = (offset + length) % config_row_size;
+
+	/* Check whether we need to fetch the whole block first */
+	if (cur_off == 0)
+		goto no_offset;
+
+	row_data = kmalloc(config_row_size, GFP_KERNEL);
+	if (!row_data) {
+		dev_err(cd->dev, "%s: Cannot allocate buffer\n", __func__);
+		rc = -ENOMEM;
+		goto exit;
+	}
+
+	copy_len = (cur_block == end_block) ?
+		length : config_row_size - cur_off;
+
+	/* Read up to current offset, append the new data and write it back */
+	rc = cyttsp4_read_config_block(cd, ebid, cur_block, row_data, cur_off);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on read config block\n", __func__);
+		goto free_row_data;
+	}
+
+	memcpy(&row_data[cur_off], data, copy_len);
+
+	rc = cyttsp4_write_config_block(cd, ebid, cur_block, row_data,
+			cur_off + copy_len);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on initial write config block\n",
+			__func__);
+		goto free_row_data;
+	}
+
+	data += copy_len;
+	cur_off = 0;
+	cur_block++;
+
+no_offset:
+	while (cur_block < end_block) {
+		rc = cyttsp4_write_config_block(cd, ebid, cur_block, data,
+				config_row_size);
+		if (rc) {
+			dev_err(cd->dev, "%s: Error on write config block\n",
+				__func__);
+			goto free_row_data;
+		}
+
+		data += config_row_size;
+		cur_block++;
+	}
+
+	/* Last block */
+	if (cur_block == end_block) {
+		rc = cyttsp4_write_config_block(cd, ebid, end_block, data,
+				end_off);
+		if (rc) {
+			dev_err(cd->dev, "%s: Error on last write config block\n",
+				__func__);
+			goto free_row_data;
+		}
+	}
+
+free_row_data:
+	kfree(row_data);
+exit:
+	return rc;
+}
+
+static int cyttsp4_write_config(struct cyttsp4_core_data *cd, u8 ebid,
+		u16 offset, u8 *data, u16 length) {
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	u16 crc_new, crc_old;
+	u16 crc_offset;
+	u16 conf_len;
+	u8 crc_data[2];
+	int rc;
+	bool ready;
+
+	mutex_lock(&cd->system_lock);
+	ready = si->ready;
+	mutex_unlock(&cd->system_lock);
+
+	if (!ready) {
+		rc  = -ENODEV;
+		goto exit;
+	}
+
+	/* CRC is stored at config max length offset */
+	rc = cyttsp4_get_config_length(cd, ebid, &conf_len, &crc_offset);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on get config length\n",
+			__func__);
+		goto exit;
+	}
+
+	/* Allow CRC update also */
+	if (offset + length > crc_offset + 2) {
+		dev_err(cd->dev, "%s: offset + length exceeds max length(%d)\n",
+			__func__, crc_offset + 2);
+		rc = -EINVAL;
+		goto exit;
+	}
+
+	rc = cyttsp4_write_config_common(cd, ebid, offset, data, length);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on write config\n",
+			__func__);
+		goto exit;
+	}
+
+	/* Verify config block CRC */
+	rc = cyttsp4_verify_config_block_crc(cd, ebid,
+			&crc_new, &crc_old, NULL);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on verify config block crc\n",
+			__func__);
+		goto exit;
+	}
+
+	dev_vdbg(cd->dev, "%s: crc_new:%04X crc_old:%04X\n",
+		__func__, crc_new, crc_old);
+
+	if (crc_new == crc_old) {
+		dev_vdbg(cd->dev, "%s: Calculated crc matches stored crc\n",
+			__func__);
+		goto exit;
+	}
+
+	PUT_FIELD16(si, crc_new, crc_data);
+
+	rc = cyttsp4_write_config_common(cd, ebid, crc_offset, crc_data, 2);
+	if (rc) {
+		dev_err(cd->dev, "%s: Error on write config crc\n",
+			__func__);
+		goto exit;
+	}
+
+exit:
+	return rc;
+}
+
+static int cyttsp4_request_write_config_(struct cyttsp4_device *ttsp, u8 ebid,
+		u16 offset, u8 *data, u16 length) {
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+
+	return cyttsp4_write_config(cd, ebid, offset, data, length);
+}
+
+#ifdef CYTTSP4_WATCHDOG_NULL_CMD
+static void cyttsp4_watchdog_work(struct work_struct *work)
+{
+	struct cyttsp4_core_data *cd =
+		container_of(work, struct cyttsp4_core_data, watchdog_work);
+	u8 cmd_buf[CY_CMD_OP_NULL_CMD_SZ];
+	bool restart = false;
+	int rc;
+
+	rc = request_exclusive(cd, cd->core, 1);
+	if (rc < 0) {
+		dev_vdbg(cd->dev, "%s: fail get exclusive ex=%p own=%p\n",
+				__func__, cd->exclusive_dev, cd->core);
+		goto exit;
+	}
+
+	cmd_buf[0] = CY_CMD_OP_NULL;
+	rc = cyttsp4_exec_cmd(cd, cd->mode,
+			cmd_buf, CY_CMD_OP_NULL_CMD_SZ,
+			NULL, CY_CMD_OP_NULL_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: Watchdog NULL cmd failed.\n", __func__);
+		restart = true;
+	}
+
+	if (release_exclusive(cd, cd->core) < 0)
+		dev_err(cd->dev, "%s: fail to release exclusive\n", __func__);
+	else
+		dev_vdbg(cd->dev, "%s: pass release exclusive\n", __func__);
+exit:
+	if (restart)
+		cyttsp4_queue_startup(cd);
+	else
+		cyttsp4_start_wd_timer(cd);
+}
+#else
+static void cyttsp4_watchdog_work(struct work_struct *work)
+{
+	struct cyttsp4_core_data *cd =
+		container_of(work, struct cyttsp4_core_data, watchdog_work);
+	u8 mode[2];
+	bool restart = false;
+	int rc;
+
+	if (cd == NULL) {
+		dev_err(cd->dev, "%s: NULL context pointer\n", __func__);
+		return;
+	}
+
+	mutex_lock(&cd->system_lock);
+	rc = cyttsp4_adap_read(cd, CY_REG_BASE, &mode, sizeof(mode));
+	if (rc) {
+		dev_err(cd->dev, "%s: failed to access device r=%d\n",
+			__func__, rc);
+		restart = true;
+		goto exit;
+	}
+
+	if (IS_BOOTLOADER(mode[0], mode[1])) {
+		dev_err(cd->dev, "%s: device found in bootloader mode\n",
+			__func__);
+		restart = true;
+		goto exit;
+	}
+exit:
+	if (restart)
+		cyttsp4_queue_startup_(cd);
+	else
+		cyttsp4_start_wd_timer(cd);
+	mutex_unlock(&cd->system_lock);
+}
+#endif
+
+static int cyttsp4_request_stop_wd_(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *core = ttsp->core;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(&core->dev);
+	cyttsp4_stop_wd_timer(cd);
+	return 0;
+}
+
+static int _cyttsp4_put_device_into_deep_sleep(struct cyttsp4_core_data *cd,
+		u8 hst_mode_reg)
+{
+	int rc;
+
+	hst_mode_reg |= CY_HST_SLEEP;
+
+	dev_vdbg(cd->dev, "%s: write DEEP SLEEP...\n", __func__);
+	rc = cyttsp4_adap_write(cd, CY_REG_BASE, &hst_mode_reg,
+			sizeof(hst_mode_reg));
+	if (rc) {
+		dev_err(cd->dev, "%s: Fail write adapter r=%d\n", __func__, rc);
+		return -EINVAL;
+	}
+	dev_vdbg(cd->dev, "%s: write DEEP SLEEP succeeded\n", __func__);
+
+	if (cd->pdata->power) {
+		dev_dbg(cd->dev, "%s: Power down HW\n", __func__);
+		rc = cd->pdata->power(cd->pdata, 0, cd->dev, &cd->ignore_irq);
+	} else {
+		dev_dbg(cd->dev, "%s: No power function\n", __func__);
+		rc = 0;
+	}
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: HW Power down fails r=%d\n",
+				__func__, rc);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int _cyttsp4_put_device_into_easy_wakeup(struct cyttsp4_core_data *cd)
+{
+	u8 command_buf[CY_CMD_OP_WAIT_FOR_EVENT_CMD_SZ];
+	int rc;
+
+	if (!IS_TTSP_VER_GE(&cd->sysinfo, 2, 5))
+		return -EINVAL;
+
+	command_buf[0] = CY_CMD_OP_WAIT_FOR_EVENT;
+	command_buf[1] = cd->easy_wakeup_gesture;
+
+	rc = _cyttsp4_exec_cmd(cd, CY_MODE_OPERATIONAL, command_buf,
+			CY_CMD_OP_WAIT_FOR_EVENT_CMD_SZ);
+	cd->int_status &= ~CY_INT_EXEC_CMD;
+	if (rc)
+		dev_err(cd->dev, "%s: Error executing command r=%d\n",
+			__func__, rc);
+
+	return rc;
+}
+
+static int _cyttsp4_wait_for_refresh_cycle(struct cyttsp4_core_data *cd,
+		int cycle)
+{
+	int active_refresh_cycle_ms;
+
+	if (cd->active_refresh_cycle_ms)
+		active_refresh_cycle_ms = cd->active_refresh_cycle_ms;
+	else
+		active_refresh_cycle_ms = 20;
+
+	msleep(cycle * active_refresh_cycle_ms);
+
+	return 0;
+}
+
+static int _cyttsp4_put_device_into_sleep(struct cyttsp4_core_data *cd,
+		u8 hst_mode_reg)
+{
+	int rc;
+
+	if (IS_DEEP_SLEEP_CONFIGURED(cd->easy_wakeup_gesture))
+		rc = _cyttsp4_put_device_into_deep_sleep(cd, hst_mode_reg);
+	else
+		rc = _cyttsp4_put_device_into_easy_wakeup(cd);
+
+	return rc;
+}
+
+static int cyttsp4_core_sleep_(struct cyttsp4_core_data *cd)
+{
+	u8 mode[2];
+	int rc = 0;
+
+	cyttsp4_stop_wd_timer(cd);
+
+	/* Wait until currently running IRQ handler exits and disable IRQ */
+	disable_irq(cd->irq);
+
+	mutex_lock(&cd->system_lock);
+	/* Already in sleep mode? */
+	if (cd->sleep_state == SS_SLEEP_ON)
+		goto exit;
+
+	cd->sleep_state = SS_SLEEPING;
+
+	rc = cyttsp4_adap_read(cd, CY_REG_BASE, &mode, sizeof(mode));
+	if (rc) {
+		dev_err(cd->dev, "%s: Fail read adapter r=%d\n", __func__, rc);
+		goto exit;
+	}
+
+	if (IS_BOOTLOADER(mode[0], mode[1])) {
+		dev_err(cd->dev, "%s: Device in BOOTLADER mode.\n", __func__);
+		rc = -EINVAL;
+		goto exit;
+	}
+
+	/* Deep sleep is only allowed in Operating mode */
+	if (GET_HSTMODE(mode[0]) != CY_HST_OPERATE) {
+		dev_err(cd->dev, "%s: Device is not in Operating mode (%02X)\n",
+			__func__, GET_HSTMODE(mode[0]));
+		mutex_unlock(&cd->system_lock);
+		enable_irq(cd->irq);
+		/* Try switching to Operating mode */
+		rc = set_mode(cd, CY_MODE_OPERATIONAL);
+		disable_irq(cd->irq);
+		mutex_lock(&cd->system_lock);
+		if (rc < 0) {
+			dev_err(cd->dev, "%s: failed to set mode to Operational rc=%d\n",
+				__func__, rc);
+			cyttsp4_queue_startup_(cd);
+			rc = 0;
+			goto exit;
+		}
+
+		/* Get the new host mode register value */
+		rc = cyttsp4_adap_read(cd, CY_REG_BASE, &mode, sizeof(mode));
+		if (rc) {
+			dev_err(cd->dev, "%s: Fail read adapter r=%d\n",
+				__func__, rc);
+			goto exit;
+		}
+	}
+
+	rc = _cyttsp4_put_device_into_sleep(cd, mode[0]);
+
+exit:
+	if (rc) {
+		cd->sleep_state = SS_SLEEP_OFF;
+		cyttsp4_start_wd_timer(cd);
+	} else {
+		cd->sleep_state = SS_SLEEP_ON;
+		cd->int_status |= CY_INT_IGNORE;
+	}
+
+	mutex_unlock(&cd->system_lock);
+	enable_irq(cd->irq);
+
+	return rc;
+}
+
+static int cyttsp4_core_sleep(struct cyttsp4_core_data *cd)
+{
+	int rc;
+
+	rc = request_exclusive(cd, cd->core,
+			CY_CORE_SLEEP_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail get exclusive ex=%p own=%p\n",
+				__func__, cd->exclusive_dev, cd->core);
+		return 0;
+	}
+
+	rc = cyttsp4_core_sleep_(cd);
+
+	if (release_exclusive(cd, cd->core) < 0)
+		dev_err(cd->dev, "%s: fail to release exclusive\n", __func__);
+	else
+		dev_vdbg(cd->dev, "%s: pass release exclusive\n", __func__);
+
+	/* Give time to FW to sleep */
+	_cyttsp4_wait_for_refresh_cycle(cd, 2);
+
+	cd->suspended = true;
+
+	return rc;
+}
+
+static int _cyttsp4_awake_device_from_deep_sleep(struct cyttsp4_core_data *cd,
+		int timeout_ms)
+{
+	struct device *dev = cd->dev;
+	u8 mode;
+	int t;
+	int rc;
+
+	cd->int_status |= CY_INT_AWAKE;
+
+	if (cd->pdata->power) {
+		/* Wake up using platform power function */
+		dev_dbg(dev, "%s: Power up HW\n", __func__);
+		rc = cd->pdata->power(cd->pdata, 1, dev, &cd->ignore_irq);
+	} else {
+		/* Initiate a read transaction to wake up */
+		rc = cyttsp4_adap_read(cd, CY_REG_BASE, &mode, sizeof(mode));
+	}
+	if (rc < 0) {
+		dev_err(dev, "%s: HW Power up fails r=%d\n", __func__, rc);
+		/* Initiate another read transaction to wake up */
+		rc = cyttsp4_adap_read(cd, CY_REG_BASE, &mode, sizeof(mode));
+	} else
+		dev_vdbg(cd->dev, "%s: HW power up succeeds\n", __func__);
+	mutex_unlock(&cd->system_lock);
+
+	t = wait_event_timeout(cd->wait_q,
+			(cd->int_status & CY_INT_AWAKE) == 0,
+			msecs_to_jiffies(timeout_ms));
+	mutex_lock(&cd->system_lock);
+	if (IS_TMO(t)) {
+		dev_dbg(dev, "%s: TMO waiting for wakeup\n", __func__);
+		cd->int_status &= ~CY_INT_AWAKE;
+		/* Perform a read transaction to check if device is awake */
+		rc = cyttsp4_adap_read(cd, CY_REG_BASE, &mode, sizeof(mode));
+		if (rc < 0 || GET_HSTMODE(mode) != CY_HST_OPERATE) {
+			dev_err(dev, "%s: Queueing startup\n", __func__);
+			/* Try starting up */
+			cyttsp4_queue_startup_(cd);
+		}
+	}
+
+	return rc;
+}
+
+static int _cyttsp4_awake_device(struct cyttsp4_core_data *cd)
+{
+	int timeout_ms;
+
+	if (cd->wake_initiated_by_device) {
+		cd->wake_initiated_by_device = 0;
+		/* To prevent sequential wake/sleep caused by ttsp modules */
+		msleep(20);
+		return 0;
+	}
+
+	if (IS_DEEP_SLEEP_CONFIGURED(cd->easy_wakeup_gesture))
+		timeout_ms = CY_CORE_WAKEUP_TIMEOUT;
+	else
+		timeout_ms = CY_CORE_WAKEUP_TIMEOUT * 4;
+
+	return _cyttsp4_awake_device_from_deep_sleep(cd, timeout_ms);
+}
+
+static int cyttsp4_core_wake_(struct cyttsp4_core_data *cd)
+{
+	int rc;
+
+	/* Already woken? */
+	mutex_lock(&cd->system_lock);
+	if (cd->sleep_state == SS_SLEEP_OFF) {
+		mutex_unlock(&cd->system_lock);
+		return 0;
+	}
+
+	cd->int_status &= ~CY_INT_IGNORE;
+	cd->sleep_state = SS_WAKING;
+
+	rc = _cyttsp4_awake_device(cd);
+
+	cd->sleep_state = SS_SLEEP_OFF;
+	mutex_unlock(&cd->system_lock);
+
+	cyttsp4_start_wd_timer(cd);
+
+	return 0;
+}
+
+static int cyttsp4_core_wake(struct cyttsp4_core_data *cd)
+{
+	int rc;
+
+	rc = request_exclusive(cd, cd->core,
+			CY_CORE_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail get exclusive ex=%p own=%p\n",
+				__func__, cd->exclusive_dev, cd->core);
+		return 0;
+	}
+
+	rc = cyttsp4_core_wake_(cd);
+
+	if (release_exclusive(cd, cd->core) < 0)
+		dev_err(cd->dev, "%s: fail to release exclusive\n", __func__);
+	else
+		dev_vdbg(cd->dev, "%s: pass release exclusive\n", __func__);
+
+	/* If a startup queued in wake, wait it to finish */
+	wait_event_timeout(cd->wait_q, cd->startup_state == STARTUP_NONE,
+			msecs_to_jiffies(CY_CORE_RESET_AND_WAIT_TIMEOUT));
+
+	cd->suspended = false;
+
+	return rc;
+}
+
+static int cyttsp4_get_ttconfig_info(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+	u16 length, max_length;
+	u16 version = 0;
+	u16 crc = 0;
+	int rc;
+
+	rc = set_mode(cd, CY_MODE_CAT);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to set mode to CAT rc=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	rc = cyttsp4_get_ttconfig_version(cd, &version);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get ttconfig version rc=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	rc = cyttsp4_get_config_length(cd, CY_TCH_PARM_EBID,
+			&length, &max_length);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get ttconfig length rc=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	rc = set_mode(cd, CY_MODE_OPERATIONAL);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to set mode to Operational rc=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	rc = cyttsp4_get_config_block_crc(cd, CY_TCH_PARM_EBID, &crc);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get ttconfig crc rc=%d\n",
+			__func__, rc);
+		return rc;
+	}
+
+	si->ttconfig.version = version;
+	si->ttconfig.length = length;
+	si->ttconfig.max_length = max_length;
+	si->ttconfig.crc = crc;
+
+	dev_vdbg(cd->dev, "%s: TT Config Version:%04X Length:%d Max Length:%d CRC:%04X\n",
+		__func__, si->ttconfig.version, si->ttconfig.length,
+		si->ttconfig.length, si->ttconfig.crc);
+
+	return 0;
+}
+static int cyttsp4_get_active_refresh_cycle(struct cyttsp4_core_data *cd)
+{
+	int rc;
+	u32 value;
+
+	rc = cyttsp4_get_parameter(cd, CY_RAM_ID_REFRESH_INTERVAL, &value);
+	if (!rc)
+		cd->active_refresh_cycle_ms = (u8)value;
+
+	return rc;
+}
+
+static int cyttsp4_set_initial_scantype(struct cyttsp4_core_data *cd)
+{
+	u8 new_scantype;
+	int rc;
+
+	rc = cyttsp4_get_scantype(cd, &cd->default_scantype);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get scantype rc=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+	/* Disable proximity sensing by default */
+	cd->default_scantype &= ~CY_SCAN_TYPE_PROXIMITY;
+
+	new_scantype = _cyttsp4_generate_new_scantype(cd);
+
+	rc = cyttsp4_set_scantype(cd, new_scantype);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to set scantype rc=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+exit:
+	return rc;
+}
+
+static int cyttsp4_startup_(struct cyttsp4_core_data *cd)
+{
+	int retry = CY_CORE_STARTUP_RETRY_COUNT;
+	int rc;
+	bool detected = false;
+
+	dev_dbg(cd->dev, "%s: enter...\n", __func__);
+
+	cyttsp4_stop_wd_timer(cd);
+
+reset:
+	if (retry != CY_CORE_STARTUP_RETRY_COUNT)
+		dev_dbg(cd->dev, "%s: Retry %d\n", __func__,
+			CY_CORE_STARTUP_RETRY_COUNT - retry);
+
+	/* reset hardware and wait for heartbeat */
+	rc = cyttsp4_reset_and_wait(cd);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: Error on h/w reset r=%d\n", __func__, rc);
+		RETRY_OR_EXIT(retry--, reset, exit);
+	}
+
+	detected = true;
+
+	/* exit bl into sysinfo mode */
+	dev_vdbg(cd->dev, "%s: write exit ldr...\n", __func__);
+	mutex_lock(&cd->system_lock);
+	cd->int_status &= ~CY_INT_IGNORE;
+	cd->int_status |= CY_INT_MODE_CHANGE;
+
+	rc = cyttsp4_adap_write(cd, CY_REG_BASE, (u8 *)ldr_exit,
+			sizeof(ldr_exit));
+	mutex_unlock(&cd->system_lock);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: Fail write adap='%s' r=%d\n",
+			__func__, cd->core->adap->id, rc);
+		RETRY_OR_EXIT(retry--, reset, exit);
+	}
+
+	rc = cyttsp4_wait_sysinfo_mode(cd);
+	if (rc < 0) {
+		u8 buf[sizeof(ldr_err_app)];
+		int rc1;
+
+		/* Check for invalid/corrupted touch application */
+		rc1 = cyttsp4_adap_read(cd, CY_REG_BASE, buf,
+				sizeof(ldr_err_app));
+		if (rc1) {
+			dev_err(cd->dev, "%s: Fail read adap='%s' r=%d\n",
+				__func__, cd->core->adap->id, rc1);
+		} else if (!memcmp(buf, ldr_err_app, sizeof(ldr_err_app))) {
+			dev_err(cd->dev, "%s: Error launching touch application\n",
+				__func__);
+			mutex_lock(&cd->system_lock);
+			cd->invalid_touch_app = true;
+			mutex_unlock(&cd->system_lock);
+			goto exit_no_wd;
+		}
+
+		RETRY_OR_EXIT(retry--, reset, exit);
+	}
+
+	mutex_lock(&cd->system_lock);
+	cd->invalid_touch_app = false;
+	mutex_unlock(&cd->system_lock);
+
+	/* read sysinfo data */
+	dev_vdbg(cd->dev, "%s: get sysinfo regs..\n", __func__);
+	rc = cyttsp4_get_sysinfo_regs(cd);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get sysinfo regs rc=%d\n",
+			__func__, rc);
+		RETRY_OR_EXIT(retry--, reset, exit);
+	}
+
+	rc = set_mode(cd, CY_MODE_OPERATIONAL);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to set mode to operational rc=%d\n",
+			__func__, rc);
+		RETRY_OR_EXIT(retry--, reset, exit);
+	}
+
+	rc = cyttsp4_set_initial_scantype(cd);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get scantype rc=%d\n",
+			__func__, rc);
+		RETRY_OR_EXIT(retry--, reset, exit);
+	}
+
+	rc = cyttsp4_get_ttconfig_info(cd);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: failed to get ttconfig info rc=%d\n",
+			__func__, rc);
+		RETRY_OR_EXIT(retry--, reset, exit);
+	}
+
+	rc = cyttsp4_get_active_refresh_cycle(cd);
+	if (rc < 0)
+		dev_err(cd->dev, "%s: failed to get refresh cycle time rc=%d\n",
+			__func__, rc);
+
+	/* attention startup */
+	call_atten_cb(cd, CY_ATTEN_STARTUP, 0);
+
+	/* restore to sleep if was suspended */
+	mutex_lock(&cd->system_lock);
+	if (cd->sleep_state == SS_SLEEP_ON) {
+		cd->sleep_state = SS_SLEEP_OFF;
+		mutex_unlock(&cd->system_lock);
+		/* watchdog is restarted by cyttsp4_core_sleep_() on error */
+		cyttsp4_core_sleep_(cd);
+		goto exit_no_wd;
+	}
+	mutex_unlock(&cd->system_lock);
+
+exit:
+	cyttsp4_start_wd_timer(cd);
+
+exit_no_wd:
+	if (!detected)
+		rc = -ENODEV;
+
+	/* Required for signal to the TTHE */
+	dev_info(cd->dev, "%s: cyttsp4_exit startup r=%d...\n", __func__, rc);
+
+	return rc;
+}
+
+static int cyttsp4_startup(struct cyttsp4_core_data *cd)
+{
+	int rc;
+
+	mutex_lock(&cd->system_lock);
+	cd->startup_state = STARTUP_RUNNING;
+	mutex_unlock(&cd->system_lock);
+
+	rc = request_exclusive(cd, cd->core,
+			CY_CORE_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(cd->dev, "%s: fail get exclusive ex=%p own=%p\n",
+				__func__, cd->exclusive_dev, cd->core);
+		goto exit;
+	}
+
+	rc = cyttsp4_startup_(cd);
+
+	if (release_exclusive(cd, cd->core) < 0)
+		/* Don't return fail code, mode is already changed. */
+		dev_err(cd->dev, "%s: fail to release exclusive\n", __func__);
+	else
+		dev_vdbg(cd->dev, "%s: pass release exclusive\n", __func__);
+
+exit:
+	mutex_lock(&cd->system_lock);
+	cd->startup_state = STARTUP_NONE;
+	mutex_unlock(&cd->system_lock);
+
+	/* Wake the waiters for end of startup */
+	wake_up(&cd->wait_q);
+
+	return rc;
+}
+
+static void cyttsp4_startup_work_function(struct work_struct *work)
+{
+	struct cyttsp4_core_data *cd =  container_of(work,
+		struct cyttsp4_core_data, startup_work);
+	int rc;
+
+	/*
+	 * Force clear exclusive access
+	 * startup queue is called for abnormal case,
+	 * and when a this called access can be acquired in other context
+	 */
+	mutex_lock(&cd->system_lock);
+	if (cd->exclusive_dev != cd->core)
+		cd->exclusive_dev = NULL;
+	mutex_unlock(&cd->system_lock);
+	rc = cyttsp4_startup(cd);
+	if (rc < 0)
+		dev_err(cd->dev, "%s: Fail queued startup r=%d\n",
+			__func__, rc);
+}
+
+static void cyttsp4_free_si_ptrs(struct cyttsp4_core_data *cd)
+{
+	struct cyttsp4_sysinfo *si = &cd->sysinfo;
+
+	if (!si)
+		return;
+
+	kfree(si->si_ptrs.cydata);
+	kfree(si->si_ptrs.test);
+	kfree(si->si_ptrs.pcfg);
+	kfree(si->si_ptrs.opcfg);
+	kfree(si->si_ptrs.ddata);
+	kfree(si->si_ptrs.mdata);
+	kfree(si->btn);
+	kfree(si->xy_mode);
+	kfree(si->btn_rec_data);
+}
+
+#if defined(CONFIG_PM_RUNTIME)
+static int cyttsp4_core_rt_suspend(struct device *dev)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	int rc;
+
+	rc = cyttsp4_core_sleep(cd);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on sleep\n", __func__);
+		return -EAGAIN;
+	}
+	return 0;
+}
+
+static int cyttsp4_core_rt_resume(struct device *dev)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	int rc;
+
+	rc = cyttsp4_core_wake(cd);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on wake\n", __func__);
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_PM_SLEEP)
+static int cyttsp4_core_suspend(struct device *dev)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+
+	if (!(cd->pdata->flags & CY_CORE_FLAG_WAKE_ON_GESTURE))
+		return 0;
+
+	/*
+	 * This will not prevent resume
+	 * Required to prevent interrupts before i2c awake
+	 */
+	disable_irq(cd->irq);
+
+	if (device_may_wakeup(dev)) {
+		dev_dbg(dev, "%s Device MAY wakeup\n", __func__);
+		if (!enable_irq_wake(cd->irq))
+			cd->irq_wake = 1;
+	} else {
+		dev_dbg(dev, "%s Device may NOT wakeup\n", __func__);
+	}
+
+	return 0;
+}
+
+static int cyttsp4_core_resume(struct device *dev)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+
+	if (!(cd->pdata->flags & CY_CORE_FLAG_WAKE_ON_GESTURE))
+		return 0;
+
+	enable_irq(cd->irq);
+
+	if (device_may_wakeup(dev)) {
+		dev_dbg(dev, "%s Device MAY wakeup\n", __func__);
+		if (cd->irq_wake) {
+			disable_irq_wake(cd->irq);
+			cd->irq_wake = 0;
+		}
+	} else {
+		dev_dbg(dev, "%s Device may NOT wakeup\n", __func__);
+	}
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops cyttsp4_core_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(cyttsp4_core_suspend, cyttsp4_core_resume)
+	SET_RUNTIME_PM_OPS(cyttsp4_core_rt_suspend, cyttsp4_core_rt_resume,
+			NULL)
+};
+
+#ifdef CONFIG_FB
+static int fb_notifier_callback(struct notifier_block *self,
+				 unsigned long event, void *data)
+{
+	struct fb_event *evdata = data;
+	int *blank;
+	struct cyttsp4_core_data *cd =
+		container_of(self, struct cyttsp4_core_data, fb_notif);
+
+	if (evdata && evdata->data && event == FB_EVENT_BLANK &&
+			cd) {
+		blank = evdata->data;
+		if (*blank == FB_BLANK_UNBLANK)
+			cyttsp4_core_wake(cd);
+		else if (*blank == FB_BLANK_POWERDOWN)
+			cyttsp4_core_sleep(cd);
+	}
+
+	return 0;
+}
+#endif
+
+static bool cyttsp4_debug_addr_is_valid(int addr)
+{
+	if (addr < 0 || addr > 0xFF) {
+		pr_err("GTP reg address is invalid: 0x%x\n", addr);
+		return false;
+	}
+
+	return true;
+}
+
+static int cyttsp4_debug_data_set(void *_data, u64 val)
+{
+	struct cyttsp4_core_data *data = _data;
+
+	mutex_lock(&data->adap_lock);
+
+	if (cyttsp4_debug_addr_is_valid(data->addr))
+		dev_info(data->dev,
+				"Writing into GTP registers not supported\n");
+
+	mutex_unlock(&data->adap_lock);
+
+	return 0;
+}
+
+static int cyttsp4_debug_data_get(void *_data, u64 *val)
+{
+	struct cyttsp4_core_data *data = _data;
+	int rc;
+	u8 reg;
+
+	mutex_lock(&data->adap_lock);
+
+	if (cyttsp4_debug_addr_is_valid(data->addr)) {
+		rc = cyttsp4_adap_read(data, data->addr, &reg, 1);
+		if (rc < 0)
+			dev_err(data->dev,
+					"GTP read register 0x%x failed (%d)\n",
+					data->addr, rc);
+		else
+			*val = reg;
+	}
+
+	mutex_unlock(&data->adap_lock);
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(debug_data_fops, cyttsp4_debug_data_get,
+			cyttsp4_debug_data_set, "0x%02llX\n");
+
+static int cyttsp4_debug_addr_set(void *_data, u64 val)
+{
+	struct cyttsp4_core_data *data = _data;
+
+	if (cyttsp4_debug_addr_is_valid(val)) {
+		mutex_lock(&data->adap_lock);
+		data->addr = val;
+		mutex_unlock(&data->adap_lock);
+	}
+
+	return 0;
+}
+
+static int cyttsp4_debug_addr_get(void *_data, u64 *val)
+{
+	struct cyttsp4_core_data *data = _data;
+
+	mutex_lock(&data->adap_lock);
+
+	if (cyttsp4_debug_addr_is_valid(data->addr))
+		*val = data->addr;
+
+	mutex_unlock(&data->adap_lock);
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(debug_addr_fops, cyttsp4_debug_addr_get,
+			cyttsp4_debug_addr_set, "0x%02llX\n");
+
+static int cyttsp4_debug_suspend_set(void *_data, u64 val)
+{
+	struct cyttsp4_core_data *data = _data;
+
+	if (val)
+		cyttsp4_core_sleep(data);
+	else
+		cyttsp4_core_wake(data);
+
+	return 0;
+}
+
+static int cyttsp4_debug_suspend_get(void *_data, u64 *val)
+{
+	struct cyttsp4_core_data *data = _data;
+
+	mutex_lock(&data->system_lock);
+	*val = data->suspended;
+	mutex_unlock(&data->system_lock);
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(debug_suspend_fops, cyttsp4_debug_suspend_get,
+			cyttsp4_debug_suspend_set, "%lld\n");
+
+static int cyttsp4_debug_dump_info(struct seq_file *m, void *v)
+{
+	struct cyttsp4_core_data *data = m->private;
+
+	seq_printf(m, "%s\n", data->ts_info);
+
+	return 0;
+}
+
+static int debugfs_dump_info_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, cyttsp4_debug_dump_info, inode->i_private);
+}
+
+static const struct file_operations debug_dump_info_fops = {
+	.owner		= THIS_MODULE,
+	.open		= debugfs_dump_info_open,
+	.read		= seq_read,
+	.release	= single_release,
+};
+
+static ssize_t cyttsp4_mt_num_max_touches_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_core_platform_data *pdata = dev_get_platdata(dev);
+	return snprintf(buf, 4, "%d\n", pdata->num_max_touches);
+}
+
+static ssize_t cyttsp4_mt_protocol_type_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	char *type_buf;
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MT_B
+	type_buf = "MT Protocal B\n";
+#else
+	type_buf = "MT Protocal A\n";
+#endif
+
+	return snprintf(buf, 16, type_buf);
+}
+
+/*
+ * Show Firmware version via sysfs
+ */
+static ssize_t cyttsp4_ic_ver_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	struct cyttsp4_cydata *cydata;
+
+	mutex_lock(&cd->system_lock);
+	if (!cd->sysinfo.ready) {
+		if (cd->invalid_touch_app) {
+			mutex_unlock(&cd->system_lock);
+			return snprintf(buf, CY_MAX_PRBUF_SIZE,
+					"Corrupted Touch application!\n");
+		} else {
+			mutex_unlock(&cd->system_lock);
+			return snprintf(buf, CY_MAX_PRBUF_SIZE,
+					"System Information not ready!\n");
+		}
+	}
+	mutex_unlock(&cd->system_lock);
+
+	cydata = cd->sysinfo.si_ptrs.cydata;
+
+	return snprintf(buf, CY_MAX_PRBUF_SIZE,
+		"%s: 0x%02X 0x%02X\n"
+		"%s: 0x%02X\n"
+		"%s: 0x%02X\n"
+		"%s: 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\n"
+		"%s: 0x%04X\n"
+		"%s: 0x%02X\n"
+		"%s: 0x%02X\n",
+		"TrueTouch Product ID", cydata->ttpidh, cydata->ttpidl,
+		"Firmware Major Version", cydata->fw_ver_major,
+		"Firmware Minor Version", cydata->fw_ver_minor,
+		"Revision Control Number", cydata->revctrl[0],
+		cydata->revctrl[1], cydata->revctrl[2], cydata->revctrl[3],
+		cydata->revctrl[4], cydata->revctrl[5], cydata->revctrl[6],
+		cydata->revctrl[7],
+		"TrueTouch Config Version", cd->sysinfo.ttconfig.version,
+		"Bootloader Major Version", cydata->blver_major,
+		"Bootloader Minor Version", cydata->blver_minor);
+}
+
+/*
+ * Show TT Config version via sysfs
+ */
+static ssize_t cyttsp4_ttconfig_ver_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+
+	return snprintf(buf, CY_MAX_PRBUF_SIZE, "0x%04X\n",
+			cd->sysinfo.ttconfig.version);
+}
+
+/*
+ * Show Driver version via sysfs
+ */
+static ssize_t cyttsp4_drv_ver_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, CY_MAX_PRBUF_SIZE,
+		"Driver: %s\nVersion: %s\nDate: %s\n",
+		cy_driver_core_name, cy_driver_core_version,
+		cy_driver_core_date);
+}
+
+/*
+ * HW reset via sysfs
+ */
+static ssize_t cyttsp4_hw_reset_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	int rc = 0;
+
+	rc = cyttsp4_startup(cd);
+	if (rc < 0)
+		dev_err(dev, "%s: HW reset failed r=%d\n",
+			__func__, rc);
+
+	return size;
+}
+
+/*
+ * Show IRQ status via sysfs
+ */
+static ssize_t cyttsp4_hw_irq_stat_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	int retval;
+
+	if (cd->pdata->irq_stat) {
+		retval = cd->pdata->irq_stat(cd->pdata, dev);
+		switch (retval) {
+		case 0:
+			return snprintf(buf, CY_MAX_PRBUF_SIZE,
+				"Interrupt line is LOW.\n");
+		case 1:
+			return snprintf(buf, CY_MAX_PRBUF_SIZE,
+				"Interrupt line is HIGH.\n");
+		default:
+			return snprintf(buf, CY_MAX_PRBUF_SIZE,
+				"Function irq_stat() returned %d.\n", retval);
+		}
+	}
+
+	return snprintf(buf, CY_MAX_PRBUF_SIZE,
+		"Function irq_stat() undefined.\n");
+}
+
+/*
+ * Show IRQ enable/disable status via sysfs
+ */
+static ssize_t cyttsp4_drv_irq_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	ssize_t ret;
+
+	mutex_lock(&cd->system_lock);
+	if (cd->irq_enabled)
+		ret = snprintf(buf, CY_MAX_PRBUF_SIZE,
+			"Driver interrupt is ENABLED\n");
+	else
+		ret = snprintf(buf, CY_MAX_PRBUF_SIZE,
+			"Driver interrupt is DISABLED\n");
+	mutex_unlock(&cd->system_lock);
+
+	return ret;
+}
+
+/*
+ * Enable/disable IRQ via sysfs
+ */
+static ssize_t cyttsp4_drv_irq_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	unsigned long value;
+	int retval;
+
+	retval = kstrtoul(buf, 10, &value);
+	if (retval < 0) {
+		dev_err(dev, "%s: Invalid value\n", __func__);
+		goto cyttsp4_drv_irq_store_error_exit;
+	}
+
+	mutex_lock(&cd->system_lock);
+	switch (value) {
+	case 0:
+		if (cd->irq_enabled) {
+			cd->irq_enabled = false;
+			/* Disable IRQ */
+			disable_irq_nosync(cd->irq);
+			dev_info(dev, "%s: Driver IRQ now disabled\n",
+				__func__);
+		} else
+			dev_info(dev, "%s: Driver IRQ already disabled\n",
+				__func__);
+		break;
+
+	case 1:
+		if (cd->irq_enabled == false) {
+			cd->irq_enabled = true;
+			/* Enable IRQ */
+			enable_irq(cd->irq);
+			dev_info(dev, "%s: Driver IRQ now enabled\n",
+				__func__);
+		} else
+			dev_info(dev, "%s: Driver IRQ already enabled\n",
+				__func__);
+		break;
+
+	default:
+		dev_err(dev, "%s: Invalid value\n", __func__);
+	}
+	mutex_unlock(&(cd->system_lock));
+
+cyttsp4_drv_irq_store_error_exit:
+
+	return size;
+}
+
+/*
+ * Debugging options via sysfs
+ */
+static ssize_t cyttsp4_drv_debug_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	unsigned long value = 0;
+	int rc = 0;
+
+	rc = kstrtoul(buf, 10, &value);
+	if (rc < 0) {
+		dev_err(dev, "%s: Invalid value\n", __func__);
+		goto cyttsp4_drv_debug_store_exit;
+	}
+
+	switch (value) {
+	case CY_DBG_SUSPEND:
+		dev_info(dev, "%s: SUSPEND (cd=%p)\n", __func__, cd);
+		rc = cyttsp4_core_sleep(cd);
+		if (rc)
+			dev_err(dev, "%s: Suspend failed rc=%d\n",
+				__func__, rc);
+		else
+			dev_info(dev, "%s: Suspend succeeded\n", __func__);
+		break;
+
+	case CY_DBG_RESUME:
+		dev_info(dev, "%s: RESUME (cd=%p)\n", __func__, cd);
+		rc = cyttsp4_core_wake(cd);
+		if (rc)
+			dev_err(dev, "%s: Resume failed rc=%d\n",
+				__func__, rc);
+		else
+			dev_info(dev, "%s: Resume succeeded\n", __func__);
+		break;
+	case CY_DBG_SOFT_RESET:
+		dev_info(dev, "%s: SOFT RESET (cd=%p)\n", __func__, cd);
+		rc = cyttsp4_hw_soft_reset(cd);
+		break;
+	case CY_DBG_RESET:
+		dev_info(dev, "%s: HARD RESET (cd=%p)\n", __func__, cd);
+		rc = cyttsp4_hw_hard_reset(cd);
+		break;
+	default:
+		dev_err(dev, "%s: Invalid value\n", __func__);
+	}
+
+cyttsp4_drv_debug_store_exit:
+	return size;
+}
+
+/*
+ * Show system status on deep sleep status via sysfs
+ */
+static ssize_t cyttsp4_sleep_status_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	ssize_t ret;
+
+	mutex_lock(&cd->system_lock);
+	if (cd->sleep_state == SS_SLEEP_ON)
+		ret = snprintf(buf, CY_MAX_PRBUF_SIZE,
+				"Deep Sleep is ENABLED\n");
+	else
+		ret = snprintf(buf, CY_MAX_PRBUF_SIZE,
+				"Deep Sleep is DISABLED\n");
+	mutex_unlock(&cd->system_lock);
+
+	return ret;
+}
+
+static ssize_t cyttsp4_easy_wakeup_gesture_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	ssize_t ret;
+
+	mutex_lock(&cd->system_lock);
+	ret = snprintf(buf, CY_MAX_PRBUF_SIZE, "0x%02X\n",
+			cd->easy_wakeup_gesture);
+	mutex_unlock(&cd->system_lock);
+	return ret;
+}
+
+static ssize_t cyttsp4_easy_wakeup_gesture_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	unsigned long value;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &value);
+	if (ret < 0)
+		return ret;
+
+	if (value > 0xFF && value < 0)
+		return -EINVAL;
+
+	pm_runtime_get_sync(dev);
+
+	mutex_lock(&cd->system_lock);
+	if (cd->sysinfo.ready && IS_TTSP_VER_GE(&cd->sysinfo, 2, 5))
+		cd->easy_wakeup_gesture = (u8)value;
+	else
+		ret = -ENODEV;
+	mutex_unlock(&cd->system_lock);
+
+	pm_runtime_put(dev);
+
+	if (ret)
+		return ret;
+
+	return size;
+}
+
+static ssize_t cyttsp4_ts_info_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	return snprintf(buf, CY_INFO_MAX_LEN, "%s\n", cd->ts_info);
+}
+
+static ssize_t cyttsp4_enable_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	if (cd->suspended) {
+		dev_info(cd->dev, "Already in suspend state\n");
+		return snprintf(buf, 4, "%s\n", "0");
+	}
+	return snprintf(buf, 4, "%s\n", cd->enable ? "1" : "0");
+}
+
+static ssize_t cyttsp4_enable_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+	unsigned long val;
+	int rc;
+
+	if (size > 2)
+		return -EINVAL;
+
+	if (cd->suspended) {
+		dev_info(cd->dev, "Already in suspend state\n");
+		goto no_operation;
+	}
+
+	rc = kstrtoul(buf, 10, &val);
+	if (rc != 0)
+		return rc;
+
+	if (val) {
+		cyttsp4_core_wake_(cd);
+		/* If a startup queued in wake, wait it to finish */
+		wait_event_timeout(cd->wait_q,
+			cd->startup_state == STARTUP_NONE,
+			msecs_to_jiffies(CY_CORE_RESET_AND_WAIT_TIMEOUT));
+		cd->enable = true;
+	} else {
+		cyttsp4_core_sleep_(cd);
+		/* Give time to FW to sleep */
+		_cyttsp4_wait_for_refresh_cycle(cd, 2);
+		cd->enable = false;
+	}
+
+no_operation:
+	return size;
+}
+
+static struct device_attribute attributes[] = {
+	__ATTR(mt_num_max_touches, S_IRUGO, cyttsp4_mt_num_max_touches_show,
+				NULL),
+	__ATTR(mt_protocol_type, S_IRUGO, cyttsp4_mt_protocol_type_show, NULL),
+	__ATTR(ic_ver, S_IRUGO, cyttsp4_ic_ver_show, NULL),
+	__ATTR(ttconfig_ver, S_IRUGO, cyttsp4_ttconfig_ver_show, NULL),
+	__ATTR(drv_ver, S_IRUGO, cyttsp4_drv_ver_show, NULL),
+	__ATTR(hw_reset, S_IWUSR, NULL, cyttsp4_hw_reset_store),
+	__ATTR(hw_irq_stat, S_IRUSR, cyttsp4_hw_irq_stat_show, NULL),
+	__ATTR(drv_irq, S_IRUSR | S_IWUSR, cyttsp4_drv_irq_show,
+		cyttsp4_drv_irq_store),
+	__ATTR(drv_debug, S_IWUSR, NULL, cyttsp4_drv_debug_store),
+	__ATTR(sleep_status, S_IRUSR, cyttsp4_sleep_status_show, NULL),
+	__ATTR(easy_wakeup_gesture, S_IRUSR | S_IWUSR,
+		cyttsp4_easy_wakeup_gesture_show,
+		cyttsp4_easy_wakeup_gesture_store),
+	__ATTR(ts_info, S_IRUGO, cyttsp4_ts_info_show, NULL),
+	__ATTR(enable, S_IRUSR | S_IWUSR,
+		cyttsp4_enable_show, cyttsp4_enable_store),
+};
+
+static int add_sysfs_interfaces(struct cyttsp4_core_data *cd,
+		struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto undo;
+
+	return 0;
+undo:
+	for (i--; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+	dev_err(dev, "%s: failed to create sysfs interface\n", __func__);
+	return -ENODEV;
+}
+
+static void remove_sysfs_interfaces(struct cyttsp4_core_data *cd,
+		struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+}
+
+static int cyttsp4_core_probe(struct cyttsp4_core *core)
+{
+	struct cyttsp4_core_data *cd;
+	struct device *dev = &core->dev;
+	struct cyttsp4_core_platform_data *pdata = dev_get_platdata(dev);
+	enum cyttsp4_atten_type type;
+	unsigned long irq_flags;
+	int rc = 0;
+	struct dentry *temp;
+#ifdef CHECK_PANEL_ID
+	u8 id_buf[2] = {0};
+#endif
+
+	dev_info(dev, "%s: startup\n", __func__);
+	dev_dbg(dev, "%s: debug on\n", __func__);
+	dev_vdbg(dev, "%s: verbose debug on\n", __func__);
+
+	if (pdata == NULL) {
+		dev_err(dev, "%s: Missing platform data\n", __func__);
+		rc = -ENODEV;
+		goto error_no_pdata;
+	}
+
+	/* get context and debug print buffers */
+	cd = kzalloc(sizeof(*cd), GFP_KERNEL);
+	if (cd == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto error_alloc_data;
+	}
+
+	/* Initialize device info */
+	cd->core = core;
+	cd->dev = dev;
+	cd->pdata = pdata;
+	cd->max_xfer = CY_DEFAULT_ADAP_MAX_XFER;
+	if (pdata->max_xfer_len) {
+		if (pdata->max_xfer_len < CY_ADAP_MIN_XFER) {
+			dev_err(dev, "%s: max_xfer_len invalid (min=%d)\n",
+				__func__, CY_ADAP_MIN_XFER);
+			rc = -EINVAL;
+			goto error_max_xfer;
+		}
+		cd->max_xfer = pdata->max_xfer_len;
+		dev_dbg(dev, "%s: max_xfer set to %d\n",
+			__func__, cd->max_xfer);
+	}
+
+	/* Initialize mutexes and spinlocks */
+	mutex_init(&cd->system_lock);
+	mutex_init(&cd->adap_lock);
+	spin_lock_init(&cd->spinlock);
+
+	/* Initialize attention lists */
+	for (type = 0; type < CY_ATTEN_NUM_ATTEN; type++)
+		INIT_LIST_HEAD(&cd->atten_list[type]);
+
+	/* Initialize wait queue */
+	init_waitqueue_head(&cd->wait_q);
+
+	/* Initialize works */
+	INIT_WORK(&cd->startup_work, cyttsp4_startup_work_function);
+	INIT_WORK(&cd->watchdog_work, cyttsp4_watchdog_work);
+	/* Initialize IRQ */
+	cd->irq = gpio_to_irq(pdata->irq_gpio);
+	if (cd->irq < 0) {
+		rc = -EINVAL;
+		goto error_gpio_irq;
+	}
+	cd->irq_enabled = true;
+
+	dev_set_drvdata(dev, cd);
+	/* Call platform init function */
+	if (cd->pdata->init) {
+		dev_info(cd->dev, "%s: Init HW\n", __func__);
+		rc = cd->pdata->init(cd->pdata, 1, cd->dev);
+	} else {
+		dev_info(cd->dev, "%s: No HW INIT function\n", __func__);
+		rc = 0;
+	}
+	if (rc < 0)
+		dev_err(cd->dev, "%s: HW Init fail r=%d\n", __func__, rc);
+
+#ifdef CHECK_PANEL_ID
+	rc = cyttsp4_hw_hard_reset(cd);
+	if (rc < 0)
+		dev_err(cd->dev, "hardware reset failed\n");
+#endif
+
+	/* Call platform detect function */
+	if (cd->pdata->detect) {
+		dev_info(cd->dev, "%s: Detect HW\n", __func__);
+		rc = cd->pdata->detect(cd->pdata, cd->dev,
+				cyttsp4_platform_detect_read);
+		if (rc) {
+			dev_info(cd->dev, "%s: No HW detected\n", __func__);
+			rc = -ENODEV;
+			goto error_detect;
+		}
+	}
+
+#ifdef CHECK_PANEL_ID
+	rc = cyttsp4_adap_read(cd, CY_IC_ID_ADDR, id_buf, 2);
+	if (rc) {
+		dev_err(cd->dev, "Read product ID failed.\n");
+		goto error_detect;
+	}
+	if (0x1 == id_buf[0] && 0x1 == id_buf[1]) {
+		dev_info(dev, "TrueTouch Product ID match successfully!\n");
+	} else {
+		dev_err(dev, "ID match failed!\n");
+		goto error_detect;
+	}
+#endif
+
+	dev_dbg(dev, "%s: initialize threaded irq=%d\n", __func__, cd->irq);
+	if (cd->pdata->level_irq_udelay > 0)
+		/* use level triggered interrupts */
+		irq_flags = IRQF_TRIGGER_LOW | IRQF_ONESHOT;
+	else
+		/* use edge triggered interrupts */
+		irq_flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT;
+	dev_dbg(dev, "%s: level_irq_udelay=%d, irq_flags=0x%lx\n",
+			__func__, cd->pdata->level_irq_udelay, irq_flags);
+
+	rc = request_threaded_irq(cd->irq, cyttsp4_hard_irq, cyttsp4_irq,
+			irq_flags, dev_name(dev), cd);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error, could not request irq\n", __func__);
+		goto error_request_irq;
+	}
+
+	/* Setup watchdog timer */
+	setup_timer(&cd->watchdog_timer, cyttsp4_watchdog_timer,
+		(unsigned long)cd);
+
+	pm_runtime_enable(dev);
+
+	/*
+	 * call startup directly to ensure that the device
+	 * is tested before leaving the probe
+	 */
+	dev_dbg(dev, "%s: call startup\n", __func__);
+
+	pm_runtime_get_sync(dev);
+	rc = cyttsp4_startup(cd);
+	pm_runtime_put(dev);
+
+	/* Do not fail probe if startup fails but the device is detected */
+	if (rc == -ENODEV) {
+		dev_err(cd->dev, "%s: Fail initial startup r=%d\n",
+			__func__, rc);
+		goto error_startup;
+	}
+
+	if (IS_TTSP_VER_GE(&cd->sysinfo, 2, 5))
+		cd->easy_wakeup_gesture = pdata->easy_wakeup_gesture;
+	else
+		cd->easy_wakeup_gesture = 0xFF;
+
+	dev_dbg(dev, "%s: add sysfs interfaces\n", __func__);
+	rc = add_sysfs_interfaces(cd, dev);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error, fail sysfs init\n", __func__);
+		goto error_startup;
+	}
+
+	cd->dir = debugfs_create_dir(CY_DEBUG_DIR_NAME, NULL);
+	if (cd->dir == NULL || IS_ERR(cd->dir)) {
+		pr_err("debugfs_create_dir failed(%ld)\n", PTR_ERR(cd->dir));
+		rc = PTR_ERR(cd->dir);
+		goto error_startup;
+	}
+
+	temp = debugfs_create_file("addr", S_IRUSR | S_IWUSR, cd->dir, cd,
+			&debug_addr_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		pr_err("debugfs_create_file failed: rc=%ld\n", PTR_ERR(temp));
+		rc = PTR_ERR(temp);
+		goto err_debug_dir;
+	}
+
+	temp = debugfs_create_file("data", S_IRUSR | S_IWUSR, cd->dir, cd,
+			&debug_data_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		pr_err("debugfs_create_file failed: rc=%ld\n", PTR_ERR(temp));
+		rc = PTR_ERR(temp);
+		goto err_debug_dir;
+	}
+
+	temp = debugfs_create_file("suspend", S_IRUSR | S_IWUSR, cd->dir,
+			cd, &debug_suspend_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		pr_err("debugfs_create_file failed: rc=%ld\n", PTR_ERR(temp));
+		rc = PTR_ERR(temp);
+		goto err_debug_dir;
+	}
+
+	temp = debugfs_create_file("dump_info", S_IRUSR | S_IWUSR, cd->dir,
+			cd, &debug_dump_info_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		pr_err("debugfs_create_file failed: rc=%ld\n", PTR_ERR(temp));
+		rc = PTR_ERR(temp);
+		goto err_debug_dir;
+	}
+
+	cd->ts_info = devm_kzalloc(dev,
+		CY_INFO_MAX_LEN, GFP_KERNEL);
+	if (!cd->ts_info) {
+		dev_err(dev, "Not enough memory\n");
+		goto err_debug_dir;
+	}
+
+	snprintf(cd->ts_info, CY_INFO_MAX_LEN,
+			"controller\t\t= cypress\n"
+			"name\t\t\t= TMA463\n"
+			"num_max_touches\t\t= %d\n"
+			"driver version\t\t= %s\n"
+			"firmware major version\t= %d\n"
+			"firmware minor version\t= %d\n",
+			pdata->num_max_touches,
+			cy_driver_core_version,
+			cd->sysinfo.si_ptrs.cydata->fw_ver_major,
+			cd->sysinfo.si_ptrs.cydata->fw_ver_minor);
+
+	device_init_wakeup(dev, 1);
+	cd->suspended = false;
+	cd->enable = true;
+#ifdef CONFIG_FB
+	cd->fb_notif.notifier_call = fb_notifier_callback;
+	rc = fb_register_client(&cd->fb_notif);
+	if (rc)
+		dev_err(dev, "Unable to register fb_notifier: %d\n",
+			rc);
+#endif
+
+	dev_dbg(dev, "%s: ok\n", __func__);
+	return 0;
+
+err_debug_dir:
+	debugfs_remove_recursive(cd->dir);
+error_startup:
+	cancel_work_sync(&cd->startup_work);
+	cyttsp4_stop_wd_timer(cd);
+	pm_runtime_disable(dev);
+	cyttsp4_free_si_ptrs(cd);
+	free_irq(cd->irq, cd);
+error_request_irq:
+error_detect:
+	if (pdata->init)
+		pdata->init(pdata, 0, dev);
+	dev_set_drvdata(dev, NULL);
+error_gpio_irq:
+error_max_xfer:
+	kfree(cd);
+error_alloc_data:
+error_no_pdata:
+	dev_err(dev, "%s failed.\n", __func__);
+	return rc;
+}
+
+static int cyttsp4_core_release(struct cyttsp4_core *core)
+{
+	struct device *dev = &core->dev;
+	struct cyttsp4_core_data *cd = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	/*
+	 * Suspend the device before freeing the startup_work and stopping
+	 * the watchdog since sleep function restarts watchdog on failure
+	 */
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+
+	cancel_work_sync(&cd->startup_work);
+
+	cyttsp4_stop_wd_timer(cd);
+
+	debugfs_remove_recursive(cd->dir);
+	remove_sysfs_interfaces(cd, dev);
+	free_irq(cd->irq, cd);
+	if (cd->pdata->init)
+		cd->pdata->init(cd->pdata, 0, dev);
+	dev_set_drvdata(dev, NULL);
+	cyttsp4_free_si_ptrs(cd);
+	kfree(cd);
+	return 0;
+}
+
+static struct cyttsp4_core_driver cyttsp4_core_driver = {
+	.probe = cyttsp4_core_probe,
+	.remove = cyttsp4_core_release,
+	.subscribe_attention = cyttsp4_subscribe_attention_,
+	.unsubscribe_attention = cyttsp4_unsubscribe_attention_,
+	.request_exclusive = cyttsp4_request_exclusive_,
+	.release_exclusive = cyttsp4_release_exclusive_,
+	.request_reset = cyttsp4_request_reset_,
+	.request_restart = cyttsp4_request_restart_,
+	.request_set_mode = cyttsp4_request_set_mode_,
+	.request_sysinfo = cyttsp4_request_sysinfo_,
+	.request_loader_pdata = cyttsp4_request_loader_pdata_,
+	.request_handshake = cyttsp4_request_handshake_,
+	.request_exec_cmd = cyttsp4_request_exec_cmd_,
+	.request_stop_wd = cyttsp4_request_stop_wd_,
+	.request_toggle_lowpower = cyttsp4_request_toggle_lowpower_,
+	.request_config_row_size = cyttsp4_request_config_row_size_,
+	.request_write_config = cyttsp4_request_write_config_,
+	.request_enable_scan_type = cyttsp4_request_enable_scan_type_,
+	.request_disable_scan_type = cyttsp4_request_disable_scan_type_,
+	.get_security_key = cyttsp4_get_security_key_,
+	.get_touch_record = cyttsp4_get_touch_record_,
+	.write = cyttsp4_write_,
+	.read = cyttsp4_read_,
+	.driver = {
+		.name = CYTTSP4_CORE_NAME,
+		.bus = &cyttsp4_bus_type,
+		.owner = THIS_MODULE,
+		.pm = &cyttsp4_core_pm_ops,
+	},
+};
+
+static int __init cyttsp4_core_init(void)
+{
+	int rc = 0;
+
+	rc = cyttsp4_register_core_driver(&cyttsp4_core_driver);
+	pr_info("%s: Cypress TTSP v4 core driver (Built %s) rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return rc;
+}
+module_init(cyttsp4_core_init);
+
+static void __exit cyttsp4_core_exit(void)
+{
+	cyttsp4_unregister_core_driver(&cyttsp4_core_driver);
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_core_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard touchscreen core driver");
+MODULE_AUTHOR("Aleksej Makarov <aleksej.makarov@sonyericsson.com>");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_debug.c b/drivers/input/touchscreen/cypress/cyttsp4_debug.c
new file mode 100644
index 0000000..16a669b
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_debug.c
@@ -0,0 +1,608 @@
+/*
+ * cyttsp4_debug.c
+ * Cypress TrueTouch(TM) Standard Product V4 Core driver module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ * Copyright (C) 2014 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ * Modified by: Cypress Semiconductor to add device functions
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/cyttsp4_bus.h>
+#include <linux/cyttsp4_core.h>
+
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/limits.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+
+#include "cyttsp4_regs.h"
+
+#define CYTTSP4_DEBUG_NAME "cyttsp4_debug"
+
+enum cyttsp4_monitor_status {
+	CY_MNTR_DISABLED,
+	CY_MNTR_ENABLED,
+};
+
+struct cyttsp4_sensor_monitor {
+	enum cyttsp4_monitor_status mntr_status;
+	u8 sensor_data[150];		/* operational sensor data */
+};
+
+struct cyttsp4_debug_data {
+	struct cyttsp4_device *ttsp;
+	struct cyttsp4_debug_platform_data *pdata;
+	struct cyttsp4_sysinfo *si;
+	uint32_t interrupt_count;
+	uint32_t formated_output;
+	struct mutex sysfs_lock;
+	struct cyttsp4_sensor_monitor monitor;
+	u8 pr_buf[CY_MAX_PRBUF_SIZE];
+};
+
+struct cyttsp4_debug_platform_data {
+	char const *debug_dev_name;
+};
+
+/*
+ * This function provide output of combined xy_mode and xy_data.
+ * Required by TTHE.
+ */
+static void cyttsp4_pr_buf_op_mode(struct device *dev, u8 *pr_buf,
+		struct cyttsp4_sysinfo *si, u8 cur_touch)
+{
+	int i, k;
+	const char fmt[] = "%02X ";
+	int max = (CY_MAX_PRBUF_SIZE - 1) - sizeof(CY_PR_TRUNCATED);
+	int total_size = si->si_ofs.mode_size
+			+ (cur_touch * si->si_ofs.tch_rec_size);
+	u8 num_btns = si->si_ofs.num_btns;
+
+	pr_buf[0] = 0;
+	for (i = k = 0; i < si->si_ofs.mode_size && i < max; i++, k += 3)
+		scnprintf(pr_buf + k, CY_MAX_PRBUF_SIZE, fmt, si->xy_mode[i]);
+
+	for (i = 0; i < (cur_touch * si->si_ofs.tch_rec_size) && i < max;
+			i++, k += 3)
+		scnprintf(pr_buf + k, CY_MAX_PRBUF_SIZE, fmt, si->xy_data[i]);
+
+	if (num_btns) {
+		/* print btn diff data for TTHE */
+		scnprintf(pr_buf + k, CY_MAX_PRBUF_SIZE, "%s", "=");
+		k++;
+		for (i = 0; i < (num_btns * si->si_ofs.btn_rec_size) && i < max;
+				i++, k += 3)
+			scnprintf(pr_buf + k, CY_MAX_PRBUF_SIZE, fmt,
+					si->btn_rec_data[i]);
+		total_size += num_btns * si->si_ofs.btn_rec_size + 1;
+	}
+	pr_info("%s=%s%s\n", "cyttsp4_OpModeData", pr_buf,
+			total_size <= max ? "" : CY_PR_TRUNCATED);
+}
+
+static void cyttsp4_debug_print(struct device *dev, u8 *pr_buf, u8 *sptr,
+		int size, const char *data_name)
+{
+	int i, j;
+	int elem_size = sizeof("XX ") - 1;
+	int max = (CY_MAX_PRBUF_SIZE - 1) / elem_size;
+	int limit = size < max ? size : max;
+
+	if (limit < 0)
+		limit = 0;
+
+	pr_buf[0] = 0;
+	for (i = j = 0; i < limit; i++, j += elem_size)
+		scnprintf(pr_buf + j, CY_MAX_PRBUF_SIZE - j, "%02X ", sptr[i]);
+
+	pr_info("%s[0..%d]=%s%s\n", data_name, size ? size - 1 : 0, pr_buf,
+			size <= max ? "" : CY_PR_TRUNCATED);
+}
+
+static void cyttsp4_debug_formated(struct device *dev, u8 *pr_buf,
+		struct cyttsp4_sysinfo *si, u8 num_cur_rec)
+{
+	u8 mode_size = si->si_ofs.mode_size;
+	u8 rep_len = si->xy_mode[si->si_ofs.rep_ofs];
+	u8 tch_rec_size = si->si_ofs.tch_rec_size;
+	u8 num_btns = si->si_ofs.num_btns;
+	u8 num_btn_regs = (num_btns + CY_NUM_BTN_PER_REG - 1)
+			/ CY_NUM_BTN_PER_REG;
+	u8 num_btn_tch;
+	u8 data_name[] = "touch[99]";
+	int max_print_length = 18;
+	int i;
+
+	/* xy_mode */
+	cyttsp4_debug_print(dev, pr_buf, si->xy_mode, mode_size, "xy_mode");
+
+	/* xy_data */
+	if (rep_len > max_print_length) {
+		pr_info("xy_data[0..%d]:\n", rep_len);
+		for (i = 0; i < rep_len - max_print_length;
+				i += max_print_length) {
+			cyttsp4_debug_print(dev, pr_buf, si->xy_data + i,
+					max_print_length, " ");
+		}
+		if (rep_len - i)
+			cyttsp4_debug_print(dev, pr_buf, si->xy_data + i,
+					rep_len - i, " ");
+	} else {
+		cyttsp4_debug_print(dev, pr_buf, si->xy_data,
+				rep_len - si->si_ofs.rep_hdr_size, "xy_data");
+	}
+
+	/* touches */
+	for (i = 0; i < num_cur_rec; i++) {
+		scnprintf(data_name, sizeof(data_name) - 1, "touch[%u]", i);
+		cyttsp4_debug_print(dev, pr_buf,
+				si->xy_data + (i * tch_rec_size),
+				tch_rec_size, data_name);
+	}
+
+	/* buttons */
+	if (num_btns) {
+		num_btn_tch = 0;
+		for (i = 0; i < num_btn_regs; i++) {
+			if (si->xy_mode[si->si_ofs.rep_ofs + 2 + i]) {
+				num_btn_tch++;
+				break;
+			}
+		}
+		if (num_btn_tch)
+			cyttsp4_debug_print(dev, pr_buf,
+					&si->xy_mode[si->si_ofs.rep_ofs + 2],
+					num_btn_regs, "button");
+	}
+}
+
+/* read xy_data for all touches for debug */
+static int cyttsp4_xy_worker(struct cyttsp4_debug_data *dd)
+{
+	struct device *dev = &dd->ttsp->dev;
+	struct cyttsp4_sysinfo *si = dd->si;
+	u8 tt_stat = si->xy_mode[si->si_ofs.tt_stat_ofs];
+	u8 num_cur_rec = GET_NUM_TOUCH_RECORDS(tt_stat);
+	uint32_t formated_output;
+	int rc;
+
+	mutex_lock(&dd->sysfs_lock);
+	dd->interrupt_count++;
+	formated_output = dd->formated_output;
+	mutex_unlock(&dd->sysfs_lock);
+
+	/* Read command parameters */
+	rc = cyttsp4_read(dd->ttsp, CY_MODE_OPERATIONAL,
+			si->si_ofs.cmd_ofs + 1,
+			&si->xy_mode[si->si_ofs.cmd_ofs + 1],
+			si->si_ofs.rep_ofs - si->si_ofs.cmd_ofs - 1);
+	if (rc < 0) {
+		dev_err(dev, "%s: read fail on command parameter regs r=%d\n",
+				__func__, rc);
+	}
+
+	if (si->si_ofs.num_btns > 0) {
+		/* read button diff data */
+		rc = cyttsp4_read(dd->ttsp, CY_MODE_OPERATIONAL,
+				/*  replace with btn_diff_ofs when that field
+				 *  becomes supported in the firmware */
+				si->si_ofs.tt_stat_ofs + 1 +
+				si->si_ofs.max_tchs * si->si_ofs.tch_rec_size,
+				si->btn_rec_data,
+				si->si_ofs.num_btns * si->si_ofs.btn_rec_size);
+		if (rc < 0) {
+			dev_err(dev, "%s: read fail on button regs r=%d\n",
+					__func__, rc);
+		}
+	}
+
+	/* Interrupt */
+	pr_info("Interrupt(%u)\n", dd->interrupt_count);
+
+	if (formated_output)
+		cyttsp4_debug_formated(dev, dd->pr_buf, si, num_cur_rec);
+	else
+		/* print data for TTHE */
+		cyttsp4_pr_buf_op_mode(dev, dd->pr_buf, si, num_cur_rec);
+
+	if (dd->monitor.mntr_status == CY_MNTR_ENABLED) {
+		int offset = (si->si_ofs.max_tchs * si->si_ofs.tch_rec_size)
+				+ (si->si_ofs.num_btns
+					* si->si_ofs.btn_rec_size)
+				+ (si->si_ofs.tt_stat_ofs + 1);
+		rc = cyttsp4_read(dd->ttsp, CY_MODE_OPERATIONAL,
+				offset, &(dd->monitor.sensor_data[0]), 150);
+		if (rc < 0)
+			dev_err(dev, "%s: read fail on sensor monitor regs r=%d\n",
+					__func__, rc);
+		/* print data for the sensor monitor */
+		cyttsp4_debug_print(dev, dd->pr_buf, dd->monitor.sensor_data,
+				150, "cyttsp4_sensor_monitor");
+	}
+
+	pr_info("\n");
+
+	dev_vdbg(dev, "%s: done\n", __func__);
+
+	return 0;
+}
+
+static int cyttsp4_debug_op_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+	int rc = 0;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	/* core handles handshake */
+	rc = cyttsp4_xy_worker(dd);
+	if (rc < 0)
+		dev_err(dev, "%s: xy_worker error r=%d\n", __func__, rc);
+
+	return rc;
+}
+
+static int cyttsp4_debug_cat_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+	struct cyttsp4_sysinfo *si = dd->si;
+	u8 cat_masked_cmd;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	/* Check for CaT command executed */
+	cat_masked_cmd = si->xy_mode[CY_REG_CAT_CMD] & CY_CMD_MASK;
+	if (cat_masked_cmd == CY_CMD_CAT_START_SENSOR_DATA_MODE) {
+		dev_vdbg(dev, "%s: Sensor data mode enabled\n", __func__);
+		dd->monitor.mntr_status = CY_MNTR_ENABLED;
+	} else if (cat_masked_cmd == CY_CMD_CAT_STOP_SENSOR_DATA_MODE) {
+		dev_vdbg(dev, "%s: Sensor data mode disabled\n", __func__);
+		dd->monitor.mntr_status = CY_MNTR_DISABLED;
+	}
+
+	return 0;
+}
+
+static int cyttsp4_debug_startup_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	dd->monitor.mntr_status = CY_MNTR_DISABLED;
+
+	return 0;
+}
+
+static ssize_t cyttsp4_interrupt_count_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+	int val;
+
+	mutex_lock(&dd->sysfs_lock);
+	val = dd->interrupt_count;
+	mutex_unlock(&dd->sysfs_lock);
+
+	return scnprintf(buf, CY_MAX_PRBUF_SIZE, "Interrupt Count: %d\n", val);
+}
+
+static ssize_t cyttsp4_interrupt_count_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+	mutex_lock(&dd->sysfs_lock);
+	dd->interrupt_count = 0;
+	mutex_unlock(&dd->sysfs_lock);
+	return size;
+}
+
+static DEVICE_ATTR(int_count, S_IRUSR | S_IWUSR,
+	cyttsp4_interrupt_count_show, cyttsp4_interrupt_count_store);
+
+static ssize_t cyttsp4_formated_output_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+	int val;
+
+	mutex_lock(&dd->sysfs_lock);
+	val = dd->formated_output;
+	mutex_unlock(&dd->sysfs_lock);
+
+	return scnprintf(buf, CY_MAX_PRBUF_SIZE,
+			"Formated debug output: %x\n", val);
+}
+
+static ssize_t cyttsp4_formated_output_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+	unsigned long value;
+	int rc;
+
+	rc = kstrtoul(buf, 10, &value);
+	if (rc < 0) {
+		dev_err(dev, "%s: Invalid value\n", __func__);
+		return size;
+	}
+
+	/* Expecting only 0 or 1 */
+	if (value != 0 && value != 1) {
+		dev_err(dev, "%s: Invalid value %lu\n", __func__, value);
+		return size;
+	}
+
+	mutex_lock(&dd->sysfs_lock);
+	dd->formated_output = value;
+	mutex_unlock(&dd->sysfs_lock);
+	return size;
+}
+
+static DEVICE_ATTR(formated_output, S_IRUSR | S_IWUSR,
+	cyttsp4_formated_output_show, cyttsp4_formated_output_store);
+
+static int cyttsp4_debug_probe(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_debug_data *dd;
+	struct cyttsp4_debug_platform_data *pdata = dev_get_platdata(dev);
+	int rc;
+
+	dev_info(dev, "%s: startup\n", __func__);
+	dev_dbg(dev, "%s: debug on\n", __func__);
+	dev_vdbg(dev, "%s: verbose debug on\n", __func__);
+
+	/* get context and debug print buffers */
+	dd = kzalloc(sizeof(*dd), GFP_KERNEL);
+	if (dd == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto cyttsp4_debug_probe_alloc_failed;
+	}
+
+	rc = device_create_file(dev, &dev_attr_int_count);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create int_count\n",
+				__func__);
+		goto cyttsp4_debug_probe_create_int_count_failed;
+	}
+
+	rc = device_create_file(dev, &dev_attr_formated_output);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create formated_output\n",
+				__func__);
+		goto cyttsp4_debug_probe_create_formated_failed;
+	}
+
+	mutex_init(&dd->sysfs_lock);
+	dd->ttsp = ttsp;
+	dd->pdata = pdata;
+	dev_set_drvdata(dev, dd);
+
+	pm_runtime_enable(dev);
+
+	dd->si = cyttsp4_request_sysinfo(ttsp);
+	if (dd->si == NULL) {
+		dev_err(dev, "%s: Fail get sysinfo pointer from core\n",
+				__func__);
+		rc = -ENODEV;
+		goto cyttsp4_debug_probe_sysinfo_failed;
+	}
+
+	rc = cyttsp4_subscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_debug_op_attention, CY_MODE_OPERATIONAL);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error, could not subscribe Operating mode attention cb\n",
+				__func__);
+		goto cyttsp4_debug_probe_subscribe_op_failed;
+	}
+
+	rc = cyttsp4_subscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_debug_cat_attention, CY_MODE_CAT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error, could not subscribe CaT mode attention cb\n",
+				__func__);
+		goto cyttsp4_debug_probe_subscribe_cat_failed;
+	}
+
+	rc = cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_debug_startup_attention, 0);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error, could not subscribe startup attention cb\n",
+				__func__);
+		goto cyttsp4_debug_probe_subscribe_startup_failed;
+	}
+	return 0;
+
+cyttsp4_debug_probe_subscribe_startup_failed:
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_debug_cat_attention, CY_MODE_CAT);
+cyttsp4_debug_probe_subscribe_cat_failed:
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_debug_op_attention, CY_MODE_OPERATIONAL);
+cyttsp4_debug_probe_subscribe_op_failed:
+cyttsp4_debug_probe_sysinfo_failed:
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+	dev_set_drvdata(dev, NULL);
+	device_remove_file(dev, &dev_attr_formated_output);
+cyttsp4_debug_probe_create_formated_failed:
+	device_remove_file(dev, &dev_attr_int_count);
+cyttsp4_debug_probe_create_int_count_failed:
+	kfree(dd);
+cyttsp4_debug_probe_alloc_failed:
+	dev_err(dev, "%s failed.\n", __func__);
+	return rc;
+}
+
+static int cyttsp4_debug_release(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_debug_data *dd = dev_get_drvdata(dev);
+	int rc = 0;
+	dev_dbg(dev, "%s\n", __func__);
+
+	if (dev_get_drvdata(&ttsp->core->dev) == NULL) {
+		dev_err(dev, "%s: Unable to un-subscribe attention\n",
+				__func__);
+		goto cyttsp4_debug_release_exit;
+	}
+
+	/* Unsubscribe from attentions */
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_debug_op_attention, CY_MODE_OPERATIONAL);
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_debug_cat_attention, CY_MODE_CAT);
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_debug_startup_attention, 0);
+
+cyttsp4_debug_release_exit:
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+	device_remove_file(dev, &dev_attr_int_count);
+	dev_set_drvdata(dev, NULL);
+	kfree(dd);
+
+	return rc;
+}
+
+static struct cyttsp4_driver cyttsp4_debug_driver = {
+	.probe = cyttsp4_debug_probe,
+	.remove = cyttsp4_debug_release,
+	.driver = {
+		.name = CYTTSP4_DEBUG_NAME,
+		.bus = &cyttsp4_bus_type,
+		.owner = THIS_MODULE,
+	},
+};
+
+static struct cyttsp4_debug_platform_data
+	_cyttsp4_debug_platform_data = {
+	.debug_dev_name = CYTTSP4_DEBUG_NAME,
+};
+
+static const char cyttsp4_debug_name[] = CYTTSP4_DEBUG_NAME;
+static struct cyttsp4_device_info
+	cyttsp4_debug_infos[CY_MAX_NUM_CORE_DEVS];
+
+static char *core_ids[CY_MAX_NUM_CORE_DEVS] = {
+	CY_DEFAULT_CORE_ID,
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static int num_core_ids = 1;
+
+module_param_array(core_ids, charp, &num_core_ids, 0);
+MODULE_PARM_DESC(core_ids,
+	"Core id list of cyttsp4 core devices for debug module");
+
+static int __init cyttsp4_debug_init(void)
+{
+	int rc = 0;
+	int i, j;
+
+	/* Check for invalid or duplicate core_ids */
+	for (i = 0; i < num_core_ids; i++) {
+		if (!strlen(core_ids[i])) {
+			pr_err("%s: core_id %d is empty\n",
+				__func__, i+1);
+			return -EINVAL;
+		}
+		for (j = i+1; j < num_core_ids; j++)
+			if (!strcmp(core_ids[i], core_ids[j])) {
+				pr_err("%s: core_ids %d and %d are same\n",
+					__func__, i+1, j+1);
+				return -EINVAL;
+			}
+	}
+
+	for (i = 0; i < num_core_ids; i++) {
+		cyttsp4_debug_infos[i].name = cyttsp4_debug_name;
+		cyttsp4_debug_infos[i].core_id = core_ids[i];
+		cyttsp4_debug_infos[i].platform_data =
+			&_cyttsp4_debug_platform_data;
+		pr_info("%s: Registering debug device for core_id: %s\n",
+			__func__, cyttsp4_debug_infos[i].core_id);
+		rc = cyttsp4_register_device(&cyttsp4_debug_infos[i]);
+		if (rc < 0) {
+			pr_err("%s: Error, failed registering device\n",
+				__func__);
+			goto fail_unregister_devices;
+		}
+	}
+	rc = cyttsp4_register_driver(&cyttsp4_debug_driver);
+	if (rc) {
+		pr_err("%s: Error, failed registering driver\n", __func__);
+		goto fail_unregister_devices;
+	}
+
+	pr_info("%s: Cypress TTSP Debug (Built %s) rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return 0;
+
+fail_unregister_devices:
+	for (i--; i >= 0; i--) {
+		cyttsp4_unregister_device(cyttsp4_debug_infos[i].name,
+			cyttsp4_debug_infos[i].core_id);
+		pr_info("%s: Unregistering device access device for core_id: %s\n",
+			__func__, cyttsp4_debug_infos[i].core_id);
+	}
+	return rc;
+}
+module_init(cyttsp4_debug_init);
+
+static void __exit cyttsp4_debug_exit(void)
+{
+	int i;
+
+	cyttsp4_unregister_driver(&cyttsp4_debug_driver);
+	for (i = 0; i < num_core_ids; i++) {
+		cyttsp4_unregister_device(cyttsp4_debug_infos[i].name,
+			cyttsp4_debug_infos[i].core_id);
+		pr_info("%s: Unregistering debug device for core_id: %s\n",
+			__func__, cyttsp4_debug_infos[i].core_id);
+	}
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_debug_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard touchscreen debug driver");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_device_access.c b/drivers/input/touchscreen/cypress/cyttsp4_device_access.c
new file mode 100644
index 0000000..c6cc82d
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_device_access.c
@@ -0,0 +1,2208 @@
+/*
+ * cyttsp4_device_access.c
+ * Cypress TrueTouch(TM) Standard Product V4 Device Access module.
+ * Configuration and Test command/status user interface.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ * Copyright (C) 2014 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/cyttsp4_bus.h>
+#include <linux/cyttsp4_core.h>
+#include <linux/cyttsp4_mt.h>
+
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/limits.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+#include <linux/workqueue.h>
+#include "cyttsp4_device_access.h"
+#include "cyttsp4_regs.h"
+
+#define CY_MAX_CONFIG_BYTES    256
+#define CY_CMD_INDEX             0
+#define CY_NULL_CMD_INDEX        1
+#define CY_NULL_CMD_MODE_INDEX   2
+#define CY_NULL_CMD_SIZE_INDEX   3
+#define CY_NULL_CMD_SIZEL_INDEX  2
+#define CY_NULL_CMD_SIZEH_INDEX  3
+
+struct heatmap_param {
+	bool scan_start;
+	enum cyttsp4_scan_data_type data_type; /* raw, base, diff */
+	int num_element;
+};
+
+struct cyttsp4_device_access_data {
+	struct cyttsp4_device *ttsp;
+	struct cyttsp4_device_access_platform_data *pdata;
+	struct cyttsp4_sysinfo *si;
+	struct cyttsp4_test_mode_params test;
+	struct mutex sysfs_lock;
+	uint32_t ic_grpnum;
+	uint32_t ic_grpoffset;
+	bool own_exclusive;
+	bool sysfs_nodes_created;
+#ifdef VERBOSE_DEBUG
+	u8 pr_buf[CY_MAX_PRBUF_SIZE];
+#endif
+	wait_queue_head_t wait_q;
+	u8 ic_buf[CY_MAX_PRBUF_SIZE];
+	u8 return_buf[CY_MAX_PRBUF_SIZE];
+	struct heatmap_param heatmap;
+};
+
+/*
+ * Show function prototype.
+ * Returns response length or Linux error code on error.
+ */
+typedef int (*cyttsp4_show_function) (struct device *dev, u8 *ic_buf,
+		size_t length);
+
+/*
+ * Store function prototype.
+ * Returns Linux error code on error.
+ */
+typedef int (*cyttsp4_store_function) (struct device *dev, u8 *ic_buf,
+		size_t length);
+
+/*
+ * grpdata show function to be used by
+ * reserved and not implemented ic group numbers.
+ */
+static int cyttsp4_grpdata_show_void (struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	return -ENOSYS;
+}
+
+/*
+ * grpdata store function to be used by
+ * reserved and not implemented ic group numbers.
+ */
+static int cyttsp4_grpdata_store_void (struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	return -ENOSYS;
+}
+
+/*
+ * SysFs group number entry show function.
+ */
+static ssize_t cyttsp4_ic_grpnum_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int val = 0;
+
+	mutex_lock(&dad->sysfs_lock);
+	val = dad->ic_grpnum;
+	mutex_unlock(&dad->sysfs_lock);
+
+	return scnprintf(buf, CY_MAX_PRBUF_SIZE, "Current Group: %d\n", val);
+}
+
+/*
+ * SysFs group number entry store function.
+ */
+static ssize_t cyttsp4_ic_grpnum_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	unsigned long value;
+	int prev_grpnum;
+	int rc;
+
+	rc = kstrtoul(buf, 10, &value);
+	if (rc < 0) {
+		dev_err(dev, "%s: Invalid value\n", __func__);
+		return size;
+	}
+
+	if (value >= CY_IC_GRPNUM_NUM) {
+		dev_err(dev, "%s: Group %lu does not exist.\n",
+				__func__, value);
+		return size;
+	}
+
+	if (value > 0xFF)
+		value = 0xFF;
+
+	mutex_lock(&dad->sysfs_lock);
+	/*
+	 * Block grpnum change when own_exclusive flag is set
+	 * which means the current grpnum implementation requires
+	 * running exclusively on some consecutive grpdata operations
+	 */
+	if (dad->own_exclusive) {
+		mutex_unlock(&dad->sysfs_lock);
+		dev_err(dev, "%s: own_exclusive\n", __func__);
+		return -EBUSY;
+	}
+	prev_grpnum = dad->ic_grpnum;
+	dad->ic_grpnum = (int) value;
+	mutex_unlock(&dad->sysfs_lock);
+
+	dev_vdbg(dev, "%s: ic_grpnum=%d, return size=%d\n",
+			__func__, (int)value, (int)size);
+	return size;
+}
+
+static DEVICE_ATTR(ic_grpnum, S_IRUSR | S_IWUSR,
+		   cyttsp4_ic_grpnum_show, cyttsp4_ic_grpnum_store);
+
+/*
+ * SysFs group offset entry show function.
+ */
+static ssize_t cyttsp4_ic_grpoffset_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int val = 0;
+
+	mutex_lock(&dad->sysfs_lock);
+	val = dad->ic_grpoffset;
+	mutex_unlock(&dad->sysfs_lock);
+
+	return scnprintf(buf, CY_MAX_PRBUF_SIZE, "Current Offset: %d\n", val);
+}
+
+/*
+ * SysFs group offset entry store function.
+ */
+static ssize_t cyttsp4_ic_grpoffset_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	unsigned long value;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &value);
+	if (ret < 0) {
+		dev_err(dev, "%s: Invalid value\n", __func__);
+		return size;
+	}
+
+	if (value > 0xFFFF)
+		value = 0xFFFF;
+
+	mutex_lock(&dad->sysfs_lock);
+	dad->ic_grpoffset = (int)value;
+	mutex_unlock(&dad->sysfs_lock);
+
+	dev_vdbg(dev, "%s: ic_grpoffset=%d, return size=%d\n", __func__,
+			(int)value, (int)size);
+	return size;
+}
+
+static DEVICE_ATTR(ic_grpoffset, S_IRUSR | S_IWUSR,
+		   cyttsp4_ic_grpoffset_show, cyttsp4_ic_grpoffset_store);
+
+/*
+ * Prints part of communication registers.
+ */
+static int cyttsp4_grpdata_show_registers(struct device *dev, u8 *ic_buf,
+		size_t length, int num_read, int offset, int mode)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc;
+
+	if (dad->ic_grpoffset >= num_read)
+		return -EINVAL;
+
+	num_read -= dad->ic_grpoffset;
+
+	if (length < num_read) {
+		dev_err(dev, "%s: not sufficient buffer req_bug_len=%d, length=%d\n",
+				__func__, num_read, length);
+		return -EINVAL;
+	}
+
+	pm_runtime_get_sync(dev);
+	rc = cyttsp4_read(dad->ttsp, mode, offset + dad->ic_grpoffset, ic_buf,
+			num_read);
+	pm_runtime_put(dev);
+	if (rc < 0)
+		return rc;
+
+	return num_read;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 1.
+ * Prints status register contents of Operational mode registers.
+ */
+static int cyttsp4_grpdata_show_operational_regs(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.rep_ofs - dad->si->si_ofs.cmd_ofs;
+	int i;
+
+	if (dad->ic_grpoffset >= num_read) {
+		dev_err(dev,
+			"%s: ic_grpoffset bigger than command registers, cmd_registers=%d\n",
+			__func__, num_read);
+		return -EINVAL;
+	}
+
+	num_read -= dad->ic_grpoffset;
+
+	if (length < num_read) {
+		dev_err(dev,
+			"%s: not sufficient buffer req_bug_len=%d, length=%d\n",
+			__func__, num_read, length);
+		return -EINVAL;
+	}
+
+	if (dad->ic_grpoffset + num_read > CY_MAX_PRBUF_SIZE) {
+		dev_err(dev,
+			"%s: not sufficient source buffer req_bug_len=%d, length=%d\n",
+			__func__, dad->ic_grpoffset + num_read,
+			CY_MAX_PRBUF_SIZE);
+		return -EINVAL;
+	}
+
+
+	/* cmd result already put into dad->return_buf */
+	for (i = 0; i < num_read; i++)
+		ic_buf[i] = dad->return_buf[dad->ic_grpoffset + i];
+
+	return num_read;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 2.
+ * Prints current contents of the touch registers (full set).
+ */
+static int cyttsp4_grpdata_show_touch_regs(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.rep_sz;
+	int offset = dad->si->si_ofs.rep_ofs;
+
+	return cyttsp4_grpdata_show_registers(dev, ic_buf, length, num_read,
+			offset, CY_MODE_OPERATIONAL);
+}
+
+/*
+ * Prints some content of the system information
+ */
+static int cyttsp4_grpdata_show_sysinfo(struct device *dev, u8 *ic_buf,
+		size_t length, int num_read, int offset)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc = 0, rc2 = 0, rc3 = 0;
+
+	if (dad->ic_grpoffset >= num_read)
+		return -EINVAL;
+
+	num_read -= dad->ic_grpoffset;
+
+	if (length < num_read) {
+		dev_err(dev, "%s: not sufficient buffer req_bug_len=%d, length=%d\n",
+				__func__, num_read, length);
+		return -EINVAL;
+	}
+
+	pm_runtime_get_sync(dev);
+
+	rc = cyttsp4_request_exclusive(dad->ttsp,
+			CY_DA_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_show_sysinfo_err_put;
+	}
+
+	rc = cyttsp4_request_set_mode(dad->ttsp, CY_MODE_SYSINFO);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_show_sysinfo_err_release;
+	}
+
+	rc = cyttsp4_read(dad->ttsp, CY_MODE_SYSINFO,
+			offset + dad->ic_grpoffset,
+			ic_buf, num_read);
+	if (rc < 0)
+		dev_err(dev, "%s: Fail read cmd regs r=%d\n",
+				__func__, rc);
+
+	rc2 = cyttsp4_request_set_mode(dad->ttsp, CY_MODE_OPERATIONAL);
+	if (rc2 < 0)
+		dev_err(dev, "%s: Error on request set mode 2 r=%d\n",
+				__func__, rc2);
+
+cyttsp4_grpdata_show_sysinfo_err_release:
+	rc3 = cyttsp4_release_exclusive(dad->ttsp);
+	if (rc3 < 0)
+		dev_err(dev, "%s: Error on release exclusive r=%d\n",
+				__func__, rc3);
+
+cyttsp4_grpdata_show_sysinfo_err_put:
+	pm_runtime_put(dev);
+
+	if (rc < 0)
+		return rc;
+	if (rc2 < 0)
+		return rc2;
+	if (rc3 < 0)
+		return rc3;
+
+	return num_read;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 3.
+ * Prints content of the system information DATA record.
+ */
+static int cyttsp4_grpdata_show_sysinfo_data_rec(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.cydata_size;
+	int offset = dad->si->si_ofs.cydata_ofs;
+
+	return cyttsp4_grpdata_show_sysinfo(dev, ic_buf, length, num_read,
+			offset);
+}
+
+/*
+ * SysFs grpdata show function implementation of group 4.
+ * Prints content of the system information TEST record.
+ */
+static int cyttsp4_grpdata_show_sysinfo_test_rec(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.test_size;
+	int offset = dad->si->si_ofs.test_ofs;
+
+	return cyttsp4_grpdata_show_sysinfo(dev, ic_buf, length, num_read,
+			offset);
+}
+
+/*
+ * SysFs grpdata show function implementation of group 5.
+ * Prints content of the system information PANEL data.
+ */
+static int cyttsp4_grpdata_show_sysinfo_panel(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.pcfg_size;
+	int offset = dad->si->si_ofs.pcfg_ofs;
+
+	return cyttsp4_grpdata_show_sysinfo(dev, ic_buf, length, num_read,
+			offset);
+}
+
+/*
+ * SysFs grpdata show function implementation of group 6.
+ * Prints contents of the touch parameters a row at a time.
+ */
+static int cyttsp4_grpdata_show_touch_params(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	u8 cmd_buf[CY_CMD_CAT_READ_CFG_BLK_CMD_SZ];
+	int return_buf_size = CY_CMD_CAT_READ_CFG_BLK_RET_SZ;
+	u16 config_row_size;
+	int row_offset;
+	int offset_in_single_row = 0;
+	int rc;
+	int rc2 = 0;
+	int rc3;
+	int i, j;
+
+	pm_runtime_get_sync(dev);
+
+	rc = cyttsp4_request_exclusive(dad->ttsp,
+			CY_DA_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_show_touch_params_err_put;
+	}
+
+	rc = cyttsp4_request_set_mode(dad->ttsp, CY_MODE_CAT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_show_touch_params_err_release;
+	}
+
+	rc = cyttsp4_request_config_row_size(dad->ttsp, &config_row_size);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request config row size r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_show_touch_params_err_change_mode;
+	}
+
+	/* Perform buffer size check since we have just acquired row size */
+	return_buf_size += config_row_size;
+
+	if (length < return_buf_size) {
+		dev_err(dev, "%s: not sufficient buffer req_buf_len=%d, length=%d\n",
+				__func__, return_buf_size, length);
+		rc = -EINVAL;
+		goto cyttsp4_grpdata_show_touch_params_err_change_mode;
+	}
+
+	row_offset = dad->ic_grpoffset / config_row_size;
+
+	cmd_buf[0] = CY_CMD_CAT_READ_CFG_BLK;
+	cmd_buf[1] = HI_BYTE(row_offset);
+	cmd_buf[2] = LO_BYTE(row_offset);
+	cmd_buf[3] = HI_BYTE(config_row_size);
+	cmd_buf[4] = LO_BYTE(config_row_size);
+	cmd_buf[5] = CY_TCH_PARM_EBID;
+	rc = cyttsp4_request_exec_cmd(dad->ttsp, CY_MODE_CAT,
+			cmd_buf, CY_CMD_CAT_READ_CFG_BLK_CMD_SZ,
+			ic_buf, return_buf_size,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+
+	offset_in_single_row = dad->ic_grpoffset % config_row_size;
+
+	/* Remove Header data from return buffer */
+	for (i = 0, j = CY_CMD_CAT_READ_CFG_BLK_RET_HDR_SZ
+				+ offset_in_single_row;
+			i < (config_row_size - offset_in_single_row);
+			i++, j++)
+		ic_buf[i] = ic_buf[j];
+
+cyttsp4_grpdata_show_touch_params_err_change_mode:
+	rc2 = cyttsp4_request_set_mode(dad->ttsp, CY_MODE_OPERATIONAL);
+	if (rc2 < 0)
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc2);
+
+cyttsp4_grpdata_show_touch_params_err_release:
+	rc3 = cyttsp4_release_exclusive(dad->ttsp);
+	if (rc3 < 0)
+		dev_err(dev, "%s: Error on release exclusive r=%d\n",
+				__func__, rc3);
+
+cyttsp4_grpdata_show_touch_params_err_put:
+	pm_runtime_put(dev);
+
+	if (rc < 0)
+		return rc;
+	if (rc2 < 0)
+		return rc2;
+	if (rc3 < 0)
+		return rc3;
+
+	return config_row_size - offset_in_single_row;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 7.
+ * Prints contents of the touch parameters sizes.
+ */
+static int cyttsp4_grpdata_show_touch_params_sizes(struct device *dev,
+		u8 *ic_buf, size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	struct cyttsp4_core_platform_data *pdata =
+			dev_get_platdata(&dad->ttsp->core->dev);
+	int max_size;
+	int block_start;
+	int block_end;
+	int num_read;
+
+	if (pdata->sett[CY_IC_GRPNUM_TCH_PARM_SIZE] == NULL) {
+		dev_err(dev, "%s: Missing platform data Touch Parameters Sizes table\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	if (pdata->sett[CY_IC_GRPNUM_TCH_PARM_SIZE]->data == NULL) {
+		dev_err(dev, "%s: Missing platform data Touch Parameters Sizes table data\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	max_size = pdata->sett[CY_IC_GRPNUM_TCH_PARM_SIZE]->size;
+	max_size *= sizeof(uint16_t);
+	if (dad->ic_grpoffset >= max_size)
+		return -EINVAL;
+
+	block_start = (dad->ic_grpoffset / CYTTSP4_TCH_PARAM_SIZE_BLK_SZ)
+			* CYTTSP4_TCH_PARAM_SIZE_BLK_SZ;
+	block_end = CYTTSP4_TCH_PARAM_SIZE_BLK_SZ + block_start;
+	if (block_end > max_size)
+		block_end = max_size;
+	num_read = block_end - dad->ic_grpoffset;
+	if (length < num_read) {
+		dev_err(dev, "%s: not sufficient buffer %s=%d, %s=%d\n",
+				__func__, "req_buf_len", num_read, "length",
+				length);
+		return -EINVAL;
+	}
+
+	memcpy(ic_buf, (u8 *)pdata->sett[CY_IC_GRPNUM_TCH_PARM_SIZE]->data
+			+ dad->ic_grpoffset, num_read);
+
+	return num_read;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 10.
+ * Prints content of the system information Operational Configuration data.
+ */
+static int cyttsp4_grpdata_show_sysinfo_opcfg(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.opcfg_size;
+	int offset = dad->si->si_ofs.opcfg_ofs;
+
+	return cyttsp4_grpdata_show_sysinfo(dev, ic_buf, length, num_read,
+			offset);
+}
+
+/*
+ * SysFs grpdata show function implementation of group 11.
+ * Prints content of the system information Design data.
+ */
+static int cyttsp4_grpdata_show_sysinfo_design(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.ddata_size;
+	int offset = dad->si->si_ofs.ddata_ofs;
+
+	return cyttsp4_grpdata_show_sysinfo(dev, ic_buf, length, num_read,
+			offset);
+}
+
+/*
+ * SysFs grpdata show function implementation of group 12.
+ * Prints content of the system information Manufacturing data.
+ */
+static int cyttsp4_grpdata_show_sysinfo_manufacturing(struct device *dev,
+		u8 *ic_buf, size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int num_read = dad->si->si_ofs.mdata_size;
+	int offset = dad->si->si_ofs.mdata_ofs;
+
+	return cyttsp4_grpdata_show_sysinfo(dev, ic_buf, length, num_read,
+			offset);
+}
+
+/*
+ * SysFs grpdata show function implementation of group 13.
+ * Prints status register contents of Configuration and
+ * Test registers.
+ */
+static int cyttsp4_grpdata_show_test_regs(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	u8 mode;
+	int rc = 0;
+	int num_read = 0;
+	int i;
+
+	dev_vdbg(dev, "%s: test.cur_cmd=%d test.cur_mode=%d\n",
+			__func__, dad->test.cur_cmd, dad->test.cur_mode);
+
+	if (dad->test.cur_cmd == CY_CMD_CAT_NULL) {
+		num_read = 1;
+		if (length < num_read) {
+			dev_err(dev, "%s: not sufficient buffer %s=%d, %s=%d\n",
+					__func__, "req_buf_len", num_read,
+					"length", length);
+			return -EINVAL;
+		}
+
+		dev_vdbg(dev, "%s: GRP=TEST_REGS: NULL CMD: host_mode=%02X\n",
+				__func__, ic_buf[0]);
+		pm_runtime_get_sync(dev);
+		rc = cyttsp4_read(dad->ttsp,
+				dad->test.cur_mode == CY_TEST_MODE_CAT ?
+					CY_MODE_CAT : CY_MODE_OPERATIONAL,
+				CY_REG_BASE, &mode, sizeof(mode));
+		pm_runtime_put(dev);
+		if (rc < 0) {
+			ic_buf[0] = 0xFF;
+			dev_err(dev, "%s: failed to read host mode r=%d\n",
+					__func__, rc);
+		} else {
+			ic_buf[0] = mode;
+		}
+	} else if (dad->test.cur_mode == CY_TEST_MODE_CAT) {
+		num_read = dad->test.cur_status_size;
+		if (length < num_read) {
+			dev_err(dev, "%s: not sufficient buffer %s=%d, %s=%d\n",
+					__func__, "req_buf_len", num_read,
+					"length", length);
+			return -EINVAL;
+		}
+		if (dad->ic_grpoffset + num_read > CY_MAX_PRBUF_SIZE) {
+			dev_err(dev,
+				"%s: not sufficient source buffer req_bug_len=%d, length=%d\n",
+				__func__, dad->ic_grpoffset + num_read,
+				CY_MAX_PRBUF_SIZE);
+			return -EINVAL;
+		}
+
+		dev_vdbg(dev, "%s: GRP=TEST_REGS: num_rd=%d at ofs=%d + grpofs=%d\n",
+				__func__, num_read, dad->si->si_ofs.cmd_ofs,
+				dad->ic_grpoffset);
+
+		/* cmd result already put into dad->return_buf */
+		for (i = 0; i < num_read; i++)
+			ic_buf[i] = dad->return_buf[dad->ic_grpoffset + i];
+	} else {
+		dev_err(dev, "%s: Not in Config/Test mode\n", __func__);
+	}
+
+	return num_read;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 14.
+ * Prints CapSense button keycodes.
+ */
+static int cyttsp4_grpdata_show_btn_keycodes(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	struct cyttsp4_btn *btn = dad->si->btn;
+	int num_btns = dad->si->si_ofs.num_btns - dad->ic_grpoffset;
+	int n;
+
+	if (num_btns <= 0 || btn == NULL || length < num_btns)
+		return -EINVAL;
+
+	for (n = 0; n < num_btns; n++)
+		ic_buf[n] = (u8) btn[dad->ic_grpoffset + n].key_code;
+
+	return n;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 15.
+ * Prints status register contents of Configuration and
+ * Test registers.
+ */
+static int cyttsp4_grpdata_show_tthe_test_regs(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc = 0;
+	int num_read = 0;
+
+	dev_vdbg(dev, "%s: test.cur_cmd=%d test.cur_mode=%d\n",
+			__func__, dad->test.cur_cmd, dad->test.cur_mode);
+
+	if (dad->test.cur_cmd == CY_CMD_CAT_NULL) {
+		num_read = dad->test.cur_status_size;
+		if (length < num_read) {
+			dev_err(dev, "%s: not sufficient buffer %s=%d, %s=%d\n",
+					__func__, "req_buf_len", num_read,
+					"length", length);
+			return -EINVAL;
+		}
+
+		dev_vdbg(dev, "%s: GRP=TEST_REGS: NULL CMD: host_mode=%02X\n",
+				__func__, ic_buf[0]);
+		rc = cyttsp4_read(dad->ttsp,
+				(dad->test.cur_mode == CY_TEST_MODE_CAT)
+					? CY_MODE_CAT :
+				(dad->test.cur_mode == CY_TEST_MODE_SYSINFO)
+					? CY_MODE_SYSINFO : CY_MODE_OPERATIONAL,
+				CY_REG_BASE, ic_buf, num_read);
+		if (rc < 0) {
+			ic_buf[0] = 0xFF;
+			dev_err(dev, "%s: failed to read host mode r=%d\n",
+					__func__, rc);
+		}
+	} else if (dad->test.cur_mode == CY_TEST_MODE_CAT
+			|| dad->test.cur_mode == CY_TEST_MODE_SYSINFO) {
+		num_read = dad->test.cur_status_size;
+		if (length < num_read) {
+			dev_err(dev, "%s: not sufficient buffer %s=%d, %s=%d\n",
+					__func__, "req_buf_len", num_read,
+					"length", length);
+			return -EINVAL;
+		}
+		dev_vdbg(dev, "%s: GRP=TEST_REGS: num_rd=%d at ofs=%d + grpofs=%d\n",
+				__func__, num_read, dad->si->si_ofs.cmd_ofs,
+				dad->ic_grpoffset);
+		rc = cyttsp4_read(dad->ttsp,
+				(dad->test.cur_mode == CY_TEST_MODE_CAT)
+					? CY_MODE_CAT : CY_MODE_SYSINFO,
+				CY_REG_BASE, ic_buf, num_read);
+		if (rc < 0)
+			return rc;
+	} else {
+		dev_err(dev, "%s: In unsupported mode\n", __func__);
+	}
+
+	return num_read;
+}
+
+static cyttsp4_show_function
+		cyttsp4_grpdata_show_functions[CY_IC_GRPNUM_NUM] = {
+	[CY_IC_GRPNUM_RESERVED] = cyttsp4_grpdata_show_void,
+	[CY_IC_GRPNUM_CMD_REGS] = cyttsp4_grpdata_show_operational_regs,
+	[CY_IC_GRPNUM_TCH_REP] = cyttsp4_grpdata_show_touch_regs,
+	[CY_IC_GRPNUM_DATA_REC] = cyttsp4_grpdata_show_sysinfo_data_rec,
+	[CY_IC_GRPNUM_TEST_REC] = cyttsp4_grpdata_show_sysinfo_test_rec,
+	[CY_IC_GRPNUM_PCFG_REC] = cyttsp4_grpdata_show_sysinfo_panel,
+	[CY_IC_GRPNUM_TCH_PARM_VAL] = cyttsp4_grpdata_show_touch_params,
+	[CY_IC_GRPNUM_TCH_PARM_SIZE] = cyttsp4_grpdata_show_touch_params_sizes,
+	[CY_IC_GRPNUM_RESERVED1] = cyttsp4_grpdata_show_void,
+	[CY_IC_GRPNUM_RESERVED2] = cyttsp4_grpdata_show_void,
+	[CY_IC_GRPNUM_OPCFG_REC] = cyttsp4_grpdata_show_sysinfo_opcfg,
+	[CY_IC_GRPNUM_DDATA_REC] = cyttsp4_grpdata_show_sysinfo_design,
+	[CY_IC_GRPNUM_MDATA_REC] = cyttsp4_grpdata_show_sysinfo_manufacturing,
+	[CY_IC_GRPNUM_TEST_REGS] = cyttsp4_grpdata_show_test_regs,
+	[CY_IC_GRPNUM_BTN_KEYS] = cyttsp4_grpdata_show_btn_keycodes,
+	[CY_IC_GRPNUM_TTHE_REGS] = cyttsp4_grpdata_show_tthe_test_regs,
+};
+
+static ssize_t cyttsp4_ic_grpdata_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int i;
+	ssize_t num_read;
+	int index;
+
+	mutex_lock(&dad->sysfs_lock);
+	dev_vdbg(dev, "%s: grpnum=%d grpoffset=%u\n",
+			__func__, dad->ic_grpnum, dad->ic_grpoffset);
+
+	index = scnprintf(buf, CY_MAX_PRBUF_SIZE,
+			"Group %d, Offset %u:\n", dad->ic_grpnum,
+			dad->ic_grpoffset);
+
+	num_read = cyttsp4_grpdata_show_functions[dad->ic_grpnum] (dev,
+			dad->ic_buf, CY_MAX_PRBUF_SIZE);
+	if (num_read < 0) {
+		index = num_read;
+		if (num_read == -ENOSYS) {
+			dev_err(dev, "%s: Group %d is not implemented.\n",
+				__func__, dad->ic_grpnum);
+			goto cyttsp4_ic_grpdata_show_error;
+		}
+		dev_err(dev, "%s: Cannot read Group %d Data.\n",
+				__func__, dad->ic_grpnum);
+		goto cyttsp4_ic_grpdata_show_error;
+	}
+
+	for (i = 0; i < num_read; i++) {
+		index += scnprintf(buf + index, CY_MAX_PRBUF_SIZE - index,
+				"0x%02X\n", dad->ic_buf[i]);
+	}
+
+	index += scnprintf(buf + index, CY_MAX_PRBUF_SIZE - index,
+			"(%d bytes)\n", num_read);
+
+cyttsp4_ic_grpdata_show_error:
+	mutex_unlock(&dad->sysfs_lock);
+	return index;
+}
+
+static int _cyttsp4_cmd_handshake(struct cyttsp4_device_access_data *dad)
+{
+	struct device *dev = &dad->ttsp->dev;
+	u8 mode;
+	int rc;
+
+	rc = cyttsp4_read(dad->ttsp, CY_MODE_CAT,
+			CY_REG_BASE, &mode, sizeof(mode));
+	if (rc < 0) {
+		dev_err(dev, "%s: Fail read host mode r=%d\n", __func__, rc);
+		return rc;
+	}
+
+	rc = cyttsp4_request_handshake(dad->ttsp, mode);
+	if (rc < 0)
+		dev_err(dev, "%s: Fail cmd handshake r=%d\n", __func__, rc);
+
+	return rc;
+}
+
+static int _cyttsp4_cmd_toggle_lowpower(struct cyttsp4_device_access_data *dad)
+{
+	struct device *dev = &dad->ttsp->dev;
+	u8 mode;
+	int rc = cyttsp4_read(dad->ttsp,
+			(dad->test.cur_mode == CY_TEST_MODE_CAT)
+				? CY_MODE_CAT : CY_MODE_OPERATIONAL,
+			CY_REG_BASE, &mode, sizeof(mode));
+	if (rc < 0) {
+		dev_err(dev, "%s: Fail read host mode r=%d\n",
+				__func__, rc);
+		return rc;
+	}
+
+	rc = cyttsp4_request_toggle_lowpower(dad->ttsp, mode);
+	if (rc < 0)
+		dev_err(dev, "%s: Fail cmd handshake r=%d\n",
+				__func__, rc);
+	return rc;
+}
+
+static int cyttsp4_test_cmd_mode(struct cyttsp4_device_access_data *dad,
+		u8 *ic_buf, size_t length)
+{
+	struct device *dev = &dad->ttsp->dev;
+	int rc = -ENOSYS;
+	u8 mode;
+
+	if (length < CY_NULL_CMD_MODE_INDEX + 1)  {
+		dev_err(dev, "%s: %s length=%d\n", __func__,
+				"Buffer length is not valid", length);
+		return -EINVAL;
+	}
+	mode = ic_buf[CY_NULL_CMD_MODE_INDEX];
+
+	if (mode == CY_HST_CAT) {
+		pm_runtime_get_sync(dev);
+		rc = cyttsp4_request_exclusive(dad->ttsp,
+				CY_DA_REQUEST_EXCLUSIVE_TIMEOUT);
+		if (rc < 0) {
+			dev_err(dev, "%s: Fail rqst exclusive r=%d\n",
+					__func__, rc);
+			pm_runtime_put(dev);
+			goto cyttsp4_test_cmd_mode_exit;
+		}
+		rc = cyttsp4_request_set_mode(dad->ttsp, CY_MODE_CAT);
+		if (rc < 0) {
+			dev_err(dev, "%s: Fail rqst set mode=%02X r=%d\n",
+					__func__, mode, rc);
+			rc = cyttsp4_release_exclusive(dad->ttsp);
+			if (rc < 0)
+				dev_err(dev, "%s: %s r=%d\n", __func__,
+						"Fail release exclusive", rc);
+			pm_runtime_put(dev);
+			goto cyttsp4_test_cmd_mode_exit;
+		}
+		dad->test.cur_mode = CY_TEST_MODE_CAT;
+		dad->own_exclusive = true;
+		dev_vdbg(dev, "%s: %s=%d %s=%02X %s=%d(CaT)\n", __func__,
+				"own_exclusive", dad->own_exclusive == true,
+				"mode", mode, "test.cur_mode",
+				dad->test.cur_mode);
+	} else if (mode == CY_HST_OPERATE) {
+		if (dad->own_exclusive) {
+			rc = cyttsp4_request_set_mode(dad->ttsp,
+					CY_MODE_OPERATIONAL);
+			if (rc < 0)
+				dev_err(dev, "%s: %s=%02X r=%d\n", __func__,
+						"Fail rqst set mode", mode, rc);
+				/* continue anyway */
+
+			rc = cyttsp4_release_exclusive(dad->ttsp);
+			if (rc < 0) {
+				dev_err(dev, "%s: %s r=%d\n", __func__,
+						"Fail release exclusive", rc);
+				/* continue anyway */
+				rc = 0;
+			}
+			dad->test.cur_mode = CY_TEST_MODE_NORMAL_OP;
+			dad->own_exclusive = false;
+			pm_runtime_put(dev);
+			dev_vdbg(dev, "%s: %s=%d %s=%02X %s=%d(Operate)\n",
+					__func__, "own_exclusive",
+					dad->own_exclusive == true,
+					"mode", mode,
+					"test.cur_mode", dad->test.cur_mode);
+		} else
+			dev_vdbg(dev, "%s: %s mode=%02X(Operate)\n", __func__,
+					"do not own exclusive; cannot switch",
+					mode);
+	} else
+		dev_vdbg(dev, "%s: unsupported mode switch=%02X\n",
+				__func__, mode);
+
+cyttsp4_test_cmd_mode_exit:
+	return rc;
+}
+
+static int cyttsp4_test_tthe_cmd_mode(struct cyttsp4_device_access_data *dad,
+		u8 *ic_buf, size_t length)
+{
+	struct device *dev = &dad->ttsp->dev;
+	int rc = -ENOSYS;
+	u8 mode;
+	enum cyttsp4_test_mode test_mode;
+	int new_mode;
+
+	if (length < CY_NULL_CMD_MODE_INDEX + 1)  {
+		dev_err(dev, "%s: %s length=%d\n", __func__,
+				"Buffer length is not valid", length);
+		return -EINVAL;
+	}
+	mode = ic_buf[CY_NULL_CMD_MODE_INDEX];
+
+	switch (mode) {
+	case CY_HST_CAT:
+		new_mode = CY_MODE_CAT;
+		test_mode = CY_TEST_MODE_CAT;
+		break;
+	case CY_HST_OPERATE:
+		new_mode = CY_MODE_OPERATIONAL;
+		test_mode = CY_TEST_MODE_NORMAL_OP;
+		break;
+	case CY_HST_SYSINFO:
+		new_mode = CY_MODE_SYSINFO;
+		test_mode = CY_TEST_MODE_SYSINFO;
+		break;
+	default:
+		dev_vdbg(dev, "%s: unsupported mode switch=%02X\n",
+				__func__, mode);
+		goto cyttsp4_test_tthe_cmd_mode_exit;
+	}
+
+	rc = cyttsp4_request_exclusive(dad->ttsp,
+			CY_DA_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Fail rqst exclusive r=%d\n", __func__, rc);
+		goto cyttsp4_test_tthe_cmd_mode_exit;
+	}
+	rc = cyttsp4_request_set_mode(dad->ttsp, new_mode);
+	if (rc < 0)
+		dev_err(dev, "%s: Fail rqst set mode=%02X r=%d\n",
+				__func__, mode, rc);
+	rc = cyttsp4_release_exclusive(dad->ttsp);
+	if (rc < 0) {
+		dev_err(dev, "%s: %s r=%d\n", __func__,
+				"Fail release exclusive", rc);
+		if (mode == CY_HST_OPERATE)
+			rc = 0;
+		else
+			goto cyttsp4_test_tthe_cmd_mode_exit;
+	}
+	dad->test.cur_mode = test_mode;
+	dev_vdbg(dev, "%s: %s=%d %s=%02X %s=%d\n", __func__,
+			"own_exclusive", dad->own_exclusive == true,
+			"mode", mode,
+			"test.cur_mode", dad->test.cur_mode);
+
+cyttsp4_test_tthe_cmd_mode_exit:
+	return rc;
+}
+
+/*
+ * SysFs grpdata store function implementation of group 1.
+ * Stores to command and parameter registers of Operational mode.
+ */
+static int cyttsp4_grpdata_store_operational_regs(struct device *dev,
+		u8 *ic_buf, size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	size_t cmd_ofs = dad->si->si_ofs.cmd_ofs;
+	int num_read = dad->si->si_ofs.rep_ofs - dad->si->si_ofs.cmd_ofs;
+	u8 *return_buf = dad->return_buf;
+	int rc, rc2 = 0;
+
+	if ((cmd_ofs + length) > dad->si->si_ofs.rep_ofs) {
+		dev_err(dev, "%s: %s length=%d\n", __func__,
+				"Buffer length is not valid", length);
+		return -EINVAL;
+	}
+
+	pm_runtime_get_sync(dev);
+
+	rc = cyttsp4_request_exclusive(dad->ttsp,
+			CY_DA_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_store_operational_regs_err_put;
+	}
+
+	return_buf[0] = ic_buf[0];
+	rc = cyttsp4_request_exec_cmd(dad->ttsp, CY_MODE_OPERATIONAL,
+			ic_buf, length,
+			return_buf + 1, num_read,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+	if (rc < 0)
+		dev_err(dev, "%s: Fail to execute cmd r=%d\n", __func__, rc);
+
+	rc2 = cyttsp4_release_exclusive(dad->ttsp);
+	if (rc2 < 0)
+		dev_err(dev, "%s: Error on release exclusive r=%d\n",
+				__func__, rc2);
+
+cyttsp4_grpdata_store_operational_regs_err_put:
+	pm_runtime_put(dev);
+
+	if (rc < 0)
+		return rc;
+	if (rc2 < 0)
+		return rc2;
+
+	return rc;
+}
+
+/*
+ * SysFs store function of Test Regs group.
+ */
+static int cyttsp4_grpdata_store_test_regs(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc;
+	u8 *return_buf = dad->return_buf;
+
+	/* Caller function guaranties, length is not bigger than ic_buf size */
+	if (length < CY_CMD_INDEX + 1) {
+		dev_err(dev, "%s: %s length=%d\n", __func__,
+				"Buffer length is not valid", length);
+		return -EINVAL;
+	}
+
+	dad->test.cur_cmd = ic_buf[CY_CMD_INDEX];
+	if (dad->test.cur_cmd == CY_CMD_CAT_NULL) {
+		if (length < CY_NULL_CMD_INDEX + 1) {
+			dev_err(dev, "%s: %s length=%d\n", __func__,
+					"Buffer length is not valid", length);
+			return -EINVAL;
+		}
+		dev_vdbg(dev, "%s: test-cur_cmd=%d null-cmd=%d\n", __func__,
+				dad->test.cur_cmd, ic_buf[CY_NULL_CMD_INDEX]);
+		switch (ic_buf[CY_NULL_CMD_INDEX]) {
+		case CY_NULL_CMD_NULL:
+			dev_err(dev, "%s: empty NULL cmd\n", __func__);
+			break;
+		case CY_NULL_CMD_MODE:
+			if (length < CY_NULL_CMD_MODE_INDEX + 1) {
+				dev_err(dev, "%s: %s length=%d\n", __func__,
+						"Buffer length is not valid",
+						length);
+				return -EINVAL;
+			}
+			dev_vdbg(dev, "%s: Set cmd mode=%02X\n", __func__,
+					ic_buf[CY_NULL_CMD_MODE_INDEX]);
+			cyttsp4_test_cmd_mode(dad, ic_buf, length);
+			break;
+		case CY_NULL_CMD_STATUS_SIZE:
+			if (length < CY_NULL_CMD_SIZE_INDEX + 1) {
+				dev_err(dev, "%s: %s length=%d\n", __func__,
+						"Buffer length is not valid",
+						length);
+				return -EINVAL;
+			}
+			dad->test.cur_status_size =
+				ic_buf[CY_NULL_CMD_SIZEL_INDEX]
+				+ (ic_buf[CY_NULL_CMD_SIZEH_INDEX] << 8);
+			dev_vdbg(dev, "%s: test-cur_status_size=%d\n",
+					__func__, dad->test.cur_status_size);
+			break;
+		case CY_NULL_CMD_HANDSHAKE:
+			dev_vdbg(dev, "%s: try null cmd handshake\n",
+					__func__);
+			rc = _cyttsp4_cmd_handshake(dad);
+			if (rc < 0)
+				dev_err(dev, "%s: %s r=%d\n", __func__,
+						"Fail test cmd handshake", rc);
+		default:
+			break;
+		}
+	} else {
+		dev_dbg(dev, "%s: TEST CMD=0x%02X length=%d %s%d\n",
+				__func__, ic_buf[0], length, "cmd_ofs+grpofs=",
+				dad->ic_grpoffset + dad->si->si_ofs.cmd_ofs);
+		cyttsp4_pr_buf(dev, dad->pr_buf, ic_buf, length, "test_cmd");
+		return_buf[0] = ic_buf[0]; /* Save cmd byte to return_buf */
+		rc = cyttsp4_request_exec_cmd(dad->ttsp, CY_MODE_CAT,
+				ic_buf, length,
+				return_buf + 1, dad->test.cur_status_size,
+				max(CY_COMMAND_COMPLETE_TIMEOUT,
+					CY_CALIBRATE_COMPLETE_TIMEOUT));
+		if (rc < 0)
+			dev_err(dev, "%s: Fail to execute cmd r=%d\n",
+					__func__, rc);
+	}
+	return 0;
+}
+
+/*
+ * SysFs store function of Test Regs group.
+ */
+static int cyttsp4_grpdata_store_tthe_test_regs(struct device *dev, u8 *ic_buf,
+		size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc;
+
+	/* Caller function guaranties, length is not bigger than ic_buf size */
+	if (length < CY_CMD_INDEX + 1) {
+		dev_err(dev, "%s: %s length=%d\n", __func__,
+				"Buffer length is not valid", length);
+		return -EINVAL;
+	}
+
+	dad->test.cur_cmd = ic_buf[CY_CMD_INDEX];
+	if (dad->test.cur_cmd == CY_CMD_CAT_NULL) {
+		if (length < CY_NULL_CMD_INDEX + 1) {
+			dev_err(dev, "%s: %s length=%d\n", __func__,
+					"Buffer length is not valid", length);
+			return -EINVAL;
+		}
+		dev_vdbg(dev, "%s: test-cur_cmd=%d null-cmd=%d\n", __func__,
+				dad->test.cur_cmd, ic_buf[CY_NULL_CMD_INDEX]);
+		switch (ic_buf[CY_NULL_CMD_INDEX]) {
+		case CY_NULL_CMD_NULL:
+			dev_err(dev, "%s: empty NULL cmd\n", __func__);
+			break;
+		case CY_NULL_CMD_MODE:
+			if (length < CY_NULL_CMD_MODE_INDEX + 1) {
+				dev_err(dev, "%s: %s length=%d\n", __func__,
+						"Buffer length is not valid",
+						length);
+				return -EINVAL;
+			}
+			dev_vdbg(dev, "%s: Set cmd mode=%02X\n", __func__,
+					ic_buf[CY_NULL_CMD_MODE_INDEX]);
+			cyttsp4_test_tthe_cmd_mode(dad, ic_buf, length);
+			break;
+		case CY_NULL_CMD_STATUS_SIZE:
+			if (length < CY_NULL_CMD_SIZE_INDEX + 1) {
+				dev_err(dev, "%s: %s length=%d\n", __func__,
+						"Buffer length is not valid",
+						length);
+				return -EINVAL;
+			}
+			dad->test.cur_status_size =
+				ic_buf[CY_NULL_CMD_SIZEL_INDEX]
+				+ (ic_buf[CY_NULL_CMD_SIZEH_INDEX] << 8);
+			dev_vdbg(dev, "%s: test-cur_status_size=%d\n",
+					__func__, dad->test.cur_status_size);
+			break;
+		case CY_NULL_CMD_HANDSHAKE:
+			dev_vdbg(dev, "%s: try null cmd handshake\n",
+					__func__);
+			rc = _cyttsp4_cmd_handshake(dad);
+			if (rc < 0)
+				dev_err(dev, "%s: %s r=%d\n", __func__,
+						"Fail test cmd handshake", rc);
+		case CY_NULL_CMD_LOW_POWER:
+			dev_vdbg(dev, "%s: try null cmd low power\n", __func__);
+			rc = _cyttsp4_cmd_toggle_lowpower(dad);
+			if (rc < 0)
+				dev_err(dev, "%s: %s r=%d\n", __func__,
+					"Fail test cmd toggle low power", rc);
+		default:
+			break;
+		}
+	} else {
+		dev_dbg(dev, "%s: TEST CMD=0x%02X length=%d %s%d\n",
+				__func__, ic_buf[0], length, "cmd_ofs+grpofs=",
+				dad->ic_grpoffset + dad->si->si_ofs.cmd_ofs);
+		cyttsp4_pr_buf(dev, dad->pr_buf, ic_buf, length, "test_cmd");
+		/* Support Operating mode command. */
+		/* Write command parameters first */
+		if (length > 1) {
+			rc = cyttsp4_write(dad->ttsp,
+				(dad->test.cur_mode == CY_TEST_MODE_CAT)
+					?  CY_MODE_CAT : CY_MODE_OPERATIONAL,
+				dad->ic_grpoffset + dad->si->si_ofs.cmd_ofs
+					+ 1, ic_buf + 1, length - 1);
+			if (rc < 0) {
+				dev_err(dev, "%s: Fail write cmd param regs r=%d\n",
+					__func__, rc);
+				return 0;
+			}
+		}
+		/* Write command */
+		rc = cyttsp4_write(dad->ttsp,
+				(dad->test.cur_mode == CY_TEST_MODE_CAT)
+					?  CY_MODE_CAT : CY_MODE_OPERATIONAL,
+				dad->ic_grpoffset + dad->si->si_ofs.cmd_ofs,
+				ic_buf, 1);
+		if (rc < 0)
+			dev_err(dev, "%s: Fail write cmd reg r=%d\n",
+					__func__, rc);
+	}
+	return 0;
+}
+
+/*
+ * SysFs grpdata store function implementation of group 6.
+ * Stores the contents of the touch parameters.
+ */
+static int cyttsp4_grpdata_store_touch_params(struct device *dev,
+		u8 *ic_buf, size_t length)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc, rc2 = 0, rc3;
+
+	pm_runtime_get_sync(dev);
+
+	rc = cyttsp4_request_exclusive(dad->ttsp,
+			CY_DA_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_store_touch_params_err_put;
+	}
+
+	rc = cyttsp4_request_set_mode(dad->ttsp, CY_MODE_CAT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_store_touch_params_err_release;
+	}
+
+	rc = cyttsp4_request_write_config(dad->ttsp, CY_TCH_PARM_EBID,
+			dad->ic_grpoffset, ic_buf, length);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request write config r=%d\n",
+				__func__, rc);
+		goto cyttsp4_grpdata_store_touch_params_err_change_mode;
+	}
+
+cyttsp4_grpdata_store_touch_params_err_change_mode:
+	rc2 = cyttsp4_request_set_mode(dad->ttsp, CY_MODE_OPERATIONAL);
+	if (rc2 < 0)
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc2);
+
+cyttsp4_grpdata_store_touch_params_err_release:
+	rc3 = cyttsp4_release_exclusive(dad->ttsp);
+	if (rc3 < 0)
+		dev_err(dev, "%s: Error on release exclusive r=%d\n",
+				__func__, rc3);
+
+cyttsp4_grpdata_store_touch_params_err_put:
+	pm_runtime_put(dev);
+
+	if (rc == 0)
+		cyttsp4_request_restart(dad->ttsp, true);
+	else
+		return rc;
+	if (rc2 < 0)
+		return rc2;
+	if (rc3 < 0)
+		return rc3;
+
+	return rc;
+}
+
+/*
+ * Gets user input from sysfs and parse it
+ * return size of parsed output buffer
+ */
+static int cyttsp4_ic_parse_input(struct device *dev, const char *buf,
+		size_t buf_size, u8 *ic_buf, size_t ic_buf_size)
+{
+	const char *pbuf = buf;
+	unsigned long value;
+	char scan_buf[CYTTSP4_INPUT_ELEM_SZ];
+	int i = 0;
+	int j;
+	int last = 0;
+	int ret;
+
+	dev_dbg(dev, "%s: pbuf=%p buf=%p size=%d %s=%d buf=%s\n", __func__,
+			pbuf, buf, (int) buf_size, "scan buf size",
+			CYTTSP4_INPUT_ELEM_SZ, buf);
+
+	while (pbuf <= (buf + buf_size)) {
+		if (i >= CY_MAX_CONFIG_BYTES) {
+			dev_err(dev, "%s: %s size=%d max=%d\n", __func__,
+					"Max cmd size exceeded", i,
+					CY_MAX_CONFIG_BYTES);
+			return -EINVAL;
+		}
+		if (i >= ic_buf_size) {
+			dev_err(dev, "%s: %s size=%d buf_size=%d\n", __func__,
+					"Buffer size exceeded", i, ic_buf_size);
+			return -EINVAL;
+		}
+		while (((*pbuf == ' ') || (*pbuf == ','))
+				&& (pbuf < (buf + buf_size))) {
+			last = *pbuf;
+			pbuf++;
+		}
+
+		if (pbuf >= (buf + buf_size))
+			break;
+
+		memset(scan_buf, 0, CYTTSP4_INPUT_ELEM_SZ);
+		if ((last == ',') && (*pbuf == ',')) {
+			dev_err(dev, "%s: %s \",,\" not allowed.\n", __func__,
+					"Invalid data format.");
+			return -EINVAL;
+		}
+		for (j = 0; j < (CYTTSP4_INPUT_ELEM_SZ - 1)
+				&& (pbuf < (buf + buf_size))
+				&& (*pbuf != ' ')
+				&& (*pbuf != ','); j++) {
+			last = *pbuf;
+			scan_buf[j] = *pbuf++;
+		}
+
+		ret = kstrtoul(scan_buf, 16, &value);
+		if (ret < 0) {
+			dev_err(dev, "%s: %s '%s' %s%s i=%d r=%d\n", __func__,
+					"Invalid data format. ", scan_buf,
+					"Use \"0xHH,...,0xHH\"", " instead.",
+					i, ret);
+			return ret;
+		}
+
+		ic_buf[i] = value;
+		i++;
+	}
+
+	return i;
+}
+
+/*
+ * SysFs store functions of each group member.
+ */
+static cyttsp4_store_function
+		cyttsp4_grpdata_store_functions[CY_IC_GRPNUM_NUM] = {
+	[CY_IC_GRPNUM_RESERVED] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_CMD_REGS] = cyttsp4_grpdata_store_operational_regs,
+	[CY_IC_GRPNUM_TCH_REP] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_DATA_REC] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_TEST_REC] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_PCFG_REC] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_TCH_PARM_VAL] = cyttsp4_grpdata_store_touch_params,
+	[CY_IC_GRPNUM_TCH_PARM_SIZE] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_RESERVED1] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_RESERVED2] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_OPCFG_REC] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_DDATA_REC] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_MDATA_REC] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_TEST_REGS] = cyttsp4_grpdata_store_test_regs,
+	[CY_IC_GRPNUM_BTN_KEYS] = cyttsp4_grpdata_store_void,
+	[CY_IC_GRPNUM_TTHE_REGS] = cyttsp4_grpdata_store_tthe_test_regs,
+};
+
+static ssize_t cyttsp4_ic_grpdata_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	ssize_t length;
+	int rc;
+
+	mutex_lock(&dad->sysfs_lock);
+	length = cyttsp4_ic_parse_input(dev, buf, size, dad->ic_buf,
+			CY_MAX_PRBUF_SIZE);
+	if (length <= 0) {
+		dev_err(dev, "%s: %s Group Data store\n", __func__,
+				"Malformed input for");
+		goto cyttsp4_ic_grpdata_store_exit;
+	}
+
+	dev_vdbg(dev, "%s: grpnum=%d grpoffset=%u\n",
+			__func__, dad->ic_grpnum, dad->ic_grpoffset);
+
+	if (dad->ic_grpnum >= CY_IC_GRPNUM_NUM) {
+		dev_err(dev, "%s: Group %d does not exist.\n",
+				__func__, dad->ic_grpnum);
+		goto cyttsp4_ic_grpdata_store_exit;
+	}
+
+	/* write ic_buf to log */
+	cyttsp4_pr_buf(dev, dad->pr_buf, dad->ic_buf, length, "ic_buf");
+
+	/* Call relevant store handler. */
+	rc = cyttsp4_grpdata_store_functions[dad->ic_grpnum] (dev, dad->ic_buf,
+			length);
+	if (rc < 0)
+		dev_err(dev, "%s: Failed to store for grpmun=%d.\n",
+				__func__, dad->ic_grpnum);
+
+cyttsp4_ic_grpdata_store_exit:
+	mutex_unlock(&dad->sysfs_lock);
+	dev_vdbg(dev, "%s: return size=%d\n", __func__, size);
+	return size;
+}
+
+static DEVICE_ATTR(ic_grpdata, S_IRUSR | S_IWUSR,
+	cyttsp4_ic_grpdata_show, cyttsp4_ic_grpdata_store);
+
+/*
+ * Execute scan command
+ */
+static int _cyttsp4_exec_scan_cmd(struct device *dev)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	u8 cmd_buf[CY_CMD_CAT_EXECUTE_PANEL_SCAN_CMD_SZ];
+	u8 return_buf[CY_CMD_CAT_EXECUTE_PANEL_SCAN_RET_SZ];
+
+	cmd_buf[0] = CY_CMD_CAT_EXEC_PANEL_SCAN;
+
+	return cyttsp4_request_exec_cmd(dad->ttsp, CY_MODE_CAT,
+			cmd_buf, CY_CMD_CAT_EXECUTE_PANEL_SCAN_CMD_SZ,
+			return_buf, CY_CMD_CAT_EXECUTE_PANEL_SCAN_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+}
+
+/*
+ * Retrieve panel data command
+ */
+static int _cyttsp4_ret_scan_data_cmd(struct device *dev, int read_offset,
+		int num_element, u8 data_type, u8 *return_buf)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	u8 cmd_buf[CY_CMD_CAT_RETRIEVE_PANEL_SCAN_CMD_SZ];
+
+	cmd_buf[0] = CY_CMD_CAT_RETRIEVE_PANEL_SCAN;
+	cmd_buf[1] = HI_BYTE(read_offset);
+	cmd_buf[2] = LO_BYTE(read_offset);
+	cmd_buf[3] = HI_BYTE(num_element);
+	cmd_buf[4] = LO_BYTE(num_element);
+	cmd_buf[5] = data_type;
+
+	return cyttsp4_request_exec_cmd(dad->ttsp, CY_MODE_CAT,
+			cmd_buf, CY_CMD_CAT_RETRIEVE_PANEL_SCAN_CMD_SZ,
+			return_buf, CY_CMD_CAT_RETRIEVE_PANEL_SCAN_RET_SZ,
+			CY_COMMAND_COMPLETE_TIMEOUT);
+}
+
+/*
+ * SysFs grpdata show function implementation of group 6.
+ * Prints contents of the touch parameters a row at a time.
+ */
+static ssize_t cyttsp4_get_panel_data_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	u8 return_buf[CY_CMD_CAT_RETRIEVE_PANEL_SCAN_RET_SZ];
+
+	int rc = 0;
+	int rc1 = 0;
+	int data_idx = 0;
+	int i = 0;
+	int print_idx = -1;
+	u8 cmd_param_ofs = dad->si->si_ofs.cmd_ofs + 1;
+	int read_byte = CY_CMD_CAT_RETRIEVE_PANEL_SCAN_RET_SZ + cmd_param_ofs;
+	int left_over_element = dad->heatmap.num_element;
+	int read_element_offset = CY_CMD_IN_DATA_OFFSET_VALUE;
+	int returned_element;
+	u8 element_start_offset = cmd_param_ofs
+		+ CY_CMD_CAT_RETRIEVE_PANEL_SCAN_RET_SZ;
+
+
+	rc = cyttsp4_request_exclusive(dad->ttsp,
+			CY_DA_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto cyttsp4_get_panel_data_show_err_release;
+	}
+
+	if (dad->heatmap.scan_start)	{
+		/* Start scan */
+		rc = _cyttsp4_exec_scan_cmd(dev);
+		if (rc < 0) {
+			dev_err(dev, "%s: Error on _cyttsp4_exec_scan_cmd()\n",
+				__func__);
+			goto cyttsp4_get_panel_data_show_err_release;
+		}
+	}
+
+	/* retrieve scan data */
+	rc = _cyttsp4_ret_scan_data_cmd(dev, read_element_offset,
+			left_over_element, dad->heatmap.data_type, return_buf);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on _cyttsp4_ret_scan_data_cmd(), offset=%d num_element:%d\n",
+			__func__, read_element_offset, left_over_element);
+		goto cyttsp4_get_panel_data_show_err_release;
+	}
+	if (return_buf[CY_CMD_OUT_STATUS_OFFSET] != CY_CMD_STATUS_SUCCESS) {
+		dev_err(dev, "%s: Fail on _cyttsp4_ret_scan_data_cmd(), offset=%d num_element:%d\n",
+			__func__, read_element_offset, left_over_element);
+		goto cyttsp4_get_panel_data_show_err_release;
+	}
+
+	returned_element = return_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_H] * 256
+		+ return_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_L];
+
+	dev_dbg(dev, "%s: _cyttsp4_ret_scan_data_cmd(): num_element:%d\n",
+		__func__, returned_element);
+
+	/* read data */
+	read_byte += returned_element *
+			(return_buf[CY_CMD_RET_PNL_OUT_DATA_FORMAT_OFFS] &
+				CY_CMD_RET_PANEL_ELMNT_SZ_MASK);
+
+	rc = cyttsp4_read(dad->ttsp, CY_MODE_CAT, 0, dad->ic_buf, read_byte);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on read r=%d\n", __func__, rc);
+		goto cyttsp4_get_panel_data_show_err_release;
+	}
+
+	left_over_element = dad->heatmap.num_element - returned_element;
+	read_element_offset = returned_element;
+	data_idx = read_byte;
+
+	while (left_over_element > 0) {
+		/* get the data */
+		rc = _cyttsp4_ret_scan_data_cmd(dev, read_element_offset,
+				left_over_element, dad->heatmap.data_type,
+				return_buf);
+		if (rc < 0) {
+			dev_err(dev, "%s: Error %d  on _cyttsp4_ret_scan_data_cmd(), offset=%d num_element:%d\n",
+				__func__, rc, read_element_offset,
+				left_over_element);
+			goto cyttsp4_get_panel_data_show_err_release;
+		}
+		if (return_buf[CY_CMD_OUT_STATUS_OFFSET]
+				!= CY_CMD_STATUS_SUCCESS) {
+			dev_err(dev, "%s: Fail on _cyttsp4_ret_scan_data_cmd(), offset=%d num_element:%d\n",
+				__func__, read_element_offset,
+				left_over_element);
+			goto cyttsp4_get_panel_data_show_err_release;
+		}
+
+		returned_element =
+			return_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_H] * 256
+			+ return_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_L];
+
+		dev_dbg(dev, "%s: _cyttsp4_ret_scan_data_cmd(): num_element:%d\n",
+			__func__, returned_element);
+
+		/* Check if we requested more elements than the device has */
+		if (returned_element == 0) {
+			dev_dbg(dev, "%s: returned_element=0, left_over_element=%d\n",
+				__func__, left_over_element);
+			break;
+		}
+
+		/* DO read */
+		read_byte = returned_element *
+			(return_buf[CY_CMD_RET_PNL_OUT_DATA_FORMAT_OFFS]
+				& CY_CMD_RET_PANEL_ELMNT_SZ_MASK);
+
+		rc = cyttsp4_read(dad->ttsp, CY_MODE_CAT,
+				element_start_offset,
+				dad->ic_buf + data_idx,
+				read_byte);
+		if (rc < 0) {
+			dev_err(dev, "%s: Error on read r=%d\n", __func__, rc);
+			goto cyttsp4_get_panel_data_show_err_release;
+		}
+
+		/* Update element status */
+		left_over_element -= returned_element;
+		read_element_offset += returned_element;
+		data_idx += read_byte;
+
+	}
+	/* update on the buffer */
+	dad->ic_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_H + cmd_param_ofs] =
+		HI_BYTE(read_element_offset);
+	dad->ic_buf[CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_L + cmd_param_ofs] =
+		LO_BYTE(read_element_offset);
+
+cyttsp4_get_panel_data_show_err_release:
+	rc1 = cyttsp4_release_exclusive(dad->ttsp);
+	if (rc1 < 0) {
+		dev_err(dev, "%s: Error on release exclusive r=%d\n",
+				__func__, rc1);
+		goto cyttsp4_get_panel_data_show_err_sysfs;
+	}
+
+	if (rc < 0)
+		goto cyttsp4_get_panel_data_show_err_sysfs;
+
+	print_idx = 0;
+	print_idx += scnprintf(buf, CY_MAX_PRBUF_SIZE, "CY_DATA:");
+	for (i = 0; i < data_idx; i++) {
+		print_idx += scnprintf(buf + print_idx,
+				CY_MAX_PRBUF_SIZE - print_idx,
+				"%02X ", dad->ic_buf[i]);
+	}
+	print_idx += scnprintf(buf + print_idx, CY_MAX_PRBUF_SIZE - print_idx,
+			":(%d bytes)\n", data_idx);
+
+cyttsp4_get_panel_data_show_err_sysfs:
+	return print_idx;
+}
+
+/*
+ * SysFs grpdata show function implementation of group 6.
+ * Prints contents of the touch parameters a row at a time.
+ */
+static int cyttsp4_get_panel_data_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	ssize_t length;
+
+	mutex_lock(&dad->sysfs_lock);
+
+	length = cyttsp4_ic_parse_input(dev, buf, size, dad->ic_buf,
+			CY_MAX_PRBUF_SIZE);
+	if (length <= 0) {
+		dev_err(dev, "%s: %s Group Data store\n", __func__,
+				"Malformed input for");
+		goto cyttsp4_get_panel_data_store_exit;
+	}
+
+	dev_vdbg(dev, "%s: grpnum=%d grpoffset=%u\n",
+			__func__, dad->ic_grpnum, dad->ic_grpoffset);
+
+	if (dad->ic_grpnum >= CY_IC_GRPNUM_NUM) {
+		dev_err(dev, "%s: Group %d does not exist.\n",
+				__func__, dad->ic_grpnum);
+		goto cyttsp4_get_panel_data_store_exit;
+	}
+
+	pm_runtime_get_sync(dev);
+	/*update parameter value */
+	dad->heatmap.num_element = dad->ic_buf[4] + (dad->ic_buf[3] * 256);
+	dad->heatmap.data_type = dad->ic_buf[5];
+
+	if (dad->ic_buf[6] > 0)
+		dad->heatmap.scan_start = true;
+	else
+		dad->heatmap.scan_start = false;
+	pm_runtime_put(dev);
+
+cyttsp4_get_panel_data_store_exit:
+	mutex_unlock(&dad->sysfs_lock);
+	dev_vdbg(dev, "%s: return size=%d\n", __func__, size);
+	return size;
+}
+
+static DEVICE_ATTR(get_panel_data, S_IRUSR | S_IWUSR,
+	cyttsp4_get_panel_data_show, cyttsp4_get_panel_data_store);
+
+#ifdef CONFIG_PM_SLEEP
+static int cyttsp4_device_access_suspend(struct device *dev)
+{
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	if (!mutex_trylock(&dad->sysfs_lock))
+		return -EBUSY;
+
+	mutex_unlock(&dad->sysfs_lock);
+	return 0;
+}
+
+static int cyttsp4_device_access_resume(struct device *dev)
+{
+	dev_dbg(dev, "%s\n", __func__);
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops cyttsp4_device_access_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(cyttsp4_device_access_suspend,
+			cyttsp4_device_access_resume)
+};
+
+static int cyttsp4_setup_sysfs(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc = 0;
+
+	rc = device_create_file(dev, &dev_attr_ic_grpnum);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create ic_grpnum\n",
+				__func__);
+		goto exit;
+	}
+
+	rc = device_create_file(dev, &dev_attr_ic_grpoffset);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create ic_grpoffset\n",
+				__func__);
+		goto unregister_grpnum;
+	}
+
+	rc = device_create_file(dev, &dev_attr_ic_grpdata);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create ic_grpdata\n",
+				__func__);
+		goto unregister_grpoffset;
+	}
+
+	rc = device_create_file(dev, &dev_attr_get_panel_data);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create get_panel_data\n",
+				__func__);
+		goto unregister_grpdata;
+	}
+
+	dad->sysfs_nodes_created = true;
+	return rc;
+
+unregister_grpdata:
+	device_remove_file(dev, &dev_attr_get_panel_data);
+unregister_grpoffset:
+	device_remove_file(dev, &dev_attr_ic_grpoffset);
+unregister_grpnum:
+	device_remove_file(dev, &dev_attr_ic_grpnum);
+exit:
+	return rc;
+}
+
+static int cyttsp4_setup_sysfs_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	int rc = 0;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	dad->si = cyttsp4_request_sysinfo(ttsp);
+	if (!dad->si)
+		return -EPERM;
+
+	rc = cyttsp4_setup_sysfs(ttsp);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_setup_sysfs_attention, 0);
+
+	return rc;
+
+}
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS_API
+static struct cyttsp4_device *device_access_devices[CY_MAX_NUM_CORE_DEVS];
+static DEFINE_MUTEX(device_access_devices_lock);
+
+static void insert_da_device(struct cyttsp4_device *ttsp)
+{
+	int i;
+
+	mutex_lock(&device_access_devices_lock);
+	for (i = 0; i < ARRAY_SIZE(device_access_devices); i++)
+		if (!device_access_devices[i]) {
+			device_access_devices[i] = ttsp;
+			goto exit;
+		}
+exit:
+	mutex_unlock(&device_access_devices_lock);
+}
+
+static void remove_da_device(struct cyttsp4_device *ttsp)
+{
+	int i;
+
+	mutex_lock(&device_access_devices_lock);
+	for (i = 0; i < ARRAY_SIZE(device_access_devices); i++)
+		if (device_access_devices[i] == ttsp) {
+			device_access_devices[i] = NULL;
+			goto exit;
+		}
+exit:
+	mutex_unlock(&device_access_devices_lock);
+}
+
+static struct cyttsp4_device *_find_da_device(const char *core_name)
+{
+	char ttsp_name[64];
+	int i;
+
+	scnprintf(ttsp_name, 64, "%s.%s", CYTTSP4_DEVICE_ACCESS_NAME,
+			core_name);
+
+	for (i = 0; i < ARRAY_SIZE(device_access_devices); i++) {
+		struct cyttsp4_device *ttsp = device_access_devices[i];
+		if (!ttsp || strncmp(dev_name(&ttsp->dev), ttsp_name, 64))
+			continue;
+
+		return ttsp;
+	}
+
+	return NULL;
+}
+
+int cyttsp4_device_access_read_command(const char *core_name, int ic_grpnum,
+		int ic_grpoffset, u8 *buf, int buf_size)
+{
+	struct cyttsp4_device_access_data *dad;
+	struct cyttsp4_device *ttsp;
+	struct device *dev;
+	int prev_grpnum;
+	int rc;
+
+	might_sleep();
+
+	/* Validate ic_grpnum */
+	if (ic_grpnum >= CY_IC_GRPNUM_NUM) {
+		pr_err("%s: Group %d does not exist.\n", __func__, ic_grpnum);
+		return -EINVAL;
+	}
+
+	/* Validate ic_grpoffset */
+	if (ic_grpoffset > 0xFFFF) {
+		pr_err("%s: Offset %d invalid.\n", __func__, ic_grpoffset);
+		return -EINVAL;
+	}
+
+	if (!core_name)
+		core_name = CY_DEFAULT_CORE_ID;
+
+	mutex_lock(&device_access_devices_lock);
+	/* Find device */
+	ttsp = _find_da_device(core_name);
+	if (!ttsp) {
+		pr_err("%s: No device.\n", __func__);
+		rc = -ENODEV;
+		goto exit_unlock_da;
+	}
+
+	dev = &ttsp->dev;
+	dad = dev_get_drvdata(dev);
+
+	/* Check sysinfo */
+	if (!dad->si) {
+		pr_err("%s: No sysinfo.\n", __func__);
+		rc = -ENODEV;
+		goto exit_unlock_da;
+	}
+
+	mutex_lock(&dad->sysfs_lock);
+	/*
+	 * Block grpnum change when own_exclusive flag is set
+	 * which means the current grpnum implementation requires
+	 * running exclusively on some consecutive grpdata operations
+	 */
+	if (dad->own_exclusive && dad->ic_grpnum != ic_grpnum) {
+		dev_err(dev, "%s: own_exclusive\n", __func__);
+		rc = -EBUSY;
+		goto exit;
+	}
+
+	prev_grpnum = dad->ic_grpnum;
+	dad->ic_grpnum = ic_grpnum;
+	dad->ic_grpoffset = ic_grpoffset;
+
+	rc = cyttsp4_grpdata_show_functions[dad->ic_grpnum] (dev,
+			buf, buf_size);
+
+exit:
+	mutex_unlock(&dad->sysfs_lock);
+exit_unlock_da:
+	mutex_unlock(&device_access_devices_lock);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_device_access_read_command);
+
+int cyttsp4_device_access_write_command(const char *core_name, int ic_grpnum,
+		int ic_grpoffset, u8 *buf, int length)
+{
+	struct cyttsp4_device_access_data *dad;
+	struct cyttsp4_device *ttsp;
+	struct device *dev;
+	int prev_grpnum;
+	int rc;
+
+	might_sleep();
+
+	/* Validate ic_grpnum */
+	if (ic_grpnum >= CY_IC_GRPNUM_NUM) {
+		pr_err("%s: Group %d does not exist.\n", __func__, ic_grpnum);
+		return -EINVAL;
+	}
+
+	/* Validate ic_grpoffset */
+	if (ic_grpoffset > 0xFFFF) {
+		pr_err("%s: Offset %d invalid.\n", __func__, ic_grpoffset);
+		return -EINVAL;
+	}
+
+	if (!core_name)
+		core_name = CY_DEFAULT_CORE_ID;
+
+	mutex_lock(&device_access_devices_lock);
+	/* Find device */
+	ttsp = _find_da_device(core_name);
+	if (!ttsp) {
+		pr_err("%s: No device.\n", __func__);
+		rc = -ENODEV;
+		goto exit_unlock_da;
+	}
+
+	dev = &ttsp->dev;
+	dad = dev_get_drvdata(dev);
+
+	/* Check sysinfo */
+	if (!dad->si) {
+		pr_err("%s: No sysinfo.\n", __func__);
+		rc = -ENODEV;
+		goto exit_unlock_da;
+	}
+
+	mutex_lock(&dad->sysfs_lock);
+	/*
+	 * Block grpnum change when own_exclusive flag is set
+	 * which means the current grpnum implementation requires
+	 * running exclusively on some consecutive grpdata operations
+	 */
+	if (dad->own_exclusive && dad->ic_grpnum != ic_grpnum) {
+		dev_err(dev, "%s: own_exclusive\n", __func__);
+		rc = -EBUSY;
+		goto exit;
+	}
+
+	prev_grpnum = dad->ic_grpnum;
+	dad->ic_grpnum = ic_grpnum;
+	dad->ic_grpoffset = ic_grpoffset;
+
+	/* write ic_buf to log */
+	cyttsp4_pr_buf(dev, dad->pr_buf, buf, length, "ic_buf");
+
+	/* Call relevant store handler. */
+	rc = cyttsp4_grpdata_store_functions[dad->ic_grpnum] (dev, buf,
+			length);
+	if (rc < 0)
+		dev_err(dev, "%s: Failed to store for grpmun=%d.\n",
+				__func__, dad->ic_grpnum);
+
+exit:
+	mutex_unlock(&dad->sysfs_lock);
+exit_unlock_da:
+	mutex_unlock(&device_access_devices_lock);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_device_access_write_command);
+#endif
+
+static int cyttsp4_device_access_probe(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_device_access_data *dad;
+	struct cyttsp4_device_access_platform_data *pdata =
+			dev_get_platdata(dev);
+	int rc = 0;
+
+	dev_info(dev, "%s\n", __func__);
+	dev_dbg(dev, "%s: debug on\n", __func__);
+	dev_vdbg(dev, "%s: verbose debug on\n", __func__);
+
+	dad = kzalloc(sizeof(*dad), GFP_KERNEL);
+	if (dad == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto cyttsp4_device_access_probe_data_failed;
+	}
+
+	mutex_init(&dad->sysfs_lock);
+	init_waitqueue_head(&dad->wait_q);
+	dad->ttsp = ttsp;
+	dad->pdata = pdata;
+	dad->ic_grpnum = CY_IC_GRPNUM_TCH_REP;
+	dad->test.cur_cmd = -1;
+	dad->heatmap.num_element = 200;
+	dev_set_drvdata(dev, dad);
+
+	pm_runtime_enable(dev);
+
+	/* get sysinfo */
+	dad->si = cyttsp4_request_sysinfo(ttsp);
+	if (dad->si) {
+		rc = cyttsp4_setup_sysfs(ttsp);
+		if (rc)
+			goto cyttsp4_device_access_setup_sysfs_failed;
+	} else {
+		dev_err(dev, "%s: Fail get sysinfo pointer from core p=%p\n",
+				__func__, dad->si);
+		cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_sysfs_attention, 0);
+	}
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS_API
+	insert_da_device(ttsp);
+#endif
+	dev_dbg(dev, "%s: ok\n", __func__);
+	return 0;
+
+ cyttsp4_device_access_setup_sysfs_failed:
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+	dev_set_drvdata(dev, NULL);
+	kfree(dad);
+ cyttsp4_device_access_probe_data_failed:
+	dev_err(dev, "%s failed.\n", __func__);
+	return rc;
+}
+
+static int cyttsp4_device_access_release(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_device_access_data *dad = dev_get_drvdata(dev);
+	u8 ic_buf[CY_NULL_CMD_MODE_INDEX + 1];
+	dev_dbg(dev, "%s\n", __func__);
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICE_ACCESS_API
+	remove_da_device(ttsp);
+#endif
+
+	if (dad->own_exclusive) {
+		dev_err(dev, "%s: Can't unload in CAT mode. First switch back to Operational mode\n"
+				, __func__);
+		ic_buf[CY_NULL_CMD_MODE_INDEX] = CY_HST_OPERATE;
+		cyttsp4_test_cmd_mode(dad, ic_buf, CY_NULL_CMD_MODE_INDEX + 1);
+	}
+
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+
+	if (dad->sysfs_nodes_created) {
+		device_remove_file(dev, &dev_attr_ic_grpnum);
+		device_remove_file(dev, &dev_attr_ic_grpoffset);
+		device_remove_file(dev, &dev_attr_ic_grpdata);
+		device_remove_file(dev, &dev_attr_get_panel_data);
+	} else {
+		cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_sysfs_attention, 0);
+	}
+
+	dev_set_drvdata(dev, NULL);
+	kfree(dad);
+	return 0;
+}
+
+static struct cyttsp4_driver cyttsp4_device_access_driver = {
+	.probe = cyttsp4_device_access_probe,
+	.remove = cyttsp4_device_access_release,
+	.driver = {
+		.name = CYTTSP4_DEVICE_ACCESS_NAME,
+		.bus = &cyttsp4_bus_type,
+		.owner = THIS_MODULE,
+		.pm = &cyttsp4_device_access_pm_ops,
+	},
+};
+
+static struct cyttsp4_device_access_platform_data
+	_cyttsp4_device_access_platform_data = {
+	.device_access_dev_name = CYTTSP4_DEVICE_ACCESS_NAME,
+};
+
+static const char cyttsp4_device_access_name[] = CYTTSP4_DEVICE_ACCESS_NAME;
+static struct cyttsp4_device_info
+	cyttsp4_device_access_infos[CY_MAX_NUM_CORE_DEVS];
+
+static char *core_ids[CY_MAX_NUM_CORE_DEVS] = {
+	CY_DEFAULT_CORE_ID,
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static int num_core_ids = 1;
+
+module_param_array(core_ids, charp, &num_core_ids, 0);
+MODULE_PARM_DESC(core_ids,
+	"Core id list of cyttsp4 core devices for device access module");
+
+static int __init cyttsp4_device_access_init(void)
+{
+	int rc = 0;
+	int i, j;
+
+	/* Check for invalid or duplicate core_ids */
+	for (i = 0; i < num_core_ids; i++) {
+		if (!strlen(core_ids[i])) {
+			pr_err("%s: core_id %d is empty\n",
+				__func__, i+1);
+			return -EINVAL;
+		}
+		for (j = i+1; j < num_core_ids; j++)
+			if (!strcmp(core_ids[i], core_ids[j])) {
+				pr_err("%s: core_ids %d and %d are same\n",
+					__func__, i+1, j+1);
+				return -EINVAL;
+			}
+	}
+
+	for (i = 0; i < num_core_ids; i++) {
+		cyttsp4_device_access_infos[i].name =
+			cyttsp4_device_access_name;
+		cyttsp4_device_access_infos[i].core_id = core_ids[i];
+		cyttsp4_device_access_infos[i].platform_data =
+			&_cyttsp4_device_access_platform_data;
+		pr_info("%s: Registering device access device for core_id: %s\n",
+			__func__, cyttsp4_device_access_infos[i].core_id);
+		rc = cyttsp4_register_device(&cyttsp4_device_access_infos[i]);
+		if (rc < 0) {
+			pr_err("%s: Error, failed registering device\n",
+				__func__);
+			goto fail_unregister_devices;
+		}
+	}
+	rc = cyttsp4_register_driver(&cyttsp4_device_access_driver);
+	if (rc) {
+		pr_err("%s: Error, failed registering driver\n", __func__);
+		goto fail_unregister_devices;
+	}
+
+	pr_info("%s: Cypress TTSP Device Access (Built %s) rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return 0;
+
+fail_unregister_devices:
+	for (i--; i >= 0; i--) {
+		cyttsp4_unregister_device(cyttsp4_device_access_infos[i].name,
+			cyttsp4_device_access_infos[i].core_id);
+		pr_info("%s: Unregistering device access device for core_id: %s\n",
+			__func__, cyttsp4_device_access_infos[i].core_id);
+	}
+	return rc;
+}
+module_init(cyttsp4_device_access_init);
+
+static void __exit cyttsp4_device_access_exit(void)
+{
+	int i;
+
+	cyttsp4_unregister_driver(&cyttsp4_device_access_driver);
+	for (i = 0; i < num_core_ids; i++) {
+		cyttsp4_unregister_device(cyttsp4_device_access_infos[i].name,
+			cyttsp4_device_access_infos[i].core_id);
+		pr_info("%s: Unregistering device access device for core_id: %s\n",
+			__func__, cyttsp4_device_access_infos[i].core_id);
+	}
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_device_access_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard Product Device Access Driver");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_device_access.h b/drivers/input/touchscreen/cypress/cyttsp4_device_access.h
new file mode 100644
index 0000000..9bd52b2
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_device_access.h
@@ -0,0 +1,67 @@
+/*
+ * cyttsp4_device_access.h
+ * Cypress TrueTouch(TM) Standard Product V4 Device Access module.
+ * Configuration and Test command/status user interface.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ * Copyright (C) 2014 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_DEVICE_ACCESS_H
+#define _LINUX_CYTTSP4_DEVICE_ACCESS_H
+
+#define CYTTSP4_DEVICE_ACCESS_NAME "cyttsp4_device_access"
+
+#define CYTTSP4_INPUT_ELEM_SZ (sizeof("0xHH") + 1)
+#define CYTTSP4_TCH_PARAM_SIZE_BLK_SZ 128
+
+/* Timeout values in ms. */
+#define CY_DA_REQUEST_EXCLUSIVE_TIMEOUT	500
+
+struct cyttsp4_device_access_platform_data {
+	char const *device_access_dev_name;
+};
+
+#define CY_CMD_IN_DATA_OFFSET_VALUE 0
+
+#define CY_CMD_OUT_STATUS_OFFSET 0
+#define CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_H 2
+#define CY_CMD_RET_PNL_OUT_ELMNT_SZ_OFFS_L 3
+#define CY_CMD_RET_PNL_OUT_DATA_FORMAT_OFFS 4
+
+#define CY_CMD_RET_PANEL_ELMNT_SZ_MASK 0x07
+
+enum cyttsp4_scan_data_type {
+	CY_MUT_RAW,
+	CY_MUT_BASE,
+	CY_MUT_DIFF,
+	CY_SELF_RAW,
+	CY_SELF_BASE,
+	CY_SELF_DIFF,
+	CY_BAL_RAW,
+	CY_BAL_BASE,
+	CY_BAL_DIFF,
+};
+
+#endif /* _LINUX_CYTTSP4_DEVICE_ACCESS_H */
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_devtree.c b/drivers/input/touchscreen/cypress/cyttsp4_devtree.c
new file mode 100644
index 0000000..77a7eda
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_devtree.c
@@ -0,0 +1,770 @@
+/*
+ * cyttsp4_devtree.c
+ * Cypress TrueTouch(TM) Standard Product V4 Device Tree Support Driver.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/of_device.h>
+#include <linux/slab.h>
+
+/* cyttsp */
+#include <linux/cyttsp4_bus.h>
+#include <linux/cyttsp4_core.h>
+#include <linux/cyttsp4_btn.h>
+#include <linux/cyttsp4_mt.h>
+#include <linux/cyttsp4_proximity.h>
+#include <linux/cyttsp4_platform.h>
+
+#include "cyttsp4_regs.h"
+#include "cyttsp4_devtree.h"
+
+#define ENABLE_VIRTUAL_KEYS
+
+#define MAX_NAME_LENGTH		64
+
+enum cyttsp4_device_type {
+	DEVICE_MT,
+	DEVICE_BTN,
+	DEVICE_PROXIMITY,
+	DEVICE_TYPE_MAX,
+};
+
+struct cyttsp4_device_pdata_func {
+	void *(*create_and_get_pdata)(struct device_node *);
+	void (*free_pdata)(void *);
+};
+
+#ifdef ENABLE_VIRTUAL_KEYS
+static struct kobject *board_properties_kobj;
+
+struct cyttsp4_virtual_keys {
+	struct kobj_attribute kobj_attr;
+	u16 *data;
+	int size;
+};
+#endif
+
+struct cyttsp4_extended_mt_platform_data {
+	struct cyttsp4_mt_platform_data pdata;
+#ifdef ENABLE_VIRTUAL_KEYS
+	struct cyttsp4_virtual_keys vkeys;
+#endif
+};
+
+static inline int get_inp_dev_name(struct device_node *dev_node,
+		const char **inp_dev_name)
+{
+	return of_property_read_string(dev_node, "cy,inp_dev_name",
+			inp_dev_name);
+}
+
+static u16 *create_and_get_u16_array(struct device_node *dev_node,
+		const char *name, int *size)
+{
+	const __be32 *values;
+	u16 *val_array;
+	int len;
+	int sz;
+	int rc;
+	int i;
+
+	values = of_get_property(dev_node, name, &len);
+	if (values == NULL)
+		return NULL;
+
+	sz = len / sizeof(u32);
+	pr_debug("%s: %s size:%d\n", __func__, name, sz);
+
+	val_array = kzalloc(sz * sizeof(u16), GFP_KERNEL);
+	if (val_array == NULL) {
+		rc = -ENOMEM;
+		goto fail;
+	}
+
+	for (i = 0; i < sz; i++)
+		val_array[i] = (u16)be32_to_cpup(values++);
+
+	*size = sz;
+
+	return val_array;
+
+fail:
+	return ERR_PTR(rc);
+}
+
+static struct touch_framework *create_and_get_touch_framework(
+		struct device_node *dev_node)
+{
+	struct touch_framework *frmwrk;
+	u16 *abs;
+	int size;
+	int rc;
+
+	abs = create_and_get_u16_array(dev_node, "cy,abs", &size);
+	if (IS_ERR_OR_NULL(abs))
+		return (void *)abs;
+
+	/* Check for valid abs size */
+	if (size % CY_NUM_ABS_SET) {
+		rc = -EINVAL;
+		goto fail_free_abs;
+	}
+
+	frmwrk = kzalloc(sizeof(*frmwrk), GFP_KERNEL);
+	if (frmwrk == NULL) {
+		rc = -ENOMEM;
+		goto fail_free_abs;
+	}
+
+	frmwrk->abs = abs;
+	frmwrk->size = size;
+
+	return frmwrk;
+
+fail_free_abs:
+	kfree(abs);
+
+	return ERR_PTR(rc);
+}
+
+static void free_touch_framework(struct touch_framework *frmwrk)
+{
+	kfree(frmwrk->abs);
+	kfree(frmwrk);
+}
+
+#ifdef ENABLE_VIRTUAL_KEYS
+#define VIRTUAL_KEY_ELEMENT_SIZE	5
+static ssize_t virtual_keys_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	struct cyttsp4_virtual_keys *vkeys = container_of(attr,
+		struct cyttsp4_virtual_keys, kobj_attr);
+	u16 *data = vkeys->data;
+	int size = vkeys->size;
+	int index;
+	int i;
+
+	index = 0;
+	for (i = 0; i < size; i += VIRTUAL_KEY_ELEMENT_SIZE)
+		index += scnprintf(buf + index, CY_MAX_PRBUF_SIZE - index,
+			"0x01:%d:%d:%d:%d:%d\n",
+			data[i], data[i+1], data[i+2], data[i+3], data[i+4]);
+
+	return index;
+}
+
+static int setup_virtual_keys(struct device_node *dev_node,
+		const char *inp_dev_name, struct cyttsp4_virtual_keys *vkeys)
+{
+	char *name;
+	u16 *data;
+	int size;
+	int rc;
+
+	data = create_and_get_u16_array(dev_node, "cy,virtual_keys", &size);
+	if (data == NULL)
+		return 0;
+	else if (IS_ERR(data)) {
+		rc = PTR_ERR(data);
+		goto fail;
+	}
+
+	/* Check for valid virtual keys size */
+	if (size % VIRTUAL_KEY_ELEMENT_SIZE) {
+		rc = -EINVAL;
+		goto fail_free_data;
+	}
+
+	name = kzalloc(MAX_NAME_LENGTH, GFP_KERNEL);
+	if (name == NULL) {
+		rc = -ENOMEM;
+		goto fail_free_data;
+	}
+
+	snprintf(name, MAX_NAME_LENGTH, "virtualkeys.%s", inp_dev_name);
+
+	vkeys->data = data;
+	vkeys->size = size;
+
+	/* TODO: Instantiate in board file and export it */
+	if (board_properties_kobj == NULL)
+		board_properties_kobj =
+			kobject_create_and_add("board_properties", NULL);
+	if (board_properties_kobj == NULL) {
+		pr_err("%s: Cannot get board_properties kobject!\n", __func__);
+		rc = -EINVAL;
+		goto fail_free_name;
+	}
+
+	/* Initialize dynamic SysFs attribute */
+	sysfs_attr_init(&vkeys->kobj_attr.attr);
+	vkeys->kobj_attr.attr.name = name;
+	vkeys->kobj_attr.attr.mode = S_IRUGO;
+	vkeys->kobj_attr.show = virtual_keys_show;
+
+	rc = sysfs_create_file(board_properties_kobj, &vkeys->kobj_attr.attr);
+	if (rc)
+		goto fail_del_kobj;
+
+	return 0;
+
+fail_del_kobj:
+	kobject_del(board_properties_kobj);
+fail_free_name:
+	kfree(name);
+	vkeys->kobj_attr.attr.name = NULL;
+fail_free_data:
+	kfree(data);
+	vkeys->data = NULL;
+fail:
+	return rc;
+}
+
+static void free_virtual_keys(struct cyttsp4_virtual_keys *vkeys)
+{
+	if (board_properties_kobj)
+		sysfs_remove_file(board_properties_kobj,
+			&vkeys->kobj_attr.attr);
+
+	kfree(vkeys->data);
+	kfree(vkeys->kobj_attr.attr.name);
+}
+#endif
+
+static void *create_and_get_mt_pdata(struct device_node *dev_node)
+{
+	struct cyttsp4_extended_mt_platform_data *ext_pdata;
+	struct cyttsp4_mt_platform_data *pdata;
+	u32 value;
+	int rc;
+
+	ext_pdata = kzalloc(sizeof(*ext_pdata), GFP_KERNEL);
+	if (ext_pdata == NULL) {
+		rc = -ENOMEM;
+		goto fail;
+	}
+
+	pdata = &ext_pdata->pdata;
+
+	rc = get_inp_dev_name(dev_node, &pdata->inp_dev_name);
+	if (rc)
+		goto fail_free_pdata;
+
+	/* Optional fields */
+	rc = of_property_read_u32(dev_node, "cy,flags", &value);
+	if (!rc)
+		pdata->flags = value;
+
+	rc = of_property_read_u32(dev_node, "cy,vkeys_x", &value);
+	if (!rc)
+		pdata->vkeys_x = value;
+
+	rc = of_property_read_u32(dev_node, "cy,vkeys_y", &value);
+	if (!rc)
+		pdata->vkeys_y = value;
+
+	/* Required fields */
+	pdata->frmwrk = create_and_get_touch_framework(dev_node);
+	if (pdata->frmwrk == NULL) {
+		rc = -EINVAL;
+		goto fail_free_pdata;
+	} else if (IS_ERR(pdata->frmwrk)) {
+		rc = PTR_ERR(pdata->frmwrk);
+		goto fail_free_pdata;
+	}
+#ifdef ENABLE_VIRTUAL_KEYS
+	rc = setup_virtual_keys(dev_node, pdata->inp_dev_name,
+			&ext_pdata->vkeys);
+	if (rc) {
+		pr_err("%s: Cannot setup virtual keys!\n", __func__);
+		goto fail_free_pdata;
+	}
+#endif
+	return pdata;
+
+fail_free_pdata:
+	kfree(ext_pdata);
+fail:
+	return ERR_PTR(rc);
+}
+
+static void free_mt_pdata(void *pdata)
+{
+	struct cyttsp4_mt_platform_data *mt_pdata =
+		(struct cyttsp4_mt_platform_data *)pdata;
+	struct cyttsp4_extended_mt_platform_data *ext_mt_pdata =
+		container_of(mt_pdata,
+			struct cyttsp4_extended_mt_platform_data, pdata);
+
+	free_touch_framework(mt_pdata->frmwrk);
+#ifdef ENABLE_VIRTUAL_KEYS
+	free_virtual_keys(&ext_mt_pdata->vkeys);
+#endif
+	kfree(ext_mt_pdata);
+}
+
+static void *create_and_get_btn_pdata(struct device_node *dev_node)
+{
+	struct cyttsp4_btn_platform_data *pdata;
+	int rc;
+
+	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+	if (pdata == NULL) {
+		rc = -ENOMEM;
+		goto fail;
+	}
+
+	rc = get_inp_dev_name(dev_node, &pdata->inp_dev_name);
+	if (rc)
+		goto fail_free_pdata;
+
+	return pdata;
+
+fail_free_pdata:
+	kfree(pdata);
+fail:
+	return ERR_PTR(rc);
+}
+
+static void free_btn_pdata(void *pdata)
+{
+	struct cyttsp4_btn_platform_data *btn_pdata =
+		(struct cyttsp4_btn_platform_data *)pdata;
+
+	kfree(btn_pdata);
+}
+
+static void *create_and_get_proximity_pdata(struct device_node *dev_node)
+{
+	struct cyttsp4_proximity_platform_data *pdata;
+	int rc;
+
+	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+	if (pdata == NULL) {
+		rc = -ENOMEM;
+		goto fail;
+	}
+
+	rc = get_inp_dev_name(dev_node, &pdata->inp_dev_name);
+	if (rc)
+		goto fail_free_pdata;
+
+	pdata->frmwrk = create_and_get_touch_framework(dev_node);
+	if (pdata->frmwrk == NULL) {
+		rc = -EINVAL;
+		goto fail_free_pdata;
+	} else if (IS_ERR(pdata->frmwrk)) {
+		rc = PTR_ERR(pdata->frmwrk);
+		goto fail_free_pdata;
+	}
+
+	return pdata;
+
+fail_free_pdata:
+	kfree(pdata);
+fail:
+	return ERR_PTR(rc);
+}
+
+static void free_proximity_pdata(void *pdata)
+{
+	struct cyttsp4_proximity_platform_data *proximity_pdata =
+		(struct cyttsp4_proximity_platform_data *)pdata;
+
+	free_touch_framework(proximity_pdata->frmwrk);
+
+	kfree(proximity_pdata);
+}
+
+static struct cyttsp4_device_pdata_func device_pdata_funcs[DEVICE_TYPE_MAX] = {
+	[DEVICE_MT] = {
+		.create_and_get_pdata = create_and_get_mt_pdata,
+		.free_pdata = free_mt_pdata,
+	},
+	[DEVICE_BTN] = {
+		.create_and_get_pdata = create_and_get_btn_pdata,
+		.free_pdata = free_btn_pdata,
+	},
+	[DEVICE_PROXIMITY] = {
+		.create_and_get_pdata = create_and_get_proximity_pdata,
+		.free_pdata = free_proximity_pdata,
+	},
+};
+
+static const char *device_names[DEVICE_TYPE_MAX] = {
+	[DEVICE_MT] = "cy,mt",
+	[DEVICE_BTN] = "cy,btn",
+	[DEVICE_PROXIMITY] = "cy,proximity",
+};
+
+static int get_device_type(struct device_node *dev_node,
+		enum cyttsp4_device_type *type)
+{
+	const char *name;
+	enum cyttsp4_device_type t;
+	int rc;
+
+	rc = of_property_read_string(dev_node, "name", &name);
+	if (rc)
+		return rc;
+
+	for (t = 0; t < DEVICE_TYPE_MAX; t++)
+		if (!strncmp(name, device_names[t], MAX_NAME_LENGTH)) {
+			*type = t;
+			return 0;
+		}
+
+	return -EINVAL;
+}
+
+static inline void *create_and_get_device_pdata(struct device_node *dev_node,
+		enum cyttsp4_device_type type)
+{
+	return device_pdata_funcs[type].create_and_get_pdata(dev_node);
+}
+
+static inline void free_device_pdata(void *pdata,
+		enum cyttsp4_device_type type)
+{
+	device_pdata_funcs[type].free_pdata(pdata);
+}
+
+static int register_device(struct device_node *dev_node,
+		const char *core_id)
+{
+	struct cyttsp4_device_info info = {0};
+	enum cyttsp4_device_type type;
+	int rc;
+
+	info.core_id = core_id;
+
+	rc = of_property_read_string(dev_node, "cy,name", &info.name);
+	if (rc) {
+		pr_err("%s: OF error rc=%d\n", __func__, rc);
+		goto fail;
+	} else
+		pr_debug("%s: OF cy,name: %s\n", __func__, info.name);
+
+	rc = get_device_type(dev_node, &type);
+	if (rc)
+		goto fail;
+
+	info.platform_data = create_and_get_device_pdata(dev_node, type);
+	if (IS_ERR(info.platform_data)) {
+		rc = PTR_ERR(info.platform_data);
+		goto fail;
+	}
+
+	rc = cyttsp4_register_device(&info);
+	if (rc)
+		goto fail_free;
+
+	return 0;
+
+fail_free:
+	free_device_pdata(info.platform_data, type);
+fail:
+	return rc;
+}
+
+static struct touch_settings *create_and_get_touch_setting(
+		struct device_node *core_node, const char *name)
+{
+	struct touch_settings *setting;
+	char *tag_name;
+	u32 tag_value;
+	u16 *data;
+	int size;
+	int rc;
+
+	data = create_and_get_u16_array(core_node, name, &size);
+	if (IS_ERR_OR_NULL(data))
+		return (void *)data;
+
+	pr_debug("%s: Touch setting:'%s' size:%d\n", __func__, name, size);
+
+	setting = kzalloc(sizeof(*setting), GFP_KERNEL);
+	if (setting == NULL) {
+		rc = -ENOMEM;
+		goto fail_free_data;
+	}
+
+	setting->data = (u8 *)data;
+	setting->size = size;
+
+	tag_name = kzalloc(MAX_NAME_LENGTH, GFP_KERNEL);
+	if (tag_name == NULL) {
+		rc = -ENOMEM;
+		goto fail_free_setting;
+	}
+
+	snprintf(tag_name, MAX_NAME_LENGTH, "%s-tag", name);
+
+	rc = of_property_read_u32(core_node, tag_name, &tag_value);
+	if (!rc)
+		setting->tag = tag_value;
+
+	kfree(tag_name);
+
+	return setting;
+
+fail_free_setting:
+	kfree(setting);
+fail_free_data:
+	kfree(data);
+
+	return ERR_PTR(rc);
+}
+
+static void free_touch_setting(struct touch_settings *setting)
+{
+	if (setting) {
+		kfree(setting->data);
+		kfree(setting);
+	}
+}
+
+static char *touch_setting_names[CY_IC_GRPNUM_NUM] = {
+	NULL,			/* CY_IC_GRPNUM_RESERVED */
+	"cy,cmd_regs",		/* CY_IC_GRPNUM_CMD_REGS */
+	"cy,tch_rep",		/* CY_IC_GRPNUM_TCH_REP */
+	"cy,data_rec",		/* CY_IC_GRPNUM_DATA_REC */
+	"cy,test_rec",		/* CY_IC_GRPNUM_TEST_REC */
+	"cy,pcfg_rec",		/* CY_IC_GRPNUM_PCFG_REC */
+	"cy,tch_parm_val",	/* CY_IC_GRPNUM_TCH_PARM_VAL */
+	"cy,tch_parm_size",	/* CY_IC_GRPNUM_TCH_PARM_SIZE */
+	NULL,			/* CY_IC_GRPNUM_RESERVED1 */
+	NULL,			/* CY_IC_GRPNUM_RESERVED2 */
+	"cy,opcfg_rec",		/* CY_IC_GRPNUM_OPCFG_REC */
+	"cy,ddata_rec",		/* CY_IC_GRPNUM_DDATA_REC */
+	"cy,mdata_rec",		/* CY_IC_GRPNUM_MDATA_REC */
+	"cy,test_regs",		/* CY_IC_GRPNUM_TEST_REGS */
+	"cy,btn_keys",		/* CY_IC_GRPNUM_BTN_KEYS */
+	NULL,			/* CY_IC_GRPNUM_TTHE_REGS */
+};
+
+static struct cyttsp4_core_platform_data *create_and_get_core_pdata(
+		struct device_node *core_node)
+{
+	struct cyttsp4_core_platform_data *pdata;
+	u32 value;
+	int rc;
+	int i;
+
+	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+	if (pdata == NULL) {
+		rc = -ENOMEM;
+		goto fail;
+	}
+
+	/* Required fields */
+	pdata->irq_gpio = of_get_named_gpio_flags(core_node,
+					"cy,irq_gpio", 0, &value);
+	if (pdata->irq_gpio < 0) {
+		rc = pdata->irq_gpio;
+		goto fail_free;
+	}
+
+	/* Optional fields */
+	/* rst_gpio is optional since a platform may use
+	 * power cycling instead of using the XRES pin
+	 */
+	pdata->rst_gpio = of_get_named_gpio_flags(core_node,
+					"cy,rst_gpio", 0, &value);
+
+	rc = of_property_read_u32(core_node, "cy,level_irq_udelay", &value);
+	if (!rc)
+		pdata->level_irq_udelay = value;
+
+	rc = of_property_read_u32(core_node, "cy,max_xfer_len", &value);
+	if (!rc)
+		pdata->max_xfer_len = value;
+
+	rc = of_property_read_u32(core_node, "cy,flags", &value);
+	if (!rc)
+		pdata->flags = value;
+
+	rc = of_property_read_u32(core_node, "cy,num-max-touches", &value);
+	if (!rc)
+		pdata->num_max_touches = value;
+
+	rc = of_property_read_u32(core_node, "cy,easy_wakeup_gesture", &value);
+	if (!rc)
+		pdata->easy_wakeup_gesture = (u8)value;
+
+	for (i = 0; (unsigned int)i < ARRAY_SIZE(touch_setting_names); i++) {
+		if (touch_setting_names[i] == NULL)
+			continue;
+
+		pdata->sett[i] = create_and_get_touch_setting(core_node,
+				touch_setting_names[i]);
+		if (IS_ERR(pdata->sett[i])) {
+			rc = PTR_ERR(pdata->sett[i]);
+			goto fail_free_sett;
+		} else if (pdata->sett[i] == NULL)
+			pr_debug("%s: No data for setting '%s'\n", __func__,
+				touch_setting_names[i]);
+	}
+
+	pr_debug("%s: irq_gpio:%d rst_gpio:%d level_irq_udelay:%d\n"
+		"max_xfer_len:%d flags:%d easy_wakeup_gesture:%d\n", __func__,
+		pdata->irq_gpio, pdata->rst_gpio, pdata->level_irq_udelay,
+		pdata->max_xfer_len, pdata->flags, pdata->easy_wakeup_gesture);
+
+	pdata->xres = cyttsp4_xres;
+	pdata->init = cyttsp4_init;
+	pdata->power = cyttsp4_power;
+#ifdef CYTTSP4_DETECT_HW
+	pdata->detect = cyttsp4_detect;
+#endif
+	pdata->irq_stat = cyttsp4_irq_stat;
+
+	pdata->loader_pdata = &_cyttsp4_loader_platform_data;
+
+	return pdata;
+
+fail_free_sett:
+	for (i--; i >= 0; i--)
+		free_touch_setting(pdata->sett[i]);
+fail_free:
+	kfree(pdata);
+fail:
+	return ERR_PTR(rc);
+}
+
+static void free_core_pdata(struct cyttsp4_core_platform_data *pdata)
+{
+	int i;
+
+	for (i = 0; i < CY_TOUCH_SETTINGS_MAX; i++)
+		free_touch_setting(pdata->sett[i]);
+
+	kfree(pdata);
+}
+
+static int register_core_device(struct device_node *core_node,
+		const char *adap_id, const char **core_id)
+{
+	struct cyttsp4_core_info info = {0};
+	int rc;
+
+	rc = of_property_read_string(core_node, "cy,name", &info.name);
+	if (rc) {
+		pr_err("%s: OF error rc=%d\n", __func__, rc);
+		goto fail;
+	} else
+		pr_debug("%s: OF cy,name: %s\n", __func__, info.name);
+
+	rc = of_property_read_string(core_node, "cy,id", &info.id);
+	if (rc) {
+		pr_err("%s: OF error rc=%d\n", __func__, rc);
+		goto fail;
+	} else
+		pr_debug("%s: OF cy,id: %s\n", __func__, info.id);
+
+	info.platform_data = create_and_get_core_pdata(core_node);
+	if (IS_ERR(info.platform_data)) {
+		rc = PTR_ERR(info.platform_data);
+		goto fail;
+	}
+
+	info.adap_id = adap_id;
+
+	rc = cyttsp4_register_core_device(&info);
+	if (rc)
+		goto fail_free;
+
+	*core_id = info.id;
+
+	return 0;
+
+fail_free:
+	free_core_pdata(info.platform_data);
+fail:
+	return rc;
+}
+
+int cyttsp4_devtree_register_devices(struct device *adap_dev)
+{
+	struct device_node *core_node, *dev_node;
+	const char *adap_id;
+	int count = 0;
+	int rc;
+
+	if (!adap_dev->of_node)
+		return 0;
+
+	rc = of_property_read_string(adap_dev->of_node, "cy,adapter_id",
+			&adap_id);
+	if (rc)
+		return rc;
+
+	/* There should be only one core node */
+	for_each_child_of_node(adap_dev->of_node, core_node) {
+		const char *core_id = NULL;
+		const char *name;
+
+		rc = of_property_read_string(core_node, "name", &name);
+		if (!rc)
+			pr_debug("%s: name:%s\n", __func__, name);
+
+		rc = register_core_device(core_node, adap_id, &core_id);
+		if (rc)
+			break;
+		/* Increment reference count */
+		of_node_get(core_node);
+
+		for_each_child_of_node(core_node, dev_node) {
+			count++;
+			rc = register_device(dev_node, core_id);
+			if (rc)
+				break;
+			/* Increment reference count */
+			of_node_get(dev_node);
+		}
+	}
+
+	pr_debug("%s: %d child node(s) found\n", __func__, count);
+
+	return rc;
+}
+EXPORT_SYMBOL_GPL(cyttsp4_devtree_register_devices);
+
+static int __init cyttsp4_devtree_init(void)
+{
+	return 0;
+}
+module_init(cyttsp4_devtree_init);
+
+static void __exit cyttsp4_devtree_exit(void)
+{
+}
+module_exit(cyttsp4_devtree_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_devtree.h b/drivers/input/touchscreen/cypress/cyttsp4_devtree.h
new file mode 100644
index 0000000..b966eb8
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_devtree.h
@@ -0,0 +1,36 @@
+/*
+ * cyttsp4_devtree.h
+ * Cypress TrueTouch(TM) Standard Product V4 Device Tree Support Driver
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_DEVICETREE_SUPPORT
+extern int cyttsp4_devtree_register_devices(struct device *adap_dev);
+#else
+static inline int cyttsp4_devtree_register_devices(struct device *adap_dev)
+{
+	return 0;
+}
+#endif
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_i2c.c b/drivers/input/touchscreen/cypress/cyttsp4_i2c.c
new file mode 100644
index 0000000..4df314e
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_i2c.c
@@ -0,0 +1,300 @@
+/*
+ * cyttsp4_i2c.c
+ * Cypress TrueTouch(TM) Standard Product V4 I2C Driver module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ * Copyright (C) 2014 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ * Modified by: Cypress Semiconductor for test with device
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/cyttsp4_bus.h>
+#include <linux/cyttsp4_core.h>
+#include "cyttsp4_i2c.h"
+
+#include <linux/delay.h>
+#include <linux/hrtimer.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/of_device.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+
+#include "cyttsp4_devtree.h"
+
+#define CY_I2C_DATA_SIZE  (3 * 256)
+
+struct cyttsp4_i2c {
+	struct i2c_client *client;
+	u8 wr_buf[CY_I2C_DATA_SIZE];
+	char const *id;
+	struct mutex lock;
+};
+
+static int cyttsp4_i2c_read_block_data(struct cyttsp4_i2c *ts_i2c, u16 addr,
+		int length, void *values, int max_xfer)
+{
+	int rc = -EINVAL;
+	int trans_len;
+	u8 client_addr;
+	u8 addr_lo;
+	struct i2c_msg msgs[2];
+
+	while (length > 0) {
+		client_addr = ts_i2c->client->addr | ((addr >> 8) & 0x1);
+		addr_lo = addr & 0xFF;
+		trans_len = min(length, max_xfer);
+
+		memset(msgs, 0, sizeof(msgs));
+		msgs[0].addr = client_addr;
+		msgs[0].flags = 0;
+		msgs[0].len = 1;
+		msgs[0].buf = &addr_lo;
+
+		msgs[1].addr = client_addr;
+		msgs[1].flags = I2C_M_RD;
+		msgs[1].len = trans_len;
+		msgs[1].buf = values;
+
+		rc = i2c_transfer(ts_i2c->client->adapter, msgs, 2);
+		if (rc != 2)
+			goto exit;
+
+		length -= trans_len;
+		values += trans_len;
+		addr += trans_len;
+	}
+
+exit:
+	return (rc < 0) ? rc : rc != ARRAY_SIZE(msgs) ? -EIO : 0;
+}
+
+static int cyttsp4_i2c_write_block_data(struct cyttsp4_i2c *ts_i2c, u16 addr,
+		int length, const void *values, int max_xfer)
+{
+	int rc = -EINVAL;
+	u8 client_addr;
+	u8 addr_lo;
+	int trans_len;
+	struct i2c_msg msg;
+
+	if (sizeof(ts_i2c->wr_buf) < (length + 1))
+		return -ENOMEM;
+
+	while (length > 0) {
+		client_addr = ts_i2c->client->addr | ((addr >> 8) & 0x1);
+		addr_lo = addr & 0xFF;
+		trans_len = min(length, max_xfer);
+
+		memset(&msg, 0, sizeof(msg));
+		msg.addr = client_addr;
+		msg.flags = 0;
+		msg.len = trans_len + 1;
+		msg.buf = ts_i2c->wr_buf;
+
+		ts_i2c->wr_buf[0] = addr_lo;
+		memcpy(&ts_i2c->wr_buf[1], values, trans_len);
+
+		/* write data */
+		rc = i2c_transfer(ts_i2c->client->adapter, &msg, 1);
+		if (rc != 1)
+			goto exit;
+
+		length -= trans_len;
+		values += trans_len;
+		addr += trans_len;
+	}
+
+exit:
+	return (rc < 0) ? rc : rc != 1 ? -EIO : 0;
+}
+
+static int cyttsp4_i2c_write(struct cyttsp4_adapter *adap, u16 addr,
+	const void *buf, int size, int max_xfer)
+{
+	struct cyttsp4_i2c *ts = dev_get_drvdata(adap->dev);
+	int rc;
+
+	pm_runtime_get_noresume(adap->dev);
+	mutex_lock(&ts->lock);
+	rc = cyttsp4_i2c_write_block_data(ts, addr, size, buf, max_xfer);
+	mutex_unlock(&ts->lock);
+	pm_runtime_put_noidle(adap->dev);
+
+	return rc;
+}
+
+static int cyttsp4_i2c_read(struct cyttsp4_adapter *adap, u16 addr,
+	void *buf, int size, int max_xfer)
+{
+	struct cyttsp4_i2c *ts = dev_get_drvdata(adap->dev);
+	int rc;
+
+	pm_runtime_get_noresume(adap->dev);
+	mutex_lock(&ts->lock);
+	rc = cyttsp4_i2c_read_block_data(ts, addr, size, buf, max_xfer);
+	mutex_unlock(&ts->lock);
+	pm_runtime_put_noidle(adap->dev);
+
+	return rc;
+}
+
+static struct cyttsp4_ops ops = {
+	.write = cyttsp4_i2c_write,
+	.read = cyttsp4_i2c_read,
+};
+
+static struct of_device_id cyttsp4_i2c_of_match[] = {
+	{ .compatible = "cy,cyttsp4_i2c_adapter", }, { }
+};
+MODULE_DEVICE_TABLE(of, cyttsp4_i2c_of_match);
+
+static int cyttsp4_i2c_probe(struct i2c_client *client,
+	const struct i2c_device_id *i2c_id)
+{
+	struct cyttsp4_i2c *ts_i2c;
+	struct device *dev = &client->dev;
+	const struct of_device_id *match;
+	char const *adap_id;
+	int rc;
+
+	dev_info(dev, "%s: Starting %s probe...\n", __func__, CYTTSP4_I2C_NAME);
+
+	dev_dbg(dev, "%s: debug on\n", __func__);
+	dev_vdbg(dev, "%s: verbose debug on\n", __func__);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_err(dev, "%s: fail check I2C functionality\n", __func__);
+		rc = -EIO;
+		goto error_alloc_data_failed;
+	}
+
+	ts_i2c = kzalloc(sizeof(struct cyttsp4_i2c), GFP_KERNEL);
+	if (ts_i2c == NULL) {
+		dev_err(dev, "%s: Error, kzalloc.\n", __func__);
+		rc = -ENOMEM;
+		goto error_alloc_data_failed;
+	}
+
+	match = of_match_device(of_match_ptr(cyttsp4_i2c_of_match), dev);
+	if (match) {
+		rc = of_property_read_string(dev->of_node, "cy,adapter_id",
+				&adap_id);
+		if (rc) {
+			dev_err(dev, "%s: OF error rc=%d\n", __func__, rc);
+			goto error_free_data;
+		}
+		cyttsp4_devtree_register_devices(dev);
+	} else {
+		adap_id = dev_get_platdata(dev);
+	}
+
+	mutex_init(&ts_i2c->lock);
+	ts_i2c->client = client;
+	ts_i2c->id = (adap_id) ? adap_id : CYTTSP4_I2C_NAME;
+	client->dev.bus = &i2c_bus_type;
+	i2c_set_clientdata(client, ts_i2c);
+	dev_set_drvdata(&client->dev, ts_i2c);
+
+	dev_dbg(dev, "%s: add adap='%s' (CYTTSP4_I2C_NAME=%s)\n", __func__,
+		ts_i2c->id, CYTTSP4_I2C_NAME);
+
+	pm_runtime_enable(&client->dev);
+
+	rc = cyttsp4_add_adapter(ts_i2c->id, &ops, dev);
+	if (rc) {
+		dev_err(dev, "%s: Error on probe %s\n", __func__,
+			CYTTSP4_I2C_NAME);
+		goto add_adapter_err;
+	}
+
+	dev_info(dev, "%s: Successful probe %s\n", __func__, CYTTSP4_I2C_NAME);
+
+	return 0;
+
+add_adapter_err:
+	pm_runtime_disable(&client->dev);
+	dev_set_drvdata(&client->dev, NULL);
+	i2c_set_clientdata(client, NULL);
+error_free_data:
+	kfree(ts_i2c);
+error_alloc_data_failed:
+	return rc;
+}
+
+/* registered in driver struct */
+static int cyttsp4_i2c_remove(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct cyttsp4_i2c *ts_i2c = dev_get_drvdata(dev);
+
+	dev_info(dev, "%s\n", __func__);
+	cyttsp4_del_adapter(ts_i2c->id);
+	pm_runtime_disable(&client->dev);
+	dev_set_drvdata(&client->dev, NULL);
+	i2c_set_clientdata(client, NULL);
+	kfree(ts_i2c);
+	return 0;
+}
+
+static const struct i2c_device_id cyttsp4_i2c_id[] = {
+	{ CYTTSP4_I2C_NAME, 0 },  { }
+};
+MODULE_DEVICE_TABLE(i2c, cyttsp4_i2c_id);
+
+static struct i2c_driver cyttsp4_i2c_driver = {
+	.driver = {
+		.name = CYTTSP4_I2C_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = cyttsp4_i2c_of_match,
+	},
+	.probe = cyttsp4_i2c_probe,
+	.remove = cyttsp4_i2c_remove,
+	.id_table = cyttsp4_i2c_id,
+};
+
+static int __init cyttsp4_i2c_init(void)
+{
+	int rc = i2c_add_driver(&cyttsp4_i2c_driver);
+
+	pr_info("%s: Cypress TTSP I2C Touchscreen Driver (Built %s) rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return rc;
+}
+module_init(cyttsp4_i2c_init);
+
+static void __exit cyttsp4_i2c_exit(void)
+{
+	i2c_del_driver(&cyttsp4_i2c_driver);
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_i2c_exit);
+
+MODULE_ALIAS(CYTTSP4_I2C_NAME);
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard Product (TTSP) I2C driver");
+MODULE_AUTHOR("Cypress");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_i2c.h b/drivers/input/touchscreen/cypress/cyttsp4_i2c.h
new file mode 100644
index 0000000..fbda24b
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_i2c.h
@@ -0,0 +1,35 @@
+/*
+ * cyttsp4_i2c.h
+ * Cypress TrueTouch(TM) Standard Product V4 I2C driver module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ * Copyright (C) 2014 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_I2C_H
+#define _LINUX_CYTTSP4_I2C_H
+
+#define CYTTSP4_I2C_NAME "cyttsp4_i2c_adapter"
+
+#endif /* _LINUX_CYTTSP4_I2C_H */
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_loader.c b/drivers/input/touchscreen/cypress/cyttsp4_loader.c
new file mode 100644
index 0000000..d854203
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_loader.c
@@ -0,0 +1,1899 @@
+/*
+ * cyttsp4_loader.c
+ * Cypress TrueTouch(TM) Standard Product V4 FW loader module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2009-2014 Cypress Semiconductor, Inc.
+ * Copyright (C) 2014 Motorola Mobility, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <asm/unaligned.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/firmware.h>
+#include <linux/cyttsp4_bus.h>
+#include <linux/cyttsp4_core.h>
+#include "cyttsp4_regs.h"
+
+#define CYTTSP4_LOADER_NAME "cyttsp4_loader"
+#define CYTTSP4_AUTO_LOAD_FOR_CORRUPTED_FW 1
+
+#define CYTTSP4_FW_UPGRADE \
+	(defined(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE) \
+	|| defined(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE))
+
+#define CYTTSP4_TTCONFIG_UPGRADE \
+	(defined(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_TTCONFIG_UPGRADE) \
+	|| defined(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE))
+
+/* Timeout values in ms. */
+#define CY_CMD_TIMEOUT					500
+#define CY_CMD_LDR_INIT_TIMEOUT				10000
+#define CY_LDR_REQUEST_EXCLUSIVE_TIMEOUT		5000
+
+#define CY_CMD_BYTE					1
+#define CY_STATUS_BYTE					1
+#define CY_MAX_STATUS_SIZE				32
+#define CY_START_OF_PACKET				0x01
+#define CY_END_OF_PACKET				0x17
+#define CY_DATA_ROW_SIZE				288
+#define CY_DATA_ROW_SIZE_TMA400				128
+#define CY_PACKET_DATA_LEN				96
+#define CY_MAX_PACKET_LEN				512
+#define CY_COMM_BUSY					0xFF
+#define CY_CMD_BUSY					0xFE
+#define CY_ARRAY_ID_OFFSET				0
+#define CY_ROW_NUM_OFFSET				1
+#define CY_ROW_SIZE_OFFSET				3
+#define CY_ROW_DATA_OFFSET				5
+#define CY_CMD_LDR_HOST_SYNC				0xFF /* tma400 */
+#define CY_CMD_LDR_EXIT					0x3B
+#define CY_CMD_LDR_EXIT_CMD_SIZE			7
+#define CY_CMD_LDR_EXIT_STAT_SIZE			7
+#define CY_CMD_LDR_ENTER				0x38
+#define CY_CMD_LDR_ENTER_CMD_SIZE			7
+#define CY_CMD_LDR_ENTER_STAT_SIZE			15
+#define CY_CMD_LDR_INIT					0x48
+#define CY_CMD_LDR_INIT_CMD_SIZE			15
+#define CY_CMD_LDR_INIT_STAT_SIZE			7
+#define CY_CMD_LDR_ERASE_ROW				0x34
+#define CY_CMD_LDR_ERASE_ROW_CMD_SIZE			10
+#define CY_CMD_LDR_ERASE_ROW_STAT_SIZE			7
+#define CY_CMD_LDR_SEND_DATA				0x37
+#define CY_CMD_LDR_SEND_DATA_CMD_SIZE			4 /* hdr bytes only */
+#define CY_CMD_LDR_SEND_DATA_STAT_SIZE			8
+#define CY_CMD_LDR_PROG_ROW				0x39
+#define CY_CMD_LDR_PROG_ROW_CMD_SIZE			7 /* hdr bytes only */
+#define CY_CMD_LDR_PROG_ROW_STAT_SIZE			7
+#define CY_CMD_LDR_VERIFY_ROW				0x3A
+#define CY_CMD_LDR_VERIFY_ROW_STAT_SIZE			8
+#define CY_CMD_LDR_VERIFY_ROW_CMD_SIZE			10
+#define CY_CMD_LDR_VERIFY_CHKSUM			0x31
+#define CY_CMD_LDR_VERIFY_CHKSUM_CMD_SIZE		7
+#define CY_CMD_LDR_VERIFY_CHKSUM_STAT_SIZE		8
+
+struct cyttsp4_loader_data {
+	struct cyttsp4_device *ttsp;
+	struct cyttsp4_sysinfo *si;
+	u8 status_buf[CY_MAX_STATUS_SIZE];
+	struct completion int_running;
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+	struct completion builtin_bin_fw_complete;
+	int builtin_bin_fw_status;
+#endif
+	struct work_struct fw_and_config_upgrade;
+	struct work_struct calibration_work;
+	struct cyttsp4_loader_platform_data *loader_pdata;
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE
+	struct mutex config_lock;
+	u8 *config_data;
+	int config_size;
+	bool config_loading;
+#endif
+};
+
+struct cyttsp4_dev_id {
+	u32 silicon_id;
+	u8 rev_id;
+	u32 bl_ver;
+};
+
+enum ldr_status {
+	ERROR_SUCCESS = 0,
+	ERROR_COMMAND = 1,
+	ERROR_FLASH_ARRAY = 2,
+	ERROR_PACKET_DATA = 3,
+	ERROR_PACKET_LEN = 4,
+	ERROR_PACKET_CHECKSUM = 5,
+	ERROR_FLASH_PROTECTION = 6,
+	ERROR_FLASH_CHECKSUM = 7,
+	ERROR_VERIFY_IMAGE = 8,
+	ERROR_UKNOWN1 = 9,
+	ERROR_UKNOWN2 = 10,
+	ERROR_UKNOWN3 = 11,
+	ERROR_UKNOWN4 = 12,
+	ERROR_UKNOWN5 = 13,
+	ERROR_UKNOWN6 = 14,
+	ERROR_INVALID_COMMAND = 15,
+	ERROR_INVALID
+};
+
+#if CYTTSP4_FW_UPGRADE || CYTTSP4_TTCONFIG_UPGRADE
+/*
+ * return code:
+ * -1: Firmware version compared is older
+ *  0: Firmware version compared is identical
+ *  1: Firmware version compared is newer
+ */
+static int cyttsp4_check_firmware_version(struct cyttsp4_device *ttsp,
+		u32 fw_ver_new, u32 fw_revctrl_new_h, u32 fw_revctrl_new_l)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	u32 fw_ver_img;
+	u32 fw_revctrl_img_h;
+	u32 fw_revctrl_img_l;
+
+	fw_ver_img = data->si->si_ptrs.cydata->fw_ver_major << 8;
+	fw_ver_img += data->si->si_ptrs.cydata->fw_ver_minor;
+
+	dev_dbg(dev, "%s: img vers:0x%04X new vers:0x%04X\n", __func__,
+			fw_ver_img, fw_ver_new);
+
+	if (fw_ver_new > fw_ver_img)
+		return 1;
+
+	if (fw_ver_new < fw_ver_img)
+		return -EPERM;
+
+	fw_revctrl_img_h = be32_to_cpu(
+		*(u32 *)(data->si->si_ptrs.cydata->revctrl + 0));
+
+	dev_dbg(dev, "%s: img revctrl_h:0x%04X new revctrl_h:0x%04X\n",
+			__func__, fw_revctrl_img_h, fw_revctrl_new_h);
+
+	if (fw_revctrl_new_h > fw_revctrl_img_h)
+		return 1;
+
+	if (fw_revctrl_new_h < fw_revctrl_img_h)
+		return -EPERM;
+
+	fw_revctrl_img_l = be32_to_cpu(
+		*(u32 *)(data->si->si_ptrs.cydata->revctrl + 4));
+
+	dev_dbg(dev, "%s: img revctrl_l:0x%04X new revctrl_l:0x%04X\n",
+			__func__, fw_revctrl_img_l, fw_revctrl_new_l);
+
+	if (fw_revctrl_new_l > fw_revctrl_img_l)
+		return 1;
+
+	if (fw_revctrl_new_l < fw_revctrl_img_l)
+		return -EPERM;
+
+	return 0;
+}
+#endif /* CYTTSP4_FW_UPGRADE || CYTTSP4_TTCONFIG_UPGRADE */
+
+
+#if CYTTSP4_FW_UPGRADE
+static u16 _cyttsp4_compute_crc(struct cyttsp4_device *ttsp, u8 *buf, int size)
+{
+	u16 crc = 0xffff;
+	u16 tmp;
+	int i;
+
+	if (size == 0)
+		crc = ~crc;
+	else {
+
+		do {
+			for (i = 0, tmp = 0x00ff & *buf++; i < 8;
+				i++, tmp >>= 1) {
+				if ((crc & 0x0001) ^ (tmp & 0x0001))
+					crc = (crc >> 1) ^ 0x8408;
+				else
+					crc >>= 1;
+			}
+		} while (--size);
+
+		crc = ~crc;
+		tmp = crc;
+		crc = (crc << 8) | (tmp >> 8 & 0xFF);
+	}
+
+	return crc;
+}
+
+static u16 _cyttsp4_get_short(u8 *buf)
+{
+	return ((u16)(*buf) << 8) + *(buf+1);
+}
+
+static u8 *_cyttsp4_get_row(struct cyttsp4_device *ttsp,
+			    u8 *row_buf, u8 *image_buf, int size)
+{
+	memcpy(row_buf, image_buf, size);
+	image_buf = image_buf + size;
+	return image_buf;
+}
+
+static int _cyttsp4_get_status(struct cyttsp4_device *ttsp,
+			       u8 *buf, int size, unsigned long timeout_ms)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+
+	unsigned long uretval;
+	int tries;
+	int retval = 0;
+
+	if (timeout_ms != 0) {
+		/* wait until status ready interrupt or timeout occurs */
+		uretval = wait_for_completion_timeout(
+			&data->int_running, msecs_to_jiffies(timeout_ms));
+
+		/* TODO: Reconsider purpose of having retries here */
+		for (tries = 0; tries < 2; tries++) {
+			retval = cyttsp4_read(ttsp, CY_MODE_BOOTLOADER,
+					      CY_REG_BASE, buf, size);
+			/*
+			 * retry if bus read error or
+			 * status byte shows not ready
+			 */
+			if (buf[1] == CY_COMM_BUSY || buf[1] == CY_CMD_BUSY)
+				msleep(20); /* TODO: Constant if code kept */
+			else
+				break;
+		}
+		dev_vdbg(dev,
+			"%s: tries=%d ret=%d status=%02X\n",
+			__func__, tries, retval, buf[1]);
+	}
+
+	return retval;
+}
+
+static int _cyttsp4_send_cmd(struct cyttsp4_device *ttsp, const u8 *cmd_buf,
+			     int cmd_size, u8 *stat_ret, size_t num_stat_byte,
+			     size_t status_size, unsigned long timeout_ms)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+
+	u8 *status_buf = data->status_buf;
+	int retval = 0;
+
+	if (cmd_buf == NULL)
+		goto _cyttsp4_send_cmd_exit;
+
+	if (cmd_size == 0)
+		goto _cyttsp4_send_cmd_exit;
+
+	if (timeout_ms > 0)
+		INIT_COMPLETION(data->int_running);
+	retval = cyttsp4_write(ttsp, CY_MODE_BOOTLOADER,
+			       CY_REG_BASE, cmd_buf, cmd_size);
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: Fail writing command=%02X\n",
+			__func__, cmd_buf[CY_CMD_BYTE]);
+		goto _cyttsp4_send_cmd_exit;
+	}
+
+	if (timeout_ms > 0) {
+		memset(status_buf, 0, sizeof(data->status_buf));
+		retval = _cyttsp4_get_status(ttsp, status_buf,
+			status_size, timeout_ms);
+		if (retval < 0 || status_buf[0] != CY_START_OF_PACKET) {
+			dev_err(dev,
+				"%s: Error getting status r=%d"
+				" status_buf[0]=%02X\n",
+				__func__, retval, status_buf[0]);
+			if (!(retval < 0))
+				retval = -EIO;
+			goto _cyttsp4_send_cmd_exit;
+		} else {
+			if (status_buf[CY_STATUS_BYTE] != ERROR_SUCCESS) {
+				dev_err(dev,
+					"%s: Status=0x%02X error\n",
+					__func__, status_buf[CY_STATUS_BYTE]);
+				retval = -EIO;
+			} else if (stat_ret != NULL) {
+				if (num_stat_byte < status_size)
+					*stat_ret = status_buf[num_stat_byte];
+				else
+					*stat_ret = 0;
+			}
+		}
+	} else {
+		if (stat_ret != NULL)
+			*stat_ret = ERROR_SUCCESS;
+	}
+
+_cyttsp4_send_cmd_exit:
+	return retval;
+}
+
+static int _cyttsp4_ldr_enter(struct cyttsp4_device *ttsp,
+		struct cyttsp4_dev_id *dev_id)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+
+	u16 crc = 0;
+	int i = 0;
+	size_t cmd_size = 0;
+	u8 *status_buf = &data->status_buf[0];
+	u8 status = 0;
+	int retval;
+	/* +1 for TMA400 host sync byte */
+	u8 ldr_enter_cmd[CY_CMD_LDR_ENTER_CMD_SIZE+1];
+	memset(status_buf, 0, sizeof(data->status_buf));
+	dev_id->bl_ver = 0;
+	dev_id->rev_id = 0;
+	dev_id->silicon_id = 0;
+
+	ldr_enter_cmd[i++] = CY_CMD_LDR_HOST_SYNC;
+	ldr_enter_cmd[i++] = CY_START_OF_PACKET;
+	ldr_enter_cmd[i++] = CY_CMD_LDR_ENTER;
+	ldr_enter_cmd[i++] = 0x00;	/* data len lsb */
+	ldr_enter_cmd[i++] = 0x00;	/* data len msb */
+	crc = _cyttsp4_compute_crc(ttsp, &ldr_enter_cmd[1], i - 1);
+	cmd_size = sizeof(ldr_enter_cmd);
+	ldr_enter_cmd[i++] = (u8)crc;
+	ldr_enter_cmd[i++] = (u8)(crc >> 8);
+	ldr_enter_cmd[i++] = CY_END_OF_PACKET;
+
+	INIT_COMPLETION(data->int_running);
+
+	retval = cyttsp4_write(ttsp, CY_MODE_BOOTLOADER,
+		CY_REG_BASE, ldr_enter_cmd, cmd_size);
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: write block failed %d\n", __func__, retval);
+		return retval;
+	}
+	retval = _cyttsp4_get_status(ttsp, status_buf,
+		CY_CMD_LDR_ENTER_STAT_SIZE, CY_CMD_TIMEOUT);
+
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: Fail get status to Enter Loader command r=%d\n",
+			__func__, retval);
+		return retval;
+	}
+	status = status_buf[CY_STATUS_BYTE];
+	if (status == ERROR_SUCCESS) {
+		dev_id->bl_ver =
+			status_buf[11] << 16 |
+			status_buf[10] <<  8 |
+			status_buf[9] <<  0;
+		dev_id->rev_id =
+			status_buf[8] <<  0;
+		dev_id->silicon_id =
+			status_buf[7] << 24 |
+			status_buf[6] << 16 |
+			status_buf[5] <<  8 |
+			status_buf[4] <<  0;
+		retval = 0;
+	} else
+		retval = -EIO;
+	dev_vdbg(dev,
+		 "%s: status=%d "
+		 "bl_ver=%08X rev_id=%02X silicon_id=%08X\n",
+		 __func__, status,
+		 dev_id->bl_ver, dev_id->rev_id, dev_id->silicon_id);
+
+	return retval;
+}
+
+static int _cyttsp4_ldr_init(struct cyttsp4_device *ttsp)
+{
+	u16 crc;
+	int i = 0;
+	int retval = 0;
+	const u8 *cyttsp4_security_key;
+	int key_size;
+	/* +1 for TMA400 host sync byte */
+	u8 ldr_init_cmd[CY_CMD_LDR_INIT_CMD_SIZE+1];
+
+	cyttsp4_security_key = cyttsp4_get_security_key(ttsp, &key_size);
+
+	ldr_init_cmd[i++] = CY_CMD_LDR_HOST_SYNC;
+	ldr_init_cmd[i++] = CY_START_OF_PACKET;
+	ldr_init_cmd[i++] = CY_CMD_LDR_INIT;
+	ldr_init_cmd[i++] = 0x08;	/* data len lsb */
+	ldr_init_cmd[i++] = 0x00;	/* data len msb */
+	memcpy(&ldr_init_cmd[i], cyttsp4_security_key,
+			key_size);
+	i += key_size;
+	crc = _cyttsp4_compute_crc(ttsp, &ldr_init_cmd[1], i - 1);
+	ldr_init_cmd[i++] = (u8)crc;
+	ldr_init_cmd[i++] = (u8)(crc >> 8);
+	ldr_init_cmd[i++] = CY_END_OF_PACKET;
+
+	retval = _cyttsp4_send_cmd(ttsp, ldr_init_cmd, i, NULL, 0,
+				   CY_CMD_LDR_INIT_STAT_SIZE,
+				   CY_CMD_LDR_INIT_TIMEOUT);
+	if (retval < 0) {
+		dev_err(&ttsp->dev,
+			"%s: Fail ldr init r=%d\n",
+			__func__, retval);
+	}
+
+	return retval;
+}
+
+struct cyttsp4_hex_image {
+	u8 array_id;
+	u16 row_num;
+	u16 row_size;
+	u8 row_data[CY_DATA_ROW_SIZE];
+} __packed;
+
+static int _cyttsp4_ldr_parse_row(struct cyttsp4_device *ttsp, u8 *row_buf,
+	struct cyttsp4_hex_image *row_image)
+{
+	int retval = 0;
+
+	row_image->array_id = row_buf[CY_ARRAY_ID_OFFSET];
+	row_image->row_num = _cyttsp4_get_short(&row_buf[CY_ROW_NUM_OFFSET]);
+	row_image->row_size = _cyttsp4_get_short(&row_buf[CY_ROW_SIZE_OFFSET]);
+
+	if (row_image->row_size > ARRAY_SIZE(row_image->row_data)) {
+		dev_err(&ttsp->dev,
+			"%s: row data buffer overflow\n", __func__);
+		retval = -EOVERFLOW;
+		goto cyttsp4_ldr_parse_row_exit;
+	}
+
+	memcpy(row_image->row_data, &row_buf[CY_ROW_DATA_OFFSET],
+	       row_image->row_size);
+cyttsp4_ldr_parse_row_exit:
+	return retval;
+}
+
+static int _cyttsp4_ldr_prog_row(struct cyttsp4_device *ttsp,
+				 struct cyttsp4_hex_image *row_image)
+{
+	u16 crc;
+	int next;
+	int data;
+	int row_data;
+	u16 row_sum;
+	size_t data_len;
+	int retval = 0;
+
+	u8 *cmd = kzalloc(CY_MAX_PACKET_LEN, GFP_KERNEL);
+
+	if (cmd != NULL) {
+		row_data = 0;
+		row_sum = 0;
+		next = 0;
+		cmd[next++] = CY_CMD_LDR_HOST_SYNC;
+		cmd[next++] = CY_START_OF_PACKET;
+		cmd[next++] = CY_CMD_LDR_PROG_ROW;
+		/*
+		 * include array id size and row id size in CY_PACKET_DATA_LEN
+		 */
+		data_len = CY_DATA_ROW_SIZE_TMA400;
+		cmd[next++] = (u8)(data_len+3);
+		cmd[next++] = (u8)((data_len+3) >> 8);
+		cmd[next++] = row_image->array_id;
+		cmd[next++] = (u8)row_image->row_num;
+		cmd[next++] = (u8)(row_image->row_num >> 8);
+
+		for (data = 0;
+			data < data_len; data++) {
+			cmd[next] = row_image->row_data[row_data++];
+			row_sum += cmd[next];
+			next++;
+		}
+
+		crc = _cyttsp4_compute_crc(ttsp, &cmd[1], next - 1);
+		cmd[next++] = (u8)crc;
+		cmd[next++] = (u8)(crc >> 8);
+		cmd[next++] = CY_END_OF_PACKET;
+
+		retval = _cyttsp4_send_cmd(ttsp, cmd, next, NULL, 0,
+					   CY_CMD_LDR_PROG_ROW_STAT_SIZE,
+					   CY_CMD_TIMEOUT);
+
+		if (retval < 0) {
+			dev_err(&ttsp->dev,
+				"%s: prog row=%d fail r=%d\n",
+				__func__, row_image->row_num, retval);
+			goto cyttsp4_ldr_prog_row_exit;
+		}
+
+	} else {
+		dev_err(&ttsp->dev,
+			"%s prog row error - cmd buf is NULL\n", __func__);
+		retval = -EIO;
+	}
+
+cyttsp4_ldr_prog_row_exit:
+	kfree(cmd);
+	return retval;
+}
+
+static int _cyttsp4_ldr_verify_row(struct cyttsp4_device *ttsp,
+	struct cyttsp4_hex_image *row_image)
+{
+	u16 crc = 0;
+	int i = 0;
+	u8 verify_checksum;
+	int retval = 0;
+	/* +1 for TMA400 host sync byte */
+	u8 ldr_verify_row_cmd[CY_CMD_LDR_VERIFY_ROW_CMD_SIZE+1];
+
+	ldr_verify_row_cmd[i++] = CY_CMD_LDR_HOST_SYNC;
+	ldr_verify_row_cmd[i++] = CY_START_OF_PACKET;
+	ldr_verify_row_cmd[i++] = CY_CMD_LDR_VERIFY_ROW;
+	ldr_verify_row_cmd[i++] = 0x03;	/* data len lsb */
+	ldr_verify_row_cmd[i++] = 0x00;	/* data len msb */
+	ldr_verify_row_cmd[i++] = row_image->array_id;
+	ldr_verify_row_cmd[i++] = (u8)row_image->row_num;
+	ldr_verify_row_cmd[i++] = (u8)(row_image->row_num >> 8);
+	crc = _cyttsp4_compute_crc(ttsp, &ldr_verify_row_cmd[1], i - 1);
+	ldr_verify_row_cmd[i++] = (u8)crc;
+	ldr_verify_row_cmd[i++] = (u8)(crc >> 8);
+	ldr_verify_row_cmd[i++] = CY_END_OF_PACKET;
+
+	retval = _cyttsp4_send_cmd(ttsp, ldr_verify_row_cmd, i,
+				   &verify_checksum, 4,
+				   CY_CMD_LDR_VERIFY_ROW_STAT_SIZE,
+				   CY_CMD_TIMEOUT);
+
+	if (retval < 0) {
+		dev_err(&ttsp->dev,
+			"%s: verify row=%d fail r=%d\n",
+			__func__, row_image->row_num, retval);
+	}
+
+	return retval;
+}
+
+static int _cyttsp4_ldr_verify_chksum(struct cyttsp4_device *ttsp,
+	u8 *app_chksum)
+{
+	u16 crc = 0;
+	int i = 0;
+	int retval = 0;
+	/* +1 for TMA400 host sync byte */
+	u8 ldr_verify_chksum_cmd[CY_CMD_LDR_VERIFY_CHKSUM_CMD_SIZE+1];
+
+	ldr_verify_chksum_cmd[i++] = CY_CMD_LDR_HOST_SYNC;
+	ldr_verify_chksum_cmd[i++] = CY_START_OF_PACKET;
+	ldr_verify_chksum_cmd[i++] = CY_CMD_LDR_VERIFY_CHKSUM;
+	ldr_verify_chksum_cmd[i++] = 0x00;	/* data len lsb */
+	ldr_verify_chksum_cmd[i++] = 0x00;	/* data len msb */
+	crc = _cyttsp4_compute_crc(ttsp, &ldr_verify_chksum_cmd[1], i - 1);
+	ldr_verify_chksum_cmd[i++] = (u8)crc;
+	ldr_verify_chksum_cmd[i++] = (u8)(crc >> 8);
+	ldr_verify_chksum_cmd[i++] = CY_END_OF_PACKET;
+
+	retval = _cyttsp4_send_cmd(ttsp, ldr_verify_chksum_cmd, i,
+				   app_chksum, 4,
+				   CY_CMD_LDR_VERIFY_CHKSUM_STAT_SIZE,
+				   CY_CMD_TIMEOUT);
+
+	if (retval < 0) {
+		dev_err(&ttsp->dev,
+			"%s: verify checksum fail r=%d\n",
+			__func__, retval);
+	}
+
+	return retval;
+}
+
+/* Constructs loader exit command and sends via _cyttsp4_send_cmd() */
+static int _cyttsp4_ldr_exit(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	u16 crc = 0;
+	int i = 0;
+	int retval;
+	/* +1 for TMA400 host sync byte */
+	u8 ldr_exit_cmd[CY_CMD_LDR_EXIT_CMD_SIZE+1];
+
+	ldr_exit_cmd[i++] = CY_CMD_LDR_HOST_SYNC;
+	ldr_exit_cmd[i++] = CY_START_OF_PACKET;
+	ldr_exit_cmd[i++] = CY_CMD_LDR_EXIT;
+	ldr_exit_cmd[i++] = 0x00;	/* data len lsb */
+	ldr_exit_cmd[i++] = 0x00;	/* data len msb */
+	crc = _cyttsp4_compute_crc(ttsp, &ldr_exit_cmd[1], i - 1);
+	ldr_exit_cmd[i++] = (u8)crc;
+	ldr_exit_cmd[i++] = (u8)(crc >> 8);
+	ldr_exit_cmd[i++] = CY_END_OF_PACKET;
+
+	retval = _cyttsp4_send_cmd(ttsp, ldr_exit_cmd, i, NULL, 0,
+				   CY_CMD_LDR_EXIT_STAT_SIZE, 0);
+
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: BL Loader exit fail r=%d\n",
+			__func__, retval);
+	}
+
+	dev_vdbg(dev,
+		"%s: Exit BL Loader r=%d\n", __func__, retval);
+
+	return retval;
+}
+
+static int _cyttsp4_load_app(struct cyttsp4_device *ttsp, const u8 *fw,
+			     int fw_size)
+{
+	struct device *dev = &ttsp->dev;
+	u8 *p;
+	int ret;
+	int retval;	/* need separate return value at exit stage */
+	struct cyttsp4_dev_id *file_id = NULL;
+	struct cyttsp4_dev_id *dev_id = NULL;
+	struct cyttsp4_hex_image *row_image = NULL;
+	u8 app_chksum;
+
+	u8 *row_buf = NULL;
+	/* Prevent loading if TMA ver not defined. */
+	size_t image_rec_size = fw_size + 1;
+	size_t row_buf_size = 1024 > CY_MAX_PRBUF_SIZE ?
+		1024 : CY_MAX_PRBUF_SIZE;
+	int row_count = 0;
+
+	image_rec_size = CY_DATA_ROW_SIZE_TMA400 +
+		(sizeof(struct cyttsp4_hex_image) - CY_DATA_ROW_SIZE);
+	if (fw_size % image_rec_size != 0) {
+		dev_err(dev,
+			"%s: Firmware image is misaligned\n", __func__);
+		retval = -EINVAL;
+		goto _cyttsp4_load_app_exit;
+	}
+
+	dev_info(dev, "%s: start load app\n", __func__);
+
+	row_buf = kzalloc(row_buf_size, GFP_KERNEL);
+	row_image = kzalloc(sizeof(struct cyttsp4_hex_image), GFP_KERNEL);
+	file_id = kzalloc(sizeof(struct cyttsp4_dev_id), GFP_KERNEL);
+	dev_id = kzalloc(sizeof(struct cyttsp4_dev_id), GFP_KERNEL);
+	if (row_buf == NULL || row_image == NULL ||
+	    file_id == NULL || dev_id == NULL) {
+		dev_err(dev,
+			"%s: Unable to alloc row buffers(%p %p %p %p)\n",
+			__func__, row_buf, row_image, file_id, dev_id);
+		retval = -ENOMEM;
+		goto _cyttsp4_load_app_exit;
+	}
+
+	cyttsp4_request_stop_wd(ttsp);
+
+	p = (u8 *)fw;
+	/* Enter Loader and return Silicon ID and Rev */
+
+	retval = cyttsp4_request_reset(ttsp);
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: Fail reset device r=%d\n", __func__, retval);
+		goto _cyttsp4_load_app_exit;
+	}
+
+	dev_info(dev, "%s: Send BL Loader Enter\n", __func__);
+
+	retval = _cyttsp4_ldr_enter(ttsp, dev_id);
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: Error cannot start Loader (ret=%d)\n",
+			__func__, retval);
+		goto _cyttsp4_load_app_exit;
+	}
+
+	dev_vdbg(dev,
+		"%s: dev: silicon id=%08X rev=%02X bl=%08X\n",
+		__func__, dev_id->silicon_id,
+		dev_id->rev_id, dev_id->bl_ver);
+
+	udelay(1000);
+	retval = _cyttsp4_ldr_init(ttsp);
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: Error cannot init Loader (ret=%d)\n",
+			__func__, retval);
+		goto _cyttsp4_load_app_exit;
+	}
+
+	dev_info(dev, "%s: Send BL Loader Blocks\n", __func__);
+
+	while (p < (fw + fw_size)) {
+		/* Get row */
+		dev_dbg(dev,
+			"%s: read row=%d\n", __func__, ++row_count);
+		memset(row_buf, 0, row_buf_size);
+		p = _cyttsp4_get_row(ttsp, row_buf, p, image_rec_size);
+
+		/* Parse row */
+		dev_vdbg(dev,
+			"%s: p=%p buf=%p buf[0]=%02X\n", __func__,
+			p, row_buf, row_buf[0]);
+		retval = _cyttsp4_ldr_parse_row(ttsp, row_buf, row_image);
+		dev_vdbg(dev,
+			"%s: array_id=%02X row_num=%04X(%d)"
+				" row_size=%04X(%d)\n", __func__,
+			row_image->array_id,
+			row_image->row_num, row_image->row_num,
+			row_image->row_size, row_image->row_size);
+		if (retval < 0) {
+			dev_err(dev,
+			"%s: Parse Row Error "
+				"(a=%d r=%d ret=%d\n",
+				__func__, row_image->array_id,
+				row_image->row_num,
+				retval);
+			goto bl_exit;
+		} else {
+			dev_vdbg(dev,
+				"%s: Parse Row "
+				"(a=%d r=%d ret=%d\n",
+				__func__, row_image->array_id,
+				row_image->row_num, retval);
+		}
+
+		/* program row */
+		retval = _cyttsp4_ldr_prog_row(ttsp, row_image);
+		if (retval < 0) {
+			dev_err(dev,
+			"%s: Program Row Error "
+				"(array=%d row=%d ret=%d)\n",
+				__func__, row_image->array_id,
+				row_image->row_num, retval);
+			goto _cyttsp4_load_app_exit;
+		}
+
+		/* verify row */
+		retval = _cyttsp4_ldr_verify_row(ttsp, row_image);
+		if (retval < 0) {
+			dev_err(dev,
+			"%s: Verify Row Error "
+				"(array=%d row=%d ret=%d)\n",
+				__func__, row_image->array_id,
+				row_image->row_num, retval);
+			goto _cyttsp4_load_app_exit;
+		}
+
+		dev_vdbg(dev,
+			"%s: array=%d row_cnt=%d row_num=%04X\n",
+			__func__, row_image->array_id, row_count,
+			row_image->row_num);
+	}
+
+	/* verify app checksum */
+	retval = _cyttsp4_ldr_verify_chksum(ttsp, &app_chksum);
+	dev_dbg(dev,
+		"%s: Application Checksum = %02X r=%d\n",
+		__func__, app_chksum, retval);
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: ldr_verify_chksum fail r=%d\n", __func__, retval);
+		retval = 0;
+	}
+
+	/* exit loader */
+bl_exit:
+	dev_info(dev,
+			"%s: Send BL Loader Terminate\n", __func__);
+	ret = _cyttsp4_ldr_exit(ttsp);
+	if (ret) {
+		dev_err(dev,
+			"%s: Error on exit Loader (ret=%d)\n",
+			__func__, ret);
+		retval = ret;
+	}
+
+_cyttsp4_load_app_exit:
+	kfree(row_buf);
+	kfree(row_image);
+	kfree(file_id);
+	kfree(dev_id);
+	return retval;
+}
+
+static void cyttsp4_fw_calibrate(struct work_struct *calibration_work)
+{
+	struct cyttsp4_loader_data *data = container_of(calibration_work,
+			struct cyttsp4_loader_data, calibration_work);
+	struct cyttsp4_device *ttsp = data->ttsp;
+	struct device *dev = &ttsp->dev;
+	u8 cmd_buf[CY_CMD_CAT_CALIBRATE_IDAC_CMD_SZ];
+	u8 return_buf[CY_CMD_CAT_CALIBRATE_IDAC_RET_SZ];
+	int rc;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	pm_runtime_get_sync(dev);
+
+	dev_vdbg(dev, "%s: Requesting exclusive\n", __func__);
+	rc = cyttsp4_request_exclusive(ttsp, CY_LDR_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto exit;
+	}
+
+	dev_vdbg(dev, "%s: Requesting mode change to CAT\n", __func__);
+	rc = cyttsp4_request_set_mode(ttsp, CY_MODE_CAT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc);
+		goto exit_release;
+	}
+
+	cmd_buf[0] = CY_CMD_CAT_CALIBRATE_IDACS;
+	cmd_buf[1] = 0x00; /* Mutual Capacitance Screen */
+	rc = cyttsp4_request_exec_cmd(ttsp, CY_MODE_CAT,
+			cmd_buf, CY_CMD_CAT_CALIBRATE_IDAC_CMD_SZ,
+			return_buf, CY_CMD_CAT_CALIBRATE_IDAC_RET_SZ,
+			CY_CALIBRATE_COMPLETE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Unable to execute calibrate command.\n",
+			__func__);
+		goto exit_setmode;
+	}
+	if (return_buf[0] != CY_CMD_STATUS_SUCCESS) {
+		dev_err(dev, "%s: calibrate command unsuccessful\n", __func__);
+		goto exit_setmode;
+	}
+
+	cmd_buf[1] = 0x01; /* Mutual Capacitance Button */
+	rc = cyttsp4_request_exec_cmd(ttsp, CY_MODE_CAT,
+			cmd_buf, CY_CMD_CAT_CALIBRATE_IDAC_CMD_SZ,
+			return_buf, CY_CMD_CAT_CALIBRATE_IDAC_RET_SZ,
+			CY_CALIBRATE_COMPLETE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Unable to execute calibrate command.\n",
+			__func__);
+		goto exit_setmode;
+	}
+	if (return_buf[0] != CY_CMD_STATUS_SUCCESS) {
+		dev_err(dev, "%s: calibrate command unsuccessful\n", __func__);
+		goto exit_setmode;
+	}
+
+	cmd_buf[1] = 0x02; /* Self Capacitance */
+	rc = cyttsp4_request_exec_cmd(ttsp, CY_MODE_CAT,
+			cmd_buf, CY_CMD_CAT_CALIBRATE_IDAC_CMD_SZ,
+			return_buf, CY_CMD_CAT_CALIBRATE_IDAC_RET_SZ,
+			CY_CALIBRATE_COMPLETE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Unable to execute calibrate command.\n",
+			__func__);
+		goto exit_setmode;
+	}
+	if (return_buf[0] != CY_CMD_STATUS_SUCCESS) {
+		dev_err(dev, "%s: calibrate command unsuccessful\n", __func__);
+		goto exit_setmode;
+	}
+
+exit_setmode:
+	rc = cyttsp4_request_set_mode(ttsp, CY_MODE_OPERATIONAL);
+	if (rc < 0)
+		dev_err(dev, "%s: Error on request set mode 2 r=%d\n",
+				__func__, rc);
+
+exit_release:
+	rc = cyttsp4_release_exclusive(ttsp);
+	if (rc < 0)
+		dev_err(dev, "%s: Error on release exclusive r=%d\n",
+				__func__, rc);
+
+exit:
+	pm_runtime_put(dev);
+}
+
+static int cyttsp4_fw_calibration_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	int rc = 0;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	schedule_work(&data->calibration_work);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_fw_calibration_attention, 0);
+
+	return rc;
+}
+
+static int cyttsp4_upgrade_firmware(struct cyttsp4_device *ttsp,
+		const u8 *fw_img, int fw_size)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	int rc;
+
+	pm_runtime_get_sync(dev);
+
+	rc = cyttsp4_request_exclusive(ttsp, CY_LDR_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0)
+		goto exit;
+
+	rc = _cyttsp4_load_app(ttsp, fw_img, fw_size);
+	if (rc < 0) {
+		dev_err(dev, "%s: Firmware update failed with error code %d\n",
+			__func__, rc);
+	} else if (data->loader_pdata &&
+			(data->loader_pdata->flags &
+				CY_LOADER_FLAG_CALIBRATE_AFTER_FW_UPGRADE)) {
+		/* set up call back for startup */
+		dev_vdbg(dev, "%s: Adding callback for calibration\n",
+			__func__);
+		rc = cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+				cyttsp4_fw_calibration_attention, 0);
+		if (rc) {
+			dev_err(dev, "%s: Failed adding callback for calibration\n",
+				__func__);
+			dev_err(dev, "%s: No calibration will be performed\n",
+				__func__);
+			rc = 0;
+		}
+	}
+
+	cyttsp4_release_exclusive(ttsp);
+	cyttsp4_request_restart(ttsp, false);
+
+exit:
+	pm_runtime_put(dev);
+	return rc;
+}
+
+static int cyttsp4_loader_attention(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_loader_data *data = dev_get_drvdata(&ttsp->dev);
+	complete(&data->int_running);
+	return 0;
+}
+#endif /* CYTTSP4_FW_UPGRADE */
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+static int cyttsp4_check_firmware_version_platform(struct cyttsp4_device *ttsp,
+		struct cyttsp4_touch_firmware *fw)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	u32 fw_ver_new;
+	u32 fw_revctrl_new_h;
+	u32 fw_revctrl_new_l;
+	int upgrade;
+
+	if (!data->si) {
+		dev_info(dev, "%s: No firmware infomation found, device FW may be corrupted\n",
+			__func__);
+		return CYTTSP4_AUTO_LOAD_FOR_CORRUPTED_FW;
+	}
+
+	fw_ver_new = get_unaligned_be16(fw->ver + 2);
+	fw_revctrl_new_h = get_unaligned_be32(fw->ver + 4);
+	fw_revctrl_new_l = get_unaligned_be32(fw->ver + 8);
+
+	upgrade = cyttsp4_check_firmware_version(ttsp, fw_ver_new,
+			fw_revctrl_new_h, fw_revctrl_new_l);
+
+	if (upgrade > 0)
+		return 1;
+
+	return 0;
+}
+
+static int upgrade_firmware_from_platform(struct cyttsp4_device *ttsp,
+		bool forced)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	struct cyttsp4_touch_firmware *fw;
+	int rc = -ENOSYS;
+	int upgrade;
+
+	if (data->loader_pdata == NULL) {
+		dev_err(dev, "%s: No loader platform data\n", __func__);
+		return rc;
+	}
+
+	fw = data->loader_pdata->fw;
+	if (fw == NULL || fw->img == NULL || fw->size == 0) {
+		dev_err(dev, "%s: No platform firmware\n", __func__);
+		return rc;
+	}
+
+	if (fw->ver == NULL || fw->vsize == 0) {
+		dev_err(dev, "%s: No platform firmware version\n",
+			__func__);
+		return rc;
+	}
+
+	if (forced)
+		upgrade = forced;
+	else
+		upgrade = cyttsp4_check_firmware_version_platform(ttsp, fw);
+
+	if (upgrade)
+		return cyttsp4_upgrade_firmware(ttsp, fw->img, fw->size);
+
+	return rc;
+}
+#endif /* CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE */
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+static void _cyttsp4_firmware_cont(const struct firmware *fw, void *context)
+{
+	struct cyttsp4_device *ttsp = context;
+	struct device *dev = &ttsp->dev;
+	u8 header_size = 0;
+
+	if (fw == NULL)
+		goto cyttsp4_firmware_cont_exit;
+
+	if (fw->data == NULL || fw->size == 0) {
+		dev_err(dev,
+			"%s: No firmware received\n", __func__);
+		goto cyttsp4_firmware_cont_release_exit;
+	}
+
+	header_size = fw->data[0];
+	if (header_size >= (fw->size + 1)) {
+		dev_err(dev,
+			"%s: Firmware format is invalid\n", __func__);
+		goto cyttsp4_firmware_cont_release_exit;
+	}
+
+	cyttsp4_upgrade_firmware(ttsp, &(fw->data[header_size + 1]),
+		fw->size - (header_size + 1));
+
+cyttsp4_firmware_cont_release_exit:
+	release_firmware(fw);
+
+cyttsp4_firmware_cont_exit:
+	return;
+}
+
+static int cyttsp4_check_firmware_version_builtin(struct cyttsp4_device *ttsp,
+		const struct firmware *fw)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	u32 fw_ver_new;
+	u32 fw_revctrl_new_h;
+	u32 fw_revctrl_new_l;
+	int upgrade;
+
+	if (!data->si) {
+		dev_info(dev, "%s: No firmware infomation found, device FW may be corrupted\n",
+			__func__);
+		return CYTTSP4_AUTO_LOAD_FOR_CORRUPTED_FW;
+	}
+
+	fw_ver_new = get_unaligned_be16(fw->data + 3);
+	fw_revctrl_new_h = get_unaligned_be32(fw->data + 5);
+	fw_revctrl_new_l = get_unaligned_be32(fw->data + 9);
+
+	upgrade = cyttsp4_check_firmware_version(ttsp, fw_ver_new,
+			fw_revctrl_new_h, fw_revctrl_new_l);
+
+	if (upgrade > 0)
+		return 1;
+
+	return 0;
+}
+
+static void _cyttsp4_firmware_cont_builtin(const struct firmware *fw,
+		void *context)
+{
+	struct cyttsp4_device *ttsp = context;
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	int upgrade;
+
+	if (fw == NULL) {
+		dev_info(dev, "%s: No builtin firmware\n", __func__);
+		goto _cyttsp4_firmware_cont_builtin_exit;
+	}
+
+	if (fw->data == NULL || fw->size == 0) {
+		dev_err(dev, "%s: Invalid builtin firmware\n", __func__);
+		goto _cyttsp4_firmware_cont_builtin_exit;
+	}
+
+	dev_dbg(dev, "%s: Found firmware\n", __func__);
+
+	upgrade = cyttsp4_check_firmware_version_builtin(ttsp, fw);
+	if (upgrade) {
+		_cyttsp4_firmware_cont(fw, ttsp);
+		data->builtin_bin_fw_status = 0;
+		complete(&data->builtin_bin_fw_complete);
+		return;
+	}
+
+_cyttsp4_firmware_cont_builtin_exit:
+	release_firmware(fw);
+
+	data->builtin_bin_fw_status = -EINVAL;
+	complete(&data->builtin_bin_fw_complete);
+}
+
+static int upgrade_firmware_from_class(struct cyttsp4_device *ttsp)
+{
+	int retval;
+
+	dev_vdbg(&ttsp->dev, "%s: Enabling firmware class loader\n", __func__);
+
+	retval = request_firmware_nowait(THIS_MODULE, FW_ACTION_NOHOTPLUG, "",
+			&ttsp->dev, GFP_KERNEL, ttsp, _cyttsp4_firmware_cont);
+	if (retval < 0) {
+		dev_err(&ttsp->dev, "%s: Fail request firmware class file load\n",
+			__func__);
+		return retval;
+	}
+
+	return 0;
+}
+
+static int upgrade_firmware_from_builtin(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	int retval;
+
+	dev_vdbg(dev, "%s: Enabling firmware class loader built-in\n",
+		__func__);
+
+	retval = request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
+			CY_FW_FILE_NAME, dev, GFP_KERNEL, ttsp,
+			_cyttsp4_firmware_cont_builtin);
+	if (retval < 0) {
+		dev_err(dev, "%s: Fail request firmware class file load\n",
+			__func__);
+		return retval;
+	}
+
+	/* wait until FW binary upgrade finishes */
+	wait_for_completion(&data->builtin_bin_fw_complete);
+
+	return data->builtin_bin_fw_status;
+}
+#endif /* CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE */
+
+#if CYTTSP4_TTCONFIG_UPGRADE
+static int cyttsp4_upgrade_ttconfig(struct cyttsp4_device *ttsp,
+		const u8 *ttconfig_data, int ttconfig_size)
+{
+	struct device *dev = &ttsp->dev;
+	int rc, rc2;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	pm_runtime_get_sync(dev);
+
+	dev_vdbg(dev, "%s: Requesting exclusive\n", __func__);
+	rc = cyttsp4_request_exclusive(ttsp, CY_LDR_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto exit;
+	}
+
+	dev_vdbg(dev, "%s: Requesting mode change to CAT\n", __func__);
+	rc = cyttsp4_request_set_mode(ttsp, CY_MODE_CAT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc);
+		goto exit_release;
+	}
+
+	rc = cyttsp4_request_write_config(ttsp, CY_TCH_PARM_EBID,
+			0, (u8 *)ttconfig_data, ttconfig_size);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request write config r=%d\n",
+				__func__, rc);
+		goto exit_setmode;
+	}
+
+exit_setmode:
+	rc2 = cyttsp4_request_set_mode(ttsp, CY_MODE_OPERATIONAL);
+	if (rc2 < 0)
+		dev_err(dev, "%s: Error on request set mode r=%d\n",
+				__func__, rc2);
+
+exit_release:
+	rc2 = cyttsp4_release_exclusive(ttsp);
+	if (rc < 0)
+		dev_err(dev, "%s: Error on release exclusive r=%d\n",
+				__func__, rc2);
+
+exit:
+	if (!rc)
+		cyttsp4_request_restart(ttsp, true);
+
+	pm_runtime_put(dev);
+
+	return rc;
+}
+#endif /* CYTTSP4_TTCONFIG_UPGRADE */
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_TTCONFIG_UPGRADE
+static int cyttsp4_get_ttconfig_crc(struct cyttsp4_device *ttsp,
+		const u8 *ttconfig_data, int ttconfig_size, u16 *crc)
+{
+	u16 crc_loc;
+
+	crc_loc = get_unaligned_le16(&ttconfig_data[2]);
+	if (ttconfig_size < crc_loc + 2)
+		return -EINVAL;
+
+	*crc = get_unaligned_le16(&ttconfig_data[crc_loc]);
+
+	return 0;
+}
+
+static int cyttsp4_get_ttconfig_version(struct cyttsp4_device *ttsp,
+		const u8 *ttconfig_data, int ttconfig_size, u16 *version)
+{
+	if (ttconfig_size < CY_TTCONFIG_VERSION_OFFSET
+			+ CY_TTCONFIG_VERSION_SIZE)
+		return -EINVAL;
+
+	*version = get_unaligned_le16(
+		&ttconfig_data[CY_TTCONFIG_VERSION_OFFSET]);
+
+	return 0;
+}
+
+static int cyttsp4_check_ttconfig_version(struct cyttsp4_device *ttsp,
+		const u8 *ttconfig_data, int ttconfig_size)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	int rc;
+
+	if (!data->si)
+		return 0;
+
+	/* Check if device POST config CRC test failed */
+	if (!(data->si->si_ptrs.test->post_codel &
+			CY_POST_CODEL_CFG_DATA_CRC_FAIL)) {
+		dev_info(dev, "%s: Config CRC invalid, will upgrade\n",
+			__func__);
+		return 1;
+	}
+
+	/* Check for config version */
+	if (data->loader_pdata->flags &
+			CY_LOADER_FLAG_CHECK_TTCONFIG_VERSION) {
+		u16 cfg_ver_new;
+
+		rc = cyttsp4_get_ttconfig_version(ttsp, ttconfig_data,
+				ttconfig_size, &cfg_ver_new);
+		if (rc)
+			return 0;
+
+		dev_dbg(dev, "%s: img_ver:0x%04X new_ver:0x%04X\n",
+			__func__, data->si->ttconfig.version, cfg_ver_new);
+
+		/* Check if config version is newer */
+		if (cfg_ver_new > data->si->ttconfig.version) {
+			dev_dbg(dev, "%s: Config version newer, will upgrade\n",
+				__func__);
+			return 1;
+		}
+
+		dev_dbg(dev, "%s: Config version is identical or older, will NOT upgrade\n",
+			__func__);
+	/* Check for config CRC */
+	} else {
+		u16 cfg_crc_new;
+
+		rc = cyttsp4_get_ttconfig_crc(ttsp, ttconfig_data,
+				ttconfig_size, &cfg_crc_new);
+		if (rc)
+			return 0;
+
+		dev_dbg(dev, "%s: img_crc:0x%04X new_crc:0x%04X\n",
+			__func__, data->si->ttconfig.crc, cfg_crc_new);
+
+		/* Check if config CRC different. */
+		if (cfg_crc_new != data->si->ttconfig.crc) {
+			dev_dbg(dev, "%s: Config CRC different, will upgrade\n",
+				__func__);
+			return 1;
+		}
+
+		dev_dbg(dev, "%s: Config CRC equal, will NOT upgrade\n",
+			__func__);
+	}
+
+	return 0;
+}
+
+static int cyttsp4_check_ttconfig_version_platform(struct cyttsp4_device *ttsp,
+		struct cyttsp4_touch_config *ttconfig)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	u32 fw_ver_config;
+	u32 fw_revctrl_config_h;
+	u32 fw_revctrl_config_l;
+
+	if (!data->si) {
+		dev_info(dev, "%s: No firmware infomation found, device FW may be corrupted\n",
+			__func__);
+		return 0;
+	}
+
+	fw_ver_config = get_unaligned_be16(ttconfig->fw_ver + 2);
+	fw_revctrl_config_h = get_unaligned_be32(ttconfig->fw_ver + 4);
+	fw_revctrl_config_l = get_unaligned_be32(ttconfig->fw_ver + 8);
+
+	/* FW versions should match */
+	if (cyttsp4_check_firmware_version(ttsp, fw_ver_config,
+			fw_revctrl_config_h, fw_revctrl_config_l)) {
+		dev_err(dev, "%s: FW versions mismatch\n", __func__);
+		return 0;
+	}
+
+	return cyttsp4_check_ttconfig_version(ttsp, ttconfig->param_regs->data,
+			ttconfig->param_regs->size);
+}
+
+static int upgrade_ttconfig_from_platform(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	struct cyttsp4_touch_config *ttconfig;
+	struct touch_settings *param_regs;
+	struct cyttsp4_touch_fw;
+	int rc = -ENOSYS;
+	int upgrade;
+
+	if (data->loader_pdata == NULL) {
+		dev_info(dev, "%s: No loader platform data\n", __func__);
+		return rc;
+	}
+
+	ttconfig = data->loader_pdata->ttconfig;
+	if (ttconfig == NULL) {
+		dev_info(dev, "%s: No ttconfig data\n", __func__);
+		return rc;
+	}
+
+	param_regs = ttconfig->param_regs;
+	if (param_regs == NULL) {
+		dev_info(dev, "%s: No touch parameters\n", __func__);
+		return rc;
+	}
+
+	if (param_regs->data == NULL || param_regs->size == 0) {
+		dev_info(dev, "%s: Invalid touch parameters\n", __func__);
+		return rc;
+	}
+
+	if (ttconfig->fw_ver == NULL || ttconfig->fw_vsize == 0) {
+		dev_info(dev, "%s: Invalid FW version for touch parameters\n",
+			__func__);
+		return rc;
+	}
+
+	upgrade = cyttsp4_check_ttconfig_version_platform(ttsp, ttconfig);
+	if (upgrade)
+		return cyttsp4_upgrade_ttconfig(ttsp, param_regs->data,
+				param_regs->size);
+
+	return rc;
+}
+#endif /* CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_TTCONFIG_UPGRADE */
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE
+static ssize_t cyttsp4_config_data_read(struct file *filp,
+		struct kobject *kobj, struct bin_attribute *bin_attr,
+		char *buf, loff_t offset, size_t count)
+{
+	pr_info("Reading config data is not supported\n");
+	return 0;
+}
+
+static ssize_t cyttsp4_config_data_write(struct file *filp,
+		struct kobject *kobj, struct bin_attribute *bin_attr,
+		char *buf, loff_t offset, size_t count)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	u8 *p;
+
+	dev_vdbg(dev, "%s: offset:%lld count:%d\n", __func__, offset, count);
+
+	mutex_lock(&data->config_lock);
+
+	if (!data->config_loading) {
+		mutex_unlock(&data->config_lock);
+		return -ENODEV;
+	}
+
+	p = krealloc(data->config_data, offset + count, GFP_KERNEL);
+	if (!p) {
+		kfree(data->config_data);
+		data->config_data = NULL;
+		data->config_size = 0;
+		data->config_loading = false;
+		mutex_unlock(&data->config_lock);
+		return -ENOMEM;
+	}
+	data->config_data = p;
+
+	memcpy(&data->config_data[offset], buf, count);
+	data->config_size += count;
+
+	mutex_unlock(&data->config_lock);
+
+	return count;
+}
+
+static struct bin_attribute bin_attr_config_data = {
+	.attr = {
+		.name = "config_data",
+		.mode = S_IWUSR,
+	},
+	.size = 0,
+	.read = cyttsp4_config_data_read,
+	.write = cyttsp4_config_data_write,
+};
+
+static ssize_t cyttsp4_config_loading_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	bool config_loading;
+
+	mutex_lock(&data->config_lock);
+	config_loading = data->config_loading;
+	mutex_unlock(&data->config_lock);
+
+	return snprintf(buf, 4, "%d\n", config_loading);
+}
+
+static int cyttsp4_verify_ttconfig_binary(struct cyttsp4_device *ttsp,
+		u8 *bin_config_data, int bin_config_size, u8 **start, int *len)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	int header_size;
+	u16 config_size;
+	u16 max_config_size;
+	u32 fw_ver_config;
+	u32 fw_revctrl_config_h;
+	u32 fw_revctrl_config_l;
+
+	if (!data->si) {
+		dev_err(dev, "%s: No firmware infomation found, device FW may be corrupted\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	/*
+	 * We need 11 bytes for FW version control info and at
+	 * least 6 bytes in config (Length + Max Length + CRC)
+	 */
+	header_size = bin_config_data[0] + 1;
+	if (header_size < 11 || header_size >= bin_config_size - 6) {
+		dev_err(dev, "%s: Invalid header size %d\n", __func__,
+			header_size);
+		return -EINVAL;
+	}
+
+	fw_ver_config = get_unaligned_be16(&bin_config_data[1]);
+	fw_revctrl_config_h = get_unaligned_be32(&bin_config_data[3]);
+	fw_revctrl_config_l = get_unaligned_be32(&bin_config_data[7]);
+
+	/* FW versions should match */
+	if (cyttsp4_check_firmware_version(ttsp, fw_ver_config,
+			fw_revctrl_config_h, fw_revctrl_config_l)) {
+		dev_err(dev, "%s: FW versions mismatch\n", __func__);
+		return -EINVAL;
+	}
+
+	config_size = get_unaligned_le16(&bin_config_data[header_size]);
+	max_config_size =
+		get_unaligned_le16(&bin_config_data[header_size + 2]);
+	/* Perform a simple size check (2 bytes for CRC) */
+	if (config_size != bin_config_size - header_size - 2) {
+		dev_err(dev, "%s: Config size invalid\n", __func__);
+		return -EINVAL;
+	}
+	/* Perform a size check against device config length */
+	if (config_size != data->si->ttconfig.length
+			|| max_config_size != data->si->ttconfig.max_length) {
+		dev_err(dev, "%s: Config size mismatch\n", __func__);
+		return -EINVAL;
+	}
+
+	*start = &bin_config_data[header_size];
+	*len = bin_config_size - header_size;
+
+	return 0;
+}
+
+/*
+ * 1: Start loading TT Config
+ * 0: End loading TT Config and perform upgrade
+ *-1: Exit loading
+ */
+static ssize_t cyttsp4_config_loading_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	long value;
+	u8 *start;
+	int length;
+	int rc;
+
+	rc = kstrtol(buf, 10, &value);
+	if (rc < 0 || value < -1 || value > 1) {
+		dev_err(dev, "%s: Invalid value\n", __func__);
+		return size;
+	}
+
+	mutex_lock(&data->config_lock);
+
+	if (value == 1)
+		data->config_loading = true;
+	else if (value == -1)
+		data->config_loading = false;
+	else if (value == 0 && data->config_loading) {
+		data->config_loading = false;
+		if (data->config_size == 0) {
+			dev_err(dev, "%s: No config data\n", __func__);
+			goto exit_free;
+		}
+
+		rc = cyttsp4_verify_ttconfig_binary(data->ttsp,
+				data->config_data, data->config_size,
+				&start, &length);
+		if (rc)
+			goto exit_free;
+
+		rc = cyttsp4_upgrade_ttconfig(data->ttsp, start, length);
+	}
+
+exit_free:
+	kfree(data->config_data);
+	data->config_data = NULL;
+	data->config_size = 0;
+
+	mutex_unlock(&data->config_lock);
+
+	if (rc)
+		return rc;
+
+	return size;
+}
+
+static DEVICE_ATTR(config_loading, S_IRUSR | S_IWUSR,
+	cyttsp4_config_loading_show, cyttsp4_config_loading_store);
+#endif /* CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE */
+
+static void cyttsp4_fw_and_config_upgrade(
+		struct work_struct *fw_and_config_upgrade)
+{
+	struct cyttsp4_loader_data *data = container_of(fw_and_config_upgrade,
+			struct cyttsp4_loader_data, fw_and_config_upgrade);
+	struct cyttsp4_device *ttsp = data->ttsp;
+	struct device *dev = &ttsp->dev;
+
+	data->si = cyttsp4_request_sysinfo(ttsp);
+	if (data->si == NULL)
+		dev_err(dev, "%s: Fail get sysinfo pointer from core\n",
+			__func__);
+
+#if !CYTTSP4_FW_UPGRADE
+	dev_info(dev, "%s: No FW upgrade method selected!\n", __func__);
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+	if (!upgrade_firmware_from_platform(ttsp, false))
+		return;
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+	if (!upgrade_firmware_from_builtin(ttsp))
+		return;
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_TTCONFIG_UPGRADE
+	if (!upgrade_ttconfig_from_platform(ttsp))
+		return;
+#endif
+}
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+static ssize_t cyttsp4_forced_upgrade_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int rc;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	rc = upgrade_firmware_from_platform(data->ttsp, true);
+	if (rc)
+		return rc;
+	return size;
+}
+
+static DEVICE_ATTR(forced_upgrade, S_IRUSR | S_IWUSR,
+	NULL, cyttsp4_forced_upgrade_store);
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+static ssize_t cyttsp4_manual_upgrade_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	pr_info("upgrade show is not supported\n");
+	return 0;
+}
+
+static ssize_t cyttsp4_manual_upgrade_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	upgrade_firmware_from_class(data->ttsp);
+	return size;
+}
+
+static DEVICE_ATTR(manual_upgrade, S_IRUSR | S_IWUSR,
+	cyttsp4_manual_upgrade_show, cyttsp4_manual_upgrade_store);
+#endif
+
+static int cyttsp4_loader_probe(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_loader_data *data;
+	struct device *dev = &ttsp->dev;
+	int rc;
+
+	dev_dbg(dev, "%s\n", __func__);
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (data == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto error_alloc_data_failed;
+	}
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+	rc = device_create_file(dev, &dev_attr_forced_upgrade);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create forced_upgrade\n",
+				__func__);
+		goto error_create_forced_upgrade;
+	}
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+	rc = device_create_file(dev, &dev_attr_manual_upgrade);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create manual_upgrade\n",
+				__func__);
+		goto error_create_manual_upgrade;
+	}
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE
+	rc = device_create_file(dev, &dev_attr_config_loading);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create config_loading\n",
+				__func__);
+		goto error_create_config_loading;
+	}
+
+	rc = device_create_bin_file(dev, &bin_attr_config_data);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create config_data\n",
+				__func__);
+		goto error_create_config_data;
+	}
+#endif
+
+	data->loader_pdata = cyttsp4_request_loader_pdata(ttsp);
+	data->ttsp = ttsp;
+	dev_set_drvdata(dev, data);
+
+	pm_runtime_enable(dev);
+
+#if CYTTSP4_FW_UPGRADE
+	init_completion(&data->int_running);
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+	init_completion(&data->builtin_bin_fw_complete);
+#endif
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_loader_attention, CY_MODE_BOOTLOADER);
+
+	INIT_WORK(&data->calibration_work, cyttsp4_fw_calibrate);
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE
+	mutex_init(&data->config_lock);
+#endif
+	INIT_WORK(&data->fw_and_config_upgrade, cyttsp4_fw_and_config_upgrade);
+	schedule_work(&data->fw_and_config_upgrade);
+
+	dev_info(dev, "%s: Successful probe %s\n", __func__, ttsp->name);
+	return 0;
+
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE
+error_create_config_data:
+	device_remove_file(dev, &dev_attr_config_loading);
+error_create_config_loading:
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+	device_remove_file(dev, &dev_attr_manual_upgrade);
+#endif
+#endif
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+error_create_manual_upgrade:
+#endif
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+	device_remove_file(dev, &dev_attr_forced_upgrade);
+error_create_forced_upgrade:
+#endif
+	kfree(data);
+error_alloc_data_failed:
+	dev_err(dev, "%s failed.\n", __func__);
+	return rc;
+}
+
+static int cyttsp4_loader_release(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_loader_data *data = dev_get_drvdata(dev);
+	int retval = 0;
+
+	dev_dbg(dev, "%s\n", __func__);
+#if CYTTSP4_FW_UPGRADE
+	retval = cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_loader_attention, CY_MODE_BOOTLOADER);
+	if (retval < 0) {
+		dev_err(dev,
+			"%s: Failed to restart IC with error code %d\n",
+			__func__, retval);
+	}
+#endif
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_MANUAL_TTCONFIG_UPGRADE
+	device_remove_bin_file(dev, &bin_attr_config_data);
+	device_remove_file(dev, &dev_attr_config_loading);
+	kfree(data->config_data);
+#endif
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_BINARY_FW_UPGRADE
+	device_remove_file(dev, &dev_attr_manual_upgrade);
+#endif
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+	device_remove_file(dev, &dev_attr_forced_upgrade);
+#endif
+	dev_set_drvdata(dev, NULL);
+	kfree(data);
+	return retval;
+}
+
+static struct cyttsp4_driver cyttsp4_loader_driver = {
+	.probe = cyttsp4_loader_probe,
+	.remove = cyttsp4_loader_release,
+	.driver = {
+		.name = CYTTSP4_LOADER_NAME,
+		.bus = &cyttsp4_bus_type,
+		.owner = THIS_MODULE,
+	},
+};
+
+static const char cyttsp4_loader_name[] = CYTTSP4_LOADER_NAME;
+static struct cyttsp4_device_info cyttsp4_loader_infos[CY_MAX_NUM_CORE_DEVS];
+
+static char *core_ids[CY_MAX_NUM_CORE_DEVS] = {
+	CY_DEFAULT_CORE_ID,
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static int num_core_ids = 1;
+
+module_param_array(core_ids, charp, &num_core_ids, 0);
+MODULE_PARM_DESC(core_ids,
+	"Core id list of cyttsp4 core devices for loader module");
+
+static int __init cyttsp4_loader_init(void)
+{
+	int rc = 0;
+	int i, j;
+
+	/* Check for invalid or duplicate core_ids */
+	for (i = 0; i < num_core_ids; i++) {
+		if (!strlen(core_ids[i])) {
+			pr_err("%s: core_id %d is empty\n",
+				__func__, i+1);
+			return -EINVAL;
+		}
+		for (j = i+1; j < num_core_ids; j++)
+			if (!strcmp(core_ids[i], core_ids[j])) {
+				pr_err("%s: core_ids %d and %d are same\n",
+					__func__, i+1, j+1);
+				return -EINVAL;
+			}
+	}
+
+	for (i = 0; i < num_core_ids; i++) {
+		cyttsp4_loader_infos[i].name = cyttsp4_loader_name;
+		cyttsp4_loader_infos[i].core_id = core_ids[i];
+		pr_info("%s: Registering loader device for core_id: %s\n",
+			__func__, cyttsp4_loader_infos[i].core_id);
+		rc = cyttsp4_register_device(&cyttsp4_loader_infos[i]);
+		if (rc < 0) {
+			pr_err("%s: Error, failed registering device\n",
+				__func__);
+			goto fail_unregister_devices;
+		}
+	}
+	rc = cyttsp4_register_driver(&cyttsp4_loader_driver);
+	if (rc) {
+		pr_err("%s: Error, failed registering driver\n", __func__);
+		goto fail_unregister_devices;
+	}
+
+	pr_info("%s: Cypress TTSP FW loader (Built %s) rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return 0;
+
+fail_unregister_devices:
+	for (i--; i >= 0; i--) {
+		cyttsp4_unregister_device(cyttsp4_loader_infos[i].name,
+			cyttsp4_loader_infos[i].core_id);
+		pr_info("%s: Unregistering loader device for core_id: %s\n",
+			__func__, cyttsp4_loader_infos[i].core_id);
+	}
+	return rc;
+}
+module_init(cyttsp4_loader_init);
+
+static void __exit cyttsp4_loader_exit(void)
+{
+	int i;
+
+	cyttsp4_unregister_driver(&cyttsp4_loader_driver);
+	for (i = 0; i < num_core_ids; i++) {
+		cyttsp4_unregister_device(cyttsp4_loader_infos[i].name,
+			cyttsp4_loader_infos[i].core_id);
+		pr_info("%s: Unregistering loader device for core_id: %s\n",
+			__func__, cyttsp4_loader_infos[i].core_id);
+	}
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_loader_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard touchscreen FW loader");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_mt_common.c b/drivers/input/touchscreen/cypress/cyttsp4_mt_common.c
new file mode 100644
index 0000000..d1d08da
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_mt_common.c
@@ -0,0 +1,693 @@
+/*
+ * cyttsp4_mt_common.c
+ * Cypress TrueTouch(TM) Standard Product V4 Multi-touch module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ * Copyright (C) 2014 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include "cyttsp4_mt_common.h"
+
+static void cyttsp4_lift_all(struct cyttsp4_mt_data *md)
+{
+	if (!md->si)
+		return;
+
+	if (md->num_prv_rec != 0) {
+		if (md->mt_function.report_slot_liftoff)
+			md->mt_function.report_slot_liftoff(md,
+				md->si->si_ofs.tch_abs[CY_TCH_T].max);
+		input_sync(md->input);
+		md->num_prv_rec = 0;
+	}
+}
+
+static void cyttsp4_mt_process_touch(struct cyttsp4_mt_data *md,
+	struct cyttsp4_touch *touch)
+{
+	struct device *dev = &md->ttsp->dev;
+	int tmp;
+	bool flipped;
+
+	if (md->pdata->flags & CY_MT_FLAG_FLIP) {
+		tmp = touch->abs[CY_TCH_X];
+		touch->abs[CY_TCH_X] = touch->abs[CY_TCH_Y];
+		touch->abs[CY_TCH_Y] = tmp;
+		flipped = true;
+	} else
+		flipped = false;
+
+	if (md->pdata->flags & CY_MT_FLAG_INV_X) {
+		if (flipped)
+			touch->abs[CY_TCH_X] = md->si->si_ofs.max_y -
+				touch->abs[CY_TCH_X];
+		else
+			touch->abs[CY_TCH_X] = md->si->si_ofs.max_x -
+				touch->abs[CY_TCH_X];
+	}
+	if (md->pdata->flags & CY_MT_FLAG_INV_Y) {
+		if (flipped)
+			touch->abs[CY_TCH_Y] = md->si->si_ofs.max_x -
+				touch->abs[CY_TCH_Y];
+		else
+			touch->abs[CY_TCH_Y] = md->si->si_ofs.max_y -
+				touch->abs[CY_TCH_Y];
+	}
+
+	dev_vdbg(dev, "%s: flip=%s inv-x=%s inv-y=%s x=%04X(%d) y=%04X(%d)\n",
+		__func__, flipped ? "true" : "false",
+		md->pdata->flags & CY_MT_FLAG_INV_X ? "true" : "false",
+		md->pdata->flags & CY_MT_FLAG_INV_Y ? "true" : "false",
+		touch->abs[CY_TCH_X], touch->abs[CY_TCH_X],
+		touch->abs[CY_TCH_Y], touch->abs[CY_TCH_Y]);
+}
+
+static void cyttsp4_get_mt_touches(struct cyttsp4_mt_data *md, int num_cur_rec)
+{
+	struct device *dev = &md->ttsp->dev;
+	struct cyttsp4_sysinfo *si = md->si;
+	struct cyttsp4_touch tch;
+	int sig;
+	int i, j, t = 0;
+	int mt_sync_count = 0;
+	DECLARE_BITMAP(ids, max(CY_TMA1036_MAX_TCH, CY_TMA4XX_MAX_TCH));
+
+	bitmap_zero(ids, si->si_ofs.tch_abs[CY_TCH_T].max);
+
+	for (i = 0; i < num_cur_rec; i++) {
+		cyttsp4_get_touch_record(md->ttsp, i, tch.abs);
+
+		/* Discard proximity event */
+		if (tch.abs[CY_TCH_O] == CY_OBJ_PROXIMITY) {
+			dev_dbg(dev, "%s: Discarding proximity event\n",
+				__func__);
+			continue;
+		}
+
+		if ((tch.abs[CY_TCH_T] < md->pdata->frmwrk->abs
+			[(CY_ABS_ID_OST * CY_NUM_ABS_SET) + CY_MIN_OST]) ||
+			(tch.abs[CY_TCH_T] > md->pdata->frmwrk->abs
+			[(CY_ABS_ID_OST * CY_NUM_ABS_SET) + CY_MAX_OST])) {
+			dev_err(dev, "%s: tch=%d -> bad trk_id=%d max_id=%d\n",
+				__func__, i, tch.abs[CY_TCH_T],
+				md->pdata->frmwrk->abs[(CY_ABS_ID_OST *
+				CY_NUM_ABS_SET) + CY_MAX_OST]);
+			if (md->mt_function.input_sync)
+				md->mt_function.input_sync(md->input);
+			mt_sync_count++;
+			continue;
+		}
+
+		/* Process touch */
+		cyttsp4_mt_process_touch(md, &tch);
+
+		/* use 0 based track id's */
+		sig = md->pdata->frmwrk->abs
+			[(CY_ABS_ID_OST * CY_NUM_ABS_SET) + 0];
+		if (sig != CY_IGNORE_VALUE) {
+			t = tch.abs[CY_TCH_T] - md->pdata->frmwrk->abs
+				[(CY_ABS_ID_OST * CY_NUM_ABS_SET) + CY_MIN_OST];
+			if (tch.abs[CY_TCH_E] == CY_EV_LIFTOFF) {
+				dev_dbg(dev, "%s: t=%d e=%d lift-off\n",
+					__func__, t, tch.abs[CY_TCH_E]);
+				goto cyttsp4_get_mt_touches_pr_tch;
+			}
+			if (md->mt_function.input_report)
+				md->mt_function.input_report(md->input, sig,
+					t, tch.abs[CY_TCH_O]);
+			__set_bit(t, ids);
+		}
+
+		/* all devices: position and pressure fields */
+		for (j = 0; j <= CY_ABS_W_OST; j++) {
+			sig = md->pdata->frmwrk->abs[((CY_ABS_X_OST + j) *
+				CY_NUM_ABS_SET) + 0];
+			if (sig != CY_IGNORE_VALUE)
+				input_report_abs(md->input, sig,
+					tch.abs[CY_TCH_X + j]);
+		}
+		if (IS_TTSP_VER_GE(si, 2, 3)) {
+			/*
+			 * TMA400 size and orientation fields:
+			 * if pressure is non-zero and major touch
+			 * signal is zero, then set major and minor touch
+			 * signals to minimum non-zero value
+			 */
+			if (tch.abs[CY_TCH_P] > 0 && tch.abs[CY_TCH_MAJ] == 0)
+				tch.abs[CY_TCH_MAJ] = tch.abs[CY_TCH_MIN] = 1;
+
+			/* Get the extended touch fields */
+			for (j = 0; j < CY_NUM_EXT_TCH_FIELDS; j++) {
+				sig = md->pdata->frmwrk->abs
+					[((CY_ABS_MAJ_OST + j) *
+					CY_NUM_ABS_SET) + 0];
+				if (sig != CY_IGNORE_VALUE)
+					input_report_abs(md->input, sig,
+						tch.abs[CY_TCH_MAJ + j]);
+			}
+		}
+		if (md->mt_function.input_sync)
+			md->mt_function.input_sync(md->input);
+		mt_sync_count++;
+
+cyttsp4_get_mt_touches_pr_tch:
+		if (IS_TTSP_VER_GE(si, 2, 3))
+			dev_dbg(dev,
+				"%s: t=%d x=%d y=%d z=%d M=%d m=%d o=%d e=%d\n",
+				__func__, t,
+				tch.abs[CY_TCH_X],
+				tch.abs[CY_TCH_Y],
+				tch.abs[CY_TCH_P],
+				tch.abs[CY_TCH_MAJ],
+				tch.abs[CY_TCH_MIN],
+				tch.abs[CY_TCH_OR],
+				tch.abs[CY_TCH_E]);
+		else
+			dev_dbg(dev,
+				"%s: t=%d x=%d y=%d z=%d e=%d\n", __func__,
+				t,
+				tch.abs[CY_TCH_X],
+				tch.abs[CY_TCH_Y],
+				tch.abs[CY_TCH_P],
+				tch.abs[CY_TCH_E]);
+	}
+
+	if (md->mt_function.final_sync)
+		md->mt_function.final_sync(md->input,
+			si->si_ofs.tch_abs[CY_TCH_T].max, mt_sync_count, ids);
+
+	md->num_prv_rec = num_cur_rec;
+	md->prv_tch_type = tch.abs[CY_TCH_O];
+
+	return;
+}
+
+/* read xy_data for all current touches */
+static int cyttsp4_xy_worker(struct cyttsp4_mt_data *md)
+{
+	struct device *dev = &md->ttsp->dev;
+	struct cyttsp4_sysinfo *si = md->si;
+	u8 num_cur_rec;
+	u8 rep_len;
+	u8 rep_stat;
+	u8 tt_stat;
+	int rc = 0;
+
+	/*
+	 * Get event data from cyttsp4 device.
+	 * The event data includes all data
+	 * for all active touches.
+	 * Event data also includes button data
+	 */
+	rep_len = si->xy_mode[si->si_ofs.rep_ofs];
+	rep_stat = si->xy_mode[si->si_ofs.rep_ofs + 1];
+	tt_stat = si->xy_mode[si->si_ofs.tt_stat_ofs];
+
+	num_cur_rec = GET_NUM_TOUCH_RECORDS(tt_stat);
+
+	if (rep_len == 0 && num_cur_rec > 0) {
+		dev_err(dev, "%s: report length error rep_len=%d num_tch=%d\n",
+			__func__, rep_len, num_cur_rec);
+		goto cyttsp4_xy_worker_exit;
+	}
+
+	/* check any error conditions */
+	if (IS_BAD_PKT(rep_stat)) {
+		dev_dbg(dev, "%s: Invalid buffer detected\n", __func__);
+		rc = 0;
+		goto cyttsp4_xy_worker_exit;
+	}
+
+	if (IS_LARGE_AREA(tt_stat)) {
+		dev_dbg(dev, "%s: Large area detected\n", __func__);
+		/* Do not report touch if configured so */
+		if (md->pdata->flags & CY_MT_FLAG_NO_TOUCH_ON_LO)
+			num_cur_rec = 0;
+	}
+
+	if (num_cur_rec > si->si_ofs.max_tchs) {
+		dev_err(dev, "%s: %s (n=%d c=%d)\n", __func__,
+			"too many tch; set to max tch",
+			num_cur_rec, si->si_ofs.max_tchs);
+		num_cur_rec = si->si_ofs.max_tchs;
+	}
+
+	/* extract xy_data for all currently reported touches */
+	dev_vdbg(dev, "%s: extract data num_cur_rec=%d\n", __func__,
+		num_cur_rec);
+	if (num_cur_rec)
+		cyttsp4_get_mt_touches(md, num_cur_rec);
+	else
+		cyttsp4_lift_all(md);
+
+	dev_vdbg(dev, "%s: done\n", __func__);
+	rc = 0;
+
+cyttsp4_xy_worker_exit:
+	return rc;
+}
+
+static void cyttsp4_mt_send_dummy_event(struct cyttsp4_mt_data *md)
+{
+	unsigned long ids = 0;
+
+	/* for easy wakeup */
+	if (md->mt_function.input_report)
+		md->mt_function.input_report(md->input, ABS_MT_TRACKING_ID,
+			0, CY_OBJ_STANDARD_FINGER);
+	if (md->mt_function.input_sync)
+		md->mt_function.input_sync(md->input);
+	if (md->mt_function.final_sync)
+		md->mt_function.final_sync(md->input, 0, 1, &ids);
+	if (md->mt_function.report_slot_liftoff)
+		md->mt_function.report_slot_liftoff(md, 1);
+	if (md->mt_function.final_sync)
+		md->mt_function.final_sync(md->input, 1, 1, &ids);
+}
+
+static int cyttsp4_mt_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+	int rc = 0;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	mutex_lock(&md->report_lock);
+	if (!md->is_suspended) {
+		/* core handles handshake */
+		rc = cyttsp4_xy_worker(md);
+	}
+	mutex_unlock(&md->report_lock);
+	if (rc < 0)
+		dev_err(dev, "%s: xy_worker error r=%d\n", __func__, rc);
+
+	return rc;
+}
+
+static int cyttsp4_mt_wake_attention(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_mt_data *md = dev_get_drvdata(&ttsp->dev);
+
+	mutex_lock(&md->report_lock);
+	cyttsp4_mt_send_dummy_event(md);
+	mutex_unlock(&md->report_lock);
+	return 0;
+}
+
+static int cyttsp4_startup_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+	int rc = 0;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	mutex_lock(&md->report_lock);
+	cyttsp4_lift_all(md);
+	mutex_unlock(&md->report_lock);
+	return rc;
+}
+
+static int cyttsp4_mt_open(struct input_dev *input)
+{
+	struct device *dev = input->dev.parent;
+	struct cyttsp4_device *ttsp =
+		container_of(dev, struct cyttsp4_device, dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	pm_runtime_get(dev);
+
+	dev_vdbg(dev, "%s: setup subscriptions\n", __func__);
+
+	/* set up touch call back */
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_mt_attention, CY_MODE_OPERATIONAL);
+
+	/* set up startup call back */
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_startup_attention, 0);
+
+	/* set up wakeup call back */
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_WAKE,
+		cyttsp4_mt_wake_attention, 0);
+
+	return 0;
+}
+
+static void cyttsp4_mt_close(struct input_dev *input)
+{
+	struct device *dev = input->dev.parent;
+	struct cyttsp4_device *ttsp =
+		container_of(dev, struct cyttsp4_device, dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_mt_attention, CY_MODE_OPERATIONAL);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_startup_attention, 0);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_WAKE,
+		cyttsp4_mt_wake_attention, 0);
+
+	pm_runtime_put(dev);
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void cyttsp4_mt_early_suspend(struct early_suspend *h)
+{
+	struct cyttsp4_mt_data *md =
+		container_of(h, struct cyttsp4_mt_data, es);
+	struct device *dev = &md->ttsp->dev;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+#ifndef CONFIG_PM_RUNTIME
+	mutex_lock(&md->report_lock);
+	md->is_suspended = true;
+	cyttsp4_lift_all(md);
+	mutex_unlock(&md->report_lock);
+#endif
+
+	pm_runtime_put(dev);
+}
+
+static void cyttsp4_mt_late_resume(struct early_suspend *h)
+{
+	struct cyttsp4_mt_data *md =
+		container_of(h, struct cyttsp4_mt_data, es);
+	struct device *dev = &md->ttsp->dev;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+#ifndef CONFIG_PM_RUNTIME
+	mutex_lock(&md->report_lock);
+	md->is_suspended = false;
+	mutex_unlock(&md->report_lock);
+#endif
+
+	pm_runtime_get(dev);
+}
+
+static void cyttsp4_setup_early_suspend(struct cyttsp4_mt_data *md)
+{
+	md->es.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	md->es.suspend = cyttsp4_mt_early_suspend;
+	md->es.resume = cyttsp4_mt_late_resume;
+
+	register_early_suspend(&md->es);
+}
+#endif
+
+#if defined(CONFIG_PM_SLEEP) || defined(CONFIG_PM_RUNTIME)
+static int cyttsp4_mt_suspend(struct device *dev)
+{
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&md->report_lock);
+	md->is_suspended = true;
+	cyttsp4_lift_all(md);
+	mutex_unlock(&md->report_lock);
+
+	return 0;
+}
+
+static int cyttsp4_mt_rt_resume(struct device *dev)
+{
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&md->report_lock);
+	md->is_suspended = false;
+	mutex_unlock(&md->report_lock);
+
+	return 0;
+}
+
+static int cyttsp4_mt_resume(struct device *dev)
+{
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops cyttsp4_mt_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(cyttsp4_mt_suspend, cyttsp4_mt_resume)
+	SET_RUNTIME_PM_OPS(cyttsp4_mt_suspend, cyttsp4_mt_rt_resume, NULL)
+};
+
+static int cyttsp4_setup_input_device(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+	int signal = CY_IGNORE_VALUE;
+	int max_x, max_y, max_p, min, max;
+	int max_x_tmp, max_y_tmp;
+	int i;
+	int rc;
+
+	dev_vdbg(dev, "%s: Initialize event signals\n", __func__);
+	__set_bit(EV_ABS, md->input->evbit);
+	__set_bit(EV_REL, md->input->evbit);
+	__set_bit(EV_KEY, md->input->evbit);
+#ifdef INPUT_PROP_DIRECT
+	__set_bit(INPUT_PROP_DIRECT, md->input->propbit);
+#endif
+
+	/* If virtualkeys enabled, don't use all screen */
+	if (md->pdata->flags & CY_MT_FLAG_VKEYS) {
+		max_x_tmp = md->pdata->vkeys_x;
+		max_y_tmp = md->pdata->vkeys_y;
+	} else {
+		max_x_tmp = md->si->si_ofs.max_x;
+		max_y_tmp = md->si->si_ofs.max_y;
+	}
+
+	/* get maximum values from the sysinfo data */
+	if (md->pdata->flags & CY_MT_FLAG_FLIP) {
+		max_x = max_y_tmp - 1;
+		max_y = max_x_tmp - 1;
+	} else {
+		max_x = max_x_tmp - 1;
+		max_y = max_y_tmp - 1;
+	}
+	max_p = md->si->si_ofs.max_p;
+
+	/* set event signal capabilities */
+	for (i = 0; i < (md->pdata->frmwrk->size / CY_NUM_ABS_SET); i++) {
+		signal = md->pdata->frmwrk->abs
+			[(i * CY_NUM_ABS_SET) + CY_SIGNAL_OST];
+		if (signal != CY_IGNORE_VALUE) {
+			__set_bit(signal, md->input->absbit);
+			min = md->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_MIN_OST];
+			max = md->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_MAX_OST];
+			if (i == CY_ABS_ID_OST) {
+				/* shift track ids down to start at 0 */
+				max = max - min;
+				min = min - min;
+			} else if (i == CY_ABS_X_OST)
+				max = max_x;
+			else if (i == CY_ABS_Y_OST)
+				max = max_y;
+			else if (i == CY_ABS_P_OST)
+				max = max_p;
+			input_set_abs_params(md->input, signal, min, max,
+				md->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_FUZZ_OST],
+				md->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_FLAT_OST]);
+			dev_dbg(dev, "%s: register signal=%02X min=%d max=%d\n",
+				__func__, signal, min, max);
+			if (i == CY_ABS_ID_OST && !IS_TTSP_VER_GE(md->si, 2, 3))
+				break;
+		}
+	}
+
+	rc = md->mt_function.input_register_device(md->input,
+			md->si->si_ofs.tch_abs[CY_TCH_T].max);
+	if (rc < 0)
+		dev_err(dev, "%s: Error, failed register input device r=%d\n",
+			__func__, rc);
+	else
+		md->input_device_registered = true;
+
+	return rc;
+}
+
+static int cyttsp4_setup_input_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+	int rc = 0;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	md->si = cyttsp4_request_sysinfo(ttsp);
+	if (!md->si)
+		return -EINVAL;
+
+	rc = cyttsp4_setup_input_device(ttsp);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_setup_input_attention, 0);
+
+	return rc;
+}
+
+static int cyttsp4_mt_release(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_mt_data *md = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	/*
+	 * This check is to prevent pm_runtime usage_count drop below zero
+	 * because of removing the module while in suspended state
+	 */
+	if (md->is_suspended)
+		pm_runtime_get_noresume(dev);
+
+	unregister_early_suspend(&md->es);
+#endif
+
+	if (md->input_device_registered) {
+		input_unregister_device(md->input);
+	} else {
+		input_free_device(md->input);
+		cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_input_attention, 0);
+	}
+
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+
+	dev_set_drvdata(dev, NULL);
+	kfree(md);
+	return 0;
+}
+
+static int cyttsp4_mt_probe(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_mt_data *md;
+	struct cyttsp4_mt_platform_data *pdata = dev_get_platdata(dev);
+	int rc = 0;
+
+	dev_info(dev, "%s\n", __func__);
+	dev_dbg(dev, "%s: debug on\n", __func__);
+	dev_vdbg(dev, "%s: verbose debug on\n", __func__);
+
+	if (pdata == NULL) {
+		dev_err(dev, "%s: Missing platform data\n", __func__);
+		rc = -ENODEV;
+		goto error_no_pdata;
+	}
+
+	md = kzalloc(sizeof(*md), GFP_KERNEL);
+	if (md == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto error_alloc_data_failed;
+	}
+
+	cyttsp4_init_function_ptrs(md);
+
+	mutex_init(&md->report_lock);
+	md->prv_tch_type = CY_OBJ_STANDARD_FINGER;
+	md->ttsp = ttsp;
+	md->pdata = pdata;
+	dev_set_drvdata(dev, md);
+	/* Create the input device and register it. */
+	dev_vdbg(dev, "%s: Create the input device and register it\n",
+		__func__);
+	md->input = input_allocate_device();
+	if (md->input == NULL) {
+		dev_err(dev, "%s: Error, failed to allocate input device\n",
+			__func__);
+		rc = -ENOSYS;
+		goto error_alloc_failed;
+	}
+
+	md->input->name = ttsp->name;
+	scnprintf(md->phys, sizeof(md->phys)-1, "%s", dev_name(dev));
+	md->input->phys = md->phys;
+	md->input->dev.parent = &md->ttsp->dev;
+	md->input->open = cyttsp4_mt_open;
+	md->input->close = cyttsp4_mt_close;
+	input_set_drvdata(md->input, md);
+
+	pm_runtime_enable(dev);
+
+	/* get sysinfo */
+	md->si = cyttsp4_request_sysinfo(ttsp);
+	if (md->si) {
+		rc = cyttsp4_setup_input_device(ttsp);
+		if (rc)
+			goto error_init_input;
+	} else {
+		dev_err(dev, "%s: Fail get sysinfo pointer from core p=%p\n",
+			__func__, md->si);
+		cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_input_attention, 0);
+	}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	cyttsp4_setup_early_suspend(md);
+#endif
+
+	dev_dbg(dev, "%s: OK\n", __func__);
+	return 0;
+
+error_init_input:
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+	input_free_device(md->input);
+error_alloc_failed:
+	dev_set_drvdata(dev, NULL);
+	kfree(md);
+error_alloc_data_failed:
+error_no_pdata:
+	dev_err(dev, "%s failed.\n", __func__);
+	return rc;
+}
+
+struct cyttsp4_driver cyttsp4_mt_driver = {
+	.probe = cyttsp4_mt_probe,
+	.remove = cyttsp4_mt_release,
+	.driver = {
+		.name = CYTTSP4_MT_NAME,
+		.bus = &cyttsp4_bus_type,
+		.pm = &cyttsp4_mt_pm_ops,
+	},
+};
+
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_mt_common.h b/drivers/input/touchscreen/cypress/cyttsp4_mt_common.h
new file mode 100644
index 0000000..73c19c2
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_mt_common.h
@@ -0,0 +1,86 @@
+/*
+ * cyttsp4_mt_common.h
+ * Cypress TrueTouch(TM) Standard Product V4 Multi-touch module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ * Copyright (C) 2014 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/cyttsp4_bus.h>
+
+#include <linux/delay.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/limits.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+
+#include <linux/cyttsp4_core.h>
+#include <linux/cyttsp4_mt.h>
+#include "cyttsp4_regs.h"
+
+struct cyttsp4_mt_data;
+struct cyttsp4_mt_function {
+	int (*mt_release)(struct cyttsp4_device *ttsp);
+	int (*mt_probe)(struct cyttsp4_device *ttsp,
+			struct cyttsp4_mt_data *md);
+	void (*report_slot_liftoff)(struct cyttsp4_mt_data *md, int max_slots);
+	void (*input_sync)(struct input_dev *input);
+	void (*input_report)(struct input_dev *input, int sig, int t,
+			int type);
+	void (*final_sync)(struct input_dev *input, int max_slots,
+			int mt_sync_count, unsigned long *ids);
+	int (*input_register_device)(struct input_dev *input, int max_slots);
+};
+
+struct cyttsp4_mt_data {
+	struct cyttsp4_device *ttsp;
+	struct cyttsp4_mt_platform_data *pdata;
+	struct cyttsp4_sysinfo *si;
+	struct input_dev *input;
+	struct cyttsp4_mt_function mt_function;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend es;
+#endif
+	struct mutex report_lock;
+	bool is_suspended;
+	bool input_device_registered;
+	char phys[NAME_MAX];
+	int num_prv_rec; /* Number of previous touch records */
+	int prv_tch_type;
+#ifdef VERBOSE_DEBUG
+	u8 pr_buf[CY_MAX_PRBUF_SIZE];
+#endif
+};
+
+extern void cyttsp4_init_function_ptrs(struct cyttsp4_mt_data *md);
+extern struct cyttsp4_driver cyttsp4_mt_driver;
+
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_mta.c b/drivers/input/touchscreen/cypress/cyttsp4_mta.c
new file mode 100644
index 0000000..d140df7
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_mta.c
@@ -0,0 +1,108 @@
+/*
+ * cyttsp4_mta.c
+ * Cypress TrueTouch(TM) Standard Product V4 Multi-touch module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ * Copyright (C) 2014 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/input.h>
+#include <linux/cyttsp4_core.h>
+
+#include "cyttsp4_mt_common.h"
+
+static void cyttsp4_final_sync(struct input_dev *input, int max_slots,
+		int mt_sync_count, unsigned long *ids)
+{
+	if (mt_sync_count)
+		input_sync(input);
+}
+
+static void cyttsp4_input_sync(struct input_dev *input)
+{
+	input_mt_sync(input);
+}
+
+static void cyttsp4_input_report(struct input_dev *input, int sig,
+		 int t, int type)
+{
+	if (type == CY_OBJ_STANDARD_FINGER || type == CY_OBJ_GLOVE) {
+		input_report_key(input, BTN_TOOL_FINGER, CY_BTN_PRESSED);
+		input_report_key(input, BTN_TOOL_PEN, CY_BTN_RELEASED);
+	} else if (type == CY_OBJ_STYLUS) {
+		input_report_key(input, BTN_TOOL_PEN, CY_BTN_PRESSED);
+		input_report_key(input, BTN_TOOL_FINGER, CY_BTN_RELEASED);
+	}
+	input_report_key(input, BTN_TOUCH, CY_BTN_PRESSED);
+
+	input_report_abs(input, sig, t);
+}
+
+static void cyttsp4_report_slot_liftoff(struct cyttsp4_mt_data *md,
+		int max_slots)
+{
+	input_report_key(md->input, BTN_TOUCH, CY_BTN_RELEASED);
+	input_report_key(md->input, BTN_TOOL_FINGER, CY_BTN_RELEASED);
+	input_report_key(md->input, BTN_TOOL_PEN, CY_BTN_RELEASED);
+
+}
+
+static int cyttsp4_input_register_device(struct input_dev *input, int max_slots)
+{
+	__set_bit(BTN_TOUCH, input->keybit);
+	__set_bit(BTN_TOOL_FINGER, input->keybit);
+	__set_bit(BTN_TOOL_PEN, input->keybit);
+	return input_register_device(input);
+}
+
+void cyttsp4_init_function_ptrs(struct cyttsp4_mt_data *md)
+{
+	md->mt_function.report_slot_liftoff = cyttsp4_report_slot_liftoff;
+	md->mt_function.final_sync = cyttsp4_final_sync;
+	md->mt_function.input_sync = cyttsp4_input_sync;
+	md->mt_function.input_report = cyttsp4_input_report;
+	md->mt_function.input_register_device = cyttsp4_input_register_device;
+}
+
+static int __init cyttsp4_mt_init(void)
+{
+	int rc;
+	cyttsp4_mt_driver.driver.owner = THIS_MODULE;
+	rc = cyttsp4_register_driver(&cyttsp4_mt_driver);
+	pr_info("%s: Cypress TTSP MT v4 multi-touch (Built %s), rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return rc;
+}
+module_init(cyttsp4_mt_init);
+
+static void __exit cyttsp4_mt_exit(void)
+{
+	cyttsp4_unregister_driver(&cyttsp4_mt_driver);
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_mt_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard 2D multi-touch driver");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_mtb.c b/drivers/input/touchscreen/cypress/cyttsp4_mtb.c
new file mode 100644
index 0000000..1e27f6f
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_mtb.c
@@ -0,0 +1,115 @@
+/*
+ * cyttsp4_mtb.c
+ * Cypress TrueTouch(TM) Standard Product V4 Multi-touch module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ * Copyright (C) 2014 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/cyttsp4_core.h>
+
+#include "cyttsp4_mt_common.h"
+
+static void cyttsp4_final_sync(struct input_dev *input, int max_slots,
+		int mt_sync_count, unsigned long *ids)
+{
+	int t;
+
+	for (t = 0; t < max_slots; t++) {
+		if (test_bit(t, ids))
+			continue;
+		input_mt_slot(input, t);
+		input_mt_report_slot_state(input, MT_TOOL_FINGER, false);
+	}
+
+	input_sync(input);
+}
+
+static void cyttsp4_input_report(struct input_dev *input, int sig,
+		int t, int type)
+{
+	input_mt_slot(input, t);
+
+	if (type == CY_OBJ_STANDARD_FINGER || type == CY_OBJ_GLOVE)
+		input_mt_report_slot_state(input, MT_TOOL_FINGER, true);
+	else if (type == CY_OBJ_STYLUS)
+		input_mt_report_slot_state(input, MT_TOOL_PEN, true);
+}
+
+static void cyttsp4_report_slot_liftoff(struct cyttsp4_mt_data *md,
+		int max_slots)
+{
+	int t;
+
+	if (md->num_prv_rec == 0)
+		return;
+
+	for (t = 0; t < max_slots; t++) {
+		input_mt_slot(md->input, t);
+		input_mt_report_slot_state(md->input,
+			MT_TOOL_FINGER, false);
+	}
+}
+
+static int cyttsp4_input_register_device(struct input_dev *input, int max_slots)
+{
+	input_set_abs_params(input, ABS_MT_TOOL_TYPE,
+			0, MT_TOOL_MAX, 0, 0);
+
+	input_mt_init_slots(input, max_slots, 0);
+	return input_register_device(input);
+}
+
+void cyttsp4_init_function_ptrs(struct cyttsp4_mt_data *md)
+{
+	md->mt_function.report_slot_liftoff = cyttsp4_report_slot_liftoff;
+	md->mt_function.final_sync = cyttsp4_final_sync;
+	md->mt_function.input_sync = NULL;
+	md->mt_function.input_report = cyttsp4_input_report;
+	md->mt_function.input_register_device = cyttsp4_input_register_device;
+}
+
+static int __init cyttsp4_mt_init(void)
+{
+	int rc;
+	cyttsp4_mt_driver.driver.owner = THIS_MODULE;
+	rc = cyttsp4_register_driver(&cyttsp4_mt_driver);
+	pr_info("%s: Cypress TTSP MT v4 multi-touch (Built %s), rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return rc;
+}
+module_init(cyttsp4_mt_init);
+
+static void __exit cyttsp4_mt_exit(void)
+{
+	cyttsp4_unregister_driver(&cyttsp4_mt_driver);
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_mt_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard 2D multi-touch driver");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_platform.c b/drivers/input/touchscreen/cypress/cyttsp4_platform.c
new file mode 100644
index 0000000..8da8f4a
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_platform.c
@@ -0,0 +1,360 @@
+/*
+ * cyttsp4_platform.c
+ * Cypress TrueTouch(TM) Standard Product V4 Platform Module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/regulator/consumer.h>
+#include <linux/err.h>
+
+/* cyttsp */
+#include <linux/cyttsp4_bus.h>
+#include <linux/cyttsp4_core.h>
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_FW_UPGRADE
+#include "cyttsp4_img.h"
+static struct cyttsp4_touch_firmware cyttsp4_firmware = {
+	.img = cyttsp4_img,
+	.size = ARRAY_SIZE(cyttsp4_img),
+	.ver = cyttsp4_ver,
+	.vsize = ARRAY_SIZE(cyttsp4_ver),
+};
+#else
+static struct cyttsp4_touch_firmware cyttsp4_firmware = {
+	.img = NULL,
+	.size = 0,
+	.ver = NULL,
+	.vsize = 0,
+};
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4_PLATFORM_TTCONFIG_UPGRADE
+#include "cyttsp4_params.h"
+static struct touch_settings cyttsp4_sett_param_regs = {
+	.data = (uint8_t *)&cyttsp4_param_regs[0],
+	.size = ARRAY_SIZE(cyttsp4_param_regs),
+	.tag = 0,
+};
+
+static struct touch_settings cyttsp4_sett_param_size = {
+	.data = (uint8_t *)&cyttsp4_param_size[0],
+	.size = ARRAY_SIZE(cyttsp4_param_size),
+	.tag = 0,
+};
+
+static struct cyttsp4_touch_config cyttsp4_ttconfig = {
+	.param_regs = &cyttsp4_sett_param_regs,
+	.param_size = &cyttsp4_sett_param_size,
+	.fw_ver = ttconfig_fw_ver,
+	.fw_vsize = ARRAY_SIZE(ttconfig_fw_ver),
+};
+#else
+static struct cyttsp4_touch_config cyttsp4_ttconfig = {
+	.param_regs = NULL,
+	.param_size = NULL,
+	.fw_ver = NULL,
+	.fw_vsize = 0,
+};
+#endif
+
+struct cyttsp4_loader_platform_data _cyttsp4_loader_platform_data = {
+	.fw = &cyttsp4_firmware,
+	.ttconfig = &cyttsp4_ttconfig,
+	.flags = CY_LOADER_FLAG_NONE,
+};
+
+int cyttsp4_xres(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev)
+{
+	int rst_gpio = pdata->rst_gpio;
+	int rc = 0;
+
+	gpio_set_value(rst_gpio, 1);
+	msleep(20);
+	gpio_set_value(rst_gpio, 0);
+	msleep(40);
+	gpio_set_value(rst_gpio, 1);
+	msleep(20);
+	dev_info(dev,
+		"%s: RESET CYTTSP gpio=%d r=%d\n", __func__,
+		pdata->rst_gpio, rc);
+	return rc;
+}
+
+static int power_init(struct cyttsp4_core_platform_data *data, bool on,
+						struct device *dev)
+{
+	int rc;
+
+	if (!on)
+		goto pwr_deinit;
+
+	data->vdd = regulator_get(dev->parent, "vdd");
+	if (IS_ERR(data->vdd)) {
+		rc = PTR_ERR(data->vdd);
+		dev_err(dev,
+				"Regulator get failed vdd rc=%d\n", rc);
+		return rc;
+	}
+
+	if (regulator_count_voltages(data->vdd) > 0) {
+		rc = regulator_set_voltage(data->vdd, 2600000, 3300000);
+		if (rc) {
+			dev_err(dev, "Regulator set_vtg failed vdd rc=%d\n",
+						rc);
+			goto reg_vdd_put;
+		}
+	}
+
+	data->vcc_i2c = regulator_get(dev->parent, "vcc_i2c");
+	if (IS_ERR(data->vcc_i2c)) {
+		rc = PTR_ERR(data->vcc_i2c);
+		dev_err(dev, "Regulator get failed vcc_i2c rc=%d\n",
+					rc);
+		goto reg_vdd_set_vtg;
+	}
+
+	if (regulator_count_voltages(data->vcc_i2c) > 0) {
+		rc = regulator_set_voltage(data->vcc_i2c, 1800000, 1800000);
+		if (rc) {
+			dev_err(dev, "Regulator set_vtg failed vcc_i2c rc=%d\n",
+						rc);
+			goto reg_vcc_i2c_put;
+		}
+	}
+
+	return 0;
+
+reg_vcc_i2c_put:
+	regulator_put(data->vcc_i2c);
+reg_vdd_set_vtg:
+	if (regulator_count_voltages(data->vdd) > 0)
+		regulator_set_voltage(data->vdd, 0, 3300000);
+reg_vdd_put:
+	regulator_put(data->vdd);
+	return rc;
+
+pwr_deinit:
+	if (regulator_count_voltages(data->vdd) > 0)
+		regulator_set_voltage(data->vdd, 0, 3300000);
+
+	regulator_put(data->vdd);
+
+	if (regulator_count_voltages(data->vcc_i2c) > 0)
+		regulator_set_voltage(data->vcc_i2c, 0, 1800000);
+
+	regulator_put(data->vcc_i2c);
+	return 0;
+}
+
+static int power_on(struct cyttsp4_core_platform_data *data, bool on,
+						struct device *dev)
+{
+	int rc;
+
+	if (!on)
+		goto power_off;
+
+	rc = regulator_enable(data->vdd);
+	if (rc) {
+		dev_err(dev,
+				"Regulator vdd enable failed rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = regulator_enable(data->vcc_i2c);
+	if (rc) {
+		dev_err(dev, "Regulator vcc_i2c enable failed rc=%d\n",
+					rc);
+		regulator_disable(data->vdd);
+	}
+
+	return rc;
+
+power_off:
+	rc = regulator_disable(data->vdd);
+	if (rc) {
+		dev_err(dev, "Regulator vdd disable failed rc=%d\n",
+					rc);
+		return rc;
+	}
+
+	rc = regulator_disable(data->vcc_i2c);
+	if (rc) {
+		dev_err(dev, "Regulator vcc_i2c disable failed rc=%d\n",
+					rc);
+	}
+
+	return rc;
+}
+
+
+int cyttsp4_init(struct cyttsp4_core_platform_data *pdata,
+		int on, struct device *dev)
+{
+	int rst_gpio = pdata->rst_gpio;
+	int irq_gpio = pdata->irq_gpio;
+	int rc = 0;
+
+	if (on) {
+		rc = power_init(pdata, 1, dev);
+		if (rc)
+			dev_err(dev, "%s: power init failed\n", __func__);
+
+		rc = power_on(pdata, 1, dev);
+		if (rc)
+			dev_err(dev, "%s: power on failed\n", __func__);
+
+		rc = gpio_request(rst_gpio, NULL);
+		if (rc < 0) {
+			gpio_free(rst_gpio);
+			rc = gpio_request(rst_gpio, NULL);
+		}
+		if (rc < 0) {
+			dev_err(dev,
+				"%s: Fail request gpio=%d\n", __func__,
+				rst_gpio);
+		} else {
+			rc = gpio_direction_output(rst_gpio, 1);
+			if (rc < 0) {
+				pr_err("%s: Fail set output gpio=%d\n",
+					__func__, rst_gpio);
+				gpio_free(rst_gpio);
+			} else {
+				rc = gpio_request(irq_gpio, NULL);
+				if (rc < 0) {
+					gpio_free(irq_gpio);
+					rc = gpio_request(irq_gpio,
+						NULL);
+				}
+				if (rc < 0) {
+					dev_err(dev,
+						"%s: Fail request gpio=%d\n",
+						__func__, irq_gpio);
+					gpio_free(rst_gpio);
+				} else {
+					gpio_direction_input(irq_gpio);
+				}
+			}
+		}
+	} else {
+		rc = power_on(pdata, 0, dev);
+		if (rc)
+			dev_err(dev, "%s: power on failed\n", __func__);
+		rc = power_init(pdata, 0, dev);
+		if (rc)
+			dev_err(dev, "%s: power init failed\n", __func__);
+
+		gpio_free(rst_gpio);
+		gpio_free(irq_gpio);
+	}
+
+	dev_info(dev,
+		"%s: INIT CYTTSP RST gpio=%d and IRQ gpio=%d r=%d\n",
+		__func__, rst_gpio, irq_gpio, rc);
+	return rc;
+}
+
+static int cyttsp4_wakeup(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev, atomic_t *ignore_irq)
+{
+	int irq_gpio = pdata->irq_gpio;
+	int rc = 0;
+
+	if (ignore_irq)
+		atomic_set(ignore_irq, 1);
+	rc = gpio_direction_output(irq_gpio, 0);
+	if (rc < 0) {
+		if (ignore_irq)
+			atomic_set(ignore_irq, 0);
+		dev_err(dev,
+			"%s: Fail set output gpio=%d\n",
+			__func__, irq_gpio);
+	} else {
+		udelay(2000);
+		rc = gpio_direction_input(irq_gpio);
+		if (ignore_irq)
+			atomic_set(ignore_irq, 0);
+		if (rc < 0) {
+			dev_err(dev,
+				"%s: Fail set input gpio=%d\n",
+				__func__, irq_gpio);
+		}
+	}
+
+	dev_info(dev,
+		"%s: WAKEUP CYTTSP gpio=%d r=%d\n", __func__,
+		irq_gpio, rc);
+	return rc;
+}
+
+static int cyttsp4_sleep(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev, atomic_t *ignore_irq)
+{
+	return 0;
+}
+
+int cyttsp4_power(struct cyttsp4_core_platform_data *pdata,
+		int on, struct device *dev, atomic_t *ignore_irq)
+{
+	if (on)
+		return cyttsp4_wakeup(pdata, dev, ignore_irq);
+
+	return cyttsp4_sleep(pdata, dev, ignore_irq);
+}
+
+int cyttsp4_irq_stat(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev)
+{
+	return gpio_get_value(pdata->irq_gpio);
+}
+
+#ifdef CYTTSP4_DETECT_HW
+int cyttsp4_detect(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev, cyttsp4_platform_read read)
+{
+	int retry = 3;
+	int rc;
+	char buf[1];
+
+	while (retry--) {
+		/* Perform reset, wait for 100 ms and perform read */
+		dev_vdbg(dev, "%s: Performing a reset\n", __func__);
+		pdata->xres(pdata, dev);
+		msleep(100);
+		rc = read(dev, 0, buf, 1);
+		if (!rc)
+			return 0;
+
+		dev_vdbg(dev, "%s: Read unsuccessful, try=%d\n",
+			__func__, 3 - retry);
+	}
+
+	return rc;
+}
+#endif
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_proximity.c b/drivers/input/touchscreen/cypress/cyttsp4_proximity.c
new file mode 100644
index 0000000..e57f5c0
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_proximity.c
@@ -0,0 +1,585 @@
+/*
+ * cyttsp4_proximity.c
+ * Cypress TrueTouch(TM) Standard Product V4 Proximity touch reports module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/cyttsp4_bus.h>
+
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/limits.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+
+#include <linux/cyttsp4_core.h>
+#include <linux/cyttsp4_mt.h>
+#include <linux/cyttsp4_proximity.h>
+#include "cyttsp4_regs.h"
+
+/* Timeout value in ms. */
+#define CY_PROXIMITY_REQUEST_EXCLUSIVE_TIMEOUT		1000
+
+#define CY_PROXIMITY_ON 0
+#define CY_PROXIMITY_OFF 1
+
+static int cyttsp4_proximity_attention(struct cyttsp4_device *ttsp);
+static int cyttsp4_startup_attention(struct cyttsp4_device *ttsp);
+
+struct cyttsp4_proximity_data {
+	struct cyttsp4_device *ttsp;
+	struct cyttsp4_proximity_platform_data *pdata;
+	struct cyttsp4_sysinfo *si;
+	struct input_dev *input;
+	struct mutex report_lock;
+	struct mutex sysfs_lock;
+	int enable_count;
+	bool is_suspended;
+	bool input_device_registered;
+	char phys[NAME_MAX];
+	u8 pr_buf[CY_MAX_PRBUF_SIZE];
+};
+
+static void cyttsp4_report_proximity(struct cyttsp4_proximity_data *pd,
+	bool on)
+{
+	int val = on ? CY_PROXIMITY_ON : CY_PROXIMITY_OFF;
+
+	input_report_abs(pd->input, ABS_DISTANCE, val);
+	input_sync(pd->input);
+}
+
+static void cyttsp4_get_proximity_touch(struct cyttsp4_proximity_data *pd,
+		int num_cur_rec)
+{
+	struct cyttsp4_touch tch;
+	int i;
+
+	for (i = 0; i < num_cur_rec; i++) {
+		cyttsp4_get_touch_record(pd->ttsp, i, tch.abs);
+
+		/* Check for proximity event */
+		if (tch.abs[CY_TCH_O] == CY_OBJ_PROXIMITY) {
+			if (tch.abs[CY_TCH_E] == CY_EV_TOUCHDOWN)
+				cyttsp4_report_proximity(pd, true);
+			else if (tch.abs[CY_TCH_E] == CY_EV_LIFTOFF)
+				cyttsp4_report_proximity(pd, false);
+			break;
+		}
+	}
+}
+
+/* read xy_data for all current touches */
+static int cyttsp4_xy_worker(struct cyttsp4_proximity_data *pd)
+{
+	struct device *dev = &pd->ttsp->dev;
+	struct cyttsp4_sysinfo *si = pd->si;
+	u8 num_cur_rec;
+	u8 rep_len;
+	u8 rep_stat;
+	u8 tt_stat;
+	int rc = 0;
+
+	/*
+	 * Get event data from cyttsp4 device.
+	 * The event data includes all data
+	 * for all active touches.
+	 * Event data also includes button data
+	 */
+	rep_len = si->xy_mode[si->si_ofs.rep_ofs];
+	rep_stat = si->xy_mode[si->si_ofs.rep_ofs + 1];
+	tt_stat = si->xy_mode[si->si_ofs.tt_stat_ofs];
+
+	num_cur_rec = GET_NUM_TOUCH_RECORDS(tt_stat);
+
+	if (rep_len == 0 && num_cur_rec > 0) {
+		dev_err(dev, "%s: report length error rep_len=%d num_rec=%d\n",
+			__func__, rep_len, num_cur_rec);
+		goto cyttsp4_xy_worker_exit;
+	}
+
+	/* check any error conditions */
+	if (IS_BAD_PKT(rep_stat)) {
+		dev_dbg(dev, "%s: Invalid buffer detected\n", __func__);
+		rc = 0;
+		goto cyttsp4_xy_worker_exit;
+	}
+
+	if (IS_LARGE_AREA(tt_stat))
+		dev_dbg(dev, "%s: Large area detected\n", __func__);
+
+	if (num_cur_rec > si->si_ofs.max_tchs) {
+		dev_err(dev, "%s: %s (n=%d c=%d)\n", __func__,
+			"too many tch; set to max tch",
+			num_cur_rec, si->si_ofs.max_tchs);
+		num_cur_rec = si->si_ofs.max_tchs;
+	}
+
+	/* extract xy_data for all currently reported touches */
+	dev_vdbg(dev, "%s: extract data num_cur_rec=%d\n", __func__,
+		num_cur_rec);
+	if (num_cur_rec)
+		cyttsp4_get_proximity_touch(pd, num_cur_rec);
+	else
+		cyttsp4_report_proximity(pd, false);
+
+	dev_vdbg(dev, "%s: done\n", __func__);
+	rc = 0;
+
+cyttsp4_xy_worker_exit:
+	return rc;
+}
+
+static int _cyttsp4_proximity_enable(struct cyttsp4_proximity_data *pd)
+{
+	struct cyttsp4_device *ttsp = pd->ttsp;
+	struct device *dev = &ttsp->dev;
+	int rc = 0;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	/* We use pm_runtime_get_sync to activate
+	 * the core device until it is disabled back
+	 */
+	pm_runtime_get_sync(dev);
+
+	rc = cyttsp4_request_exclusive(ttsp,
+			CY_PROXIMITY_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto exit;
+	}
+
+	rc = cyttsp4_request_enable_scan_type(ttsp, CY_ST_PROXIMITY);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request enable proximity scantype r=%d\n",
+				__func__, rc);
+		goto exit_release;
+	}
+
+	dev_vdbg(dev, "%s: setup subscriptions\n", __func__);
+
+	/* set up touch call back */
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_IRQ,
+		cyttsp4_proximity_attention, CY_MODE_OPERATIONAL);
+
+	/* set up startup call back */
+	cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_startup_attention, 0);
+
+exit_release:
+	cyttsp4_release_exclusive(ttsp);
+exit:
+	return rc;
+}
+
+static int _cyttsp4_proximity_disable(struct cyttsp4_proximity_data *pd,
+		bool force)
+{
+	struct cyttsp4_device *ttsp = pd->ttsp;
+	struct device *dev = &ttsp->dev;
+	int rc = 0;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	rc = cyttsp4_request_exclusive(ttsp,
+			CY_PROXIMITY_REQUEST_EXCLUSIVE_TIMEOUT);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request exclusive r=%d\n",
+				__func__, rc);
+		goto exit;
+	}
+
+	rc = cyttsp4_request_disable_scan_type(ttsp, CY_ST_PROXIMITY);
+	if (rc < 0) {
+		dev_err(dev, "%s: Error on request disable proximity scan r=%d\n",
+				__func__, rc);
+		goto exit_release;
+	}
+
+exit_release:
+	cyttsp4_release_exclusive(ttsp);
+
+exit:
+	if (!rc || force) {
+		cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_IRQ,
+			cyttsp4_proximity_attention, CY_MODE_OPERATIONAL);
+
+		cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_startup_attention, 0);
+
+		pm_runtime_put(dev);
+	}
+
+	return rc;
+}
+
+static ssize_t cyttsp4_proximity_enable_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+	int val = 0;
+
+	mutex_lock(&pd->sysfs_lock);
+	val = pd->enable_count;
+	mutex_unlock(&pd->sysfs_lock);
+
+	return scnprintf(buf, CY_MAX_PRBUF_SIZE, "%d\n", val);
+}
+
+static ssize_t cyttsp4_proximity_enable_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+	unsigned long value;
+	int rc;
+
+	rc = kstrtoul(buf, 10, &value);
+	if (rc < 0 || (value != 0 && value != 1)) {
+		dev_err(dev, "%s: Invalid value\n", __func__);
+		return -EINVAL;
+	}
+
+	mutex_lock(&pd->sysfs_lock);
+	if (value) {
+		if (pd->enable_count++) {
+			dev_vdbg(dev, "%s: '%s' already enabled\n", __func__,
+				pd->ttsp->name);
+		} else {
+			rc = _cyttsp4_proximity_enable(pd);
+			if (rc)
+				pd->enable_count--;
+		}
+	} else {
+		if (--pd->enable_count) {
+			if (pd->enable_count < 0) {
+				dev_err(dev, "%s: '%s' unbalanced disable\n",
+					__func__, pd->ttsp->name);
+				pd->enable_count = 0;
+			}
+		} else {
+			rc = _cyttsp4_proximity_disable(pd, false);
+			if (rc)
+				pd->enable_count++;
+		}
+	}
+	mutex_unlock(&pd->sysfs_lock);
+
+	if (rc)
+		return rc;
+
+	return size;
+}
+
+static DEVICE_ATTR(enable, S_IRUSR | S_IWUSR,
+		cyttsp4_proximity_enable_show,
+		cyttsp4_proximity_enable_store);
+
+static int cyttsp4_proximity_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+	int rc = 0;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	mutex_lock(&pd->report_lock);
+	if (!pd->is_suspended) {
+		/* core handles handshake */
+		rc = cyttsp4_xy_worker(pd);
+	} else {
+		dev_vdbg(dev, "%s: Ignoring report while suspended\n",
+			__func__);
+	}
+	mutex_unlock(&pd->report_lock);
+	if (rc < 0)
+		dev_err(dev, "%s: xy_worker error r=%d\n", __func__, rc);
+
+	return rc;
+}
+
+static int cyttsp4_startup_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	mutex_lock(&pd->report_lock);
+	cyttsp4_report_proximity(pd, false);
+	mutex_unlock(&pd->report_lock);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_RUNTIME
+static int cyttsp4_proximity_suspend(struct device *dev)
+{
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&pd->report_lock);
+	pd->is_suspended = true;
+	cyttsp4_report_proximity(pd, false);
+	mutex_unlock(&pd->report_lock);
+
+	return 0;
+}
+
+static int cyttsp4_proximity_resume(struct device *dev)
+{
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	mutex_lock(&pd->report_lock);
+	pd->is_suspended = false;
+	mutex_unlock(&pd->report_lock);
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops cyttsp4_proximity_pm_ops = {
+	SET_RUNTIME_PM_OPS(cyttsp4_proximity_suspend,
+		cyttsp4_proximity_resume, NULL)
+};
+
+static int cyttsp4_setup_input_device_and_sysfs(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+	int signal = CY_IGNORE_VALUE;
+	int min, max;
+	int i;
+	int rc;
+
+	rc = device_create_file(dev, &dev_attr_enable);
+	if (rc) {
+		dev_err(dev, "%s: Error, could not create enable\n",
+				__func__);
+		goto exit;
+	}
+
+	dev_vdbg(dev, "%s: Initialize event signals\n", __func__);
+
+	__set_bit(EV_ABS, pd->input->evbit);
+
+	for (i = 0; i < (pd->pdata->frmwrk->size / CY_NUM_ABS_SET); i++) {
+		signal = pd->pdata->frmwrk->abs
+			[(i * CY_NUM_ABS_SET) + CY_SIGNAL_OST];
+		if (signal != CY_IGNORE_VALUE) {
+			min = pd->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_MIN_OST];
+			max = pd->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_MAX_OST];
+			input_set_abs_params(pd->input, signal, min, max,
+				pd->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_FUZZ_OST],
+				pd->pdata->frmwrk->abs
+				[(i * CY_NUM_ABS_SET) + CY_FLAT_OST]);
+		}
+	}
+
+	rc = input_register_device(pd->input);
+	if (rc) {
+		dev_err(dev, "%s: Error, failed register input device r=%d\n",
+			__func__, rc);
+		goto unregister_enable;
+	}
+
+	pd->input_device_registered = true;
+	return rc;
+
+unregister_enable:
+	device_remove_file(dev, &dev_attr_enable);
+exit:
+	return rc;
+}
+
+static int cyttsp4_setup_input_attention(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+	int rc;
+
+	dev_vdbg(dev, "%s\n", __func__);
+
+	pd->si = cyttsp4_request_sysinfo(ttsp);
+	if (!pd->si)
+		return -EINVAL;
+
+	rc = cyttsp4_setup_input_device_and_sysfs(ttsp);
+
+	cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+		cyttsp4_setup_input_attention, 0);
+
+	return rc;
+}
+
+static int cyttsp4_proximity_probe(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_proximity_data *pd;
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_proximity_platform_data *pdata = dev_get_platdata(dev);
+	int rc = 0;
+
+	dev_info(dev, "%s\n", __func__);
+	dev_dbg(dev, "%s: debug on\n", __func__);
+	dev_vdbg(dev, "%s: verbose debug on\n", __func__);
+
+	if (pdata == NULL) {
+		dev_err(dev, "%s: Missing platform data\n", __func__);
+		rc = -ENODEV;
+		goto error_no_pdata;
+	}
+
+	pd = kzalloc(sizeof(*pd), GFP_KERNEL);
+	if (pd == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto error_alloc_data_failed;
+	}
+
+	mutex_init(&pd->report_lock);
+	mutex_init(&pd->sysfs_lock);
+	pd->ttsp = ttsp;
+	pd->pdata = pdata;
+	dev_set_drvdata(dev, pd);
+	/* Create the input device and register it. */
+	dev_vdbg(dev, "%s: Create the input device and register it\n",
+		__func__);
+	pd->input = input_allocate_device();
+	if (pd->input == NULL) {
+		dev_err(dev, "%s: Error, failed to allocate input device\n",
+			__func__);
+		rc = -ENOSYS;
+		goto error_alloc_failed;
+	}
+
+	pd->input->name = ttsp->name;
+	scnprintf(pd->phys, sizeof(pd->phys)-1, "%s", dev_name(dev));
+	pd->input->phys = pd->phys;
+	pd->input->dev.parent = &pd->ttsp->dev;
+	input_set_drvdata(pd->input, pd);
+
+	pm_runtime_enable(dev);
+
+	/* get sysinfo */
+	pd->si = cyttsp4_request_sysinfo(ttsp);
+	if (pd->si) {
+		rc = cyttsp4_setup_input_device_and_sysfs(ttsp);
+		if (rc)
+			goto error_init_input;
+	} else {
+		dev_err(dev, "%s: Fail get sysinfo pointer from core p=%p\n",
+			__func__, pd->si);
+		cyttsp4_subscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_input_attention, 0);
+	}
+
+	dev_dbg(dev, "%s: ok\n", __func__);
+	return 0;
+
+error_init_input:
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+	input_free_device(pd->input);
+error_alloc_failed:
+	dev_set_drvdata(dev, NULL);
+	kfree(pd);
+error_alloc_data_failed:
+error_no_pdata:
+	dev_err(dev, "%s failed.\n", __func__);
+	return rc;
+}
+
+static int cyttsp4_proximity_release(struct cyttsp4_device *ttsp)
+{
+	struct device *dev = &ttsp->dev;
+	struct cyttsp4_proximity_data *pd = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	if (pd->input_device_registered) {
+		/* Disable proximity sensing */
+		mutex_lock(&pd->sysfs_lock);
+		if (pd->enable_count)
+			_cyttsp4_proximity_disable(pd, true);
+		mutex_unlock(&pd->sysfs_lock);
+		device_remove_file(dev, &dev_attr_enable);
+		input_unregister_device(pd->input);
+	} else {
+		input_free_device(pd->input);
+		cyttsp4_unsubscribe_attention(ttsp, CY_ATTEN_STARTUP,
+			cyttsp4_setup_input_attention, 0);
+	}
+
+	pm_runtime_suspend(dev);
+	pm_runtime_disable(dev);
+
+	dev_set_drvdata(dev, NULL);
+	kfree(pd);
+	return 0;
+}
+
+static struct cyttsp4_driver cyttsp4_proximity_driver = {
+	.probe = cyttsp4_proximity_probe,
+	.remove = cyttsp4_proximity_release,
+	.driver = {
+		.name = CYTTSP4_PROXIMITY_NAME,
+		.bus = &cyttsp4_bus_type,
+		.owner = THIS_MODULE,
+		.pm = &cyttsp4_proximity_pm_ops,
+	},
+};
+
+static int __init cyttsp4_proximity_init(void)
+{
+	int rc = 0;
+	rc = cyttsp4_register_driver(&cyttsp4_proximity_driver);
+	pr_info("%s: Cypress TTSP MT v4 Proximity (Built %s), rc=%d\n",
+		 __func__, CY_DRIVER_DATE, rc);
+	return rc;
+}
+module_init(cyttsp4_proximity_init);
+
+static void __exit cyttsp4_proximity_exit(void)
+{
+	cyttsp4_unregister_driver(&cyttsp4_proximity_driver);
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_proximity_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TTSP Proximity driver");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_regs.h b/drivers/input/touchscreen/cypress/cyttsp4_regs.h
new file mode 100644
index 0000000..6c61ae3
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_regs.h
@@ -0,0 +1,578 @@
+/*
+ * cyttsp4_regs.h
+ * Cypress TrueTouch(TM) Standard Product V4 registers.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ * Copyright (C) 2014 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ * Modified by: Cypress Semiconductor to add test modes and commands
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _CYTTSP4_REGS_H
+#define _CYTTSP4_REGS_H
+
+#define CY_FW_FILE_NAME			"cyttsp4_fw.bin"
+
+#define CY_DEFAULT_ADAP_MAX_XFER	512
+#define CY_ADAP_MIN_XFER		140
+
+#define CY_MAX_PRBUF_SIZE		PIPE_BUF
+#define CY_PR_TRUNCATED			" truncated..."
+
+#define CY_DEFAULT_CORE_ID		"main_ttsp_core"
+#define CY_MAX_NUM_CORE_DEVS		5
+
+#define CY_TMA1036_MAX_TCH		0x0E
+#define CY_TMA4XX_MAX_TCH		0x1E
+
+#define IS_BOOTLOADER(hst_mode, reset_detect) \
+		((hst_mode) & 0x01 || (reset_detect) != 0)
+#define IS_BOOTLOADER_IDLE(hst_mode, reset_detect) \
+		((hst_mode) & 0x01 && (reset_detect) & 0x01)
+
+#define GET_HSTMODE(reg)		((reg & 0x70) >> 4)
+#define GET_TOGGLE(reg)			((reg & 0x80) >> 7)
+
+#define IS_LITTLEENDIAN(reg)		((reg & 0x01) == 1)
+#define GET_PANELID(reg)		(reg & 0x07)
+
+#define HI_BYTE(x)			(u8)(((x) >> 8) & 0xFF)
+#define LO_BYTE(x)			(u8)((x) & 0xFF)
+
+#define CY_REG_BASE			0x00
+#define CY_NUM_REVCTRL			8
+#define CY_NUM_DDATA			32
+#define CY_NUM_MDATA			64
+
+#define CY_REG_CAT_CMD			2
+#define CY_CMD_COMPLETE_MASK		(1 << 6)
+#define CY_CMD_MASK			0x3F
+
+#define CY_TTCONFIG_VERSION_OFFSET	8
+#define CY_TTCONFIG_VERSION_SIZE	2
+#define CY_TTCONFIG_VERSION_ROW		0
+
+#define CY_CONFIG_LENGTH_INFO_OFFSET	0
+#define CY_CONFIG_LENGTH_INFO_SIZE	4
+#define CY_CONFIG_LENGTH_OFFSET		0
+#define CY_CONFIG_LENGTH_SIZE		2
+#define CY_CONFIG_MAXLENGTH_OFFSET	2
+#define CY_CONFIG_MAXLENGTH_SIZE	2
+
+enum cyttsp4_ic_ebid {
+	CY_TCH_PARM_EBID,
+	CY_MDATA_EBID,
+	CY_DDATA_EBID,
+	CY_EBID_NUM,
+};
+
+/* touch record system information offset masks and shifts */
+#define CY_BYTE_OFS_MASK		0x1F
+#define CY_BOFS_MASK			0xE0
+#define CY_BOFS_SHIFT			5
+
+/* helpers */
+#define GET_NUM_TOUCH_RECORDS(x)	((x) & 0x1F)
+#define IS_LARGE_AREA(x)		((x) & 0x20)
+#define IS_BAD_PKT(x)			((x) & 0x20)
+#define IS_TTSP_VER_GE(p, maj, min) \
+		((p)->si_ptrs.cydata == NULL ? \
+		0 : \
+		((p)->si_ptrs.cydata->ttsp_ver_major < (maj) ? \
+			0 : \
+			((p)->si_ptrs.cydata->ttsp_ver_minor < (min) ? \
+				0 : \
+				1)))
+
+/* Timeout in ms. */
+#define CY_COMMAND_COMPLETE_TIMEOUT	500
+#define CY_CALIBRATE_COMPLETE_TIMEOUT	5000
+#define CY_WATCHDOG_TIMEOUT		1000
+
+/* drv_debug commands */
+#define CY_DBG_SUSPEND			4
+#define CY_DBG_RESUME			5
+#define CY_DBG_SOFT_RESET		97
+#define CY_DBG_RESET			98
+
+/* scan types */
+#define CY_SCAN_TYPE_GLOVE		0x8
+#define CY_SCAN_TYPE_STYLUS		0x10
+#define CY_SCAN_TYPE_PROXIMITY		0x40
+#define CY_SCAN_TYPE_APA_MC		0x80
+
+enum cyttsp4_hst_mode_bits {
+	CY_HST_TOGGLE      = (1 << 7),
+	CY_HST_MODE_CHANGE = (1 << 3),
+	CY_HST_DEVICE_MODE = (7 << 4),
+	CY_HST_OPERATE     = (0 << 4),
+	CY_HST_SYSINFO     = (1 << 4),
+	CY_HST_CAT         = (2 << 4),
+	CY_HST_LOWPOW      = (1 << 2),
+	CY_HST_SLEEP       = (1 << 1),
+	CY_HST_RESET       = (1 << 0),
+};
+
+enum cyttsp_cmd_bits {
+	CY_CMD_COMPLETE    = (1 << 6),
+};
+
+enum cyttsp4_cmd_cat {
+	CY_CMD_CAT_NULL,
+	CY_CMD_CAT_RESERVED_1,
+	CY_CMD_CAT_GET_CFG_ROW_SZ,
+	CY_CMD_CAT_READ_CFG_BLK,
+	CY_CMD_CAT_WRITE_CFG_BLK,
+	CY_CMD_CAT_RESERVED_2,
+	CY_CMD_CAT_LOAD_SELF_TEST_DATA,
+	CY_CMD_CAT_RUN_SELF_TEST,
+	CY_CMD_CAT_GET_SELF_TEST_RESULT,
+	CY_CMD_CAT_CALIBRATE_IDACS,
+	CY_CMD_CAT_INIT_BASELINES,
+	CY_CMD_CAT_EXEC_PANEL_SCAN,
+	CY_CMD_CAT_RETRIEVE_PANEL_SCAN,
+	CY_CMD_CAT_START_SENSOR_DATA_MODE,
+	CY_CMD_CAT_STOP_SENSOR_DATA_MODE,
+	CY_CMD_CAT_INT_PIN_MODE,
+	CY_CMD_CAT_RETRIEVE_DATA_STRUCTURE,
+	CY_CMD_CAT_VERIFY_CFG_BLK_CRC,
+	CY_CMD_CAT_RESERVED_N,
+};
+
+enum cyttsp4_cmd_op {
+	CY_CMD_OP_NULL,
+	CY_CMD_OP_RESERVED_1,
+	CY_CMD_OP_GET_PARAM,
+	CY_CMD_OP_SET_PARAM,
+	CY_CMD_OP_RESERVED_2,
+	CY_CMD_OP_GET_CRC,
+	CY_CMD_OP_WAIT_FOR_EVENT,
+};
+
+enum cyttsp4_cmd_status {
+	CY_CMD_STATUS_SUCCESS,
+	CY_CMD_STATUS_FAILURE,
+};
+
+/* Operational Mode Command Sizes */
+/* NULL Command */
+#define CY_CMD_OP_NULL_CMD_SZ			1
+#define CY_CMD_OP_NULL_RET_SZ			0
+/* Get Parameter */
+#define CY_CMD_OP_GET_PARAM_CMD_SZ		2
+#define CY_CMD_OP_GET_PARAM_RET_SZ		6
+/* Set Parameter */
+#define CY_CMD_OP_SET_PARAM_CMD_SZ		7
+#define CY_CMD_OP_SET_PARAM_RET_SZ		2
+/* Get Config Block CRC */
+#define CY_CMD_OP_GET_CFG_BLK_CRC_CMD_SZ	2
+#define CY_CMD_OP_GET_CFG_BLK_CRC_RET_SZ	3
+/* Wait For Event */
+#define CY_CMD_OP_WAIT_FOR_EVENT_CMD_SZ		2
+
+/* CaT Mode Command Sizes */
+/* NULL Command */
+#define CY_CMD_CAT_NULL_CMD_SZ			1
+#define CY_CMD_CAT_NULL_RET_SZ			0
+/* Get Config Row Size */
+#define CY_CMD_CAT_GET_CFG_ROW_SIZE_CMD_SZ	1
+#define CY_CMD_CAT_GET_CFG_ROW_SIZE_RET_SZ	2
+/* Read Config Block */
+#define CY_CMD_CAT_READ_CFG_BLK_CMD_SZ		6
+#define CY_CMD_CAT_READ_CFG_BLK_RET_SZ		7 /* + Data */
+#define CY_CMD_CAT_READ_CFG_BLK_RET_HDR_SZ	5
+/* Write Config Block */
+#define CY_CMD_CAT_WRITE_CFG_BLK_CMD_SZ		8 /* + Data + Security Key */
+#define CY_CMD_CAT_WRITE_CFG_BLK_RET_SZ		5
+#define CY_CMD_CAT_WRITE_CFG_BLK_CMD_HDR_SZ	6
+/* Load Self-Test Data */
+#define CY_CMD_CAT_LOAD_SELFTEST_DATA_CMD_SZ	6
+#define CY_CMD_CAT_LOAD_SELFTEST_DATA_RET_SZ	5 /* + Data */
+/* Run Self-Test */
+#define CY_CMD_CAT_RUN_SELFTEST_CMD_SZ		2
+#define CY_CMD_CAT_RUN_SELFTEST_RET_SZ		3
+/* Calibrate IDACs */
+#define CY_CMD_CAT_CALIBRATE_IDAC_CMD_SZ	2
+#define CY_CMD_CAT_CALIBRATE_IDAC_RET_SZ	1
+/* Get Self-Test Results */
+#define CY_CMD_CAT_GET_SELFTEST_RES_CMD_SZ	6
+#define CY_CMD_CAT_GET_SELFTEST_RES_RET_SZ	5 /* + Data */
+/* Initialize Baselines */
+#define CY_CMD_CAT_INIT_BASELINE_CMD_SZ		2
+#define CY_CMD_CAT_INIT_BASELINE_RET_SZ		1
+/* Execute Panel Scan */
+#define CY_CMD_CAT_EXECUTE_PANEL_SCAN_CMD_SZ	1
+#define CY_CMD_CAT_EXECUTE_PANEL_SCAN_RET_SZ	1
+/* Retrieve Panel Scan */
+#define CY_CMD_CAT_RETRIEVE_PANEL_SCAN_CMD_SZ	6
+#define CY_CMD_CAT_RETRIEVE_PANEL_SCAN_RET_SZ	5 /* + Data */
+/* Start Sensor Data Mode */
+#define CY_CMD_CAT_START_SENSOR_MODE_CMD_SZ	1 /* + Data */
+#define CY_CMD_CAT_START_SENSOR_MODE_RET_SZ	0 /* + Data */
+/* Stop Sensor Data Mode */
+#define CY_CMD_CAT_STOP_SENSOR_MODE_CMD_SZ	1
+#define CY_CMD_CAT_STOP_SENSOR_MODE_RET_SZ	0
+/* Interrupt Pin Override */
+#define CY_CMD_CAT_INT_PIN_OVERRIDE_CMD_SZ	2
+#define CY_CMD_CAT_INT_PIN_OVERRIDE_RET_SZ	1
+/* Retrieve Data Structure */
+#define CY_CMD_CAT_RETRIEVE_DATA_STRUCT_CMD_SZ	6
+#define CY_CMD_CAT_RETRIEVE_DATA_STRUCT_RET_SZ	5 /* + Data */
+/* Verify Config Block CRC */
+#define CY_CMD_CAT_VERIFY_CFG_BLK_CRC_CMD_SZ	2
+#define CY_CMD_CAT_VERIFY_CFG_BLK_CRC_RET_SZ	5
+
+#define CY_RAM_ID_ACTIVE_DISTANCE		0x4A
+#define CY_RAM_ID_SCAN_TYPE			0x4B
+#define CY_RAM_ID_LOW_POWER_INTERVAL		0x4C
+#define CY_RAM_ID_REFRESH_INTERVAL		0x4D
+#define CY_RAM_ID_ACTIVE_MODE_TIMEOUT		0x4E
+#define CY_RAM_ID_ACTIVE_LFT_INTERVAL		0x4F
+#define CY_RAM_ID_ACTIVE_DISTANCE2		0x50
+#define CY_RAM_ID_CHARGER_STATUS		0x51
+#define CY_RAM_ID_IMO_TRIM_VALUE		0x52
+#define CY_RAM_ID_FINGER_THRESHOLH		0x93
+#define CY_RAM_ID_DETECT_AREA_MARGIN_X		0x58
+#define CY_RAM_ID_DETECT_AREA_MARGIN_Y		0x59
+#define CY_RAM_ID_GRIP_XEDGE_A			0x70
+#define CY_RAM_ID_GRIP_XEDGE_B			0x71
+#define CY_RAM_ID_GRIP_XEXC_A			0x72
+#define CY_RAM_ID_GRIP_XEXC_B			0x73
+#define CY_RAM_ID_GRIP_YEDGE_A			0x74
+#define CY_RAM_ID_GRIP_YEDGE_B			0x75
+#define CY_RAM_ID_GRIP_YEXC_A			0x76
+#define CY_RAM_ID_GRIP_YEXC_B			0x77
+#define CY_RAM_ID_GRIP_FIRST_EXC		0x78
+#define CY_RAM_ID_GRIP_EXC_EDGE_ORIGIN		0x79
+#define CY_RAM_ID_PROX_ACTIVE_DIST_Z_VALUE	0x9B
+
+enum cyttsp4_scan_type {
+	CY_ST_APA_MC,
+	CY_ST_GLOVE,
+	CY_ST_STYLUS,
+	CY_ST_PROXIMITY,
+};
+
+enum cyttsp4_mode {
+	CY_MODE_UNKNOWN      = 0,
+	CY_MODE_BOOTLOADER   = (1 << 1),
+	CY_MODE_OPERATIONAL  = (1 << 2),
+	CY_MODE_SYSINFO      = (1 << 3),
+	CY_MODE_CAT          = (1 << 4),
+	CY_MODE_STARTUP      = (1 << 5),
+	CY_MODE_LOADER       = (1 << 6),
+	CY_MODE_CHANGE_MODE  = (1 << 7),
+	CY_MODE_CHANGED      = (1 << 8),
+	CY_MODE_CMD_COMPLETE = (1 << 9),
+};
+
+enum cyttsp4_int_state {
+	CY_INT_NONE,
+	CY_INT_IGNORE      = (1 << 0),
+	CY_INT_MODE_CHANGE = (1 << 1),
+	CY_INT_EXEC_CMD    = (1 << 2),
+	CY_INT_AWAKE       = (1 << 3),
+};
+
+enum cyttsp4_ic_grpnum {
+	CY_IC_GRPNUM_RESERVED,
+	CY_IC_GRPNUM_CMD_REGS,
+	CY_IC_GRPNUM_TCH_REP,
+	CY_IC_GRPNUM_DATA_REC,
+	CY_IC_GRPNUM_TEST_REC,
+	CY_IC_GRPNUM_PCFG_REC,
+	CY_IC_GRPNUM_TCH_PARM_VAL,
+	CY_IC_GRPNUM_TCH_PARM_SIZE,
+	CY_IC_GRPNUM_RESERVED1,
+	CY_IC_GRPNUM_RESERVED2,
+	CY_IC_GRPNUM_OPCFG_REC,
+	CY_IC_GRPNUM_DDATA_REC,
+	CY_IC_GRPNUM_MDATA_REC,
+	CY_IC_GRPNUM_TEST_REGS,
+	CY_IC_GRPNUM_BTN_KEYS,
+	CY_IC_GRPNUM_TTHE_REGS,
+	CY_IC_GRPNUM_NUM
+};
+
+enum cyttsp4_event_id {
+	CY_EV_NO_EVENT,
+	CY_EV_TOUCHDOWN,
+	CY_EV_MOVE,		/* significant displacement (> act dist) */
+	CY_EV_LIFTOFF,		/* record reports last position */
+};
+
+enum cyttsp4_object_id {
+	CY_OBJ_STANDARD_FINGER = 0,
+	CY_OBJ_PROXIMITY       = 1,
+	CY_OBJ_STYLUS          = 2,
+	CY_OBJ_GLOVE           = 4,
+};
+
+#define CY_POST_CODEL_WDG_RST           0x01
+#define CY_POST_CODEL_CFG_DATA_CRC_FAIL 0x02
+#define CY_POST_CODEL_PANEL_TEST_FAIL   0x04
+
+/* test mode NULL command driver codes */
+enum cyttsp4_null_test_cmd_code {
+	CY_NULL_CMD_NULL,
+	CY_NULL_CMD_MODE,
+	CY_NULL_CMD_STATUS_SIZE,
+	CY_NULL_CMD_HANDSHAKE,
+	CY_NULL_CMD_LOW_POWER,
+};
+
+enum cyttsp4_test_mode {
+	CY_TEST_MODE_NORMAL_OP,		/* Send touch data to OS; normal op */
+	CY_TEST_MODE_CAT,		/* Configuration and Test */
+	CY_TEST_MODE_SYSINFO,		/* System information mode */
+	CY_TEST_MODE_CLOSED_UNIT,	/* Send scan data to sysfs */
+};
+
+struct cyttsp4_test_mode_params {
+	int cur_mode;
+	int cur_cmd;
+	size_t cur_status_size;
+};
+
+/* GEN4/SOLO Operational interface definitions */
+/* TTSP System Information interface definitions */
+struct cyttsp4_cydata {
+	u8 ttpidh;
+	u8 ttpidl;
+	u8 fw_ver_major;
+	u8 fw_ver_minor;
+	u8 revctrl[CY_NUM_REVCTRL];
+	u8 blver_major;
+	u8 blver_minor;
+	u8 jtag_si_id3;
+	u8 jtag_si_id2;
+	u8 jtag_si_id1;
+	u8 jtag_si_id0;
+	u8 mfgid_sz;
+	u8 cyito_idh;
+	u8 cyito_idl;
+	u8 cyito_verh;
+	u8 cyito_verl;
+	u8 ttsp_ver_major;
+	u8 ttsp_ver_minor;
+	u8 device_info;
+	u8 mfg_id[];
+} __packed;
+
+struct cyttsp4_test {
+	u8 post_codeh;
+	u8 post_codel;
+} __packed;
+
+struct cyttsp4_pcfg {
+	u8 electrodes_x;
+	u8 electrodes_y;
+	u8 len_xh;
+	u8 len_xl;
+	u8 len_yh;
+	u8 len_yl;
+	u8 res_xh;
+	u8 res_xl;
+	u8 res_yh;
+	u8 res_yl;
+	u8 max_zh;
+	u8 max_zl;
+	u8 panel_info0;
+} __packed;
+
+enum cyttsp4_tch_abs {	/* for ordering within the extracted touch data array */
+	CY_TCH_X,	/* X */
+	CY_TCH_Y,	/* Y */
+	CY_TCH_P,	/* P (Z) */
+	CY_TCH_T,	/* TOUCH ID */
+	CY_TCH_E,	/* EVENT ID */
+	CY_TCH_O,	/* OBJECT ID */
+	CY_TCH_W,	/* SIZE */
+	CY_TCH_MAJ,	/* TOUCH_MAJOR */
+	CY_TCH_MIN,	/* TOUCH_MINOR */
+	CY_TCH_OR,	/* ORIENTATION */
+	CY_TCH_NUM_ABS
+};
+
+static const char * const cyttsp4_tch_abs_string[] = {
+	[CY_TCH_X]	= "X",
+	[CY_TCH_Y]	= "Y",
+	[CY_TCH_P]	= "P",
+	[CY_TCH_T]	= "T",
+	[CY_TCH_E]	= "E",
+	[CY_TCH_O]	= "O",
+	[CY_TCH_W]	= "W",
+	[CY_TCH_MAJ]	= "MAJ",
+	[CY_TCH_MIN]	= "MIN",
+	[CY_TCH_OR]	= "OR",
+	[CY_TCH_NUM_ABS] = "INVALID"
+};
+
+#define CY_NUM_TCH_FIELDS		7
+#define CY_NUM_EXT_TCH_FIELDS		3
+
+struct cyttsp4_tch_rec_params {
+	u8 loc;
+	u8 size;
+} __packed;
+
+struct cyttsp4_opcfg {
+	u8 cmd_ofs;
+	u8 rep_ofs;
+	u8 rep_szh;
+	u8 rep_szl;
+	u8 num_btns;
+	u8 tt_stat_ofs;
+	u8 obj_cfg0;
+	u8 max_tchs;
+	u8 tch_rec_size;
+	struct cyttsp4_tch_rec_params tch_rec_old[CY_NUM_TCH_FIELDS];
+	u8 btn_rec_size;/* btn record size (in bytes) */
+	u8 btn_diff_ofs;/* btn data loc ,diff counts, (Op-Mode byte ofs) */
+	u8 btn_diff_size;/* btn size of diff counts (in bits) */
+	struct cyttsp4_tch_rec_params tch_rec_new[CY_NUM_EXT_TCH_FIELDS];
+	u8 noise_data_ofs;
+	u8 noise_data_sz;
+} __packed;
+
+struct cyttsp4_sysinfo_data {
+	u8 hst_mode;
+	u8 reserved;
+	u8 map_szh;
+	u8 map_szl;
+	u8 cydata_ofsh;
+	u8 cydata_ofsl;
+	u8 test_ofsh;
+	u8 test_ofsl;
+	u8 pcfg_ofsh;
+	u8 pcfg_ofsl;
+	u8 opcfg_ofsh;
+	u8 opcfg_ofsl;
+	u8 ddata_ofsh;
+	u8 ddata_ofsl;
+	u8 mdata_ofsh;
+	u8 mdata_ofsl;
+} __packed;
+
+struct cyttsp4_sysinfo_ptr {
+	struct cyttsp4_cydata *cydata;
+	struct cyttsp4_test *test;
+	struct cyttsp4_pcfg *pcfg;
+	struct cyttsp4_opcfg *opcfg;
+	struct cyttsp4_ddata *ddata;
+	struct cyttsp4_mdata *mdata;
+} __packed;
+
+struct cyttsp4_touch {
+	int abs[CY_TCH_NUM_ABS];
+};
+
+struct cyttsp4_tch_abs_params {
+	size_t ofs;	/* abs byte offset */
+	size_t size;	/* size in bits */
+	size_t max;	/* max value */
+	size_t bofs;	/* bit offset */
+};
+
+#define CY_NORMAL_ORIGIN		0	/* upper, left corner */
+#define CY_INVERT_ORIGIN		1	/* lower, right corner */
+
+struct cyttsp4_sysinfo_ofs {
+	size_t chip_type;
+	size_t cmd_ofs;
+	size_t rep_ofs;
+	size_t rep_sz;
+	size_t num_btns;
+	size_t num_btn_regs;	/* ceil(num_btns/4) */
+	size_t tt_stat_ofs;
+	size_t tch_rec_size;
+	size_t obj_cfg0;
+	size_t max_tchs;
+	size_t mode_size;
+	size_t data_size;
+	size_t rep_hdr_size;
+	size_t map_sz;
+	size_t max_x;
+	size_t x_origin;	/* left or right corner */
+	size_t max_y;
+	size_t y_origin;	/* upper or lower corner */
+	size_t max_p;
+	size_t cydata_ofs;
+	size_t test_ofs;
+	size_t pcfg_ofs;
+	size_t opcfg_ofs;
+	size_t ddata_ofs;
+	size_t mdata_ofs;
+	size_t cydata_size;
+	size_t test_size;
+	size_t pcfg_size;
+	size_t opcfg_size;
+	size_t ddata_size;
+	size_t mdata_size;
+	size_t btn_keys_size;
+	struct cyttsp4_tch_abs_params tch_abs[CY_TCH_NUM_ABS];
+	size_t btn_rec_size; /* btn record size (in bytes) */
+	size_t btn_diff_ofs;/* btn data loc ,diff counts, (Op-Mode byte ofs) */
+	size_t btn_diff_size;/* btn size of diff counts (in bits) */
+	size_t noise_data_ofs;
+	size_t noise_data_sz;
+};
+
+/* button to keycode support */
+#define CY_NUM_BTN_PER_REG		4
+#define CY_BITS_PER_BTN			2
+
+enum cyttsp4_btn_state {
+	CY_BTN_RELEASED = 0,
+	CY_BTN_PRESSED = 1,
+	CY_BTN_NUM_STATE
+};
+
+struct cyttsp4_btn {
+	bool enabled;
+	int state;	/* CY_BTN_PRESSED, CY_BTN_RELEASED */
+	int key_code;
+};
+
+struct cyttsp4_ttconfig {
+	u16 version;
+	u16 length;
+	u16 max_length;
+	u16 crc;
+};
+
+struct cyttsp4_sysinfo {
+	bool ready;
+	struct cyttsp4_sysinfo_data si_data;
+	struct cyttsp4_sysinfo_ptr si_ptrs;
+	struct cyttsp4_sysinfo_ofs si_ofs;
+	struct cyttsp4_ttconfig ttconfig;
+	struct cyttsp4_btn *btn;	/* button states */
+	u8 *btn_rec_data;		/* button diff count data */
+	u8 *xy_mode;			/* operational mode and status regs */
+	u8 *xy_data;			/* operational touch regs */
+};
+
+#endif /* _CYTTSP4_REGS_H */
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_spi.c b/drivers/input/touchscreen/cypress/cyttsp4_spi.c
new file mode 100644
index 0000000..9d244e2
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_spi.c
@@ -0,0 +1,462 @@
+/*
+ * cyttsp4_spi.c
+ * Cypress TrueTouch(TM) Standard Product V4 SPI Driver module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ * Copyright (C) 2014 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ * Modified by: Cypress Semiconductor for test with device
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/spi/spi.h>
+#include <linux/delay.h>
+#include <linux/mutex.h>
+#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/hrtimer.h>
+#include <linux/cyttsp4_bus.h>
+#include <linux/cyttsp4_core.h>
+#include "cyttsp4_spi.h"
+
+#include "cyttsp4_devtree.h"
+
+#define CY_SPI_WR_OP		0x00 /* r/~w */
+#define CY_SPI_RD_OP		0x01
+#define CY_SPI_A8_BIT		0x02
+#define CY_SPI_WR_HEADER_BYTES	2
+#define CY_SPI_RD_HEADER_BYTES	1
+#define CY_SPI_SYNC_BYTE	0
+#define CY_SPI_SYNC_ACK		0x62 /* from TRM *A protocol */
+#define CY_SPI_DATA_SIZE	(3 * 256)
+#define CY_SPI_BITS_PER_WORD	8
+#define CY_SPI_NUM_RETRY	3
+
+#define CY_SPI_MAX_HEADER_BYTES	\
+		max(CY_SPI_WR_HEADER_BYTES, CY_SPI_RD_HEADER_BYTES)
+
+struct cyttsp4_spi {
+	struct spi_device *client;
+	char const *id;
+	struct mutex lock;
+};
+
+static void _cyttsp4_spi_pr_buf(struct cyttsp4_spi *ts_spi, u8 *buf,
+			int size, char const *info)
+{
+#ifdef VERBOSE_DEBUG
+	static char b[CY_SPI_DATA_SIZE * 3 + 1];
+	unsigned i, k;
+
+	for (i = k = 0; i < size; i++, k += 3)
+		snprintf(b + k, sizeof(b) - k, "%02x ", buf[i]);
+	dev_dbg(&ts_spi->client->dev, "%s: %s\n", info, b);
+#endif
+}
+
+static int cyttsp4_spi_xfer(u8 op, struct cyttsp4_spi *ts,
+			u16 reg, u8 *buf, int length)
+{
+	struct device *dev = &ts->client->dev;
+	struct spi_message msg;
+	struct spi_transfer xfer[2];
+	u8 wr_hdr_buf[CY_SPI_MAX_HEADER_BYTES];
+	u8 rd_hdr_buf[CY_SPI_MAX_HEADER_BYTES];
+	int rc;
+
+	memset(wr_hdr_buf, 0, CY_SPI_MAX_HEADER_BYTES);
+	memset(rd_hdr_buf, 0, CY_SPI_MAX_HEADER_BYTES);
+	memset(xfer, 0, sizeof(xfer));
+
+	spi_message_init(&msg);
+
+	/* Header buffer */
+	xfer[0].tx_buf = wr_hdr_buf;
+	xfer[0].rx_buf = rd_hdr_buf;
+
+	switch (op) {
+	case CY_SPI_WR_OP:
+		if (length + CY_SPI_WR_HEADER_BYTES > CY_SPI_DATA_SIZE) {
+			dev_vdbg(dev,
+				"%s: length+%d=%d is greater than SPI max=%d\n",
+				__func__, CY_SPI_WR_HEADER_BYTES,
+				length + CY_SPI_WR_HEADER_BYTES,
+				CY_SPI_DATA_SIZE);
+			rc = -EINVAL;
+			goto cyttsp4_spi_xfer_exit;
+		}
+
+		/* Header byte 0 */
+		if (reg > 255)
+			wr_hdr_buf[0] = CY_SPI_WR_OP + CY_SPI_A8_BIT;
+		else
+			wr_hdr_buf[0] = CY_SPI_WR_OP;
+
+		/* Header byte 1 */
+		wr_hdr_buf[1] = reg % 256;
+
+		xfer[0].len = CY_SPI_WR_HEADER_BYTES;
+
+		spi_message_add_tail(&xfer[0], &msg);
+
+		/* Data buffer */
+		if (buf) {
+			xfer[1].tx_buf = buf;
+			xfer[1].len = length;
+
+			spi_message_add_tail(&xfer[1], &msg);
+		}
+		break;
+
+	case CY_SPI_RD_OP:
+		if (!buf) {
+			dev_err(dev, "%s: No read buffer\n", __func__);
+			rc = -EINVAL;
+			goto cyttsp4_spi_xfer_exit;
+		}
+
+		if ((length + CY_SPI_RD_HEADER_BYTES) > CY_SPI_DATA_SIZE) {
+			dev_vdbg(dev,
+				"%s: length+%d=%d is greater than SPI max=%d\n",
+				__func__, CY_SPI_RD_HEADER_BYTES,
+				length + CY_SPI_RD_HEADER_BYTES,
+				CY_SPI_DATA_SIZE);
+			rc = -EINVAL;
+			goto cyttsp4_spi_xfer_exit;
+		}
+
+		/* Header byte 0 */
+		wr_hdr_buf[0] = CY_SPI_RD_OP;
+
+		xfer[0].len = CY_SPI_RD_HEADER_BYTES;
+
+		spi_message_add_tail(&xfer[0], &msg);
+
+		/* Data buffer */
+		xfer[1].rx_buf = buf;
+		xfer[1].len = length;
+
+		spi_message_add_tail(&xfer[1], &msg);
+		break;
+
+	default:
+		dev_dbg(dev, "%s: bad op code=%d\n", __func__, op);
+		rc = -EINVAL;
+		goto cyttsp4_spi_xfer_exit;
+	}
+
+	rc = spi_sync(ts->client, &msg);
+	if (rc < 0) {
+		dev_vdbg(dev, "%s: spi_sync() error %d, len=%d, op=%d\n",
+			__func__, rc, xfer[0].len, op);
+		/*
+		 * do not return here since probably a bad ACK sequence
+		 * let the following ACK check handle any errors and
+		 * allow silent retries
+		 */
+	}
+
+	if (rd_hdr_buf[CY_SPI_SYNC_BYTE] != CY_SPI_SYNC_ACK) {
+		/* signal ACK error so silent retry */
+		rc = 1;
+
+		switch (op) {
+		case CY_SPI_WR_OP:
+			_cyttsp4_spi_pr_buf(ts, wr_hdr_buf,
+				CY_SPI_WR_HEADER_BYTES,
+				"spi_wr_buf HEAD");
+			if (buf)
+				_cyttsp4_spi_pr_buf(ts, buf,
+					length, "spi_wr_buf DATA");
+			break;
+
+		case CY_SPI_RD_OP:
+			_cyttsp4_spi_pr_buf(ts, rd_hdr_buf,
+				CY_SPI_RD_HEADER_BYTES, "spi_rd_buf HEAD");
+			_cyttsp4_spi_pr_buf(ts, buf, length,
+				"spi_rd_buf DATA");
+			break;
+
+		default:
+			/*
+			 * should not get here due to error check
+			 * in first switch
+			 */
+			break;
+		}
+	}
+
+cyttsp4_spi_xfer_exit:
+	return rc;
+}
+
+static s32 cyttsp4_spi_read_block_data(struct cyttsp4_spi *ts, u16 addr,
+				int length, void *data, int max_xfer)
+{
+	int rc = -EINVAL;
+	int retry = 0;
+	int trans_len;
+	struct device *dev = &ts->client->dev;
+
+	dev_vdbg(dev, "%s: Enter\n", __func__);
+
+	while (length > 0) {
+		trans_len = min(length, max_xfer);
+
+		/* Write address */
+		rc = cyttsp4_spi_xfer(CY_SPI_WR_OP, ts, addr, NULL, 0);
+		if (rc < 0) {
+			dev_err(dev, "%s: Fail write address r=%d\n",
+				__func__, rc);
+			return rc;
+		}
+
+		/* Read data */
+		rc = cyttsp4_spi_xfer(CY_SPI_RD_OP, ts, addr, data, trans_len);
+		if (rc < 0) {
+			dev_err(dev, "%s: Fail read r=%d\n", __func__, rc);
+			goto exit;
+		} else if (rc > 0) {
+			/* Perform retry or fail */
+			if (retry++ < CY_SPI_NUM_RETRY) {
+				dev_dbg(dev, "%s: ACK error, retry %d\n",
+					__func__, retry);
+				continue;
+			} else {
+				dev_err(dev, "%s: ACK error\n", __func__);
+				rc = -EIO;
+				goto exit;
+			}
+		}
+
+		length -= trans_len;
+		data += trans_len;
+		addr += trans_len;
+	}
+exit:
+	return rc;
+}
+
+static s32 cyttsp4_spi_write_block_data(struct cyttsp4_spi *ts, u16 addr,
+				int length, const void *data, int max_xfer)
+{
+	int rc = -EINVAL;
+	int retry = 0;
+	int trans_len;
+	struct device *dev = &ts->client->dev;
+
+	dev_vdbg(dev, "%s: Enter\n", __func__);
+
+	while (length > 0) {
+		trans_len = min(length, max_xfer);
+
+		rc = cyttsp4_spi_xfer(CY_SPI_WR_OP, ts, addr, (void *)data,
+				trans_len);
+		if (rc < 0) {
+			dev_err(dev, "%s: Fail write r=%d\n", __func__, rc);
+			goto exit;
+		} else if (rc > 0) {
+			/* Perform retry or fail */
+			if (retry++ < CY_SPI_NUM_RETRY) {
+				dev_dbg(dev, "%s: ACK error, retry %d\n",
+					__func__, retry);
+				continue;
+			} else {
+				dev_err(dev, "%s: ACK error\n", __func__);
+				rc = -EIO;
+				goto exit;
+			}
+		}
+
+		length -= trans_len;
+		data += trans_len;
+		addr += trans_len;
+	}
+exit:
+	return rc;
+}
+
+static int cyttsp4_spi_write(struct cyttsp4_adapter *adap, u16 addr,
+		const void *buf, int size, int max_xfer)
+{
+	struct cyttsp4_spi *ts = dev_get_drvdata(adap->dev);
+	int rc;
+
+	pm_runtime_get_noresume(adap->dev);
+	mutex_lock(&ts->lock);
+	rc = cyttsp4_spi_write_block_data(ts, addr, size, buf, max_xfer);
+	mutex_unlock(&ts->lock);
+	pm_runtime_put_noidle(adap->dev);
+
+	return rc;
+}
+
+static int cyttsp4_spi_read(struct cyttsp4_adapter *adap, u16 addr,
+		void *buf, int size, int max_xfer)
+{
+	struct cyttsp4_spi *ts = dev_get_drvdata(adap->dev);
+	int rc;
+
+	pm_runtime_get_noresume(adap->dev);
+	mutex_lock(&ts->lock);
+	rc = cyttsp4_spi_read_block_data(ts, addr, size, buf, max_xfer);
+	mutex_unlock(&ts->lock);
+	pm_runtime_put_noidle(adap->dev);
+
+	return rc;
+}
+
+static struct cyttsp4_ops ops = {
+	.write = cyttsp4_spi_write,
+	.read = cyttsp4_spi_read,
+};
+
+static struct of_device_id cyttsp4_spi_of_match[] = {
+	{ .compatible = "cy,cyttsp4_spi_adapter", }, { }
+};
+MODULE_DEVICE_TABLE(of, cyttsp4_spi_of_match);
+
+static int cyttsp4_spi_probe(struct spi_device *spi)
+{
+	struct cyttsp4_spi *ts_spi;
+	int rc = 0;
+	struct device *dev = &spi->dev;
+	const struct of_device_id *match;
+	char const *adap_id;
+
+	dev_dbg(dev, "%s: Probing ...\n", __func__);
+
+	spi->bits_per_word = CY_SPI_BITS_PER_WORD;
+	spi->mode = SPI_MODE_0;
+
+	rc = spi_setup(spi);
+	if (rc < 0) {
+		dev_err(dev, "%s: SPI setup error %d\n", __func__, rc);
+		return rc;
+	}
+
+	ts_spi = kzalloc(sizeof(*ts_spi), GFP_KERNEL);
+	if (ts_spi == NULL) {
+		dev_err(dev, "%s: Error, kzalloc\n", __func__);
+		rc = -ENOMEM;
+		goto error_alloc_data_failed;
+	}
+
+	match = of_match_device(of_match_ptr(cyttsp4_spi_of_match), dev);
+	if (match) {
+		rc = of_property_read_string(dev->of_node, "cy,adapter_id",
+				&adap_id);
+		if (rc) {
+			dev_err(dev, "%s: OF error rc=%d\n", __func__, rc);
+			goto error_free_data;
+		}
+		cyttsp4_devtree_register_devices(dev);
+	} else {
+		adap_id = dev_get_platdata(dev);
+	}
+
+	mutex_init(&ts_spi->lock);
+	ts_spi->client = spi;
+	ts_spi->id = (adap_id) ? adap_id : CYTTSP4_SPI_NAME;
+	dev_set_drvdata(&spi->dev, ts_spi);
+
+	dev_dbg(dev, "%s: add adap='%s' (CYTTSP4_SPI_NAME=%s)\n", __func__,
+		ts_spi->id, CYTTSP4_SPI_NAME);
+
+	pm_runtime_enable(&spi->dev);
+
+	rc = cyttsp4_add_adapter(ts_spi->id, &ops, dev);
+	if (rc) {
+		dev_err(dev, "%s: Error on probe %s\n", __func__,
+			CYTTSP4_SPI_NAME);
+		goto add_adapter_err;
+	}
+
+	dev_info(dev, "%s: Successful prob %s\n", __func__, CYTTSP4_SPI_NAME);
+
+	return 0;
+
+add_adapter_err:
+	pm_runtime_disable(&spi->dev);
+	dev_set_drvdata(&spi->dev, NULL);
+error_free_data:
+	kfree(ts_spi);
+error_alloc_data_failed:
+	return rc;
+}
+
+static int cyttsp4_spi_remove(struct spi_device *spi)
+{
+	struct device *dev = &spi->dev;
+	struct cyttsp4_spi *ts_spi = dev_get_drvdata(dev);
+
+	dev_info(dev, "%s\n", __func__);
+	cyttsp4_del_adapter(ts_spi->id);
+	pm_runtime_disable(&spi->dev);
+	dev_set_drvdata(&spi->dev, NULL);
+	kfree(ts_spi);
+	return 0;
+}
+
+static const struct spi_device_id cyttsp4_spi_id[] = {
+	{ CYTTSP4_SPI_NAME, 0 },  { }
+};
+MODULE_DEVICE_TABLE(spi, cyttsp4_spi_id);
+
+static struct spi_driver cyttsp4_spi_driver = {
+	.driver = {
+		.name = CYTTSP4_SPI_NAME,
+		.bus = &spi_bus_type,
+		.owner = THIS_MODULE,
+		.of_match_table = cyttsp4_spi_of_match,
+	},
+	.probe = cyttsp4_spi_probe,
+	.remove = cyttsp4_spi_remove,
+	.id_table = cyttsp4_spi_id,
+};
+
+static int __init cyttsp4_spi_init(void)
+{
+	int err;
+
+	err = spi_register_driver(&cyttsp4_spi_driver);
+	pr_info("%s: Cypress TTSP SPI Touchscreen Driver (Built %s) rc=%d\n",
+		 __func__, CY_DRIVER_DATE, err);
+
+	return err;
+}
+module_init(cyttsp4_spi_init);
+
+static void __exit cyttsp4_spi_exit(void)
+{
+	spi_unregister_driver(&cyttsp4_spi_driver);
+	pr_info("%s: module exit\n", __func__);
+}
+module_exit(cyttsp4_spi_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard Product SPI driver");
+MODULE_AUTHOR("Aleksej Makarov <aleksej.makarov@sonyericsson.com>");
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_spi.h b/drivers/input/touchscreen/cypress/cyttsp4_spi.h
new file mode 100644
index 0000000..3052d4c
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_spi.h
@@ -0,0 +1,37 @@
+/*
+ * cyttsp4_spi.h
+ * Cypress TrueTouch(TM) Standard Product V4 SPI Driver module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ * Copyright (C) 2014 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_SPI_H
+#define _LINUX_CYTTSP4_SPI_H
+
+#define CYTTSP4_SPI_NAME "cyttsp4_spi_adapter"
+
+#endif /* _LINUX_CYTTSP4_SPI_H */
diff --git a/drivers/input/touchscreen/cypress/cyttsp4_test_device_access_api.c b/drivers/input/touchscreen/cypress/cyttsp4_test_device_access_api.c
new file mode 100644
index 0000000..da92b6c
--- /dev/null
+++ b/drivers/input/touchscreen/cypress/cyttsp4_test_device_access_api.c
@@ -0,0 +1,196 @@
+/*
+ * cyttsp4_test_device_access_api.c
+ * Cypress TrueTouch(TM) Standard Product V4 Device Access API test module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/cyttsp4_device_access-api.h>
+
+#define CONFIG_VER_OFFSET	8
+#define CONFIG_VER_SIZE		2
+
+#define BUFFER_SIZE		256
+
+static u8 buffer[BUFFER_SIZE];
+static int active_refresh_interval;
+
+static int __init cyttsp4_test_device_access_api_init(void)
+{
+	u16 config_ver;
+	int i;
+	int j;
+	int value;
+	int rc;
+
+	pr_info("%s: Enter\n", __func__);
+
+	/*
+	 * CASE 1 - Get CONFIG_VER and update it
+	 */
+
+	/*
+	 * Get CONFIG_VER
+	 * Group 6 read requires to fetch from offset to the end of row
+	 * The return buffer should be at least read config block command
+	 * return size + config row size bytes
+	 */
+	rc = cyttsp4_device_access_read_command(NULL,
+			GRPNUM_TOUCH_CONFIG, CONFIG_VER_OFFSET,
+			buffer, BUFFER_SIZE);
+	if (rc < 0) {
+		pr_err("%s: cyttsp4_device_access_read_command failed, rc=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+	pr_info("%s: cyttsp4_device_access_read_command returned %d bytes\n",
+		__func__, rc);
+
+	/* Calculate CONFIG_VER (Little Endian) */
+	config_ver = buffer[0] + (buffer[1] << 8);
+
+	pr_info("%s: Old CONFIG_VER:%04X New CONFIG_VER:%04X\n", __func__,
+		config_ver, config_ver + 1);
+
+	config_ver++;
+
+	/* Store CONFIG_VER (Little Endian) */
+	buffer[0] = config_ver & 0xFF;
+	buffer[1] = config_ver >> 8;
+
+	/*
+	 * Set CONFIG_VER
+	 * Group 6 write supports writing arbitrary number of bytes
+	 */
+	rc = cyttsp4_device_access_write_command(NULL,
+			GRPNUM_TOUCH_CONFIG, CONFIG_VER_OFFSET,
+			buffer, CONFIG_VER_SIZE);
+	if (rc < 0) {
+		pr_err("%s: cyttsp4_device_access_write_command failed, rc=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+	/*
+	 * CASE 2 - Get Operational mode parameters
+	 */
+	for (i = OP_PARAM_ACTIVE_DISTANCE;
+			i <= OP_PARAM_ACTIVE_LOOK_FOR_TOUCH_INTERVAL; i++) {
+		buffer[0] = OP_CMD_GET_PARAMETER;
+		buffer[1] = i;
+
+		rc = cyttsp4_device_access_write_command(NULL,
+				GRPNUM_OP_COMMAND, 0, buffer, 2);
+		if (rc < 0) {
+			pr_err("%s: cyttsp4_device_access_write_command failed, rc=%d\n",
+				__func__, rc);
+			goto exit;
+		}
+
+		/*
+		 * The return buffer should be at least
+		 * number of command data registers + 1
+		 */
+		rc = cyttsp4_device_access_read_command(NULL,
+				GRPNUM_OP_COMMAND, 0, buffer, 7);
+		if (rc < 0) {
+			pr_err("%s: cyttsp4_device_access_read_command failed, rc=%d\n",
+				__func__, rc);
+			goto exit;
+		}
+
+		if (buffer[0] != OP_CMD_GET_PARAMETER || buffer[1] != i) {
+			pr_err("%s: Invalid response\n", __func__);
+			rc = -EINVAL;
+			goto exit;
+		}
+
+		/*
+		 * Get value stored starting at &buffer[3] whose
+		 * size (in bytes) is specified at buffer[2]
+		 */
+		value = 0;
+		j = 0;
+		while (buffer[2]--)
+			value += buffer[3 + j++] << (8 * buffer[2]);
+
+		/* Store Active mode refresh interval to restore */
+		if (i == OP_PARAM_REFRESH_INTERVAL)
+			active_refresh_interval = value;
+
+		pr_info("%s: Parameter %02X: %d\n", __func__, i, value);
+	}
+
+	/*
+	 * CASE 3 - Set Active mode refresh interval to 200 ms
+	 */
+	buffer[0] = OP_CMD_SET_PARAMETER; /* Set Parameter */
+	buffer[1] = OP_PARAM_REFRESH_INTERVAL; /* Refresh Interval parameter */
+	buffer[2] = 1; /* Parameter length - 1 byte */
+	buffer[3] = 200; /* 200 ms */
+
+	rc = cyttsp4_device_access_write_command(NULL,
+			GRPNUM_OP_COMMAND, 0, buffer, 4);
+	if (rc < 0) {
+		pr_err("%s: cyttsp4_device_access_write_command failed, rc=%d\n",
+			__func__, rc);
+		goto exit;
+	}
+
+exit:
+	return 0;
+}
+module_init(cyttsp4_test_device_access_api_init);
+
+static void __exit cyttsp4_test_device_access_api_exit(void)
+{
+	int rc;
+
+	pr_info("%s: Exit\n", __func__);
+
+	/*
+	 * CASE 4 - Restore Active mode refresh interval to original
+	 */
+	if (active_refresh_interval) {
+		buffer[0] = OP_CMD_SET_PARAMETER; /* Set Parameter */
+		buffer[1] = OP_PARAM_REFRESH_INTERVAL;
+					/* Refresh Interval parameter */
+		buffer[2] = 1; /* Parameter length - 1 byte */
+		buffer[3] = (u8)active_refresh_interval;
+
+		rc = cyttsp4_device_access_write_command(NULL,
+				GRPNUM_OP_COMMAND, 0, buffer, 4);
+		if (rc < 0) {
+			pr_err("%s: cyttsp4_device_access_write_command failed, rc=%d\n",
+				__func__, rc);
+		}
+	}
+}
+module_exit(cyttsp4_test_device_access_api_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Cypress TrueTouch(R) Standard touchscreen device access API tester");
+MODULE_AUTHOR("Cypress Semiconductor");
diff --git a/include/linux/cyttsp4_btn.h b/include/linux/cyttsp4_btn.h
new file mode 100644
index 0000000..67edcfa
--- /dev/null
+++ b/include/linux/cyttsp4_btn.h
@@ -0,0 +1,39 @@
+/*
+ * cyttsp4_btn.h
+ * Cypress TrueTouch(TM) Standard Product V4 CapSense touch reports module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ * Copyright (C) 2014 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_BTN_H
+#define _LINUX_CYTTSP4_BTN_H
+
+#define CYTTSP4_BTN_NAME "cyttsp4_btn"
+
+struct cyttsp4_btn_platform_data {
+	char const *inp_dev_name;
+};
+
+#endif /* _LINUX_CYTTSP4_BTN_H */
diff --git a/include/linux/cyttsp4_bus.h b/include/linux/cyttsp4_bus.h
new file mode 100644
index 0000000..5c4fac7
--- /dev/null
+++ b/include/linux/cyttsp4_bus.h
@@ -0,0 +1,346 @@
+/*
+ * cyttsp4_bus.h
+ * Cypress TrueTouch(TM) Standard Product V4 Bus Driver.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ * Copyright (C) 2014 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ * Modified by: Cypress Semiconductor to add device functions
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_BUS_H
+#define _LINUX_CYTTSP4_BUS_H
+
+#include <linux/device.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/limits.h>
+
+
+extern struct bus_type cyttsp4_bus_type;
+
+struct cyttsp4_driver;
+struct cyttsp4_device;
+struct cyttsp4_adapter;
+
+enum cyttsp4_atten_type {
+	CY_ATTEN_IRQ,
+	CY_ATTEN_STARTUP,
+	CY_ATTEN_EXCLUSIVE,
+	CY_ATTEN_WAKE,
+	CY_ATTEN_NUM_ATTEN,
+};
+
+typedef int (*cyttsp4_atten_func) (struct cyttsp4_device *);
+
+struct cyttsp4_ops {
+	int (*write)(struct cyttsp4_adapter *dev, u16 addr,
+		const void *buf, int size, int max_xfer);
+	int (*read)(struct cyttsp4_adapter *dev, u16 addr, void *buf,
+		int size, int max_xfer);
+};
+
+struct cyttsp4_adapter {
+	struct list_head node;
+	char id[NAME_MAX];
+	struct device *dev;
+	int (*write)(struct cyttsp4_adapter *dev, u16 addr,
+		const void *buf, int size, int max_xfer);
+	int (*read)(struct cyttsp4_adapter *dev, u16 addr, void *buf,
+		int size, int max_xfer);
+};
+#define to_cyttsp4_adapter(d) container_of(d, struct cyttsp4_adapter, dev)
+
+struct cyttsp4_core_info {
+	char const *name;
+	char const *id;
+	char const *adap_id;
+	void *platform_data;
+};
+
+struct cyttsp4_core {
+	struct list_head node;
+	char const *name;
+	char const *id;
+	char const *adap_id;
+	struct device dev;
+	struct cyttsp4_adapter *adap;
+};
+#define to_cyttsp4_core(d) container_of(d, struct cyttsp4_core, dev)
+
+struct cyttsp4_device_info {
+	char const *name;
+	char const *core_id;
+	void *platform_data;
+};
+
+struct cyttsp4_device {
+	struct list_head node;
+	char const *name;
+	char const *core_id;
+	struct device dev;
+	struct cyttsp4_core *core;
+};
+#define to_cyttsp4_device(d) container_of(d, struct cyttsp4_device, dev)
+
+struct cyttsp4_core_driver {
+	struct device_driver driver;
+	int (*probe)(struct cyttsp4_core *core);
+	int (*remove)(struct cyttsp4_core *core);
+	int (*subscribe_attention)(struct cyttsp4_device *ttsp,
+				enum cyttsp4_atten_type type,
+				cyttsp4_atten_func func,
+				int flags);
+	int (*unsubscribe_attention)(struct cyttsp4_device *ttsp,
+				enum cyttsp4_atten_type type,
+				cyttsp4_atten_func func,
+				int flags);
+	int (*request_exclusive)(struct cyttsp4_device *ttsp, int timeout_ms);
+	int (*release_exclusive)(struct cyttsp4_device *ttsp);
+	int (*request_reset)(struct cyttsp4_device *ttsp);
+	int (*request_restart)(struct cyttsp4_device *ttsp, bool wait);
+	int (*request_set_mode)(struct cyttsp4_device *ttsp, int mode);
+	struct cyttsp4_sysinfo *(*request_sysinfo)(struct cyttsp4_device *ttsp);
+	struct cyttsp4_loader_platform_data
+		*(*request_loader_pdata)(struct cyttsp4_device *ttsp);
+	int (*request_handshake)(struct cyttsp4_device *ttsp, u8 mode);
+	int (*request_exec_cmd)(struct cyttsp4_device *ttsp, u8 mode,
+			u8 *cmd_buf, size_t cmd_size, u8 *return_buf,
+			size_t return_buf_size, int timeout_ms);
+	int (*request_stop_wd)(struct cyttsp4_device *ttsp);
+	int (*request_toggle_lowpower)(struct cyttsp4_device *ttsp, u8 mode);
+	int (*request_config_row_size)(struct cyttsp4_device *ttsp,
+			u16 *config_row_size);
+	int (*request_write_config)(struct cyttsp4_device *ttsp, u8 ebid,
+			u16 offset, u8 *data, u16 length);
+	int (*request_enable_scan_type)(struct cyttsp4_device *ttsp,
+			u8 scan_type);
+	int (*request_disable_scan_type)(struct cyttsp4_device *ttsp,
+			u8 scan_type);
+	const u8 *(*get_security_key)(struct cyttsp4_device *ttsp, int *size);
+	void (*get_touch_record)(struct cyttsp4_device *ttsp, int rec_no,
+			int *rec_abs);
+	int (*write)(struct cyttsp4_device *ttsp, int mode,
+		u16 addr, const void *buf, int size);
+	int (*read)(struct cyttsp4_device *ttsp, int mode,
+		u16 addr, void *buf, int size);
+};
+#define to_cyttsp4_core_driver(d) \
+	container_of(d, struct cyttsp4_core_driver, driver)
+
+struct cyttsp4_driver {
+	struct device_driver driver;
+	int (*probe)(struct cyttsp4_device *dev);
+	int (*remove)(struct cyttsp4_device *fev);
+};
+#define to_cyttsp4_driver(d) container_of(d, struct cyttsp4_driver, driver)
+
+extern int cyttsp4_register_driver(struct cyttsp4_driver *drv);
+extern void cyttsp4_unregister_driver(struct cyttsp4_driver *drv);
+
+extern int cyttsp4_register_core_driver(struct cyttsp4_core_driver *drv);
+extern void cyttsp4_unregister_core_driver(struct cyttsp4_core_driver *drv);
+
+extern int cyttsp4_register_device(struct cyttsp4_device_info const *dev_info);
+extern int cyttsp4_unregister_device(char const *name, char const *core_id);
+
+extern int cyttsp4_register_core_device(
+		struct cyttsp4_core_info const *core_info);
+
+extern int cyttsp4_add_adapter(char const *id, struct cyttsp4_ops const *ops,
+		struct device *parent);
+
+extern int cyttsp4_del_adapter(char const *id);
+
+static inline int cyttsp4_read(struct cyttsp4_device *ttsp, int mode, u16 addr,
+		void *buf, int size)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->read(ttsp, mode, addr, buf, size);
+}
+
+static inline int cyttsp4_write(struct cyttsp4_device *ttsp, int mode, u16 addr,
+		const void *buf, int size)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->write(ttsp, mode, addr, buf, size);
+}
+
+static inline int cyttsp4_subscribe_attention(struct cyttsp4_device *ttsp,
+		enum cyttsp4_atten_type type, cyttsp4_atten_func func,
+		int flags)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->subscribe_attention(ttsp, type, func, flags);
+}
+
+static inline int cyttsp4_unsubscribe_attention(struct cyttsp4_device *ttsp,
+		enum cyttsp4_atten_type type, cyttsp4_atten_func func,
+		int flags)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->unsubscribe_attention(ttsp, type, func, flags);
+}
+
+static inline int cyttsp4_request_exclusive(struct cyttsp4_device *ttsp,
+		int timeout_ms)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_exclusive(ttsp, timeout_ms);
+}
+
+static inline int cyttsp4_release_exclusive(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->release_exclusive(ttsp);
+}
+
+static inline int cyttsp4_request_reset(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_reset(ttsp);
+}
+
+static inline int cyttsp4_request_restart(struct cyttsp4_device *ttsp,
+		bool wait)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_restart(ttsp, wait);
+}
+
+static inline int cyttsp4_request_set_mode(struct cyttsp4_device *ttsp,
+		int mode)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_set_mode(ttsp, mode);
+}
+
+static inline struct cyttsp4_sysinfo *cyttsp4_request_sysinfo(
+		struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_sysinfo(ttsp);
+}
+
+static inline struct cyttsp4_loader_platform_data *cyttsp4_request_loader_pdata(
+		struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_loader_pdata(ttsp);
+}
+
+static inline int cyttsp4_request_handshake(struct cyttsp4_device *ttsp,
+		u8 mode)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_handshake(ttsp, mode);
+}
+
+static inline int cyttsp4_request_exec_cmd(struct cyttsp4_device *ttsp,
+		u8 mode, u8 *cmd_buf, size_t cmd_size, u8 *return_buf,
+		size_t return_buf_size, int timeout_ms)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_exec_cmd(ttsp, mode, cmd_buf, cmd_size, return_buf,
+			return_buf_size, timeout_ms);
+}
+
+static inline int cyttsp4_request_stop_wd(struct cyttsp4_device *ttsp)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_stop_wd(ttsp);
+}
+
+static inline int cyttsp4_request_toggle_lowpower(struct cyttsp4_device *ttsp,
+		u8 mode)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_toggle_lowpower(ttsp, mode);
+}
+
+static inline int cyttsp4_request_config_row_size(struct cyttsp4_device *ttsp,
+		u16 *config_row_size)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_config_row_size(ttsp, config_row_size);
+}
+
+static inline int cyttsp4_request_write_config(struct cyttsp4_device *ttsp,
+		u8 ebid, u16 offset, u8 *data, u16 length)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_write_config(ttsp, ebid, offset, data, length);
+}
+
+static inline int cyttsp4_request_enable_scan_type(struct cyttsp4_device *ttsp,
+		u8 scan_type)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_enable_scan_type(ttsp, scan_type);
+}
+
+static inline int cyttsp4_request_disable_scan_type(struct cyttsp4_device *ttsp,
+		u8 scan_type)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->request_disable_scan_type(ttsp, scan_type);
+}
+
+static inline const u8 *cyttsp4_get_security_key(struct cyttsp4_device *ttsp,
+		int *size)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	return d->get_security_key(ttsp, size);
+}
+
+static inline void cyttsp4_get_touch_record(struct cyttsp4_device *ttsp,
+		int rec_no, int *rec_abs)
+{
+	struct cyttsp4_core *cd = ttsp->core;
+	struct cyttsp4_core_driver *d = to_cyttsp4_core_driver(cd->dev.driver);
+	d->get_touch_record(ttsp, rec_no, rec_abs);
+}
+#endif /* _LINUX_CYTTSP4_BUS_H */
diff --git a/include/linux/cyttsp4_core.h b/include/linux/cyttsp4_core.h
new file mode 100644
index 0000000..b7fe03e
--- /dev/null
+++ b/include/linux/cyttsp4_core.h
@@ -0,0 +1,152 @@
+/*
+ * cyttsp4_core.h
+ * Cypress TrueTouch(TM) Standard Product V4 Core driver module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ * Copyright (C) 2014 Sony Ericsson Mobile Communications AB.
+ *
+ * Author: Aleksej Makarov <aleksej.makarov@sonyericsson.com>
+ * Modifed by: Cypress Semiconductor to add touch settings
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_CORE_H
+#define _LINUX_CYTTSP4_CORE_H
+
+#include <linux/stringify.h>
+#include <linux/of_gpio.h>
+
+#define CYTTSP4_CORE_NAME "cyttsp4_core"
+
+#define CY_DRIVER_NAME TTDA
+#define CY_DRIVER_MAJOR 02
+#define CY_DRIVER_MINOR 03
+#define CY_DRIVER_SUBRELEASE 01
+
+#define CY_DRIVER_REVCTRL 485332
+
+#define CY_DRIVER_VERSION		    \
+__stringify(CY_DRIVER_NAME)		    \
+"." __stringify(CY_DRIVER_MAJOR)	    \
+"." __stringify(CY_DRIVER_MINOR)	    \
+"." __stringify(CY_DRIVER_SUBRELEASE)	    \
+"." __stringify(CY_DRIVER_REVCTRL)
+
+#define CY_DRIVER_DATE "20130612"	/* YYYYMMDD */
+
+/* x-axis resolution of panel in pixels */
+#define CY_PCFG_RESOLUTION_X_MASK 0x7F
+
+/* y-axis resolution of panel in pixels */
+#define CY_PCFG_RESOLUTION_Y_MASK 0x7F
+
+/* x-axis, 0:origin is on left side of panel, 1: right */
+#define CY_PCFG_ORIGIN_X_MASK 0x80
+
+/* y-axis, 0:origin is on top side of panel, 1: bottom */
+#define CY_PCFG_ORIGIN_Y_MASK 0x80
+
+#define CY_TOUCH_SETTINGS_MAX 32
+#define CY_TOUCH_SETTINGS_PARAM_REGS 6
+
+enum cyttsp4_core_platform_flags {
+	CY_CORE_FLAG_NONE = 0x00,
+	CY_CORE_FLAG_WAKE_ON_GESTURE = 0x01,
+};
+
+enum cyttsp4_core_platform_easy_wakeup_gesture {
+	CY_CORE_EWG_NONE = 0x00,
+	CY_CORE_EWG_TAP_TAP = 0x01,
+	CY_CORE_EWG_TWO_FINGER_SLIDE = 0x02,
+	CY_CORE_EWG_RESERVED = 0x03,
+	CY_CORE_EWG_WAKE_ON_INT_FROM_HOST = 0xFF,
+};
+
+enum cyttsp4_loader_platform_flags {
+	CY_LOADER_FLAG_NONE = 0x00,
+	CY_LOADER_FLAG_CALIBRATE_AFTER_FW_UPGRADE = 0x01,
+	/* Use CONFIG_VER field in TT_CFG to decide TT_CFG update */
+	CY_LOADER_FLAG_CHECK_TTCONFIG_VERSION = 0x02,
+};
+
+struct touch_settings {
+	const uint8_t *data;
+	uint32_t size;
+	uint8_t tag;
+} __packed;
+
+struct cyttsp4_touch_firmware {
+	const uint8_t *img;
+	uint32_t size;
+	const uint8_t *ver;
+	uint8_t vsize;
+} __packed;
+
+struct cyttsp4_touch_config {
+	struct touch_settings *param_regs;
+	struct touch_settings *param_size;
+	const uint8_t *fw_ver;
+	uint8_t fw_vsize;
+};
+
+struct cyttsp4_loader_platform_data {
+	struct cyttsp4_touch_firmware *fw;
+	struct cyttsp4_touch_config *ttconfig;
+	u32 flags;
+} __packed;
+
+typedef int (*cyttsp4_platform_read) (struct device *dev, u16 addr,
+	void *buf, int size);
+
+struct cyttsp4_core_platform_data {
+	int irq_gpio;
+	int rst_gpio;
+	int level_irq_udelay;
+	int max_xfer_len;
+	int num_max_touches;
+	struct regulator *vdd;
+	struct regulator *vcc_i2c;
+	int (*xres)(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev);
+	int (*init)(struct cyttsp4_core_platform_data *pdata,
+		int on, struct device *dev);
+	int (*power)(struct cyttsp4_core_platform_data *pdata,
+		int on, struct device *dev, atomic_t *ignore_irq);
+	int (*detect)(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev, cyttsp4_platform_read read);
+	int (*irq_stat)(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev);
+	struct touch_settings *sett[CY_TOUCH_SETTINGS_MAX];
+	struct cyttsp4_loader_platform_data *loader_pdata;
+	u32 flags;
+	u8 easy_wakeup_gesture;
+};
+
+#ifdef VERBOSE_DEBUG
+extern void cyttsp4_pr_buf(struct device *dev, u8 *pr_buf, u8 *dptr, int size,
+			   const char *data_name);
+#else
+#define cyttsp4_pr_buf(a, b, c, d, e) do { } while (0)
+#endif
+
+#endif /* _LINUX_CYTTSP4_CORE_H */
diff --git a/include/linux/cyttsp4_device_access-api.h b/include/linux/cyttsp4_device_access-api.h
new file mode 100644
index 0000000..40ddf9e
--- /dev/null
+++ b/include/linux/cyttsp4_device_access-api.h
@@ -0,0 +1,56 @@
+/*
+ * cyttsp4_device_access-api.h
+ * Cypress TrueTouch(TM) Standard Product V4 Device Access API module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_DEVICE_ACCESS_API_H
+#define _LINUX_CYTTSP4_DEVICE_ACCESS_API_H
+
+#include <linux/types.h>
+#include <linux/device.h>
+
+#define GRPNUM_OP_COMMAND	1
+#define GRPNUM_TOUCH_CONFIG	6
+
+#define OP_CMD_NULL		0
+#define OP_CMD_GET_PARAMETER	2
+#define OP_CMD_SET_PARAMETER	3
+#define OP_CMD_GET_CONFIG_CRC	5
+
+#define OP_PARAM_ACTIVE_DISTANCE		0x4A
+#define OP_PARAM_SCAN_TYPE			0x4B
+#define OP_PARAM_LOW_POWER_INTERVAL		0x4C
+#define OP_PARAM_REFRESH_INTERVAL		0x4D
+#define OP_PARAM_ACTIVE_MODE_TIMEOUT		0x4E
+#define OP_PARAM_ACTIVE_LOOK_FOR_TOUCH_INTERVAL 0x4F
+
+extern int cyttsp4_device_access_read_command(const char *core_name,
+		int ic_grpnum, int ic_grpoffset, u8 *buf, int buf_size);
+
+extern int cyttsp4_device_access_write_command(const char *core_name,
+		int ic_grpnum, int ic_grpoffset, u8 *buf, int length);
+
+#endif /* _LINUX_CYTTSP4_DEVICE_ACCESS_API_H */
diff --git a/include/linux/cyttsp4_mt.h b/include/linux/cyttsp4_mt.h
new file mode 100644
index 0000000..8cc84b6
--- /dev/null
+++ b/include/linux/cyttsp4_mt.h
@@ -0,0 +1,84 @@
+/*
+ * cyttsp4_mt.h
+ * Cypress TrueTouch(TM) Standard Product V4 Multi-touch module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ * Copyright (C) 2014 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_MT_H
+#define _LINUX_CYTTSP4_MT_H
+
+#define CYTTSP4_MT_NAME "cyttsp4_mt"
+
+/* abs settings */
+#define CY_IGNORE_VALUE             0xFFFF
+/* abs signal capabilities offsets in the frameworks array */
+enum cyttsp4_sig_caps {
+	CY_SIGNAL_OST,
+	CY_MIN_OST,
+	CY_MAX_OST,
+	CY_FUZZ_OST,
+	CY_FLAT_OST,
+	CY_NUM_ABS_SET	/* number of signal capability fields */
+};
+
+/* abs axis signal offsets in the framworks array  */
+enum cyttsp4_sig_ost {
+	CY_ABS_X_OST,
+	CY_ABS_Y_OST,
+	CY_ABS_P_OST,
+	CY_ABS_W_OST,
+	CY_ABS_ID_OST,
+	CY_ABS_MAJ_OST,
+	CY_ABS_MIN_OST,
+	CY_ABS_OR_OST,
+	CY_NUM_ABS_OST	/* number of abs signals */
+};
+
+enum cyttsp4_mt_platform_flags {
+	CY_MT_FLAG_NONE = 0x00,
+	CY_MT_FLAG_HOVER = 0x04,
+	CY_MT_FLAG_FLIP = 0x08,
+	CY_MT_FLAG_INV_X = 0x10,
+	CY_MT_FLAG_INV_Y = 0x20,
+	CY_MT_FLAG_VKEYS = 0x40,
+	CY_MT_FLAG_NO_TOUCH_ON_LO = 0x80,
+};
+
+struct touch_framework {
+	const uint16_t  *abs;
+	uint8_t         size;
+	uint8_t         enable_vkeys;
+} __packed;
+
+struct cyttsp4_mt_platform_data {
+	struct touch_framework *frmwrk;
+	unsigned short flags;
+	char const *inp_dev_name;
+	int vkeys_x;
+	int vkeys_y;
+};
+
+#endif /* _LINUX_CYTTSP4_MT_H */
diff --git a/include/linux/cyttsp4_platform.h b/include/linux/cyttsp4_platform.h
new file mode 100644
index 0000000..9a1138e
--- /dev/null
+++ b/include/linux/cyttsp4_platform.h
@@ -0,0 +1,61 @@
+/*
+ * cyttsp4_platform.h
+ * Cypress TrueTouch(TM) Standard Product V4 Platform Module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_PLATFORM_H
+#define _LINUX_CYTTSP4_PLATFORM_H
+
+#include <linux/cyttsp4_core.h>
+
+#if IS_ENABLED(CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4)
+extern struct cyttsp4_loader_platform_data _cyttsp4_loader_platform_data;
+
+extern int cyttsp4_xres(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev);
+extern int cyttsp4_init(struct cyttsp4_core_platform_data *pdata,
+		int on, struct device *dev);
+extern int cyttsp4_power(struct cyttsp4_core_platform_data *pdata,
+		int on, struct device *dev, atomic_t *ignore_irq);
+extern int cyttsp4_irq_stat(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev);
+#ifdef CYTTSP4_DETECT_HW
+extern int cyttsp4_detect(struct cyttsp4_core_platform_data *pdata,
+		struct device *dev, cyttsp4_platform_read read);
+#else
+#define cyttsp4_detect		NULL
+#endif
+
+#else /* !CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4 */
+static struct cyttsp4_loader_platform_data _cyttsp4_loader_platform_data;
+#define cyttsp4_xres		NULL
+#define cyttsp4_init		NULL
+#define cyttsp4_power		NULL
+#define cyttsp4_irq_stat	NULL
+#define cyttsp4_detect		NULL
+#endif /* CONFIG_TOUCHSCREEN_CYPRESS_CYTTSP4 */
+
+#endif /* _LINUX_CYTTSP4_PLATFORM_H */
diff --git a/include/linux/cyttsp4_proximity.h b/include/linux/cyttsp4_proximity.h
new file mode 100644
index 0000000..75577e5
--- /dev/null
+++ b/include/linux/cyttsp4_proximity.h
@@ -0,0 +1,42 @@
+/*
+ * cyttsp4_proximity.h
+ * Cypress TrueTouch(TM) Standard Product V4 Proximity touch reports module.
+ * For use with Cypress Txx4xx parts.
+ * Supported parts include:
+ * TMA4XX
+ * TMA1036
+ *
+ * Copyright (C) 2014 Cypress Semiconductor
+ * Copyright (C) 2014 Sony Ericsson Mobile Communications AB.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2, and only version 2, as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * Contact Cypress Semiconductor at www.cypress.com <ttdrivers@cypress.com>
+ *
+ */
+
+#ifndef _LINUX_CYTTSP4_PROXIMITY_H
+#define _LINUX_CYTTSP4_PROXIMITY_H
+
+#include <linux/cyttsp4_mt.h>
+
+#define CYTTSP4_PROXIMITY_NAME "cyttsp4_proximity"
+
+struct cyttsp4_proximity_platform_data {
+	struct touch_framework *frmwrk;
+	char const *inp_dev_name;
+};
+
+#endif /* _LINUX_CYTTSP4_PROXIMITY_H */
-- 
1.7.9.5

