From 0fb7282ef21b98b763b5049415627810da793855 Mon Sep 17 00:00:00 2001
From: Li Zhanchao <lizc1023@thundersoft.com>
Date: Tue, 13 Sep 2016 13:28:20 +0800
Subject: [PATCH 2/2] input:touchscreen: support ctp ofilm ft5446dqs

Add CTP O-FILM@FT15-T151-1@FT5446DQS driver

Change-Id: I0521cd5c50415b82272009235846f2e837f49411
Signed-off-by: Li Zhanchao <lizc1023@thundersoft.com>
---
 drivers/input/touchscreen/ft5x06_ts.c | 1350 +++++++--------------------------
 1 file changed, 286 insertions(+), 1064 deletions(-)

diff --git a/drivers/input/touchscreen/ft5x06_ts.c b/drivers/input/touchscreen/ft5x06_ts.c
index 4b1663b..2a584be 100644
--- a/drivers/input/touchscreen/ft5x06_ts.c
+++ b/drivers/input/touchscreen/ft5x06_ts.c
@@ -2,7 +2,7 @@
  *
  * FocalTech ft5x06 TouchScreen driver.
  *
- * Copyright (c) 2010  Focal tech Ltd.
+ * Copyright (c) 2010-2016 Focal tech Ltd.
  * Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
@@ -13,7 +13,6 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- *
  */
 
 #include <linux/i2c.h>
@@ -30,13 +29,6 @@
 #include <linux/firmware.h>
 #include <linux/debugfs.h>
 #include <linux/input/ft5x06_ts.h>
-#include <linux/init.h>
-#include <linux/fs.h>
-#include <linux/uaccess.h>
-#include <linux/kobject.h>
-#include <linux/sysfs.h>
-
-
 #if defined(CONFIG_FB)
 #include <linux/notifier.h>
 #include <linux/fb.h>
@@ -47,14 +39,6 @@
 #define FT_SUSPEND_LEVEL 1
 #endif
 
-#if defined(CONFIG_FT_SECURE_TOUCH)
-#include <linux/completion.h>
-#include <linux/atomic.h>
-#include <linux/clk.h>
-#include <linux/pm_runtime.h>
-static irqreturn_t ft5x06_ts_interrupt(int irq, void *data);
-#endif
-
 #define FT_DRIVER_VERSION	0x02
 
 #define FT_META_REGS		3
@@ -73,7 +57,7 @@ static irqreturn_t ft5x06_ts_interrupt(int irq, void *data);
 #define FT_TOUCH_DOWN		0
 #define FT_TOUCH_CONTACT	2
 
-/* register address*/
+/*register address*/
 #define FT_REG_DEV_MODE		0x00
 #define FT_DEV_MODE_REG_CAL	0x02
 #define FT_REG_ID		0xA3
@@ -87,27 +71,6 @@ static irqreturn_t ft5x06_ts_interrupt(int irq, void *data);
 #define FT_REG_FW_MIN_VER	0xB2
 #define FT_REG_FW_SUB_MIN_VER	0xB3
 
-/* gesture register address*/
-#define FT_REG_GESTURE_ENABLE	0xD0
-#define FT_REG_GESTURE_OUTPUT	0xD3
-
-/* gesture register bits*/
-#define FT_GESTURE_DOUBLECLICK_COORD_X		100
-#define FT_GESTURE_DOUBLECLICK_COORD_Y		100
-#define FT_GESTURE_WAKEUP_TIMEOUT		500
-#define FT_GESTURE_DEFAULT_TRACKING_ID		0x0A
-#define FT_GESTURE_DOUBLECLICK_ID		0x24
-#define FT_GESTURE_POINTER_NUM_MAX		128
-#define FT_GESTURE_POINTER_SIZEOF		4
-#define FT_GESTURE_ID_FLAG_SIZE			1
-#define FT_GESTURE_POINTER_NUM_FLAG_SIZE	1
-/* 6 bytes are taken to mark which gesture is supported in firmware */
-#define FT_GESTURE_SET_FLAG_SIZE		6
-#define I2C_TRANSFER_MAX_BYTE			255
-#define FT_GESTURE_DATA_HEADER	(FT_GESTURE_ID_FLAG_SIZE + \
-				FT_GESTURE_POINTER_NUM_FLAG_SIZE + \
-				FT_GESTURE_SET_FLAG_SIZE)
-
 /* power register bits*/
 #define FT_PMODE_ACTIVE		0x00
 #define FT_PMODE_MONITOR	0x01
@@ -203,12 +166,6 @@ static irqreturn_t ft5x06_ts_interrupt(int irq, void *data);
 #define FT_MAGIC_BLOADER_GZF_30	0x7ff4
 #define FT_MAGIC_BLOADER_GZF	0x7bf4
 
-#define PINCTRL_STATE_ACTIVE	"pmx_ts_active"
-#define PINCTRL_STATE_SUSPEND	"pmx_ts_suspend"
-#define PINCTRL_STATE_RELEASE	"pmx_ts_release"
-
-static irqreturn_t ft5x06_ts_interrupt(int irq, void *data);
-
 enum {
 	FT_BLOADER_VERSION_LZ4 = 0,
 	FT_BLOADER_VERSION_Z7 = 1,
@@ -222,17 +179,8 @@ enum {
 	FT_FT5336_FAMILY_ID_0x14 = 0x14,
 };
 
-#define FT_STORE_TS_INFO(buf, id, fw_maj, fw_min, fw_sub_min) \
-			snprintf(buf, FT_INFO_MAX_LEN, \
-				"vendor name = Focaltech\n" \
-				"model = 0x%x\n" \
-				"fw_version = %d.%d.%d\n", \
-				id, fw_maj, fw_min, fw_sub_min)
-#define FT_TS_INFO_SYSFS_DIR_NAME "ts_info"
-static char *ts_info_buff;
-
-#define FT_STORE_TS_DBG_INFO(buf, id, name, max_tch, group_id, \
-			fw_vkey_support, fw_name, fw_maj, fw_min, fw_sub_min) \
+#define FT_STORE_TS_INFO(buf, id, name, max_tch, group_id, fw_vkey_support, \
+			fw_name, fw_maj, fw_min, fw_sub_min) \
 			snprintf(buf, FT_INFO_MAX_LEN, \
 				"controller\t= focaltech\n" \
 				"model\t\t= 0x%x\n" \
@@ -253,14 +201,13 @@ struct ft5x06_ts_data {
 	struct i2c_client *client;
 	struct input_dev *input_dev;
 	const struct ft5x06_ts_platform_data *pdata;
-	struct ft5x06_gesture_platform_data *gesture_pdata;
 	struct regulator *vdd;
 	struct regulator *vcc_i2c;
-	struct mutex ft_clk_io_ctrl_mutex;
 	char fw_name[FT_FW_NAME_MAX_LEN];
 	bool loading_fw;
 	u8 family_id;
 	struct dentry *dir;
+	u8 enable;
 	u16 addr;
 	bool suspended;
 	char *ts_info;
@@ -268,271 +215,16 @@ struct ft5x06_ts_data {
 	u32 tch_data_len;
 	u8 fw_ver[3];
 	u8 fw_vendor_id;
-	struct kobject *ts_info_kobj;
 #if defined(CONFIG_FB)
-	struct work_struct fb_notify_work;
 	struct notifier_block fb_notif;
 #elif defined(CONFIG_HAS_EARLYSUSPEND)
 	struct early_suspend early_suspend;
 #endif
 	struct pinctrl *ts_pinctrl;
-	struct pinctrl_state *pinctrl_state_active;
-	struct pinctrl_state *pinctrl_state_suspend;
-	struct pinctrl_state *pinctrl_state_release;
-#if defined(CONFIG_FT_SECURE_TOUCH)
-	atomic_t st_enabled;
-	atomic_t st_pending_irqs;
-	struct completion st_powerdown;
-	struct completion st_irq_processed;
-	bool st_initialized;
-	struct clk *core_clk;
-	struct clk *iface_clk;
-#endif
-};
-
-static int ft5x06_ts_start(struct device *dev);
-static int ft5x06_ts_stop(struct device *dev);
-
-#if defined(CONFIG_FT_SECURE_TOUCH)
-static void ft5x06_secure_touch_init(struct ft5x06_ts_data *data)
-{
-	data->st_initialized = 0;
-
-	init_completion(&data->st_powerdown);
-	init_completion(&data->st_irq_processed);
-
-	/* Get clocks */
-	data->core_clk = devm_clk_get(&data->client->dev, "core_clk");
-	if (IS_ERR(data->core_clk)) {
-		data->core_clk = NULL;
-		dev_warn(&data->client->dev,
-			"%s: core_clk is not defined\n", __func__);
-	}
-
-	data->iface_clk = devm_clk_get(&data->client->dev, "iface_clk");
-	if (IS_ERR(data->iface_clk)) {
-		data->iface_clk = NULL;
-		dev_warn(&data->client->dev,
-			"%s: iface_clk is not defined", __func__);
-	}
-	data->st_initialized = 1;
-}
-
-static void ft5x06_secure_touch_notify(struct ft5x06_ts_data *data)
-{
-	sysfs_notify(&data->input_dev->dev.kobj, NULL, "secure_touch");
-}
-
-static irqreturn_t ft5x06_filter_interrupt(struct ft5x06_ts_data *data)
-{
-	if (atomic_read(&data->st_enabled)) {
-		if (atomic_cmpxchg(&data->st_pending_irqs, 0, 1) == 0) {
-			reinit_completion(&data->st_irq_processed);
-			ft5x06_secure_touch_notify(data);
-			wait_for_completion_interruptible(
-						&data->st_irq_processed);
-		}
-		return IRQ_HANDLED;
-	}
-	return IRQ_NONE;
-}
-
-/*
- * 'blocking' variable will have value 'true' when we want to prevent the driver
- * from accessing the xPU/SMMU protected HW resources while the session is
- * active.
- */
-static void ft5x06_secure_touch_stop(struct ft5x06_ts_data *data, bool blocking)
-{
-	if (atomic_read(&data->st_enabled)) {
-		atomic_set(&data->st_pending_irqs, -1);
-		ft5x06_secure_touch_notify(data);
-		if (blocking)
-			wait_for_completion_interruptible(
-						&data->st_powerdown);
-	}
-}
-
-static int ft5x06_clk_prepare_enable(struct ft5x06_ts_data *data)
-{
-	int ret;
-
-	ret = clk_prepare_enable(data->iface_clk);
-	if (ret) {
-		dev_err(&data->client->dev,
-			"error on clk_prepare_enable(iface_clk):%d\n", ret);
-		return ret;
-	}
-
-	ret = clk_prepare_enable(data->core_clk);
-	if (ret) {
-		clk_disable_unprepare(data->iface_clk);
-		dev_err(&data->client->dev,
-			"error clk_prepare_enable(core_clk):%d\n", ret);
-	}
-	return ret;
-}
-
-static void ft5x06_clk_disable_unprepare(struct ft5x06_ts_data *data)
-{
-	clk_disable_unprepare(data->core_clk);
-	clk_disable_unprepare(data->iface_clk);
-}
-
-static int ft5x06_bus_get(struct ft5x06_ts_data *data)
-{
-	int retval;
-
-	mutex_lock(&data->ft_clk_io_ctrl_mutex);
-	retval = pm_runtime_get_sync(data->client->adapter->dev.parent);
-	if (retval >= 0 &&  data->core_clk != NULL && data->iface_clk != NULL) {
-		retval = ft5x06_clk_prepare_enable(data);
-		if (retval)
-			pm_runtime_put_sync(data->client->adapter->dev.parent);
-	}
-	mutex_unlock(&data->ft_clk_io_ctrl_mutex);
-	return retval;
-}
-
-static void ft5x06_bus_put(struct ft5x06_ts_data *data)
-{
-	mutex_lock(&data->ft_clk_io_ctrl_mutex);
-	if (data->core_clk != NULL && data->iface_clk != NULL)
-		ft5x06_clk_disable_unprepare(data);
-	pm_runtime_put_sync(data->client->adapter->dev.parent);
-	mutex_unlock(&data->ft_clk_io_ctrl_mutex);
-}
-
-static ssize_t ft5x06_secure_touch_enable_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	struct ft5x06_ts_data *data = dev_get_drvdata(dev);
-
-	return scnprintf(buf, PAGE_SIZE, "%d", atomic_read(&data->st_enabled));
-}
-
-/*
- * Accept only "0" and "1" valid values.
- * "0" will reset the st_enabled flag, then wake up the reading process and
- * the interrupt handler.
- * The bus driver is notified via pm_runtime that it is not required to stay
- * awake anymore.
- * It will also make sure the queue of events is emptied in the controller,
- * in case a touch happened in between the secure touch being disabled and
- * the local ISR being ungated.
- * "1" will set the st_enabled flag and clear the st_pending_irqs flag.
- * The bus driver is requested via pm_runtime to stay awake.
- */
-static ssize_t ft5x06_secure_touch_enable_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	struct ft5x06_ts_data *data = dev_get_drvdata(dev);
-	unsigned long value;
-	int err = 0;
-
-	if (count > 2)
-		return -EINVAL;
-	err = kstrtoul(buf, 10, &value);
-	if (err != 0)
-		return err;
-
-	if (!data->st_initialized)
-		return -EIO;
-
-	err = count;
-	switch (value) {
-	case 0:
-		if (atomic_read(&data->st_enabled) == 0)
-			break;
-		ft5x06_bus_put(data);
-		atomic_set(&data->st_enabled, 0);
-		ft5x06_secure_touch_notify(data);
-		complete(&data->st_irq_processed);
-		ft5x06_ts_interrupt(data->client->irq, data);
-		complete(&data->st_powerdown);
-		break;
-
-	case 1:
-		if (atomic_read(&data->st_enabled)) {
-			err = -EBUSY;
-			break;
-		}
-		synchronize_irq(data->client->irq);
-		if (ft5x06_bus_get(data) < 0) {
-			dev_err(&data->client->dev, "ft5x06_bus_get failed\n");
-			err = -EIO;
-			break;
-		}
-		reinit_completion(&data->st_powerdown);
-		reinit_completion(&data->st_irq_processed);
-		atomic_set(&data->st_enabled, 1);
-		atomic_set(&data->st_pending_irqs,  0);
-		break;
-
-	default:
-		dev_err(&data->client->dev, "unsupported value: %lu\n", value);
-		err = -EINVAL;
-		break;
-	}
-	return err;
-}
-
-/*
- * This function returns whether there are pending interrupts, or
- * other error conditions that need to be signaled to the userspace library,
- * according tot he following logic:
- * - st_enabled is 0 if secure touch is not enabled, returning -EBADF
- * - st_pending_irqs is -1 to signal that secure touch is in being stopped,
- *   returning -EINVAL
- * - st_pending_irqs is 1 to signal that there is a pending irq, returning
- *   the value "1" to the sysfs read operation
- * - st_pending_irqs is 0 (only remaining case left) if the pending interrupt
- *   has been processed, so the interrupt handler can be allowed to continue.
- */
-static ssize_t ft5x06_secure_touch_show(struct device *dev,
-			struct device_attribute *attr, char *buf)
-{
-	struct ft5x06_ts_data *data = dev_get_drvdata(dev);
-	int val = 0;
-
-	if (atomic_read(&data->st_enabled) == 0)
-		return -EBADF;
-	if (atomic_cmpxchg(&data->st_pending_irqs, -1, 0) == -1)
-		return -EINVAL;
-	if (atomic_cmpxchg(&data->st_pending_irqs, 1, 0) == 1)
-		val = 1;
-	else
-		complete(&data->st_irq_processed);
-	return scnprintf(buf, PAGE_SIZE, "%u", val);
-}
-#else
-static void ft5x06_secure_touch_init(struct ft5x06_ts_data *data)
-{
-}
-static irqreturn_t ft5x06_filter_interrupt(struct ft5x06_ts_data *data)
-{
-	return IRQ_NONE;
-}
-static void ft5x06_secure_touch_stop(struct ft5x06_ts_data *data, bool blocking)
-{
-}
-#endif
-
-static struct device_attribute attrs[] = {
-#if defined(CONFIG_FT_SECURE_TOUCH)
-		__ATTR(secure_touch_enable, (S_IRUGO | S_IWUSR | S_IWGRP),
-				ft5x06_secure_touch_enable_show,
-				ft5x06_secure_touch_enable_store),
-		__ATTR(secure_touch, S_IRUGO ,
-				ft5x06_secure_touch_show, NULL),
-#endif
+	struct pinctrl_state *gpio_state_active;
+	struct pinctrl_state *gpio_state_suspend;
 };
 
-static inline bool ft5x06_gesture_support_enabled(void)
-{
-	return config_enabled(CONFIG_TOUCHSCREEN_FT5X06_GESTURE);
-}
-
 static int ft5x06_i2c_read(struct i2c_client *client, char *writebuf,
 			   int writelen, char *readbuf, int readlen)
 {
@@ -608,201 +300,6 @@ static int ft5x0x_read_reg(struct i2c_client *client, u8 addr, u8 *val)
 	return ft5x06_i2c_read(client, &addr, 1, val, 1);
 }
 
-#ifdef CONFIG_TOUCHSCREEN_FT5X06_GESTURE
-static ssize_t ft5x06_gesture_enable_to_set_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	struct ft5x06_ts_data *data = dev_get_drvdata(dev);
-
-	return scnprintf(buf, PAGE_SIZE, "%d\n",
-			data->gesture_pdata->gesture_enable_to_set);
-}
-
-static ssize_t ft5x06_gesture_enable_to_set_store(struct device *dev,
-				struct device_attribute *attr,
-				const char *buf, size_t size)
-{
-	struct ft5x06_ts_data *data = dev_get_drvdata(dev);
-	unsigned long value = 0;
-	int ret;
-
-	if (data->suspended)
-		return -EINVAL;
-
-	ret = kstrtoul(buf, 16, &value);
-	if (ret < 0) {
-		dev_err(dev, "%s:kstrtoul failed, ret=0x%x\n",
-			__func__, ret);
-		return ret;
-	}
-
-	if (1 == value)
-		data->gesture_pdata->gesture_enable_to_set = 1;
-	else
-		data->gesture_pdata->gesture_enable_to_set = 0;
-	return size;
-}
-
-static DEVICE_ATTR(enable, 0664,
-		ft5x06_gesture_enable_to_set_show,
-		ft5x06_gesture_enable_to_set_store);
-
-static int ft5x06_entry_pocket(struct device *dev)
-{
-	return ft5x06_ts_stop(dev);
-}
-
-static int ft5x06_leave_pocket(struct device *dev)
-{
-	struct ft5x06_ts_data *data = dev_get_drvdata(dev);
-	int err;
-
-	ft5x06_ts_start(dev);
-	ft5x0x_write_reg(data->client, FT_REG_GESTURE_ENABLE, 1);
-	err = enable_irq_wake(data->client->irq);
-	if (err)
-		dev_err(&data->client->dev,
-			"%s: set_irq_wake failed\n", __func__);
-	data->suspended = true;
-
-	return err;
-}
-
-static ssize_t gesture_in_pocket_mode_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	struct ft5x06_ts_data *data = dev_get_drvdata(dev);
-
-	return scnprintf(buf, PAGE_SIZE, "%d\n",
-			data->gesture_pdata->in_pocket);
-}
-
-static ssize_t gesture_in_pocket_mode_store(struct device *dev,
-				struct device_attribute *attr,
-				const char *buf, size_t size)
-{
-	struct ft5x06_ts_data *data = dev_get_drvdata(dev);
-	unsigned long value = 0;
-	int ret;
-
-	ret = kstrtoul(buf, 16, &value);
-	if (ret < 0) {
-		dev_err(dev, "%s:kstrtoul failed, ret=0x%x\n",
-			__func__, ret);
-		return ret;
-	}
-
-	if (1 == value && data->gesture_pdata->in_pocket == 0) {
-		data->gesture_pdata->in_pocket = 1;
-		ft5x06_entry_pocket(dev);
-	} else if (0 == value && data->gesture_pdata->in_pocket == 1) {
-		ft5x06_leave_pocket(dev);
-		data->gesture_pdata->in_pocket = 0;
-	}
-	return size;
-}
-
-static DEVICE_ATTR(pocket, 0664,
-		gesture_in_pocket_mode_show,
-		gesture_in_pocket_mode_store);
-
-static int ft5x06_report_gesture_doubleclick(struct input_dev *ip_dev)
-{
-	int i;
-
-	for (i = 0; i < 2; i++) {
-		input_mt_slot(ip_dev, FT_GESTURE_DEFAULT_TRACKING_ID);
-		input_mt_report_slot_state(ip_dev, MT_TOOL_FINGER, 1);
-		input_report_abs(ip_dev, ABS_MT_POSITION_X,
-					FT_GESTURE_DOUBLECLICK_COORD_X);
-		input_report_abs(ip_dev, ABS_MT_POSITION_Y,
-					FT_GESTURE_DOUBLECLICK_COORD_Y);
-		input_mt_report_pointer_emulation(ip_dev, false);
-		input_sync(ip_dev);
-		input_mt_slot(ip_dev, FT_GESTURE_DEFAULT_TRACKING_ID);
-		input_mt_report_slot_state(ip_dev, MT_TOOL_FINGER, 0);
-		input_mt_report_pointer_emulation(ip_dev, false);
-		input_sync(ip_dev);
-	}
-	return 0;
-}
-
-static int ft5x06_report_gesture(struct i2c_client *i2c_client,
-		struct input_dev *ip_dev)
-{
-	int i, temp, gesture_data_size;
-	int gesture_coord_x, gesture_coord_y;
-	int ret = -1;
-	short pointnum = 0;
-	unsigned char buf[FT_GESTURE_POINTER_NUM_MAX *
-			FT_GESTURE_POINTER_SIZEOF + FT_GESTURE_DATA_HEADER];
-
-	buf[0] = FT_REG_GESTURE_OUTPUT;
-	ret = ft5x06_i2c_read(i2c_client, buf, 1,
-				buf, FT_GESTURE_DATA_HEADER);
-	if (ret < 0) {
-		dev_err(&i2c_client->dev, "%s read touchdata failed.\n",
-			__func__);
-		return ret;
-	}
-
-	/* FW support doubleclick */
-	if (FT_GESTURE_DOUBLECLICK_ID == buf[0]) {
-		ft5x06_report_gesture_doubleclick(ip_dev);
-		return 0;
-	}
-
-	pointnum = (short)(buf[1]) & 0xff;
-	gesture_data_size = pointnum * FT_GESTURE_POINTER_SIZEOF +
-			FT_GESTURE_DATA_HEADER;
-	buf[0] = FT_REG_GESTURE_OUTPUT;
-	temp = gesture_data_size / I2C_TRANSFER_MAX_BYTE;
-	for (i = 0; i < temp; i++)
-		ret = ft5x06_i2c_read(i2c_client, buf, ((i == 0) ? 1 : 0),
-			buf + I2C_TRANSFER_MAX_BYTE * i, I2C_TRANSFER_MAX_BYTE);
-	ret = ft5x06_i2c_read(i2c_client, buf, ((temp == 0) ? 1 : 0),
-			buf + I2C_TRANSFER_MAX_BYTE * temp,
-			gesture_data_size - I2C_TRANSFER_MAX_BYTE * temp);
-	if (ret < 0) {
-		dev_err(&i2c_client->dev, "%s read touchdata failed.\n",
-			__func__);
-		return ret;
-	}
-
-	for (i = 0; i < pointnum; i++) {
-		gesture_coord_x = (((s16) buf[FT_GESTURE_DATA_HEADER +
-				(FT_GESTURE_POINTER_SIZEOF * i)]) & 0x0F) << 8 |
-				(((s16) buf[FT_GESTURE_DATA_HEADER + 1 +
-				(FT_GESTURE_POINTER_SIZEOF * i)]) & 0xFF);
-		gesture_coord_y = (((s16) buf[FT_GESTURE_DATA_HEADER + 2 +
-				(FT_GESTURE_POINTER_SIZEOF * i)]) & 0x0F) << 8 |
-				(((s16) buf[FT_GESTURE_DATA_HEADER + 3 +
-				(FT_GESTURE_POINTER_SIZEOF * i)]) & 0xFF);
-		input_mt_slot(ip_dev, FT_GESTURE_DEFAULT_TRACKING_ID);
-		input_mt_report_slot_state(ip_dev, MT_TOOL_FINGER, 1);
-		input_report_abs(ip_dev, ABS_MT_POSITION_X, gesture_coord_x);
-		input_report_abs(ip_dev, ABS_MT_POSITION_Y, gesture_coord_y);
-		input_mt_report_pointer_emulation(ip_dev, false);
-		input_sync(ip_dev);
-	}
-	input_mt_slot(ip_dev, FT_GESTURE_DEFAULT_TRACKING_ID);
-	input_mt_report_slot_state(ip_dev, MT_TOOL_FINGER, 0);
-	input_mt_report_pointer_emulation(ip_dev, false);
-	input_sync(ip_dev);
-
-	return 0;
-}
-#else
-static DEVICE_ATTR(pocket, 0664, NULL, NULL);
-static DEVICE_ATTR(enable, 0664, NULL, NULL);
-
-static int ft5x06_report_gesture(struct i2c_client *i2c_client,
-		struct input_dev *ip_dev)
-{
-	return 0;
-}
-#endif
-
 static void ft5x06_update_fw_vendor_id(struct ft5x06_ts_data *data)
 {
 	struct i2c_client *client = data->client;
@@ -846,7 +343,7 @@ static irqreturn_t ft5x06_ts_interrupt(int irq, void *dev_id)
 	struct input_dev *ip_dev;
 	int rc, i;
 	u32 id, x, y, status, num_touches;
-	u8 reg, *buf, gesture_is_active;
+	u8 reg = 0x00, *buf;
 	bool update_input = false;
 
 	if (!data) {
@@ -854,40 +351,17 @@ static irqreturn_t ft5x06_ts_interrupt(int irq, void *dev_id)
 		return IRQ_HANDLED;
 	}
 
-	if (IRQ_HANDLED == ft5x06_filter_interrupt(data))
-		return IRQ_HANDLED;
-
 	ip_dev = data->input_dev;
 	buf = data->tch_data;
 
-	if (ft5x06_gesture_support_enabled() && data->pdata->gesture_support) {
-		ft5x0x_read_reg(data->client, FT_REG_GESTURE_ENABLE,
-					&gesture_is_active);
-		if (gesture_is_active) {
-			pm_wakeup_event(&(data->client->dev),
-					FT_GESTURE_WAKEUP_TIMEOUT);
-			ft5x06_report_gesture(data->client, ip_dev);
-			return IRQ_HANDLED;
-		}
-	}
-
-	/*
-	 * Read touch data start from register FT_REG_DEV_MODE.
-	 * The touch x/y value start from FT_TOUCH_X_H/L_POS and
-	 * FT_TOUCH_Y_H/L_POS in buf.
-	 */
-	reg = FT_REG_DEV_MODE;
-	rc = ft5x06_i2c_read(data->client, &reg, 1, buf, data->tch_data_len);
+	rc = ft5x06_i2c_read(data->client, &reg, 1,
+			buf, data->tch_data_len);
 	if (rc < 0) {
 		dev_err(&data->client->dev, "%s: read data fail\n", __func__);
 		return IRQ_HANDLED;
 	}
 
 	for (i = 0; i < data->pdata->num_max_touches; i++) {
-		/*
-		 * Getting the finger ID of the touch event incase of
-		 * multiple touch events
-		 */
 		id = (buf[FT_TOUCH_ID_POS + FT_ONE_TCH_LEN * i]) >> 4;
 		if (id >= FT_MAX_ID)
 			break;
@@ -912,9 +386,8 @@ static irqreturn_t ft5x06_ts_interrupt(int irq, void *dev_id)
 			input_mt_report_slot_state(ip_dev, MT_TOOL_FINGER, 1);
 			input_report_abs(ip_dev, ABS_MT_POSITION_X, x);
 			input_report_abs(ip_dev, ABS_MT_POSITION_Y, y);
-		} else {
+		} else
 			input_mt_report_slot_state(ip_dev, MT_TOOL_FINGER, 0);
-		}
 	}
 
 	if (update_input) {
@@ -925,79 +398,6 @@ static irqreturn_t ft5x06_ts_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static int ft5x06_gpio_configure(struct ft5x06_ts_data *data, bool on)
-{
-	int err = 0;
-
-	if (on) {
-		if (gpio_is_valid(data->pdata->irq_gpio)) {
-			err = gpio_request(data->pdata->irq_gpio,
-						"ft5x06_irq_gpio");
-			if (err) {
-				dev_err(&data->client->dev,
-					"irq gpio request failed");
-				goto err_irq_gpio_req;
-			}
-
-			err = gpio_direction_input(data->pdata->irq_gpio);
-			if (err) {
-				dev_err(&data->client->dev,
-					"set_direction for irq gpio failed\n");
-				goto err_irq_gpio_dir;
-			}
-		}
-
-		if (gpio_is_valid(data->pdata->reset_gpio)) {
-			err = gpio_request(data->pdata->reset_gpio,
-						"ft5x06_reset_gpio");
-			if (err) {
-				dev_err(&data->client->dev,
-					"reset gpio request failed");
-				goto err_irq_gpio_dir;
-			}
-
-			err = gpio_direction_output(data->pdata->reset_gpio, 0);
-			if (err) {
-				dev_err(&data->client->dev,
-				"set_direction for reset gpio failed\n");
-				goto err_reset_gpio_dir;
-			}
-			msleep(data->pdata->hard_rst_dly);
-			gpio_set_value_cansleep(data->pdata->reset_gpio, 1);
-		}
-
-		return 0;
-	}
-	if (gpio_is_valid(data->pdata->irq_gpio))
-		gpio_free(data->pdata->irq_gpio);
-	if (gpio_is_valid(data->pdata->reset_gpio)) {
-		/*
-		 * This is intended to save leakage current
-		 * only. Even if the call(gpio_direction_input)
-		 * fails, only leakage current will be more but
-		 * functionality will not be affected.
-		 */
-		err = gpio_direction_input(data->pdata->reset_gpio);
-		if (err) {
-			dev_err(&data->client->dev,
-				"unable to set direction for gpio [%d]\n",
-				data->pdata->irq_gpio);
-		}
-		gpio_free(data->pdata->reset_gpio);
-	}
-
-		return 0;
-
-err_reset_gpio_dir:
-	if (gpio_is_valid(data->pdata->reset_gpio))
-		gpio_free(data->pdata->reset_gpio);
-err_irq_gpio_dir:
-	if (gpio_is_valid(data->pdata->irq_gpio))
-		gpio_free(data->pdata->irq_gpio);
-err_irq_gpio_req:
-	return err;
-}
-
 static int ft5x06_power_on(struct ft5x06_ts_data *data, bool on)
 {
 	int rc;
@@ -1034,10 +434,9 @@ power_off:
 		dev_err(&data->client->dev,
 			"Regulator vcc_i2c disable failed rc=%d\n", rc);
 		rc = regulator_enable(data->vdd);
-		if (rc) {
+		if (rc)
 			dev_err(&data->client->dev,
 				"Regulator vdd enable failed rc=%d\n", rc);
-		}
 	}
 
 	return rc;
@@ -1117,124 +516,84 @@ static int ft5x06_ts_pinctrl_init(struct ft5x06_ts_data *ft5x06_data)
 	/* Get pinctrl if target uses pinctrl */
 	ft5x06_data->ts_pinctrl = devm_pinctrl_get(&(ft5x06_data->client->dev));
 	if (IS_ERR_OR_NULL(ft5x06_data->ts_pinctrl)) {
-		retval = PTR_ERR(ft5x06_data->ts_pinctrl);
 		dev_dbg(&ft5x06_data->client->dev,
-			"Target does not use pinctrl %d\n", retval);
-		goto err_pinctrl_get;
+			"Target does not use pinctrl\n");
+		retval = PTR_ERR(ft5x06_data->ts_pinctrl);
+		ft5x06_data->ts_pinctrl = NULL;
+		return retval;
 	}
 
-	ft5x06_data->pinctrl_state_active
+	ft5x06_data->gpio_state_active
 		= pinctrl_lookup_state(ft5x06_data->ts_pinctrl,
-				PINCTRL_STATE_ACTIVE);
-	if (IS_ERR_OR_NULL(ft5x06_data->pinctrl_state_active)) {
-		retval = PTR_ERR(ft5x06_data->pinctrl_state_active);
-		dev_err(&ft5x06_data->client->dev,
-			"Can not lookup %s pinstate %d\n",
-			PINCTRL_STATE_ACTIVE, retval);
-		goto err_pinctrl_lookup;
+			"pmx_ts_active");
+	if (IS_ERR_OR_NULL(ft5x06_data->gpio_state_active)) {
+		dev_dbg(&ft5x06_data->client->dev,
+			"Can not get ts default pinstate\n");
+		retval = PTR_ERR(ft5x06_data->gpio_state_active);
+		ft5x06_data->ts_pinctrl = NULL;
+		return retval;
 	}
 
-	ft5x06_data->pinctrl_state_suspend
+	ft5x06_data->gpio_state_suspend
 		= pinctrl_lookup_state(ft5x06_data->ts_pinctrl,
-			PINCTRL_STATE_SUSPEND);
-	if (IS_ERR_OR_NULL(ft5x06_data->pinctrl_state_suspend)) {
-		retval = PTR_ERR(ft5x06_data->pinctrl_state_suspend);
+			"pmx_ts_suspend");
+	if (IS_ERR_OR_NULL(ft5x06_data->gpio_state_suspend)) {
 		dev_err(&ft5x06_data->client->dev,
-			"Can not lookup %s pinstate %d\n",
-			PINCTRL_STATE_SUSPEND, retval);
-		goto err_pinctrl_lookup;
-	}
-
-	ft5x06_data->pinctrl_state_release
-		= pinctrl_lookup_state(ft5x06_data->ts_pinctrl,
-			PINCTRL_STATE_RELEASE);
-	if (IS_ERR_OR_NULL(ft5x06_data->pinctrl_state_release)) {
-		retval = PTR_ERR(ft5x06_data->pinctrl_state_release);
-		dev_dbg(&ft5x06_data->client->dev,
-			"Can not lookup %s pinstate %d\n",
-			PINCTRL_STATE_RELEASE, retval);
+			"Can not get ts sleep pinstate\n");
+		retval = PTR_ERR(ft5x06_data->gpio_state_suspend);
+		ft5x06_data->ts_pinctrl = NULL;
+		return retval;
 	}
 
 	return 0;
+}
+
+static int ft5x06_ts_pinctrl_select(struct ft5x06_ts_data *ft5x06_data,
+						bool on)
+{
+	struct pinctrl_state *pins_state;
+	int ret;
+
+	pins_state = on ? ft5x06_data->gpio_state_active
+		: ft5x06_data->gpio_state_suspend;
+	if (!IS_ERR_OR_NULL(pins_state)) {
+		ret = pinctrl_select_state(ft5x06_data->ts_pinctrl, pins_state);
+		if (ret) {
+			dev_err(&ft5x06_data->client->dev,
+				"can not set %s pins\n",
+				on ? "pmx_ts_active" : "pmx_ts_suspend");
+			return ret;
+		}
+	} else
+		dev_err(&ft5x06_data->client->dev,
+			"not a valid '%s' pinstate\n",
+				on ? "pmx_ts_active" : "pmx_ts_suspend");
 
-err_pinctrl_lookup:
-	devm_pinctrl_put(ft5x06_data->ts_pinctrl);
-err_pinctrl_get:
-	ft5x06_data->ts_pinctrl = NULL;
-	return retval;
+	return 0;
 }
 
+
 #ifdef CONFIG_PM
-static int ft5x06_ts_start(struct device *dev)
+static int ft5x06_ts_suspend(struct device *dev)
 {
 	struct ft5x06_ts_data *data = dev_get_drvdata(dev);
+	char txbuf[2], i;
 	int err;
 
-	if (data->pdata->power_on) {
-		err = data->pdata->power_on(true);
-		if (err) {
-			dev_err(dev, "power on failed");
-			return err;
-		}
-	} else {
-		err = ft5x06_power_on(data, true);
-		if (err) {
-			dev_err(dev, "power on failed");
-			return err;
-		}
-	}
-
-	if (data->ts_pinctrl) {
-		err = pinctrl_select_state(data->ts_pinctrl,
-				data->pinctrl_state_active);
-		if (err < 0)
-			dev_err(dev, "Cannot get active pinctrl state\n");
-	}
-
-	err = ft5x06_gpio_configure(data, true);
-	if (err < 0) {
-		dev_err(&data->client->dev,
-			"failed to put gpios in resue state\n");
-		goto err_gpio_configuration;
+	if (data->loading_fw) {
+		dev_info(dev, "Firmware loading in process...\n");
+		return 0;
 	}
 
-	if (gpio_is_valid(data->pdata->reset_gpio)) {
-		gpio_set_value_cansleep(data->pdata->reset_gpio, 0);
-		msleep(data->pdata->hard_rst_dly);
-		gpio_set_value_cansleep(data->pdata->reset_gpio, 1);
+	if (data->suspended) {
+		dev_info(dev, "Already in suspend state\n");
+		return 0;
 	}
-
-	msleep(data->pdata->soft_rst_dly);
-
-	enable_irq(data->client->irq);
-	data->suspended = false;
-
-	return 0;
-
-err_gpio_configuration:
 	if (data->ts_pinctrl) {
-		err = pinctrl_select_state(data->ts_pinctrl,
-					data->pinctrl_state_suspend);
+		err = ft5x06_ts_pinctrl_select(data, false);
 		if (err < 0)
-			dev_err(dev, "Cannot get suspend pinctrl state\n");
+			dev_err(dev, "Cannot get idle pinctrl state\n");
 	}
-	if (data->pdata->power_on) {
-		err = data->pdata->power_on(false);
-		if (err)
-			dev_err(dev, "power off failed");
-	} else {
-		err = ft5x06_power_on(data, false);
-		if (err)
-			dev_err(dev, "power off failed");
-	}
-	return err;
-}
-
-static int ft5x06_ts_stop(struct device *dev)
-{
-	struct ft5x06_ts_data *data = dev_get_drvdata(dev);
-	char txbuf[2];
-	int i, err;
 
 	disable_irq(data->client->irq);
 
@@ -1266,40 +625,10 @@ static int ft5x06_ts_stop(struct device *dev)
 		}
 	}
 
-	if (data->ts_pinctrl) {
-		err = pinctrl_select_state(data->ts_pinctrl,
-					data->pinctrl_state_suspend);
-		if (err < 0)
-			dev_err(dev, "Cannot get suspend pinctrl state\n");
-	}
-
-	err = ft5x06_gpio_configure(data, false);
-	if (err < 0) {
-		dev_err(&data->client->dev,
-			"failed to put gpios in suspend state\n");
-		goto gpio_configure_fail;
-	}
-
 	data->suspended = true;
 
 	return 0;
 
-gpio_configure_fail:
-	if (data->ts_pinctrl) {
-		err = pinctrl_select_state(data->ts_pinctrl,
-					data->pinctrl_state_active);
-		if (err < 0)
-			dev_err(dev, "Cannot get active pinctrl state\n");
-	}
-	if (data->pdata->power_on) {
-		err = data->pdata->power_on(true);
-		if (err)
-			dev_err(dev, "power on failed");
-	} else {
-		err = ft5x06_power_on(data, true);
-		if (err)
-			dev_err(dev, "power on failed");
-	}
 pwr_off_fail:
 	if (gpio_is_valid(data->pdata->reset_gpio)) {
 		gpio_set_value_cansleep(data->pdata->reset_gpio, 0);
@@ -1310,39 +639,6 @@ pwr_off_fail:
 	return err;
 }
 
-static int ft5x06_ts_suspend(struct device *dev)
-{
-	struct ft5x06_ts_data *data = dev_get_drvdata(dev);
-	int err;
-
-	if (data->loading_fw) {
-		dev_info(dev, "Firmware loading in process...\n");
-		return 0;
-	}
-
-	if (data->suspended) {
-		dev_info(dev, "Already in suspend state\n");
-		return 0;
-	}
-
-	ft5x06_secure_touch_stop(data, true);
-
-	if (ft5x06_gesture_support_enabled() && data->pdata->gesture_support &&
-		device_may_wakeup(dev) &&
-		data->gesture_pdata->gesture_enable_to_set) {
-
-		ft5x0x_write_reg(data->client, FT_REG_GESTURE_ENABLE, 1);
-		err = enable_irq_wake(data->client->irq);
-		if (err)
-			dev_err(&data->client->dev,
-				"%s: set_irq_wake failed\n", __func__);
-		data->suspended = true;
-		return err;
-	}
-
-	return ft5x06_ts_stop(dev);
-}
-
 static int ft5x06_ts_resume(struct device *dev)
 {
 	struct ft5x06_ts_data *data = dev_get_drvdata(dev);
@@ -1353,39 +649,37 @@ static int ft5x06_ts_resume(struct device *dev)
 		return 0;
 	}
 
-	ft5x06_secure_touch_stop(data, true);
-
-	if (ft5x06_gesture_support_enabled() && data->pdata->gesture_support &&
-		device_may_wakeup(dev) &&
-		!(data->gesture_pdata->in_pocket) &&
-		data->gesture_pdata->gesture_enable_to_set) {
+	if (data->pdata->power_on) {
+		err = data->pdata->power_on(true);
+		if (err) {
+			dev_err(dev, "power on failed");
+			return err;
+		}
+	} else {
+		err = ft5x06_power_on(data, true);
+		if (err) {
+			dev_err(dev, "power on failed");
+			return err;
+		}
+	}
+	if (data->ts_pinctrl) {
+		err = ft5x06_ts_pinctrl_select(data, true);
+		if (err < 0)
+			dev_err(dev, "Cannot get default pinctrl state\n");
+	}
 
-		ft5x0x_write_reg(data->client, FT_REG_GESTURE_ENABLE, 0);
-		err = disable_irq_wake(data->client->irq);
-		if (err)
-			dev_err(dev, "%s: disable_irq_wake failed\n",
-				__func__);
-		data->suspended = false;
-		return err;
+	if (gpio_is_valid(data->pdata->reset_gpio)) {
+		gpio_set_value_cansleep(data->pdata->reset_gpio, 0);
+		msleep(data->pdata->hard_rst_dly);
+		gpio_set_value_cansleep(data->pdata->reset_gpio, 1);
 	}
 
-	err = ft5x06_ts_start(dev);
-	if (err < 0)
-		return err;
+	msleep(data->pdata->soft_rst_dly);
 
-	if (ft5x06_gesture_support_enabled() && data->pdata->gesture_support &&
-		device_may_wakeup(dev) &&
-		data->gesture_pdata->in_pocket &&
-		data->gesture_pdata->gesture_enable_to_set) {
+	enable_irq(data->client->irq);
+
+	data->suspended = false;
 
-		ft5x0x_write_reg(data->client, FT_REG_GESTURE_ENABLE, 0);
-		err = disable_irq_wake(data->client->irq);
-		if (err)
-			dev_err(dev, "%s: disable_irq_wake failed\n",
-				__func__);
-		data->suspended = false;
-		data->gesture_pdata->in_pocket = 0;
-	}
 	return 0;
 }
 
@@ -1410,13 +704,6 @@ static int ft5x06_ts_resume(struct device *dev)
 #endif
 
 #if defined(CONFIG_FB)
-static void fb_notify_resume_work(struct work_struct *work)
-{
-	struct ft5x06_ts_data *ft5x06_data =
-		container_of(work, struct ft5x06_ts_data, fb_notify_work);
-	ft5x06_ts_resume(&ft5x06_data->client->dev);
-}
-
 static int fb_notifier_callback(struct notifier_block *self,
 				 unsigned long event, void *data)
 {
@@ -1425,27 +712,13 @@ static int fb_notifier_callback(struct notifier_block *self,
 	struct ft5x06_ts_data *ft5x06_data =
 		container_of(self, struct ft5x06_ts_data, fb_notif);
 
-	if (evdata && evdata->data && ft5x06_data && ft5x06_data->client) {
+	if (evdata && evdata->data && event == FB_EVENT_BLANK &&
+			ft5x06_data && ft5x06_data->client) {
 		blank = evdata->data;
-		if (ft5x06_data->pdata->resume_in_workqueue) {
-			if (event == FB_EARLY_EVENT_BLANK &&
-						 *blank == FB_BLANK_UNBLANK)
-				schedule_work(&ft5x06_data->fb_notify_work);
-			else if (event == FB_EVENT_BLANK &&
-						 *blank == FB_BLANK_POWERDOWN) {
-				flush_work(&ft5x06_data->fb_notify_work);
-				ft5x06_ts_suspend(&ft5x06_data->client->dev);
-			}
-		} else {
-			if (event == FB_EVENT_BLANK) {
-				if (*blank == FB_BLANK_UNBLANK)
-					ft5x06_ts_resume(
-						&ft5x06_data->client->dev);
-				else if (*blank == FB_BLANK_POWERDOWN)
-					ft5x06_ts_suspend(
-						&ft5x06_data->client->dev);
-			}
-		}
+		if (*blank == FB_BLANK_UNBLANK)
+			ft5x06_ts_resume(&ft5x06_data->client->dev);
+		else if (*blank == FB_BLANK_POWERDOWN)
+			ft5x06_ts_suspend(&ft5x06_data->client->dev);
 	}
 
 	return 0;
@@ -1457,13 +730,6 @@ static void ft5x06_ts_early_suspend(struct early_suspend *handler)
 						   struct ft5x06_ts_data,
 						   early_suspend);
 
-	/*
-	 * During early suspend/late resume, the driver doesn't access xPU/SMMU
-	 * protected HW resources. So, there is no compelling need to block,
-	 * but notifying the userspace that a power event has occurred is
-	 * enough. Hence 'blocking' variable can be set to false.
-	 */
-	ft5x06_secure_touch_stop(data, false);
 	ft5x06_ts_suspend(&data->client->dev);
 }
 
@@ -1473,7 +739,6 @@ static void ft5x06_ts_late_resume(struct early_suspend *handler)
 						   struct ft5x06_ts_data,
 						   early_suspend);
 
-	ft5x06_secure_touch_stop(data, false);
 	ft5x06_ts_resume(&data->client->dev);
 }
 #endif
@@ -1493,7 +758,7 @@ static int ft5x06_auto_cal(struct i2c_client *client)
 	msleep(2 * data->pdata->soft_rst_dly);
 	for (i = 0; i < FT_CAL_RETRY; i++) {
 		ft5x0x_read_reg(client, FT_REG_CAL, &temp);
-		/* return to normal mode, calibration finish */
+		/*return to normal mode, calibration finish */
 		if (((temp & FT_CAL_MASK) >> FT_4BIT_SHIFT) == FT_CAL_FIN)
 			break;
 	}
@@ -1555,6 +820,7 @@ static int ft5x06_fw_upgrade_start(struct i2c_client *client,
 		/* Enter upgrade mode */
 		w_buf[0] = FT_UPGRADE_55;
 		ft5x06_i2c_write(client, w_buf, 1);
+		/*usleep(FT_55_AA_DLY_NS);*/
 		usleep_range(FT_55_AA_DLY_NS, FT_55_AA_DLY_NS + 1);
 		w_buf[0] = FT_UPGRADE_AA;
 		ft5x06_i2c_write(client, w_buf, 1);
@@ -1628,10 +894,10 @@ static int ft5x06_fw_upgrade_start(struct i2c_client *client,
 
 	for (i = 0; i < pkt_num; i++) {
 		temp = i * FT_FW_PKT_LEN;
-		pkt_buf[2] = (u8) (temp >> FT_8BIT_SHIFT);
-		pkt_buf[3] = (u8) temp;
-		pkt_buf[4] = (u8) (pkt_len >> FT_8BIT_SHIFT);
-		pkt_buf[5] = (u8) pkt_len;
+		pkt_buf[2] = (u8)(temp >> FT_8BIT_SHIFT);
+		pkt_buf[3] = (u8)temp;
+		pkt_buf[4] = (u8)(pkt_len >> FT_8BIT_SHIFT);
+		pkt_buf[5] = (u8)pkt_len;
 
 		for (j = 0; j < FT_FW_PKT_LEN; j++) {
 			pkt_buf[6 + j] = data[i * FT_FW_PKT_LEN + j];
@@ -1646,11 +912,11 @@ static int ft5x06_fw_upgrade_start(struct i2c_client *client,
 	/* send remaining bytes */
 	if ((data_len) % FT_FW_PKT_LEN > 0) {
 		temp = pkt_num * FT_FW_PKT_LEN;
-		pkt_buf[2] = (u8) (temp >> FT_8BIT_SHIFT);
-		pkt_buf[3] = (u8) temp;
+		pkt_buf[2] = (u8)(temp >> FT_8BIT_SHIFT);
+		pkt_buf[3] = (u8)temp;
 		temp = (data_len) % FT_FW_PKT_LEN;
-		pkt_buf[4] = (u8) (temp >> FT_8BIT_SHIFT);
-		pkt_buf[5] = (u8) temp;
+		pkt_buf[4] = (u8)(temp >> FT_8BIT_SHIFT);
+		pkt_buf[5] = (u8)temp;
 
 		for (i = 0; i < temp; i++) {
 			pkt_buf[6 + i] = data[pkt_num * FT_FW_PKT_LEN + i];
@@ -1757,7 +1023,6 @@ static int ft5x06_fw_upgrade(struct device *dev, bool force)
 	}
 	fw_file_min = FT_FW_FILE_MIN_VER(fw);
 	fw_file_sub_min = FT_FW_FILE_SUB_MIN_VER(fw);
-	fw_file_vendor_id = FT_FW_FILE_VENDOR_ID(fw);
 
 	dev_info(dev, "Current firmware: %d.%d.%d", data->fw_ver[0],
 				data->fw_ver[1], data->fw_ver[2]);
@@ -1790,13 +1055,11 @@ static int ft5x06_fw_upgrade(struct device *dev, bool force)
 
 	ft5x06_update_fw_ver(data);
 
-	FT_STORE_TS_DBG_INFO(data->ts_info, data->family_id, data->pdata->name,
+	FT_STORE_TS_INFO(data->ts_info, data->family_id, data->pdata->name,
 			data->pdata->num_max_touches, data->pdata->group_id,
 			data->pdata->fw_vkey_support ? "yes" : "no",
 			data->pdata->fw_name, data->fw_ver[0],
 			data->fw_ver[1], data->fw_ver[2]);
-	FT_STORE_TS_INFO(ts_info_buff, data->family_id, data->fw_ver[0],
-			 data->fw_ver[1], data->fw_ver[2]);
 rel_fw:
 	release_firmware(fw);
 	return rc;
@@ -1841,9 +1104,6 @@ static ssize_t ft5x06_update_fw_store(struct device *dev,
 	return size;
 }
 
-static DEVICE_ATTR(update_fw, 0664, ft5x06_update_fw_show,
-				ft5x06_update_fw_store);
-
 static ssize_t ft5x06_force_update_fw_store(struct device *dev,
 				struct device_attribute *attr,
 				const char *buf, size_t size)
@@ -1870,8 +1130,6 @@ static ssize_t ft5x06_force_update_fw_store(struct device *dev,
 	return size;
 }
 
-static DEVICE_ATTR(force_update_fw, 0664, ft5x06_update_fw_show,
-				ft5x06_force_update_fw_store);
 
 static ssize_t ft5x06_fw_name_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
@@ -1897,15 +1155,110 @@ static ssize_t ft5x06_fw_name_store(struct device *dev,
 	return size;
 }
 
-static DEVICE_ATTR(fw_name, 0664, ft5x06_fw_name_show, ft5x06_fw_name_store);
+static ssize_t ft5x06_enable_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct ft5x06_ts_data *data = dev_get_drvdata(dev);
+
+	if (data->suspended) {
+		dev_info(&data->client->dev, "Already in suspend state\n");
+		return snprintf(buf, 4, "%s\n", "0");
+	}
+	return snprintf(buf, 4, "%s\n", data->enable ? "1" : "0");
+}
 
-static ssize_t ts_info_show(struct kobject *kobj,
-		struct kobj_attribute *attr, char *buf)
+static ssize_t ft5x06_enable_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
 {
-	strlcpy(buf, ts_info_buff, FT_INFO_MAX_LEN);
-	return strnlen(buf, FT_INFO_MAX_LEN);
+	struct ft5x06_ts_data *data = dev_get_drvdata(dev);
+	unsigned long val;
+	int rc, i;
+
+	if (size > 2)
+		return -EINVAL;
+
+	if (data->suspended) {
+		dev_info(&data->client->dev, "Already in suspend state\n");
+		return size;
+	}
+
+	rc = kstrtoul(buf, 10, &val);
+	if (rc != 0)
+		return rc;
+
+	mutex_lock(&data->input_dev->mutex);
+	if (val) {
+		rc = ft5x0x_write_reg(data->client,
+				FT_REG_PMODE, FT_PMODE_ACTIVE);
+		if (rc < 0)
+			dev_err(&data->client->dev, "enable tp failed\n");
+		enable_irq(data->client->irq);
+		data->enable = true;
+	} else {
+		disable_irq(data->client->irq);
+
+		/* release all touches */
+		for (i = 0; i < data->pdata->num_max_touches; i++) {
+			input_mt_slot(data->input_dev, i);
+			input_mt_report_slot_state(data->input_dev,
+				MT_TOOL_FINGER, 0);
+		}
+		input_mt_report_pointer_emulation(data->input_dev, false);
+		input_sync(data->input_dev);
+
+		rc = ft5x0x_write_reg(data->client,
+				FT_REG_PMODE, FT_PMODE_STANDBY);
+		if (rc < 0)
+			dev_err(&data->client->dev, "disable tp failed\n");
+		data->enable = false;
+	}
+	mutex_unlock(&data->input_dev->mutex);
+
+	return size;
 }
-static struct kobj_attribute ts_info_attr = __ATTR_RO(ts_info);
+
+static ssize_t ft5x06_mt_protocol_type_show(struct device *dev,
+					    struct device_attribute *attr,
+					    char *buf)
+{
+	return snprintf(buf, 16, "%s\n", "MT Protocal B");
+}
+
+static ssize_t ft5x06_ts_info_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct ft5x06_ts_data *data = dev_get_drvdata(dev);
+
+	return snprintf(buf, FT_INFO_MAX_LEN, "%s\n", data->ts_info);
+}
+
+static DEVICE_ATTR(update_fw,  (S_IRUGO | S_IWUSR | S_IWGRP),
+		ft5x06_update_fw_show, ft5x06_update_fw_store);
+static DEVICE_ATTR(force_update_fw,  (S_IRUGO | S_IWUSR | S_IWGRP),
+		ft5x06_update_fw_show, ft5x06_force_update_fw_store);
+static DEVICE_ATTR(fw_name,  (S_IRUGO | S_IWUSR | S_IWGRP),
+		ft5x06_fw_name_show, ft5x06_fw_name_store);
+static DEVICE_ATTR(enable, (S_IRUGO | S_IWUSR | S_IWGRP),
+		ft5x06_enable_show, ft5x06_enable_store);
+static DEVICE_ATTR(mt_protocol_type, (S_IRUGO | S_IWUSR | S_IWGRP),
+		ft5x06_mt_protocol_type_show, NULL);
+static DEVICE_ATTR(ts_info, (S_IRUGO | S_IWUSR | S_IWGRP),
+		ft5x06_ts_info_show, NULL);
+
+static struct attribute *ft_gtp_attrs[] = {
+	&dev_attr_fw_name.attr,
+	&dev_attr_update_fw.attr,
+	&dev_attr_force_update_fw.attr,
+	&dev_attr_enable.attr,
+	&dev_attr_mt_protocol_type.attr,
+	&dev_attr_ts_info.attr,
+	NULL
+};
+
+static const struct attribute_group ft_gtp_attr_grp = {
+	.attrs = ft_gtp_attrs,
+};
 
 static bool ft5x06_debug_addr_is_valid(int addr)
 {
@@ -2210,12 +1563,6 @@ static int ft5x06_parse_dt(struct device *dev,
 	pdata->ignore_id_check = of_property_read_bool(np,
 						"focaltech,ignore-id-check");
 
-	pdata->gesture_support = of_property_read_bool(np,
-						"focaltech,gesture-support");
-
-	pdata->resume_in_workqueue = of_property_read_bool(np,
-					"focaltech,resume-in-workqueue");
-
 	rc = of_property_read_u32(np, "focaltech,family-id", &temp_val);
 	if (!rc)
 		pdata->family_id = temp_val;
@@ -2251,13 +1598,12 @@ static int ft5x06_ts_probe(struct i2c_client *client,
 			   const struct i2c_device_id *id)
 {
 	struct ft5x06_ts_platform_data *pdata;
-	struct ft5x06_gesture_platform_data *gesture_pdata;
 	struct ft5x06_ts_data *data;
 	struct input_dev *input_dev;
 	struct dentry *temp;
 	u8 reg_value;
 	u8 reg_addr;
-	int err, len, retval, attr_count;
+	int err, len;
 
 	if (client->dev.of_node) {
 		pdata = devm_kzalloc(&client->dev,
@@ -2301,8 +1647,10 @@ static int ft5x06_ts_probe(struct i2c_client *client,
 	data->tch_data_len = FT_TCH_LEN(pdata->num_max_touches);
 	data->tch_data = devm_kzalloc(&client->dev,
 				data->tch_data_len, GFP_KERNEL);
-	if (!data->tch_data)
+	if (!data) {
+		dev_err(&client->dev, "Not enough memory\n");
 		return -ENOMEM;
+	}
 
 	input_dev = input_allocate_device();
 	if (!input_dev) {
@@ -2335,8 +1683,7 @@ static int ft5x06_ts_probe(struct i2c_client *client,
 	err = input_register_device(input_dev);
 	if (err) {
 		dev_err(&client->dev, "Input device registration failed\n");
-		input_free_device(input_dev);
-		return err;
+		goto free_inputdev;
 	}
 
 	if (pdata->power_init) {
@@ -2369,24 +1716,40 @@ static int ft5x06_ts_probe(struct i2c_client *client,
 
 	err = ft5x06_ts_pinctrl_init(data);
 	if (!err && data->ts_pinctrl) {
-		/*
-		 * Pinctrl handle is optional. If pinctrl handle is found
-		 * let pins to be configured in active state. If not
-		 * found continue further without error.
-		 */
-		err = pinctrl_select_state(data->ts_pinctrl,
-					data->pinctrl_state_active);
-		if (err < 0) {
+		err = ft5x06_ts_pinctrl_select(data, true);
+		if (err < 0)
+			goto pwr_off;
+	}
+
+	if (gpio_is_valid(pdata->irq_gpio)) {
+		err = gpio_request(pdata->irq_gpio, "ft5x06_irq_gpio");
+		if (err) {
+			dev_err(&client->dev, "irq gpio request failed");
+			goto pwr_off;
+		}
+		err = gpio_direction_input(pdata->irq_gpio);
+		if (err) {
 			dev_err(&client->dev,
-				"failed to select pin to active state");
+				"set_direction for irq gpio failed\n");
+			goto free_irq_gpio;
 		}
 	}
 
-	err = ft5x06_gpio_configure(data, true);
-	if (err < 0) {
-		dev_err(&client->dev,
-			"Failed to configure the gpios\n");
-		goto err_gpio_req;
+	if (gpio_is_valid(pdata->reset_gpio)) {
+		err = gpio_request(pdata->reset_gpio, "ft5x06_reset_gpio");
+		if (err) {
+			dev_err(&client->dev, "reset gpio request failed");
+			goto free_irq_gpio;
+		}
+
+		err = gpio_direction_output(pdata->reset_gpio, 0);
+		if (err) {
+			dev_err(&client->dev,
+				"set_direction for reset gpio failed\n");
+			goto free_reset_gpio;
+		}
+		msleep(data->pdata->hard_rst_dly);
+		gpio_set_value_cansleep(data->pdata->reset_gpio, 1);
 	}
 
 	/* make sure CTP already finish startup process */
@@ -2397,99 +1760,39 @@ static int ft5x06_ts_probe(struct i2c_client *client,
 	err = ft5x06_i2c_read(client, &reg_addr, 1, &reg_value, 1);
 	if (err < 0) {
 		dev_err(&client->dev, "version read failed");
-		goto free_gpio;
+		goto free_reset_gpio;
 	}
 
 	dev_info(&client->dev, "Device ID = 0x%x\n", reg_value);
 
 	if ((pdata->family_id != reg_value) && (!pdata->ignore_id_check)) {
 		dev_err(&client->dev, "%s:Unsupported controller\n", __func__);
-		goto free_gpio;
+		goto free_reset_gpio;
 	}
 
 	data->family_id = pdata->family_id;
 
 	err = request_threaded_irq(client->irq, NULL,
 				ft5x06_ts_interrupt,
-	/*
-	* the interrupt trigger mode will be set in Device Tree with property
-	* "interrupts", so here we just need to set the flag IRQF_ONESHOT
-	*/
-				IRQF_ONESHOT,
+				pdata->irqflags | IRQF_ONESHOT,
 				client->dev.driver->name, data);
 	if (err) {
 		dev_err(&client->dev, "request irq failed\n");
-		goto free_gpio;
-	}
-
-	if (ft5x06_gesture_support_enabled() && data->pdata->gesture_support) {
-		device_init_wakeup(&client->dev, 1);
-		gesture_pdata = devm_kzalloc(&client->dev,
-				sizeof(struct ft5x06_gesture_platform_data),
-				GFP_KERNEL);
-		if (!gesture_pdata) {
-			dev_err(&client->dev, "Failed to allocate memory\n");
-			goto free_gesture_dev;
-		}
-		data->gesture_pdata = gesture_pdata;
-		gesture_pdata->data = data;
-
-		gesture_pdata->gesture_class =
-					class_create(THIS_MODULE, "gesture");
-		if (IS_ERR(gesture_pdata->gesture_class)) {
-			err = PTR_ERR(gesture_pdata->gesture_class);
-			dev_err(&client->dev, "Failed to create class.\n");
-			goto free_gesture_pdata;
-		}
-
-		gesture_pdata->dev = device_create(gesture_pdata->gesture_class,
-				NULL, 0, NULL, "gesture_ft5x06");
-		if (IS_ERR(gesture_pdata->dev)) {
-			err = PTR_ERR(gesture_pdata->dev);
-			dev_err(&client->dev, "Failed to create device.\n");
-			goto free_gesture_class;
-		}
-
-		dev_set_drvdata(gesture_pdata->dev, data);
-		err = device_create_file(gesture_pdata->dev,
-					&dev_attr_enable);
-		if (err) {
-			dev_err(gesture_pdata->dev,
-					"sys file creation failed\n");
-			goto free_gesture_dev;
-		}
-		err = device_create_file(gesture_pdata->dev,
-					&dev_attr_pocket);
-		if (err) {
-			dev_err(gesture_pdata->dev,
-					"sys file creation failed\n");
-			goto free_enable_sys;
-		}
-	}
-
-	err = device_create_file(&client->dev, &dev_attr_fw_name);
-	if (err) {
-		dev_err(&client->dev, "sys file creation failed\n");
-		goto free_pocket_sys;
-	}
-
-	err = device_create_file(&client->dev, &dev_attr_update_fw);
-	if (err) {
-		dev_err(&client->dev, "sys file creation failed\n");
-		goto free_fw_name_sys;
+		goto free_reset_gpio;
 	}
 
-	err = device_create_file(&client->dev, &dev_attr_force_update_fw);
+	data->enable = true;
+	err = sysfs_create_group(&client->dev.kobj, &ft_gtp_attr_grp);
 	if (err) {
-		dev_err(&client->dev, "sys file creation failed\n");
-		goto free_update_fw_sys;
+		dev_err(&client->dev, "sys group_file creation failed.\n");
+		goto irq_free;
 	}
 
 	data->dir = debugfs_create_dir(FT_DEBUG_DIR_NAME, NULL);
 	if (data->dir == NULL || IS_ERR(data->dir)) {
 		pr_err("debugfs_create_dir failed(%ld)\n", PTR_ERR(data->dir));
 		err = PTR_ERR(data->dir);
-		goto free_force_update_fw_sys;
+		goto exit_remove_sysfs;
 	}
 
 	temp = debugfs_create_file("addr", S_IRUSR | S_IWUSR, data->dir, data,
@@ -2544,53 +1847,16 @@ static int ft5x06_ts_probe(struct i2c_client *client,
 
 	dev_dbg(&client->dev, "touch threshold = %d\n", reg_value * 4);
 
-	/*creation touch panel info kobj*/
-	data->ts_info_kobj = kobject_create_and_add(FT_TS_INFO_SYSFS_DIR_NAME,
-					kernel_kobj);
-	if (!data->ts_info_kobj) {
-		dev_err(&client->dev, "kobject creation failed.\n");
-	} else {
-		err = sysfs_create_file(data->ts_info_kobj, &ts_info_attr.attr);
-		if (err) {
-			kobject_put(data->ts_info_kobj);
-			dev_err(&client->dev, "sysfs creation failed.\n");
-		} else {
-			ts_info_buff = devm_kzalloc(&client->dev,
-						 FT_INFO_MAX_LEN, GFP_KERNEL);
-			if (!ts_info_buff)
-				goto free_debug_dir;
-		}
-	}
-
-	/*Initialize secure touch */
-	ft5x06_secure_touch_init(data);
-	ft5x06_secure_touch_stop(data, true);
-	mutex_init(&(data->ft_clk_io_ctrl_mutex));
-
-	/* Creation of secure touch sysfs files */
-	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++) {
-		retval = sysfs_create_file(&data->input_dev->dev.kobj,
-						&attrs[attr_count].attr);
-		if (retval < 0) {
-			dev_err(&client->dev,
-				"%s: Failed to create sysfs attributes\n",
-							__func__);
-			goto free_secure_touch_sysfs;
-		}
-	}
-
 	ft5x06_update_fw_ver(data);
 	ft5x06_update_fw_vendor_id(data);
 
-	FT_STORE_TS_DBG_INFO(data->ts_info, data->family_id, data->pdata->name,
+	FT_STORE_TS_INFO(data->ts_info, data->family_id, data->pdata->name,
 			data->pdata->num_max_touches, data->pdata->group_id,
 			data->pdata->fw_vkey_support ? "yes" : "no",
 			data->pdata->fw_name, data->fw_ver[0],
 			data->fw_ver[1], data->fw_ver[2]);
-	FT_STORE_TS_INFO(ts_info_buff, data->family_id, data->fw_ver[0],
-			 data->fw_ver[1], data->fw_ver[2]);
+
 #if defined(CONFIG_FB)
-	INIT_WORK(&data->fb_notify_work, fb_notify_resume_work);
 	data->fb_notif.notifier_call = fb_notifier_callback;
 
 	err = fb_register_client(&data->fb_notif);
@@ -2605,56 +1871,32 @@ static int ft5x06_ts_probe(struct i2c_client *client,
 	data->early_suspend.resume = ft5x06_ts_late_resume;
 	register_early_suspend(&data->early_suspend);
 #endif
+
 	return 0;
 
-free_secure_touch_sysfs:
-	for (attr_count--; attr_count >= 0; attr_count--) {
-		sysfs_remove_file(&data->input_dev->dev.kobj,
-					&attrs[attr_count].attr);
-	}
 free_debug_dir:
 	debugfs_remove_recursive(data->dir);
-free_force_update_fw_sys:
-	device_remove_file(&client->dev, &dev_attr_force_update_fw);
-free_update_fw_sys:
-	device_remove_file(&client->dev, &dev_attr_update_fw);
-free_fw_name_sys:
-	device_remove_file(&client->dev, &dev_attr_fw_name);
-free_pocket_sys:
-	if (ft5x06_gesture_support_enabled() && data->pdata->gesture_support)
-		device_remove_file(&client->dev, &dev_attr_pocket);
-free_enable_sys:
-	if (ft5x06_gesture_support_enabled() && data->pdata->gesture_support)
-		device_remove_file(&client->dev, &dev_attr_enable);
-free_gesture_dev:
-	if (ft5x06_gesture_support_enabled() && data->pdata->gesture_support)
-		device_destroy(gesture_pdata->gesture_class, 0);
-free_gesture_class:
-	if (ft5x06_gesture_support_enabled() && data->pdata->gesture_support)
-		class_destroy(gesture_pdata->gesture_class);
-free_gesture_pdata:
-	if (ft5x06_gesture_support_enabled() && data->pdata->gesture_support) {
-		devm_kfree(&client->dev, gesture_pdata);
-		data->gesture_pdata = NULL;
-	}
-
-free_gpio:
+exit_remove_sysfs:
+	sysfs_remove_group(&data->input_dev->dev.kobj, &ft_gtp_attr_grp);
+irq_free:
+	free_irq(client->irq, data);
+free_reset_gpio:
 	if (gpio_is_valid(pdata->reset_gpio))
 		gpio_free(pdata->reset_gpio);
+	if (data->ts_pinctrl) {
+		err = ft5x06_ts_pinctrl_select(data, false);
+		if (err < 0)
+			pr_err("Cannot get idle pinctrl state\n");
+	}
+free_irq_gpio:
 	if (gpio_is_valid(pdata->irq_gpio))
 		gpio_free(pdata->irq_gpio);
-err_gpio_req:
 	if (data->ts_pinctrl) {
-		if (IS_ERR_OR_NULL(data->pinctrl_state_release)) {
-			devm_pinctrl_put(data->ts_pinctrl);
-			data->ts_pinctrl = NULL;
-		} else {
-			err = pinctrl_select_state(data->ts_pinctrl,
-					data->pinctrl_state_release);
-			if (err)
-				pr_err("failed to select relase pinctrl state\n");
-		}
+		err = ft5x06_ts_pinctrl_select(data, false);
+		if (err < 0)
+			pr_err("Cannot get idle pinctrl state\n");
 	}
+pwr_off:
 	if (pdata->power_on)
 		pdata->power_on(false);
 	else
@@ -2666,28 +1908,19 @@ pwr_deinit:
 		ft5x06_power_init(data, false);
 unreg_inputdev:
 	input_unregister_device(input_dev);
+	input_dev = NULL;
+free_inputdev:
+	input_free_device(input_dev);
 	return err;
 }
 
 static int ft5x06_ts_remove(struct i2c_client *client)
 {
 	struct ft5x06_ts_data *data = i2c_get_clientdata(client);
-	int retval, attr_count;
-
-	if (ft5x06_gesture_support_enabled() && data->pdata->gesture_support) {
-		device_init_wakeup(&client->dev, 0);
-		device_remove_file(&client->dev, &dev_attr_pocket);
-		device_remove_file(&client->dev, &dev_attr_enable);
-		device_destroy(data->gesture_pdata->gesture_class, 0);
-		class_destroy(data->gesture_pdata->gesture_class);
-		devm_kfree(&client->dev, data->gesture_pdata);
-		data->gesture_pdata = NULL;
-	}
+	int retval;
 
 	debugfs_remove_recursive(data->dir);
-	device_remove_file(&client->dev, &dev_attr_force_update_fw);
-	device_remove_file(&client->dev, &dev_attr_update_fw);
-	device_remove_file(&client->dev, &dev_attr_fw_name);
+	sysfs_remove_group(&data->input_dev->dev.kobj, &ft_gtp_attr_grp);
 
 #if defined(CONFIG_FB)
 	if (fb_unregister_client(&data->fb_notif))
@@ -2704,20 +1937,9 @@ static int ft5x06_ts_remove(struct i2c_client *client)
 		gpio_free(data->pdata->irq_gpio);
 
 	if (data->ts_pinctrl) {
-		if (IS_ERR_OR_NULL(data->pinctrl_state_release)) {
-			devm_pinctrl_put(data->ts_pinctrl);
-			data->ts_pinctrl = NULL;
-		} else {
-			retval = pinctrl_select_state(data->ts_pinctrl,
-					data->pinctrl_state_release);
-			if (retval < 0)
-				pr_err("failed to select release pinctrl state\n");
-		}
-	}
-
-	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs); attr_count++) {
-		sysfs_remove_file(&data->input_dev->dev.kobj,
-					&attrs[attr_count].attr);
+		retval = ft5x06_ts_pinctrl_select(data, false);
+		if (retval < 0)
+			pr_err("Cannot get idle pinctrl state\n");
 	}
 
 	if (data->pdata->power_on)
@@ -2731,7 +1953,7 @@ static int ft5x06_ts_remove(struct i2c_client *client)
 		ft5x06_power_init(data, false);
 
 	input_unregister_device(data->input_dev);
-	kobject_put(data->ts_info_kobj);
+
 	return 0;
 }
 
@@ -2744,8 +1966,8 @@ MODULE_DEVICE_TABLE(i2c, ft5x06_ts_id);
 
 #ifdef CONFIG_OF
 static struct of_device_id ft5x06_match_table[] = {
-	{ .compatible = "focaltech,5x06",},
-	{ },
+	{.compatible = "focaltech,5x06",},
+	{},
 };
 #else
 #define ft5x06_match_table NULL
@@ -2755,13 +1977,13 @@ static struct i2c_driver ft5x06_ts_driver = {
 	.probe = ft5x06_ts_probe,
 	.remove = ft5x06_ts_remove,
 	.driver = {
-		   .name = "ft5x06_ts",
-		   .owner = THIS_MODULE,
+		.name = "ft5x06_ts",
+		.owner = THIS_MODULE,
 		.of_match_table = ft5x06_match_table,
 #ifdef CONFIG_PM
-		   .pm = &ft5x06_ts_pm_ops,
+		.pm = &ft5x06_ts_pm_ops,
 #endif
-		   },
+		},
 	.id_table = ft5x06_ts_id,
 };
 
-- 
1.9.1

