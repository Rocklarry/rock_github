From c22e9f4ca13e302a413a3ee9ac5977d4c0ca993e Mon Sep 17 00:00:00 2001
From: Li Zhanchao <lizc1023@thundersoft.com>
Date: Tue, 11 Oct 2016 11:45:23 +0800
Subject: [PATCH 3/3] input:touchscreen: support ctp holitech msg2836

Add CTP HOLITECH@CBM6164@MSG2836 driver

Change-Id: I808d682b3eab042e29a09fddf84524c3c612d342
Signed-off-by: Li Zhanchao <lizc1023@thundersoft.com>
---
 drivers/input/touchscreen/Kconfig                  |   10 +
 drivers/input/touchscreen/Makefile                 |    1 +
 drivers/input/touchscreen/msg28xx/Makefile         |   14 +
 .../input/touchscreen/msg28xx/mstar_drv_common.c   |  143 +
 .../input/touchscreen/msg28xx/mstar_drv_common.h   |  552 ++
 .../input/touchscreen/msg28xx/mstar_drv_extern.h   |   41 +
 .../msg28xx/mstar_drv_ic_fw_porting_layer.c        |  239 +
 .../msg28xx/mstar_drv_ic_fw_porting_layer.h        |  116 +
 .../touchscreen/msg28xx/mstar_drv_jni_interface.c  |  272 +
 .../touchscreen/msg28xx/mstar_drv_jni_interface.h  |   93 +
 drivers/input/touchscreen/msg28xx/mstar_drv_main.c | 3458 +++++++++++++
 drivers/input/touchscreen/msg28xx/mstar_drv_main.h |  273 +
 .../msg28xx/mstar_drv_mutual_fw_control.c          | 5287 ++++++++++++++++++++
 .../msg28xx/mstar_drv_mutual_fw_control.h          |  251 +
 .../msg28xx/mstar_drv_platform_interface.c         |  305 ++
 .../msg28xx/mstar_drv_platform_interface.h         |   87 +
 .../msg28xx/mstar_drv_platform_porting_layer.c     |  810 +++
 .../msg28xx/mstar_drv_platform_porting_layer.h     |  139 +
 drivers/input/touchscreen/msg28xx/mstar_drv_qcom.c |  137 +
 .../msg28xx/mstar_drv_utility_adaption.c           |  525 ++
 .../msg28xx/mstar_drv_utility_adaption.h           |   93 +
 21 files changed, 12846 insertions(+)
 create mode 100644 drivers/input/touchscreen/msg28xx/Makefile
 create mode 100644 drivers/input/touchscreen/msg28xx/mstar_drv_common.c
 create mode 100644 drivers/input/touchscreen/msg28xx/mstar_drv_common.h
 create mode 100644 drivers/input/touchscreen/msg28xx/mstar_drv_extern.h
 create mode 100644 drivers/input/touchscreen/msg28xx/mstar_drv_ic_fw_porting_layer.c
 create mode 100644 drivers/input/touchscreen/msg28xx/mstar_drv_ic_fw_porting_layer.h
 create mode 100644 drivers/input/touchscreen/msg28xx/mstar_drv_jni_interface.c
 create mode 100644 drivers/input/touchscreen/msg28xx/mstar_drv_jni_interface.h
 create mode 100644 drivers/input/touchscreen/msg28xx/mstar_drv_main.c
 create mode 100644 drivers/input/touchscreen/msg28xx/mstar_drv_main.h
 create mode 100644 drivers/input/touchscreen/msg28xx/mstar_drv_mutual_fw_control.c
 create mode 100644 drivers/input/touchscreen/msg28xx/mstar_drv_mutual_fw_control.h
 create mode 100644 drivers/input/touchscreen/msg28xx/mstar_drv_platform_interface.c
 create mode 100644 drivers/input/touchscreen/msg28xx/mstar_drv_platform_interface.h
 create mode 100644 drivers/input/touchscreen/msg28xx/mstar_drv_platform_porting_layer.c
 create mode 100644 drivers/input/touchscreen/msg28xx/mstar_drv_platform_porting_layer.h
 create mode 100644 drivers/input/touchscreen/msg28xx/mstar_drv_qcom.c
 create mode 100644 drivers/input/touchscreen/msg28xx/mstar_drv_utility_adaption.c
 create mode 100644 drivers/input/touchscreen/msg28xx/mstar_drv_utility_adaption.h

diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 3cc1d6c..8d25066 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -1114,6 +1114,16 @@ config TOUCHSCREEN_GT9XX
 
           If unsure, say N.
 
+config TOUCHSCREEN_MSG28XX
+	bool "Mstar touchpanel MSG28XX series"
+	depends on I2C
+	help
+	  Say Y here if you have a Mstar MSG28XX touchscreen.
+	  MSG28XX controllers are multi touch controllers which can
+	  report 5 touches at a time.
+
+          If unsure, say N.
+
 config TOUCHSCREEN_MAXIM_STI
 	tristate "Maxim based STI touchscreens"
 	depends on SPI_MASTER
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 8dacb2e..6856d88 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -86,6 +86,7 @@ obj-$(CONFIG_TOUCHSCREEN_WM97XX_ZYLONITE)	+= zylonite-wm97xx.o
 obj-$(CONFIG_TOUCHSCREEN_W90X900)	+= w90p910_ts.o
 obj-$(CONFIG_TOUCHSCREEN_TPS6507X)	+= tps6507x-ts.o
 obj-$(CONFIG_TOUCHSCREEN_ZFORCE)	+= zforce_ts.o
+obj-$(CONFIG_TOUCHSCREEN_MSG28XX)	+= msg28xx/
 obj-$(CONFIG_TOUCHSCREEN_MSTAR21XX)	+= msg21xx_ts.o
 obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4)		+= synaptics_i2c_rmi4.o
 obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI4_DEV)	+= synaptics_rmi_dev.o
diff --git a/drivers/input/touchscreen/msg28xx/Makefile b/drivers/input/touchscreen/msg28xx/Makefile
new file mode 100644
index 0000000..60128c1
--- /dev/null
+++ b/drivers/input/touchscreen/msg28xx/Makefile
@@ -0,0 +1,14 @@
+#obj-$(CONFIG_TOUCHSCREEN_MSG28XX_COMMON) += mstar_drv_common.o mstar_drv_qcom.o
+#obj-$(CONFIG_TOUCHSCREEN_MSG28XX_MAIN) += mstar_drv_main.o
+#obj-$(CONFIG_TOUCHSCREEN_MSG28XX_CONTROL) += mstar_drv_mutual_control.o
+#obj-$(CONFIG_TOUCHSCREEN_MSG28XX_PORTING) += mstar_drv_platform_porting_layer.o
+#obj-$(CONFIG_TOUCHSCREEN_MSG28XX_INTERFACE) += mstar_drv_platform_interface.o
+#obj-$(CONFIG_TOUCHSCREEN_MSG28XX_ADAPTION) += mstar_drv_utility_adaption.o
+
+obj-y += mstar_drv_common.o mstar_drv_qcom.o
+obj-y += mstar_drv_main.o
+obj-y += mstar_drv_mutual_fw_control.o
+obj-y += mstar_drv_platform_porting_layer.o
+obj-y += mstar_drv_platform_interface.o
+obj-y += mstar_drv_utility_adaption.o
+obj-y += mstar_drv_ic_fw_porting_layer.o
diff --git a/drivers/input/touchscreen/msg28xx/mstar_drv_common.c b/drivers/input/touchscreen/msg28xx/mstar_drv_common.c
new file mode 100644
index 0000000..17d9dfd
--- /dev/null
+++ b/drivers/input/touchscreen/msg28xx/mstar_drv_common.c
@@ -0,0 +1,143 @@
+/*******************************************
+//
+// Copyright (c) 2006-2016 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages,
+// losses, costs and expenses resulting therefrom.
+//
+************************************************/
+
+/**
+ *
+ * @file	mstar_drv_common.c
+ *
+ * @brief	This file defines the interface of touch screen
+ *
+ *
+ */
+
+
+#include "mstar_drv_common.h"
+
+
+static u32 _gCrc32Table[256];
+
+
+u32 DrvCommonCrcDoReflect(u32 nRef, s8 nCh)
+{
+	u32 nValue = 0;
+	u32 i = 0;
+
+	for (i = 1; i < (nCh + 1); i++) {
+		if (nRef & 1)
+			nValue |= 1 << (nCh - i);
+		nRef >>= 1;
+	}
+
+	return nValue;
+}
+
+u32 DrvCommonCrcGetValue(u32 nText, u32 nPrevCRC)
+{
+	u32 nCRC = nPrevCRC;
+
+	nCRC = (nCRC >> 8) ^ _gCrc32Table[(nCRC & 0xFF) ^ nText];
+
+	return nCRC;
+}
+
+void DrvCommonCrcInitTable(void)
+{
+	u32 nMagicNumber = 0x04c11db7;
+	u32 i, j;
+
+	for (i = 0; i <= 0xFF; i++) {
+		_gCrc32Table[i] = DrvCommonCrcDoReflect(i, 8) << 24;
+		for (j = 0; j < 8; j++)
+			_gCrc32Table[i] = (_gCrc32Table[i] << 1) ^
+				(_gCrc32Table[i] &
+				(0x80000000L) ? nMagicNumber : 0);
+
+		_gCrc32Table[i] =
+			DrvCommonCrcDoReflect(_gCrc32Table[i], 32);
+	}
+}
+
+u8 DrvCommonCalculateCheckSum(u8 *pMsg, u32 nLength)
+{
+	s32 nCheckSum = 0;
+	u32 i;
+
+	for (i = 0; i < nLength; i++)
+		nCheckSum += pMsg[i];
+
+	return (u8)((-nCheckSum) & 0xFF);
+}
+
+u32 DrvCommonConvertCharToHexDigit(char *pCh, u32 nLength)
+{
+	u32 nRetVal = 0;
+	u32 i;
+
+	DBG("nLength = %d\n", nLength);
+
+	for (i = 0; i < nLength; i++) {
+		char ch = *pCh++;
+		u32 n = 0;
+		u8	nIsValidDigit = 0;
+
+		if ((i == 0 && ch == '0') || (i == 1 && ch == 'x'))
+			continue;
+
+		if ('0' <= ch && ch <= '9') {
+			n = ch-'0';
+			nIsValidDigit = 1;
+		} else if ('a' <= ch && ch <= 'f') {
+			n = 10 + ch-'a';
+			nIsValidDigit = 1;
+		} else if ('A' <= ch && ch <= 'F') {
+			n = 10 + ch-'A';
+			nIsValidDigit = 1;
+		}
+
+		if (1 == nIsValidDigit)
+			nRetVal = n + nRetVal * 16;
+	}
+
+	return nRetVal;
+}
+
+void DrvCommonReadFile(char *pFilePath, u8 *pBuf, u16 nLength)
+{
+	struct file *pFile = NULL;
+	mm_segment_t old_fs;
+	ssize_t nReadBytes = 0;
+
+	old_fs = get_fs();
+	set_fs(get_ds());
+
+	/*pFile = filp_open(pFilePath, O_RDONLY, 0);*/
+	if (IS_ERR(pFile)) {
+		DBG("Open file failed: %s\n", pFilePath);
+		return;
+	}
+
+	pFile->f_op->llseek(pFile, 0, SEEK_SET);
+	nReadBytes =
+		pFile->f_op->read(pFile,
+		pBuf, nLength, &pFile->f_pos);
+	DBG("Read %d bytes!\n", (int)nReadBytes);
+
+	set_fs(old_fs);
+	filp_close(pFile, NULL);
+}
+
diff --git a/drivers/input/touchscreen/msg28xx/mstar_drv_common.h b/drivers/input/touchscreen/msg28xx/mstar_drv_common.h
new file mode 100644
index 0000000..db89a1e
--- /dev/null
+++ b/drivers/input/touchscreen/msg28xx/mstar_drv_common.h
@@ -0,0 +1,552 @@
+/*********************************************
+// Copyright (c) 2006-2016 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages,
+// losses, costs and expenses resulting therefrom.
+//
+**********************************************************/
+/**
+ *
+ * @file	mstar_drv_common.h
+ *
+ * @brief	This file defines the interface of touch screen
+ *
+ *
+ */
+
+#ifndef __MSTAR_DRV_COMMON_H__
+#define __MSTAR_DRV_COMMON_H__
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#if defined(CONDIF_HAS_EARLYSUSPEND)
+#include <linux/earlysuspend.h>
+#endif
+#include <linux/i2c.h>
+#include <linux/proc_fs.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/miscdevice.h>
+#include <linux/time.h>
+#include <linux/input/mt.h>
+#include <asm/unistd.h>
+#include <linux/uaccess.h>
+#include <asm/irq.h>
+#include <linux/io.h>
+#include <linux/debugfs.h>
+#include <linux/version.h>
+#if defined(CONFIG_FB)
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#endif
+
+#define DEVICE_DRIVER_RELEASE_VERSION	("3.6.0.0")
+
+
+
+/*
+ * Note.
+ * The below compile option is used to enable the specific device driver code
+ * handling to make sure main board can supply power to touch ic for some
+ * specific BB chip of MTK(EX. MT6582)/SPRD(EX. SC7715)/QCOM(EX. MSM8610).
+ * By default, this compile option is disabled.
+ */
+#define CONFIG_ENABLE_REGULATOR_POWER_ON
+
+/*
+ * Note.
+ * The below compile option is used to
+ * enable touch pin control for specific SPRD/QCOM platform.
+ * This compile option is used for specific SPRD/QCOM platform only.
+ * By default, this compile option is disabled.
+ */
+#define CONFIG_ENABLE_TOUCH_PIN_CONTROL
+
+
+
+
+
+/*
+ * Note.
+ * The below compile option is used to enable the specific device driver code
+ * handling when touch panel support virtual key(EX. Menu, Home, Back, Search).
+ * If this compile option is not defined,
+ * the function for virtual key handling will be disabled.
+ * By default, this compile option is enabled.
+ */
+#define CONFIG_TP_HAVE_KEY
+
+/*
+ * Note.
+ * Since specific MTK BB chip report virtual key touch by using coordinate
+ * instead of key code, the below compile option is used to enable the code
+ * handling for reporting key with coordinate.
+ * By default, this compile option is disabled.
+ */
+/*#define CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE*/
+
+/*
+ * Note.
+ * The below flag is used to enable debug mode data log for firmware.
+ * Please make sure firmware support
+ * debug mode data log firstly, then you can enable this flag.
+ * By default, this flag is enabled.
+ */
+#define CONFIG_ENABLE_FIRMWARE_DATA_LOG (1)
+
+/*
+ * Note.
+ * The below compile option is used to enable segment read debug mode finger
+ * touch data for MSG26XXM/MSG28XX only.
+ * Since I2C transaction length limitation for some specific MTK BB chip(EX.
+ * MT6589/MT6572/...) or QCOM BB chip, the debug mode finger touch data of
+ * MSG26XXM/MSG28XX can not be retrieved by one time I2C read operation.
+ * So we need to retrieve the complete finger touch data by segment read.
+ * By default, this compile option is enabled.
+ */
+#define CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+
+/*
+ * Note.
+ * The below compile option is used to enable gesture wakeup.
+ * By default, this compile option is disabled.
+ */
+/*#define CONFIG_ENABLE_GESTURE_WAKEUP*/
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+
+/*
+ * Note.
+ * The below compile option is used to enable device driver to support at most
+ * 64 types of gesture wakeup mode.
+ * If the below compile option is not enabled, device driver can only support
+ * at most 16 types of gesture wakeup mode.
+ * By the way, 64 types of gesture wakeup
+ * mode is ready for MSG22XX/MSG28XX only.
+ * But, 64 types of gesture wakeup mode for
+ * MSG21XXA/MSG26XXM is not supported.
+ * By default, this compile option is disabled.
+ */
+/*#define CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE*/
+
+/*
+ * Note.
+ * The below compile option is used to enable gesture debug mode.
+ * By default, this compile option is disabled.
+ */
+/*#define CONFIG_ENABLE_GESTURE_DEBUG_MODE*/
+
+/*
+ * Note.
+ * The below compile option is used to enable gesture information mode.
+ * By default, this compile option is disabled.
+ */
+/*#define CONFIG_ENABLE_GESTURE_INFORMATION_MODE*/
+
+#endif
+
+/*
+ * Note.
+ * The below compile option is used to enable phone level MP test handling.
+ * By default, this compile option is disabled.
+ */
+/*#define CONFIG_ENABLE_ITO_MP_TEST*/
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+
+/*
+ * Note.
+ * The below compile option is used to enable the specific short test item of
+ * 2R triangle pattern for self-capacitive touch ic.
+ * This compile option is used for MSG21XXA/MSG22XX only.
+ * Please enable the compile option if the ITO pattern is 2R triangle pattern
+ * for MSG21XXA/MSG22XX.
+ * Please disable the compile option if the ITO pattern is H(horizontal)
+ * triangle pattern for MSG21XXA/MSG22XX.
+ * By default, this compile option is enabled.
+ */
+#define CONFIG_ENABLE_MP_TEST_ITEM_FOR_2R_TRIANGLE
+
+#endif
+
+
+/*
+ * Note.
+ * If this compile option is not defined, the SW ID mechanism for updating
+ * firmware will be disabled.
+ * By default, this compile option is disabled.
+ */
+/*#define CONFIG_UPDATE_FIRMWARE_BY_SW_ID*/
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+/*
+ * Note.
+ * If this compile option is defined, the update firmware bin file shall be
+ * stored in a two dimensional array format.
+ * Else, the update firmware bin file shall be stored in an one dimensional
+ * array format.
+ * Be careful, MSG22XX only support storing update firmware bin file in an one
+ * dimensional array format, it does not support two dimensional array format.
+ * By default, this compile option is enabled.
+ */
+#define CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY
+
+#endif
+
+
+/*
+ * Note.
+ * The below compile option is used to enable proximity detection.
+ * By default, this compile option is disabled.
+ */
+/*#define CONFIG_ENABLE_PROXIMITY_DETECTION*/
+
+/*
+ * Note.
+ * The below compile option is used to enable notifier feedback handling for
+ * QCOM platform.
+ * By default, this compile option is disabled.
+ */
+#define CONFIG_ENABLE_NOTIFIER_FB
+
+
+/*
+ * Note.
+ * The below compile option is used to enable report rate calculation.
+ * By default, this compile option is enabled.
+ */
+#define CONFIG_ENABLE_COUNT_REPORT_RATE
+
+
+/*
+ * Note.
+ * The below compile option is used to
+ * enable glove mode and only supports MSG28XX.
+ * By default, this compile option is disabled.
+ */
+/*#define CONFIG_ENABLE_GLOVE_MODE*/
+
+
+/*
+ * Note.
+ * The below compile option is used to enable jni interface.
+ * By default, this compile option is enabled.
+ */
+/*#define CONFIG_ENABLE_JNI_INTERFACE*/
+
+
+/*
+ * Note.
+ * The below compile option is used to enable charger detection for notifying
+ * the charger plug in/plug out status to touch firmware.
+ * By default, this compile option is disabled.
+ */
+/*#define CONFIG_ENABLE_CHARGER_DETECTION*/
+
+
+/*
+ * Note.
+ * The below compile option is used to enable the debug code for clarifying
+ * some issues. For example, to debug the delay time issue for IC hardware
+ * reset.
+ * By the way, this feature is supported for MSG28XX only.
+ * By default, this compile option is disabled.
+ */
+#define CONFIG_ENABLE_CODE_FOR_DEBUG
+
+
+/*
+ * Note.
+ * The below compile option is used to enable/disable Type A/Type B multi-touch
+ * protocol for reporting touch point/key to Linux input sub-system.
+ * If this compile option is defined, Type B protocol is enabled.
+ * Else, Type A protocol is enabled.
+ * By default, this compile option is disabled.
+ */
+#define CONFIG_ENABLE_TYPE_B_PROTOCOL
+
+
+/*
+ * Note.
+ * The below compile option is used to enable force touch for reporting touch
+ * point to Linux input sub-system.
+ * By the way, force touch is supported for MSG28XX only, but is not supported
+ * for MSG26XXM/MSG21XXA/MSG22XX yet.
+ * By default, this compile option is disabled.
+ */
+/*#define CONFIG_ENABLE_FORCE_TOUCH*/
+
+
+/*
+ *	Note.
+ * The below compile option is used to enable update firmware with 8 byte each
+ * time for MSG28XX.
+ * If this compile option is disabled, then update firmware with 128 byte each
+ * time for MSG28XX
+ * By default, this compile option is disabled.
+ */
+/*#define CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_8_BYTE_EACH_TIME */
+
+/*
+ * Note.
+ * The below compile option is used to enable update firmware with I2C data
+ * rate 400KHz for MSG22XX.
+ * If this compile option is disabled, then update firmware with I2C data rate
+ * less than 400KHz for MSG22XX
+ * By default, this compile option is disabled.
+ */
+/*#define CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_SUPPORT_I2C_SPEED_400K */
+
+
+
+/*
+#define u8	 unsigned char
+#define u16  unsigned short
+#define u32  unsigned int
+#define s8	 signed char
+#define s16  signed short
+#define s32  signed int
+#define s64  int64_t
+#define u64  uint64_t
+*/
+#define CHIP_TYPE_MSG28XX	(0x85)
+#define MAOYQ (1)
+
+#define PACKET_TYPE_TOOTH_PATTERN	(0x20)
+#define PACKET_TYPE_GESTURE_WAKEUP	(0x50)
+#define PACKET_TYPE_GESTURE_DEBUG		(0x51)
+#define PACKET_TYPE_GESTURE_INFORMATION	(0x52)
+
+#define TOUCH_SCREEN_X_MIN	 (0)
+#define TOUCH_SCREEN_Y_MIN	 (0)
+/*
+ * Note.
+ * Please change the below touch screen resolution according to the touch panel
+ * that you are using.
+ */
+#define TOUCH_SCREEN_X_MAX	 (720)
+#define TOUCH_SCREEN_Y_MAX	 (1280)
+/*
+ * Note.
+ * Please do not change the below setting.
+ */
+#define TPD_WIDTH	(2048)
+#define TPD_HEIGHT	(2048)
+
+
+#define BIT0  (1<<0)
+#define BIT1  (1<<1)
+#define BIT2  (1<<2)
+#define BIT3  (1<<3)
+#define BIT4  (1<<4)
+#define BIT5  (1<<5)
+#define BIT6  (1<<6)
+#define BIT7  (1<<7)
+#define BIT8  (1<<8)
+#define BIT9  (1<<9)
+#define BIT10 (1<<10)
+#define BIT11 (1<<11)
+#define BIT12 (1<<12)
+#define BIT13 (1<<13)
+#define BIT14 (1<<14)
+#define BIT15 (1<<15)
+
+
+#define MAX_DEBUG_REGISTER_NUM	   (10)
+#define MAX_DEBUG_COMMAND_ARGUMENT_NUM		(4)
+
+#define MAX_UPDATE_FIRMWARE_BUFFER_SIZE    (130)
+
+#define MAX_I2C_TRANSACTION_LENGTH_LIMIT	  (250)
+#define MAX_TOUCH_IC_REGISTER_BANK_SIZE		  (256)
+
+
+#define PROCFS_AUTHORITY (0666)
+
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#define GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG	  0x00000001
+#define GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG		  0x00000002
+#define GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG	  0x00000004
+#define GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG	  0x00000008
+#define GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG	  0x00000010
+#define GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG	  0x00000020
+#define GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG	  0x00000040
+#define GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG	  0x00000080
+#define GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG	  0x00000100
+#define GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG	  0x00000200
+#define GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG	  0x00000400
+#define GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG	  0x00000800
+#define GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG	  0x00001000
+#define GESTURE_WAKEUP_MODE_RESERVE1_FLAG		  0x00002000
+#define GESTURE_WAKEUP_MODE_RESERVE2_FLAG		  0x00004000
+#define GESTURE_WAKEUP_MODE_RESERVE3_FLAG		  0x00008000
+
+#ifdef CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE
+#define GESTURE_WAKEUP_MODE_RESERVE4_FLAG		  0x00010000
+#define GESTURE_WAKEUP_MODE_RESERVE5_FLAG		  0x00020000
+#define GESTURE_WAKEUP_MODE_RESERVE6_FLAG		  0x00040000
+#define GESTURE_WAKEUP_MODE_RESERVE7_FLAG		  0x00080000
+#define GESTURE_WAKEUP_MODE_RESERVE8_FLAG		  0x00100000
+#define GESTURE_WAKEUP_MODE_RESERVE9_FLAG		  0x00200000
+#define GESTURE_WAKEUP_MODE_RESERVE10_FLAG		  0x00400000
+#define GESTURE_WAKEUP_MODE_RESERVE11_FLAG		  0x00800000
+#define GESTURE_WAKEUP_MODE_RESERVE12_FLAG		  0x01000000
+#define GESTURE_WAKEUP_MODE_RESERVE13_FLAG		  0x02000000
+#define GESTURE_WAKEUP_MODE_RESERVE14_FLAG		  0x04000000
+#define GESTURE_WAKEUP_MODE_RESERVE15_FLAG		  0x08000000
+#define GESTURE_WAKEUP_MODE_RESERVE16_FLAG		  0x10000000
+#define GESTURE_WAKEUP_MODE_RESERVE17_FLAG		  0x20000000
+#define GESTURE_WAKEUP_MODE_RESERVE18_FLAG		  0x40000000
+#define GESTURE_WAKEUP_MODE_RESERVE19_FLAG		  0x80000000
+
+#define GESTURE_WAKEUP_MODE_RESERVE20_FLAG		  0x00000001
+#define GESTURE_WAKEUP_MODE_RESERVE21_FLAG		  0x00000002
+#define GESTURE_WAKEUP_MODE_RESERVE22_FLAG		  0x00000004
+#define GESTURE_WAKEUP_MODE_RESERVE23_FLAG		  0x00000008
+#define GESTURE_WAKEUP_MODE_RESERVE24_FLAG		  0x00000010
+#define GESTURE_WAKEUP_MODE_RESERVE25_FLAG		  0x00000020
+#define GESTURE_WAKEUP_MODE_RESERVE26_FLAG		  0x00000040
+#define GESTURE_WAKEUP_MODE_RESERVE27_FLAG		  0x00000080
+#define GESTURE_WAKEUP_MODE_RESERVE28_FLAG		  0x00000100
+#define GESTURE_WAKEUP_MODE_RESERVE29_FLAG		  0x00000200
+#define GESTURE_WAKEUP_MODE_RESERVE30_FLAG		  0x00000400
+#define GESTURE_WAKEUP_MODE_RESERVE31_FLAG		  0x00000800
+#define GESTURE_WAKEUP_MODE_RESERVE32_FLAG		  0x00001000
+#define GESTURE_WAKEUP_MODE_RESERVE33_FLAG		  0x00002000
+#define GESTURE_WAKEUP_MODE_RESERVE34_FLAG		  0x00004000
+#define GESTURE_WAKEUP_MODE_RESERVE35_FLAG		  0x00008000
+#define GESTURE_WAKEUP_MODE_RESERVE36_FLAG		  0x00010000
+#define GESTURE_WAKEUP_MODE_RESERVE37_FLAG		  0x00020000
+#define GESTURE_WAKEUP_MODE_RESERVE38_FLAG		  0x00040000
+#define GESTURE_WAKEUP_MODE_RESERVE39_FLAG		  0x00080000
+#define GESTURE_WAKEUP_MODE_RESERVE40_FLAG		  0x00100000
+#define GESTURE_WAKEUP_MODE_RESERVE41_FLAG		  0x00200000
+#define GESTURE_WAKEUP_MODE_RESERVE42_FLAG		  0x00400000
+#define GESTURE_WAKEUP_MODE_RESERVE43_FLAG		  0x00800000
+#define GESTURE_WAKEUP_MODE_RESERVE44_FLAG		  0x01000000
+#define GESTURE_WAKEUP_MODE_RESERVE45_FLAG		  0x02000000
+#define GESTURE_WAKEUP_MODE_RESERVE46_FLAG		  0x04000000
+#define GESTURE_WAKEUP_MODE_RESERVE47_FLAG		  0x08000000
+#define GESTURE_WAKEUP_MODE_RESERVE48_FLAG		  0x10000000
+#define GESTURE_WAKEUP_MODE_RESERVE49_FLAG		  0x20000000
+#define GESTURE_WAKEUP_MODE_RESERVE50_FLAG		  0x40000000
+#define GESTURE_WAKEUP_MODE_RESERVE51_FLAG		  0x80000000
+#endif
+
+#define GESTURE_WAKEUP_PACKET_LENGTH	(6)
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+#define GESTURE_DEBUG_MODE_PACKET_LENGTH	(128)
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+#define GESTURE_WAKEUP_INFORMATION_PACKET_LENGTH	(128)
+#endif
+
+#endif
+
+#define FEATURE_GESTURE_WAKEUP_MODE			0x0001
+#define FEATURE_GESTURE_DEBUG_MODE			0x0002
+#define FEATURE_GESTURE_INFORMATION_MODE	0x0003
+
+#define FEATURE_TOUCH_DRIVER_DEBUG_LOG		0x0010
+#define FEATURE_FIRMWARE_DATA_LOG			0x0011
+#define FEATURE_FORCE_TO_UPDATE_FIRMWARE	0x0012
+
+
+#define I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE   (20)
+
+#define FIRMWARE_FILE_PATH_ON_SD_CARD	   \
+	"/mnt/sdcard/msctp_update.bin"
+
+
+#define POWER_SUPPLY_BATTERY_STATUS_PATCH  \
+	"/sys/class/power_supply/battery/status"
+
+
+/*
+ * Note.
+ * The below flag is used to enable the
+ * output log mechanism while touch device driver is running.
+ * If the debug log level is set as 0,
+ * the function for output log will be disabled.
+ * By default, the debug log level is set as 1.
+ */
+#define CONFIG_TOUCH_DRIVER_DEBUG_LOG_LEVEL (1)
+
+
+extern u8 TOUCH_DRIVER_DEBUG_LOG_LEVEL;
+
+
+#define DEBUG_LEVEL(level, fmt, arg...) \
+	do {\
+		if (level <= TOUCH_DRIVER_DEBUG_LOG_LEVEL)\
+			printk(fmt, ##arg);\
+	} while (0)
+
+#define DBG(fmt, arg...) DEBUG_LEVEL(2, fmt, ##arg)
+
+
+
+enum EmemType_e {
+	EMEM_ALL = 0,
+	EMEM_MAIN,
+	EMEM_INFO
+};
+
+enum ItoTestMode_e {
+	ITO_TEST_MODE_OPEN_TEST = 1,
+	ITO_TEST_MODE_SHORT_TEST = 2,
+	ITO_TEST_MODE_WATERPROOF_TEST = 3
+};
+
+enum ItoTestResult_e {
+	ITO_TEST_OK = 0,
+	ITO_TEST_FAIL,
+	ITO_TEST_GET_TP_TYPE_ERROR,
+	ITO_TEST_UNDEFINED_ERROR,
+	ITO_TEST_UNDER_TESTING
+
+};
+
+enum AddressMode_e {
+	ADDRESS_MODE_8BIT = 0,
+	ADDRESS_MODE_16BIT = 1
+};
+
+enum ItoTestFwMode_e {
+	MUTUAL = 0,
+	SELF,
+	WATERPROOF,
+	MUTUAL_SINGLE_DRIVE
+};
+
+
+extern u8 DrvCommonCalculateCheckSum(u8 *pMsg, u32 nLength);
+extern u32 DrvCommonConvertCharToHexDigit(char *pCh, u32 nLength);
+extern u32 DrvCommonCrcDoReflect(u32 nRef, s8 nCh);
+extern u32 DrvCommonCrcGetValue(u32 nText, u32 nPrevCRC);
+extern void DrvCommonCrcInitTable(void);
+extern void DrvCommonReadFile(char *pFilePath, u8 *pBuf, u16 nLength);
+
+#endif	/* __MSTAR_DRV_COMMON_H__ */
diff --git a/drivers/input/touchscreen/msg28xx/mstar_drv_extern.h b/drivers/input/touchscreen/msg28xx/mstar_drv_extern.h
new file mode 100644
index 0000000..55f574e
--- /dev/null
+++ b/drivers/input/touchscreen/msg28xx/mstar_drv_extern.h
@@ -0,0 +1,41 @@
+/*******************************
+//
+// Copyright (c) 2006-2016 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages,
+// losses, costs and expenses resulting therefrom.
+//
+************************/
+
+/**
+ *
+ * @file    mstar_drv_extern.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+#ifndef __MSTAR_DRV_EXTERN_H__
+#define __MSTAR_DRV_EXTERN_H__
+
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+
+
+extern void DrvFwCtrlChargerDetection(u8 nChargerStatus);
+
+
+#endif  /* __MSTAR_DRV_EXTERN_H__ */
diff --git a/drivers/input/touchscreen/msg28xx/mstar_drv_ic_fw_porting_layer.c b/drivers/input/touchscreen/msg28xx/mstar_drv_ic_fw_porting_layer.c
new file mode 100644
index 0000000..2220906
--- /dev/null
+++ b/drivers/input/touchscreen/msg28xx/mstar_drv_ic_fw_porting_layer.c
@@ -0,0 +1,239 @@
+/*******************************************
+//
+// Copyright (c) 2006-2016 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages,
+// losses, costs and expenses resulting therefrom.
+//
+**********************************/
+
+/**
+ *
+ * @file	mstar_drv_ic_fw_porting_layer.c
+ *
+ * @brief	This file defines the interface of touch screen
+ *
+ *
+ */
+
+#include "mstar_drv_ic_fw_porting_layer.h"
+
+void DrvIcFwLyrVariableInitialize(void)
+{
+
+	DrvFwCtrlVariableInitialize();
+}
+
+void DrvIcFwLyrOptimizeCurrentConsumption(void)
+{
+
+	DrvFwCtrlOptimizeCurrentConsumption();
+}
+
+u8 DrvIcFwLyrGetChipType(void)
+{
+	return DrvFwCtrlGetChipType();
+}
+
+void DrvIcFwLyrGetCustomerFirmwareVersion(u16 *pMajor,
+	u16 *pMinor, u8 **ppVersion)
+{
+	DrvFwCtrlGetCustomerFirmwareVersion(pMajor, pMinor, ppVersion);
+}
+
+void DrvIcFwLyrGetPlatformFirmwareVersion(u8 **ppVersion)
+{
+
+	DrvFwCtrlGetPlatformFirmwareVersion(ppVersion);
+}
+
+s32 DrvIcFwLyrUpdateFirmware(u8 szFwData[][1024], enum EmemType_e eEmemType)
+{
+
+	return DrvFwCtrlUpdateFirmware(szFwData, eEmemType);
+}
+
+s32 DrvIcFwLyrUpdateFirmwareBySdCard(const char *pFilePath)
+{
+
+	return DrvFwCtrlUpdateFirmwareBySdCard(pFilePath);
+}
+
+u32 DrvIcFwLyrIsRegisterFingerTouchInterruptHandler(void)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	return 1;
+}
+
+void DrvIcFwLyrHandleFingerTouch(u8 *pPacket, u16 nLength)
+{
+
+	DrvFwCtrlHandleFingerTouch();
+}
+
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+
+void DrvIcFwLyrOpenGestureWakeup(u32 *pWakeupMode)
+{
+
+	DrvFwCtrlOpenGestureWakeup(pWakeupMode);
+}
+
+void DrvIcFwLyrCloseGestureWakeup(void)
+{
+
+	DrvFwCtrlCloseGestureWakeup();
+}
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+void DrvIcFwLyrOpenGestureDebugMode(u8 nGestureFlag)
+{
+
+	DrvFwCtrlOpenGestureDebugMode(nGestureFlag);
+}
+
+void DrvIcFwLyrCloseGestureDebugMode(void)
+{
+
+	DrvFwCtrlCloseGestureDebugMode();
+}
+#endif
+
+#endif
+
+u32 DrvIcFwLyrReadDQMemValue(u16 nAddr)
+{
+	return DrvFwCtrlReadDQMemValue(nAddr);
+}
+
+void DrvIcFwLyrWriteDQMemValue(u16 nAddr, u32 nData)
+{
+	DrvFwCtrlWriteDQMemValue(nAddr, nData);
+}
+
+
+u16 DrvIcFwLyrGetFirmwareMode(void)
+{
+
+	return DrvFwCtrlGetFirmwareMode();
+}
+
+u16 DrvIcFwLyrChangeFirmwareMode(u16 nMode)
+{
+
+	return DrvFwCtrlChangeFirmwareMode(nMode);
+}
+
+void DrvIcFwLyrGetFirmwareInfo(struct FirmwareInfo_t *pInfo)
+{
+
+	DrvFwCtrlGetFirmwareInfo(pInfo);
+}
+
+void DrvIcFwLyrRestoreFirmwareModeToLogDataMode(void)
+{
+	DrvFwCtrlRestoreFirmwareModeToLogDataMode();
+}
+
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+void DrvIcFwLyrCheckFirmwareUpdateBySwId(void)
+{
+	DrvFwCtrlCheckFirmwareUpdateBySwId();
+}
+#endif
+
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+
+void DrvIcFwLyrCreateMpTestWorkQueue(void)
+{
+	DrvMpTestCreateMpTestWorkQueue();
+}
+
+void DrvIcFwLyrScheduleMpTestWork(ItoTestMode_e eItoTestMode)
+{
+	DrvMpTestScheduleMpTestWork(eItoTestMode);
+}
+
+s32 DrvIcFwLyrGetMpTestResult(void)
+{
+	return DrvMpTestGetTestResult();
+}
+
+void DrvIcFwLyrGetMpTestFailChannel(ItoTestMode_e eItoTestMode,
+	u8 *pFailChannel, u32 *pFailChannelCount)
+{
+	return DrvMpTestGetTestFailChannel(eItoTestMode,
+		pFailChannel, pFailChannelCount);
+}
+
+void DrvIcFwLyrGetMpTestDataLog(ItoTestMode_e eItoTestMode,
+	u8 *pDataLog, u32 *pLength)
+{
+	return DrvMpTestGetTestDataLog(eItoTestMode, pDataLog, pLength);
+}
+
+void DrvIcFwLyrGetMpTestScope(TestScopeInfo_t *pInfo)
+{
+	return DrvMpTestGetTestScope(pInfo);
+}
+
+#endif
+
+
+#ifdef CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+
+void DrvIcFwLyrGetTouchPacketAddress(u16 *pDataAddress, u16 *pFlagAddress)
+{
+	return DrvFwCtrlGetTouchPacketAddress(pDataAddress, pFlagAddress);
+}
+
+#endif
+
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+
+s32 DrvIcFwLyrEnableProximity(void)
+{
+
+	return DrvFwCtrlEnableProximity();
+}
+
+s32 DrvIcFwLyrDisableProximity(void)
+{
+	return DrvFwCtrlDisableProximity();
+}
+
+#endif
+
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+void DrvIcFwLyrOpenGloveMode(void)
+{
+	DrvFwCtrlOpenGloveMode();
+}
+
+void DrvIcFwLyrCloseGloveMode(void)
+{
+	DrvFwCtrlCloseGloveMode();
+}
+
+void DrvIcFwLyrGetGloveInfo(u8 *pGloveMode)
+{
+	DrvFwCtrlGetGloveInfo(pGloveMode);
+}
+#endif
+
+
diff --git a/drivers/input/touchscreen/msg28xx/mstar_drv_ic_fw_porting_layer.h b/drivers/input/touchscreen/msg28xx/mstar_drv_ic_fw_porting_layer.h
new file mode 100644
index 0000000..6f542aa
--- /dev/null
+++ b/drivers/input/touchscreen/msg28xx/mstar_drv_ic_fw_porting_layer.h
@@ -0,0 +1,116 @@
+/*****************************************************************
+//
+// Copyright (c) 2006-2016 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages,
+// losses, costs and expenses resulting therefrom.
+//
+************************************************************************/
+/**
+ *
+ * @file    mstar_drv_ic_fw_porting_layer.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+#ifndef __MSTAR_DRV_IC_FW_PORTING_LAYER_H__
+#define __MSTAR_DRV_IC_FW_PORTING_LAYER_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include "mstar_drv_common.h"
+#include "mstar_drv_mutual_fw_control.h"
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+#include "mstar_drv_mutual_mp_test.h"
+#endif
+
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR CONSTANT DEFINITION                                         */
+/*--------------------------------------------------------------------------*/
+
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL FUNCTION DECLARATION                                              */
+/*--------------------------------------------------------------------------*/
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern void DrvIcFwLyrOpenGestureWakeup(u32 *pWakeupMode);
+extern void DrvIcFwLyrCloseGestureWakeup(void);
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+extern void DrvIcFwLyrOpenGestureDebugMode(u8 nGestureFlag);
+extern void DrvIcFwLyrCloseGestureDebugMode(void);
+#endif
+
+#endif
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern u32 g_GestureWakeupMode[2];
+extern u8 g_GestureWakeupFlag;
+#endif
+
+extern u32 DrvIcFwLyrReadDQMemValue(u16 nAddr);
+extern void DrvIcFwLyrWriteDQMemValue(u16 nAddr, u32 nData);
+
+extern u16 DrvIcFwLyrChangeFirmwareMode(u16 nMode);
+extern void DrvIcFwLyrGetFirmwareInfo(struct FirmwareInfo_t *pInfo);
+extern u16 DrvIcFwLyrGetFirmwareMode(void);
+extern void DrvIcFwLyrRestoreFirmwareModeToLogDataMode(void);
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+extern void DrvIcFwLyrCheckFirmwareUpdateBySwId(void);
+#endif
+
+extern void DrvIcFwLyrVariableInitialize(void);
+extern void DrvIcFwLyrOptimizeCurrentConsumption(void);
+extern u8 DrvIcFwLyrGetChipType(void);
+extern void DrvIcFwLyrGetCustomerFirmwareVersion(u16 *pMajor,
+	u16 *pMinor, u8 **ppVersion);
+extern void DrvIcFwLyrGetPlatformFirmwareVersion(u8 **ppVersion);
+extern void DrvIcFwLyrHandleFingerTouch(u8 *pPacket, u16 nLength);
+extern u32 DrvIcFwLyrIsRegisterFingerTouchInterruptHandler(void);
+extern s32 DrvIcFwLyrUpdateFirmware(u8 szFwData[][1024],
+	enum EmemType_e eEmemType);
+extern s32 DrvIcFwLyrUpdateFirmwareBySdCard(const char *pFilePath);
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+extern void DrvIcFwLyrCreateMpTestWorkQueue(void);
+extern void DrvIcFwLyrScheduleMpTestWork(ItoTestMode_e eItoTestMode);
+extern void DrvIcFwLyrGetMpTestDataLog(ItoTestMode_e eItoTestMode, u8
+		*pDataLog, u32 *pLength);
+extern void DrvIcFwLyrGetMpTestFailChannel(ItoTestMode_e eItoTestMode, u8
+		*pFailChannel, u32 *pFailChannelCount);
+extern s32 DrvIcFwLyrGetMpTestResult(void);
+extern void DrvIcFwLyrGetMpTestScope(TestScopeInfo_t *pInfo);
+#endif
+
+#ifdef CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+extern void DrvIcFwLyrGetTouchPacketAddress(u16 *pDataAddress,
+u16 *pFlagAddress);
+#endif
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+extern s32 DrvIcFwLyrEnableProximity(void);
+extern s32 DrvIcFwLyrDisableProximity(void);
+#endif
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+extern void DrvIcFwLyrOpenGloveMode(void);
+extern void DrvIcFwLyrCloseGloveMode(void);
+extern void DrvIcFwLyrGetGloveInfo(u8 *pGloveMode);
+#endif
+
+#endif  /* __MSTAR_DRV_IC_FW_PORTING_LAYER_H__ */
diff --git a/drivers/input/touchscreen/msg28xx/mstar_drv_jni_interface.c b/drivers/input/touchscreen/msg28xx/mstar_drv_jni_interface.c
new file mode 100644
index 0000000..37e51ba
--- /dev/null
+++ b/drivers/input/touchscreen/msg28xx/mstar_drv_jni_interface.c
@@ -0,0 +1,272 @@
+/***********************************************
+//
+// Copyright (c) 2006-2016 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages,
+// losses, costs and expenses resulting therefrom.
+//
+*********************************************/
+
+/**
+ *
+ * @file	mstar_drv_jni_interface.c
+ *
+ * @brief	This file defines the jni interface functions
+ *
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kthread.h>
+#include <linux/uaccess.h>
+#include "mstar_drv_jni_interface.h"
+#include "mstar_drv_utility_adaption.h"
+#include "mstar_drv_platform_porting_layer.h"
+
+
+#ifdef CONFIG_ENABLE_JNI_INTERFACE
+void _DebugJniShowArray(u8 *pBuf, u16 nLen)
+{
+	int i;
+
+	for (i = 0; i < nLen; i++)
+		DBG("%02X ", pBuf[i]);
+}
+
+
+u64 PtrToU64(u8 *pValue)
+{
+	uintptr_t nValue = (uintptr_t)pValue;
+
+	return (u64)(0xFFFFFFFFFFFFFFFF&nValue);
+}
+
+u8 *U64ToPtr(u64 nValue)
+{
+	uintptr_t pValue = (uintptr_t)nValue;
+
+	return (u8 *)pValue;
+}
+
+
+ssize_t MsgToolRead(struct file *pFile,
+	char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	long nRet = 0;
+	u8 nBusType = 0;
+	u16 nReadLen = 0;
+	u8 szCmdData[20] = {0};
+
+
+	DBG("*** %s() ***\n", __func__);
+	nBusType = nCount&0xFF;
+	nReadLen = (nCount >> 8)&0xFFFF;
+	if (nBusType == SLAVE_I2C_ID_DBBUS ||
+		nBusType == SLAVE_I2C_ID_DWI2C)
+		IicReadData(nBusType, &szCmdData[0], nReadLen);
+
+	nRet = copy_to_user(pBuffer, &szCmdData[0], nReadLen);
+
+	return nRet;
+}
+
+
+ssize_t MsgToolWrite(struct file *pFile,
+	const char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	long nRet = 0;
+	u8 nBusType = 0;
+	u16 nWriteLen = 0;
+	u8 szCmdData[20] = {0};
+
+
+	DBG("*** %s() ***\n", __func__);
+	nBusType = nCount&0xFF;
+	nWriteLen = (nCount >> 8)&0xFFFF;
+	nRet = copy_from_user(szCmdData, &pBuffer[0], nWriteLen);
+	if (nBusType == SLAVE_I2C_ID_DBBUS ||
+		nBusType == SLAVE_I2C_ID_DWI2C)
+		IicWriteData(nBusType,
+		&szCmdData[0], nWriteLen);
+
+	return nRet;
+}
+
+
+void _RegGetXByteData(MsgToolDrvCmd_t *pCmd)
+{
+	u16 nAddr = 0;
+
+	DBG("*** %s() ***\n", __func__);
+	nAddr = (_gSndCmdData[1]<<8)|_gSndCmdData[0];
+	RegGetXBitValue(nAddr, _gRtnCmdData,
+		pCmd->nRtnCmdLen,
+		MAX_I2C_TRANSACTION_LENGTH_LIMIT);
+}
+
+
+void _ClearMsgToolMem(void)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	memset(_gMsgToolCmdIn, 0, sizeof(MsgToolDrvCmd_t));
+	memset(_gSndCmdData, 0, 1024);
+	memset(_gRtnCmdData, 0, 1024);
+}
+
+
+static MsgToolDrvCmd_t*
+	_TransJniCmdFromUser(unsigned long nArg)
+{
+	long nRet;
+	MsgToolDrvCmd_t tCmdIn;
+	MsgToolDrvCmd_t *pTransCmd;
+
+	DBG("*** %s() ***\n", __func__);
+	_ClearMsgToolMem();
+	pTransCmd = (MsgToolDrvCmd_t *)_gMsgToolCmdIn;
+	nRet = copy_from_user(&tCmdIn, (void *)nArg,
+		sizeof(MsgToolDrvCmd_t));
+	pTransCmd->nCmdId = tCmdIn.nCmdId;
+
+	if (tCmdIn.nSndCmdLen > 0) {
+		pTransCmd->nSndCmdLen = tCmdIn.nSndCmdLen;
+		nRet = copy_from_user(_gSndCmdData,
+			U64ToPtr(tCmdIn.nSndCmdDataPtr),
+			pTransCmd->nSndCmdLen);
+	}
+
+	if (tCmdIn.nRtnCmdLen > 0) {
+		pTransCmd->nRtnCmdLen = tCmdIn.nRtnCmdLen;
+		nRet = copy_from_user(_gRtnCmdData,
+			U64ToPtr(tCmdIn.nRtnCmdDataPtr),
+			pTransCmd->nRtnCmdLen);
+	}
+
+	return pTransCmd;
+}
+
+
+static void _TransJniCmdToUser(MsgToolDrvCmd_t *pTransCmd,
+	unsigned long nArg)
+{
+	MsgToolDrvCmd_t tCmdOut;
+	long nRet;
+
+	DBG("*** %s() ***\n", __func__);
+	nRet = copy_from_user(&tCmdOut, (void *)nArg,
+		sizeof(MsgToolDrvCmd_t));
+
+	nRet =
+		copy_to_user(U64ToPtr(tCmdOut.nRtnCmdDataPtr),
+		_gRtnCmdData, tCmdOut.nRtnCmdLen);
+}
+
+
+long MsgToolIoctl(struct file *pFile,
+	unsigned int nCmd, unsigned long nArg)
+{
+	long nRet = 0;
+
+	DBG("*** %s() ***\n", __func__);
+	switch (nCmd) {
+	case MSGTOOL_IOCTL_RUN_CMD:
+	{
+		MsgToolDrvCmd_t *pTransCmd;
+
+		pTransCmd = _TransJniCmdFromUser(nArg);
+		switch (pTransCmd->nCmdId) {
+		case MSGTOOL_RESETHW:
+			DrvPlatformLyrTouchDeviceResetHw();
+			break;
+		case MSGTOOL_REGGETXBYTEVALUE:
+			_RegGetXByteData(pTransCmd);
+			_TransJniCmdToUser(pTransCmd, nArg);
+			break;
+		case MSGTOOL_HOTKNOTSTATUS:
+			_gRtnCmdData[0] = g_IsHotknotEnabled;
+			_TransJniCmdToUser(pTransCmd, nArg);
+			break;
+		case MSGTOOL_FINGERTOUCH:
+			if (pTransCmd->nSndCmdLen == 1)
+				DrvPlatformLyrEnableFingerTouchReport();
+			else if (pTransCmd->nSndCmdLen == 0)
+				DrvPlatformLyrDisableFingerTouchReport();
+			break;
+		case MSGTOOL_BYPASSHOTKNOT:
+			if (pTransCmd->nSndCmdLen == 1)
+				g_IsBypassHotknot = 1;
+			else if (pTransCmd->nSndCmdLen == 0)
+				g_IsBypassHotknot = 0;
+			break;
+		case MSGTOOL_DEVICEPOWEROFF:
+			DrvPlatformLyrTouchDevicePowerOff();
+			break;
+		case MSGTOOL_GETSMDBBUS:
+			DBG("*** MSGTOOL_GETSMDBBUS ***\n");
+			_gRtnCmdData[0] = SLAVE_I2C_ID_DBBUS&0xFF;
+			_gRtnCmdData[1] = SLAVE_I2C_ID_DWI2C&0xFF;
+			_TransJniCmdToUser(pTransCmd, nArg);
+			break;
+		case MSGTOOL_SETIICDATARATE:
+			DrvPlatformLyrSetIicDataRate(g_I2cClient,
+					((_gSndCmdData[1] << 8) |
+					_gSndCmdData[0]) * 1000);
+			break;
+		default:
+			break;
+		}
+	}
+		break;
+
+	default:
+		nRet = -EINVAL;
+		break;
+	}
+
+	return nRet;
+}
+
+
+void CreateMsgToolMem(void)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	_gMsgToolCmdIn = kmalloc(
+		sizeof(MsgToolDrvCmd_t), GFP_KERNEL);
+	_gSndCmdData = kmalloc(1024, GFP_KERNEL);
+	_gRtnCmdData = kmalloc(1024, GFP_KERNEL);
+}
+
+
+void DeleteMsgToolMem(void)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	if (_gMsgToolCmdIn) {
+		/*kfree(_gSndCmdData);*/
+		_gMsgToolCmdIn = NULL;
+	}
+
+	if (_gSndCmdData) {
+		/*kfree(_gSndCmdData);*/
+		_gSndCmdData = NULL;
+	}
+
+	if (_gRtnCmdData) {
+		/*kfree(_gRtnCmdData);*/
+		_gRtnCmdData = NULL;
+	}
+}
+
+#endif
diff --git a/drivers/input/touchscreen/msg28xx/mstar_drv_jni_interface.h b/drivers/input/touchscreen/msg28xx/mstar_drv_jni_interface.h
new file mode 100644
index 0000000..9b9b1de
--- /dev/null
+++ b/drivers/input/touchscreen/msg28xx/mstar_drv_jni_interface.h
@@ -0,0 +1,93 @@
+/*****************************************************************
+//
+// Copyright (c) 2006-2016 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages,
+// losses, costs and expenses resulting therefrom.
+//
+***************************************************************************/
+
+/**
+ *
+ * @file	mstar_drv_jni_interface.h
+ *
+ * @brief	This file defines the jni interface functions
+ *
+ *
+ */
+
+#ifndef __MSTAR_DRV_JNI_INTERFACE_H__
+#define __MSTAR_DRV_JNI_INTERFACE_H__
+
+#include "mstar_drv_common.h"
+
+#ifdef CONFIG_ENABLE_JNI_INTERFACE
+/*
+typedef struct
+{
+	u64			 nCmdId;
+	u8		   *pSndCmdData;
+	u64			nSndCmdLen;
+	u8		   *pRtnCmdData;
+	u64			nRtnCmdLen;
+} MsgToolDrvCmd_t;
+*/
+
+struct MsgToolDrvCmd_t {
+	u64			nCmdId;
+	u64			nSndCmdDataPtr;
+	u64			nSndCmdLen;
+	u64			nRtnCmdDataPtr;
+	u64			nRtnCmdLen;
+};
+
+
+
+#define MSGTOOL_MAGIC_NUMBER			   96
+#define MSGTOOL_IOCTL_RUN_CMD			   _IO(MSGTOOL_MAGIC_NUMBER, 1)
+
+
+#define MSGTOOL_RESETHW			  0x01
+#define MSGTOOL_REGGETXBYTEVALUE  0x02
+#define MSGTOOL_HOTKNOTSTATUS	  0x03
+#define MSGTOOL_FINGERTOUCH		  0x04
+#define MSGTOOL_BYPASSHOTKNOT	  0x05
+#define MSGTOOL_DEVICEPOWEROFF	  0x06
+#define MSGTOOL_GETSMDBBUS		  0x07
+#define MSGTOOL_SETIICDATARATE	  0x08
+
+#ifdef CONFIG_ENABLE_JNI_INTERFACE
+extern u32 SLAVE_I2C_ID_DBBUS;
+extern u32 SLAVE_I2C_ID_DWI2C;
+extern u8 g_IsHotknotEnabled;
+extern u8 g_IsBypassHotknot;
+extern struct i2c_client *g_I2cClient;
+
+static MsgToolDrvCmd_t *_gMsgToolCmdIn;
+static u8 *_gSndCmdData;
+static u8 *_gRtnCmdData;
+#endif
+
+
+
+extern ssize_t MsgToolRead(struct file *pFile,
+	char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t MsgToolWrite(struct file *pFile,
+	const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern long MsgToolIoctl(struct file *pFile,
+	unsigned int nCmd, unsigned long nArg);
+extern void CreateMsgToolMem(void);
+extern void DeleteMsgToolMem(void);
+
+
+#endif
+#endif
diff --git a/drivers/input/touchscreen/msg28xx/mstar_drv_main.c b/drivers/input/touchscreen/msg28xx/mstar_drv_main.c
new file mode 100644
index 0000000..24a78e2
--- /dev/null
+++ b/drivers/input/touchscreen/msg28xx/mstar_drv_main.c
@@ -0,0 +1,3458 @@
+/***********************************************************
+//
+// Copyright (c) 2006-2016 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages,
+// losses, costs and expenses resulting therefrom.
+//
+**************************************************************************/
+
+/**
+ *
+ * @file	mstar_drv_main.c
+ *
+ * @brief	This file defines the interface of touch screen
+ *
+ *
+ */
+
+
+#include "mstar_drv_main.h"
+
+#ifdef CONFIG_ENABLE_JNI_INTERFACE
+#include "mstar_drv_jni_interface.h"
+#endif
+
+
+#ifdef MAOYQ
+#define MSTAR_FW_NAME_MAX_LEN 30
+static char fw_name[MSTAR_FW_NAME_MAX_LEN];
+static char *ts_info;
+#define INFO_MAX_LEN		256
+#define DEBUG_DIR_NAME		"ts_debug"
+#define STORE_TS_INFO(buf, chip_name, num_max_touches, fw_version) \
+			snprintf(buf, INFO_MAX_LEN, \
+				"controller     = MStar Semiconductor, Inc.\n" \
+				"chip name      = %s\n" \
+				"max_touches    = %d\n" \
+				"driver_ver     = v2.3\n" \
+				"fw_ver         = %d\n" \
+				"fw_vkey_support= yes\n", \
+				chip_name, num_max_touches, fw_version)
+
+u8 _MsgSuspended = 0;
+
+static struct dentry *msg_debug_base;
+#define MSG_DEBUGFS_DIR			"ts_debug"
+#define MSG_DEBUGFS_FILE_SUSPEND	"suspend"
+#define MSG_DEBUGFS_FILE_DATA		"data"
+#define MSG_DEBUGFS_FILE_ADDR		"addr"
+#define MSG_DEBUGFS_FILE_DUMP_INFO	"dump_info"
+
+static u64 MSG_addr;
+
+#endif
+
+static u16 _gDebugReg[MAX_DEBUG_REGISTER_NUM] = {0};
+static u16 _gDebugRegValue[MAX_DEBUG_REGISTER_NUM] = {0};
+static u32 _gDebugRegCount;
+
+static u8 _gDebugCmdArgu[MAX_DEBUG_COMMAND_ARGUMENT_NUM] = {0};
+static u16 _gDebugCmdArguCount;
+static u32 _gDebugReadDataSize;
+
+static char _gDebugBuf[1024] = {0};
+
+static u8 *_gPlatformFwVersion;
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+static ItoTestMode_e _gItoTestMode;
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+static u32 _gLogGestureCount;
+static u8 _gLogGestureInforType;
+#endif
+
+#endif
+
+static u32 _gIsUpdateComplete;
+
+static u8 *_gFwVersion;
+
+static u32 _gFeatureSupportStatus;
+
+static struct proc_dir_entry *_gProcClassEntry;
+static struct proc_dir_entry *_gProcMsTouchScreenMsg20xxEntry;
+static struct proc_dir_entry *_gProcDeviceEntry;
+static struct proc_dir_entry *_gProcChipTypeEntry;
+static struct proc_dir_entry *_gProcFirmwareDataEntry;
+static struct proc_dir_entry *_gProcApkFirmwareUpdateEntry;
+static struct proc_dir_entry *_gProcCustomerFirmwareVersionEntry;
+static struct proc_dir_entry *_gProcPlatformFirmwareVersionEntry;
+static struct proc_dir_entry *_gProcDeviceDriverVersionEntry;
+static struct proc_dir_entry *_gProcSdCardFirmwareUpdateEntry;
+static struct proc_dir_entry *_gProcFirmwareDebugEntry;
+static struct proc_dir_entry *_gProcFirmwareSetDebugValueEntry;
+static struct proc_dir_entry *_gProcFirmwareSmBusDebugEntry;
+static struct proc_dir_entry *_gProcFirmwareSetDQMemValueEntry;
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+static struct proc_dir_entry *_gProcMpTestEntry;
+static struct proc_dir_entry *_gProcMpTestLogEntry;
+static struct proc_dir_entry *_gProcMpTestFailChannelEntry;
+static struct proc_dir_entry *_gProcMpTestScopeEntry;
+#endif
+static struct proc_dir_entry *_gProcFirmwareModeEntry;
+static struct proc_dir_entry *_gProcFirmwareSensorEntry;
+static struct proc_dir_entry
+	*_gProcFirmwarePacketHeaderEntry;
+static struct proc_dir_entry
+	*_gProcQueryFeatureSupportStatusEntry;
+static struct proc_dir_entry
+	*_gProcChangeFeatureSupportStatusEntry;
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+static struct proc_dir_entry *_gProcGestureWakeupModeEntry;
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+static struct proc_dir_entry *_gProcGestureDebugModeEntry;
+#endif
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+static struct proc_dir_entry *_gProcGestureInforModeEntry;
+#endif
+#endif
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+static struct proc_dir_entry *_gProcReportRateEntry;
+#endif
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+static struct proc_dir_entry *_gProcGloveModeEntry;
+static struct proc_dir_entry *_gProcOpenGloveModeEntry;
+static struct proc_dir_entry *_gProcCloseGloveModeEntry;
+#endif
+#ifdef CONFIG_ENABLE_JNI_INTERFACE
+static struct proc_dir_entry *_gProcJniMethodEntry;
+#endif
+static struct proc_dir_entry
+	*_gProcSeLinuxLimitFirmwareUpdateEntry;
+
+#ifdef MAOYQ
+
+static ssize_t msg28xx_ts_mt_protocol_type_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	return snprintf(buf, 16, "%s\n", "MT Protocal B");
+}
+
+
+static ssize_t msg28xx_ts_enable_store(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	unsigned long val;
+	int rc;
+
+	if (size > 2)
+		return -EINVAL;
+
+	rc = kstrtoul(buf, 10, &val);
+	if (rc != 0)
+		return rc;
+	if (val) {
+	#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+		DrvPlatformLyrTouchDeviceRegulatorPowerOn(true);
+	#endif
+		DrvPlatformLyrTouchDevicePowerOn();
+
+	} else {
+		DrvPlatformLyrFingerTouchReleased(0, 0, 0);
+		input_sync(g_InputDevice);
+
+		DrvPlatformLyrDisableFingerTouchReport();
+
+		DrvPlatformLyrTouchDevicePowerOff();
+		}
+
+
+	return size;
+}
+
+static ssize_t msg28xx_ts_enable_show(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	if (_MsgSuspended)
+		return snprintf(buf, 4, "%s\n", "0");
+
+
+	return snprintf(buf, 4, "%s\n", !_MsgSuspended ? "1" : "0");
+}
+static ssize_t msg28xx_fw_name_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, MSTAR_FW_NAME_MAX_LEN - 1,
+				"%s\n", fw_name);
+}
+
+static ssize_t msg28xx_fw_name_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t size)
+{
+	if (size > MSTAR_FW_NAME_MAX_LEN - 1)
+		return -EINVAL;
+
+	strlcpy(fw_name, buf, size);
+	if (fw_name[size - 1] == '\n')
+		fw_name[size - 1] = 0;
+
+	return size;
+}
+
+static ssize_t ts_info_show(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, INFO_MAX_LEN, "%s\n", ts_info);
+}
+
+static DEVICE_ATTR(ts_info, 0444, ts_info_show, NULL);
+
+
+static DEVICE_ATTR(fw_name, (S_IRUGO | S_IWUSR),
+			msg28xx_fw_name_show, msg28xx_fw_name_store);
+
+static DEVICE_ATTR(mt_protocol_type, 0664,
+			msg28xx_ts_mt_protocol_type_show, NULL);
+
+static DEVICE_ATTR(enable, 0664, msg28xx_ts_enable_show,
+					msg28xx_ts_enable_store);
+
+static struct attribute *msg_attrs[] = {
+	&dev_attr_mt_protocol_type.attr,
+	&dev_attr_enable.attr,
+	&dev_attr_fw_name.attr,
+	&dev_attr_ts_info.attr,
+	NULL
+};
+
+static const struct attribute_group msg_attr_grp = {
+	.attrs = msg_attrs,
+};
+#endif
+
+
+static const struct file_operations
+_gProcChipType = {
+	.read = DrvMainProcfsChipTypeRead,
+	.write = DrvMainProcfsChipTypeWrite,
+};
+
+static const struct file_operations
+	_gProcFirmwareData = {
+	.read = DrvMainProcfsFirmwareDataRead,
+	.write = DrvMainProcfsFirmwareDataWrite,
+};
+
+static const struct file_operations
+	_gProcApkFirmwareUpdate = {
+	.read = DrvMainProcfsFirmwareUpdateRead,
+	.write = DrvMainProcfsFirmwareUpdateWrite,
+};
+
+static const struct file_operations
+	_gProcCustomerFirmwareVersion = {
+	.read = DrvMainProcfsCustomerFirmwareVersionRead,
+	.write = DrvMainProcfsCustomerFirmwareVersionWrite,
+};
+
+static const struct file_operations
+	_gProcPlatformFirmwareVersion = {
+	.read = DrvMainProcfsPlatformFirmwareVersionRead,
+	.write = DrvMainProcfsPlatformFirmwareVersionWrite,
+};
+
+static const struct file_operations
+	_gProcDeviceDriverVersion = {
+	.read = DrvMainProcfsDeviceDriverVersionRead,
+	.write = DrvMainProcfsDeviceDriverVersionWrite,
+};
+
+static const struct file_operations
+	_gProcSdCardFirmwareUpdate = {
+	.read = DrvMainProcfsSdCardFirmwareUpdateRead,
+	.write = DrvMainProcfsSdCardFirmwareUpdateWrite,
+};
+
+static const struct file_operations
+	_gProcFirmwareDebug = {
+	.read = DrvMainProcfsFirmwareDebugRead,
+	.write = DrvMainProcfsFirmwareDebugWrite,
+};
+
+static const struct file_operations
+	_gProcFirmwareSetDebugValue = {
+	.read = DrvMainProcfsFirmwareSetDebugValueRead,
+	.write = DrvMainProcfsFirmwareSetDebugValueWrite,
+};
+
+static const struct file_operations
+	_gProcFirmwareSmBusDebug = {
+	.read = DrvMainProcfsFirmwareSmBusDebugRead,
+	.write = DrvMainProcfsFirmwareSmBusDebugWrite,
+};
+
+static const struct file_operations
+	_gProcFirmwareSetDQMemValue = {
+	.read = DrvMainProcfsFirmwareSetDQMemValueRead,
+	.write = DrvMainProcfsFirmwareSetDQMemValueWrite,
+};
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+static const struct file_operations _gProcMpTest = {
+	.read = DrvMainProcfsMpTestRead,
+	.write = DrvMainProcfsMpTestWrite,
+};
+
+static const struct file_operations _gProcMpTestLog = {
+	.read = DrvMainProcfsMpTestLogRead,
+	.write = DrvMainProcfsMpTestLogWrite,
+};
+
+static const struct file_operations
+	_gProcMpTestFailChannel = {
+	.read = DrvMainProcfsMpTestFailChannelRead,
+	.write = DrvMainProcfsMpTestFailChannelWrite,
+};
+
+static const struct file_operations _gProcMpTestScope = {
+	.read = DrvMainProcfsMpTestScopeRead,
+	.write = DrvMainProcfsMpTestScopeWrite,
+};
+#endif
+
+
+static const struct file_operations
+	_gProcFirmwareMode = {
+	.read = DrvMainProcfsFirmwareModeRead,
+	.write = DrvMainProcfsFirmwareModeWrite,
+};
+
+static const struct file_operations
+	_gProcFirmwareSensor = {
+	.read = DrvMainProcfsFirmwareSensorRead,
+	.write = DrvMainProcfsFirmwareSensorWrite,
+};
+
+static const struct file_operations
+	_gProcFirmwarePacketHeader = {
+	.read = DrvMainProcfsFirmwarePacketHeaderRead,
+	.write = DrvMainProcfsFirmwarePacketHeaderWrite,
+};
+
+
+static const struct file_operations
+	_gProcQueryFeatureSupportStatus = {
+	.read = DrvMainProcfsQueryFeatureSupportStatusRead,
+	.write = DrvMainProcfsQueryFeatureSupportStatusWrite,
+};
+
+static const struct file_operations
+	_gProcChangeFeatureSupportStatus = {
+	.read = DrvMainProcfsChangeFeatureSupportStatusRead,
+	.write = DrvMainProcfsChangeFeatureSupportStatusWrite,
+};
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+static const struct file_operations
+	_gProcGestureWakeupMode = {
+	.read = DrvMainProcfsGestureWakeupModeRead,
+	.write = DrvMainProcfsGestureWakeupModeWrite,
+};
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+static const struct file_operations _gProcGestureDebugMode = {
+	.read = DrvMainProcfsGestureDebugModeRead,
+	.write = DrvMainProcfsGestureDebugModeWrite,
+};
+#endif
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+static const struct file_operations _gProcGestureInforMode = {
+	.read = DrvMainProcfsGestureInforModeRead,
+	.write = DrvMainProcfsGestureInforModeWrite,
+};
+#endif
+#endif
+
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+static const struct file_operations _gProcReportRate = {
+	.read = DrvMainProcfsReportRateRead,
+	.write = DrvMainProcfsReportRateWrite,
+};
+#endif
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+static const struct file_operations _gProcGloveMode = {
+	.read = DrvMainProcfsGloveModeRead,
+	.write = DrvMainProcfsGloveModeWrite,
+};
+
+static const struct file_operations
+	_gProcOpenGloveMode = {
+	.read = DrvMainProcfsOpenGloveModeRead,
+};
+
+static const struct file_operations
+	_gProcCloseGloveMode = {
+	.read = DrvMainProcfsCloseGloveModeRead,
+};
+#endif
+
+#ifdef CONFIG_ENABLE_JNI_INTERFACE
+static const struct file_operations _gProcJniMethod = {
+	.read = MsgToolRead,
+	.write = MsgToolWrite,
+	.unlocked_ioctl = MsgToolIoctl,
+	.compat_ioctl = MsgToolIoctl,
+};
+#endif
+
+static const struct
+file_operations _gProcSeLinuxLimitFirmwareUpdate = {
+	.read = DrvMainProcfsSeLinuxLimitFirmwareUpdateRead,
+};
+u32 SLAVE_I2C_ID_DBBUS = (0xC4>>1); /*0x62 for MSG28XX*/
+u32 SLAVE_I2C_ID_DWI2C = (0x4C>>1); /*0x26 */
+
+
+u16 FIRMWARE_MODE_UNKNOWN_MODE = 0xFFFF;
+u16 FIRMWARE_MODE_DEMO_MODE = 0xFFFF;
+u16 FIRMWARE_MODE_DEBUG_MODE = 0xFFFF;
+u16 FIRMWARE_MODE_RAW_DATA_MODE = 0xFFFF;
+
+struct kset *g_TouchKSet = NULL;
+struct kobject *g_TouchKObj = NULL;
+u8 g_IsSwitchModeByAPK = 0;
+
+
+u8 IS_GESTURE_WAKEUP_ENABLED = 0;
+u8 IS_GESTURE_DEBUG_MODE_ENABLED = 0;
+u8 IS_GESTURE_INFORMATION_MODE_ENABLED = 0;
+u8 IS_GESTURE_WAKEUP_MODE_SUPPORT_64_TYPES_ENABLED = 0;
+
+u8 TOUCH_DRIVER_DEBUG_LOG_LEVEL =
+	CONFIG_TOUCH_DRIVER_DEBUG_LOG_LEVEL;
+u8 IS_FIRMWARE_DATA_LOG_ENABLED =
+	CONFIG_ENABLE_FIRMWARE_DATA_LOG;
+u8 IS_FORCE_TO_UPDATE_FIRMWARE_ENABLED = 0;
+
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+struct kset *g_GestureKSet = NULL;
+struct kobject *g_GestureKObj = NULL;
+#endif
+#endif
+
+#ifdef CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+u16 g_FwPacketDataAddress = 0;
+u16 g_FwPacketFlagAddress = 0;
+u8 g_FwSupportSegment = 0;
+#endif
+
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+u32 g_IsEnableReportRate = 0;
+u32 g_InterruptCount = 0;
+u32 g_ValidTouchCount = 0;
+u32 g_InterruptReportRate = 0;
+u32 g_ValidTouchReportRate = 0;
+
+struct timeval g_StartTime;
+#endif
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+u8 g_IsEnableGloveMode = 0;
+#endif
+
+u8 g_FwData[MAX_UPDATE_FIRMWARE_BUFFER_SIZE][1024];
+u32 g_FwDataCount = 0;
+
+u8 g_IsHotknotEnabled = 0;
+u8 g_IsBypassHotknot = 0;
+
+
+static s32 _DrvMainCreateProcfsDirEntry(void);
+
+ssize_t DrvMainProcfsChipTypeRead(struct file *pFile,
+	char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 nLength = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (*pPos != 0)
+		return 0;
+
+	nLength = snprintf(pBuffer, 1, "%d", g_ChipType);
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsChipTypeWrite(struct file *pFile,
+	const char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	return nCount;
+}
+
+ssize_t DrvMainProcfsFirmwareDataRead(struct file *pFile,
+	char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	DBG("*** %s() g_FwDataCount = %d ***\n", __func__, g_FwDataCount);
+
+	if (*pPos != 0)
+		return 0;
+
+	*pPos += g_FwDataCount;
+
+	return g_FwDataCount;
+}
+
+ssize_t DrvMainProcfsFirmwareDataWrite(struct file *pFile,
+	const char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 nNum = nCount / 1024;
+	u32 nRemainder = nCount % 1024;
+	u32 i;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (nNum > 0) {
+		for (i = 0; i < nNum; i++) {
+			memcpy(g_FwData[g_FwDataCount],
+				pBuffer + (i * 1024), 1024);
+
+			g_FwDataCount++;
+		}
+
+		if (nRemainder > 0) {
+			DBG("nRemainder = %d\n", nRemainder);
+
+			memcpy(g_FwData[g_FwDataCount],
+				pBuffer + (i * 1024), nRemainder);
+
+			g_FwDataCount++;
+		}
+	} else {
+		if (nCount > 0) {
+			memcpy(g_FwData[g_FwDataCount], pBuffer, nCount);
+
+			g_FwDataCount++;
+		}
+	}
+
+	return nCount;
+}
+
+ssize_t DrvMainProcfsFirmwareUpdateRead(struct file *pFile,
+	char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 nLength = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (*pPos != 0)
+		return 0;
+
+	nLength = snprintf(pBuffer, sizeof(_gIsUpdateComplete),
+		"%d", _gIsUpdateComplete);
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsFirmwareUpdateWrite(struct file *pFile,
+		const char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	DrvPlatformLyrDisableFingerTouchReport();
+
+	if (0 != DrvIcFwLyrUpdateFirmware(g_FwData, EMEM_ALL)) {
+		_gIsUpdateComplete = 0;
+		DBG("Update FAILED\n");
+	} else {
+		_gIsUpdateComplete = 1;
+		DBG("Update SUCCESS\n");
+	}
+
+	DrvPlatformLyrEnableFingerTouchReport();
+
+	return nCount;
+}
+
+ssize_t DrvMainProcfsCustomerFirmwareVersionRead(struct file *pFile,
+		char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 nLength = 0;
+
+	if (*pPos != 0)
+		return 0;
+
+	nLength = snprintf(pBuffer, sizeof(_gFwVersion),
+		"%s\n", _gFwVersion);
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsCustomerFirmwareVersionWrite(struct file *pFile,
+			const char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	u16 nMajor = 0, nMinor = 0;
+
+	DrvIcFwLyrGetCustomerFirmwareVersion(
+		&nMajor, &nMinor, &_gFwVersion);
+
+	return nCount;
+}
+
+ssize_t DrvMainProcfsPlatformFirmwareVersionRead(struct file *pFile,
+		char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 nLength = 0;
+
+	if (*pPos != 0)
+		return 0;
+
+	nLength = snprintf(pBuffer, sizeof(_gPlatformFwVersion),
+		"%s\n", _gPlatformFwVersion);
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsPlatformFirmwareVersionWrite(struct file *pFile, const
+	char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	DrvIcFwLyrGetPlatformFirmwareVersion(&_gPlatformFwVersion);
+	return nCount;
+}
+
+ssize_t DrvMainProcfsDeviceDriverVersionRead(struct file *pFile, char __user
+	*pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 nLength = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (*pPos != 0)
+		return 0;
+
+	nLength = snprintf(pBuffer, 8, "%s",
+		DEVICE_DRIVER_RELEASE_VERSION);
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsDeviceDriverVersionWrite(struct file *pFile, const char
+	__user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	return nCount;
+}
+
+ssize_t DrvMainProcfsSdCardFirmwareUpdateRead(struct file *pFile, char __user
+*pBuffer, size_t nCount, loff_t *pPos)
+{
+	u16 nMajor = 0, nMinor = 0;
+	u32 nLength = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (*pPos != 0)
+		return 0;
+
+	DrvIcFwLyrGetCustomerFirmwareVersion(
+		&nMajor, &nMinor, &_gFwVersion);
+
+	nLength = snprintf(pBuffer,
+		sizeof(_gFwVersion), "%s\n", _gFwVersion);
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsSdCardFirmwareUpdateWrite(struct file *pFile, const char
+__user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	char *pValid = NULL;
+	char *pTmpFilePath = NULL;
+	char szFilePath[100] = {0};
+
+	DBG("*** %s() ***\n", __func__);
+	DBG("pBuffer = %s\n", pBuffer);
+
+	if (pBuffer != NULL) {
+		pValid = strnstr(pBuffer, ".bin", 0);
+
+		if (pValid) {
+			pTmpFilePath = strsep((char **)&pBuffer, ".");
+
+			DBG("pTmpFilePath = %s\n", pTmpFilePath);
+
+			strlcat(szFilePath, pTmpFilePath, sizeof(szFilePath));
+			strlcat(szFilePath, ".bin", sizeof(szFilePath));
+
+			DBG("szFilePath = %s\n", szFilePath);
+
+		}
+		}
+
+	return nCount;
+}
+
+ssize_t DrvMainProcfsSeLinuxLimitFirmwareUpdateRead(struct file *pFile, char
+__user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 nLength = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (*pPos != 0)
+		return 0;
+
+
+	if (0 != DrvIcFwLyrUpdateFirmwareBySdCard(
+			FIRMWARE_FILE_PATH_ON_SD_CARD)) {
+		_gIsUpdateComplete = 0;
+		DBG("Update FAILED\n");
+	} else {
+		_gIsUpdateComplete = 1;
+		DBG("Update SUCCESS\n");
+	}
+
+	nLength = snprintf(pBuffer,
+		sizeof(_gIsUpdateComplete), "%d", _gIsUpdateComplete);
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsFirmwareDebugRead(struct file *pFile, char __user
+*pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 i, nLength = 0;
+	u8 nBank, nAddr;
+	u16 szRegData[MAX_DEBUG_REGISTER_NUM] = {0};
+	u8 szOut[MAX_DEBUG_REGISTER_NUM*25] = {0}, szValue[10] = {0};
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (*pPos != 0)
+		return 0;
+
+	DbBusEnterSerialDebugMode();
+	DbBusStopMCU();
+	DbBusIICUseBus();
+	DbBusIICReshape();
+	msleep(100);
+
+	for (i = 0; i < _gDebugRegCount; i++)
+		szRegData[i] = RegGet16BitValue(_gDebugReg[i]);
+
+	DbBusIICNotUseBus();
+	DbBusNotStopMCU();
+	DbBusExitSerialDebugMode();
+
+	for (i = 0; i < _gDebugRegCount; i++) {
+		nBank = (_gDebugReg[i] >> 8) & 0xFF;
+		nAddr = _gDebugReg[i] & 0xFF;
+
+		strlcat(szOut, "reg(", sizeof(szOut));
+		snprintf(szValue, sizeof(u16), "0x%02X", nBank);
+		strlcat(szOut, szValue, sizeof(szOut));
+		strlcat(szOut, ",", sizeof(szOut));
+		snprintf(szValue, sizeof(u16), "0x%02X", nAddr);
+		strlcat(szOut, szValue, sizeof(szOut));
+		strlcat(szOut, ")=", sizeof(szOut));
+		snprintf(szValue, sizeof(u16), "0x%04X", szRegData[i]);
+		strlcat(szOut, szValue, sizeof(szOut));
+		strlcat(szOut, "\n", sizeof(szOut));
+	}
+
+	nLength = snprintf(pBuffer, sizeof(szOut), "%s\n", szOut);
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsFirmwareDebugWrite(struct file *pFile, const char __user
+*pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 i;
+	char *pCh = NULL;
+	char *pStr = NULL;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (pBuffer != NULL) {
+		DBG("*** pBuffer[0] = %c ***\n", pBuffer[0]);
+		DBG("*** pBuffer[1] = %c ***\n", pBuffer[1]);
+		DBG("*** pBuffer[2] = %c ***\n", pBuffer[2]);
+		DBG("*** pBuffer[3] = %c ***\n", pBuffer[3]);
+		DBG("*** pBuffer[4] = %c ***\n", pBuffer[4]);
+		DBG("*** pBuffer[5] = %c ***\n", pBuffer[5]);
+
+		DBG("nCount = %d\n", (int)nCount);
+
+		memset(_gDebugBuf, 0, 1024);
+
+		if (copy_from_user(_gDebugBuf, pBuffer, nCount))
+			return -EFAULT;
+
+		_gDebugBuf[nCount] = '\0';
+		pStr = _gDebugBuf;
+
+		i = 0;
+
+		while ((pCh = strsep((char **)&pStr, " ,")) && (i <
+				MAX_DEBUG_REGISTER_NUM)) {
+			DBG("pCh = %s\n", pCh);
+
+			_gDebugReg[i] =
+				DrvCommonConvertCharToHexDigit(
+				pCh, strlen(pCh));
+
+			i++;
+		}
+		_gDebugRegCount = i;
+
+		DBG("_gDebugRegCount = %d\n", _gDebugRegCount);
+	}
+
+	return nCount;
+}
+
+ssize_t DrvMainProcfsFirmwareSetDebugValueRead(struct file *pFile, char __user
+*pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 i, nLength = 0;
+	u8 nBank, nAddr;
+	u16 szRegData[MAX_DEBUG_REGISTER_NUM] = {0};
+	u8 szOut[MAX_DEBUG_REGISTER_NUM*25] = {0}, szValue[10] = {0};
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (*pPos != 0)
+		return 0;
+
+	DbBusEnterSerialDebugMode();
+	DbBusStopMCU();
+	DbBusIICUseBus();
+	DbBusIICReshape();
+	msleep(100);
+
+	for (i = 0; i < _gDebugRegCount; i++)
+		szRegData[i] = RegGet16BitValue(_gDebugReg[i]);
+
+	DbBusIICNotUseBus();
+	DbBusNotStopMCU();
+	DbBusExitSerialDebugMode();
+
+	for (i = 0; i < _gDebugRegCount; i++) {
+		nBank = (_gDebugReg[i] >> 8) & 0xFF;
+		nAddr = _gDebugReg[i] & 0xFF;
+
+
+		strlcat(szOut, "reg(", sizeof(szOut));
+		snprintf(szValue, sizeof(nBank), "0x%02X", nBank);
+		strlcat(szOut, szValue, sizeof(szOut));
+		strlcat(szOut, ",", sizeof(szOut));
+		snprintf(szValue, sizeof(nAddr), "0x%02X", nAddr);
+		strlcat(szOut, szValue, sizeof(szOut));
+		strlcat(szOut, ")=", sizeof(szOut));
+		snprintf(szValue,
+			sizeof(szRegData[i]), "0x%04X", szRegData[i]);
+		strlcat(szOut, szValue, sizeof(szOut));
+		strlcat(szOut, "\n", sizeof(szOut));
+	}
+
+	nLength = snprintf(pBuffer,
+			sizeof(szOut), "%s\n", szOut);
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsFirmwareSetDebugValueWrite(struct file *pFile, const char
+__user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 i, j, k;
+	char *pCh = NULL;
+	char *pStr = NULL;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (pBuffer != NULL) {
+		DBG("*** pBuffer[0] = %c ***\n", pBuffer[0]);
+		DBG("*** pBuffer[1] = %c ***\n", pBuffer[1]);
+
+		DBG("nCount = %d\n", (int)nCount);
+
+		memset(_gDebugBuf, 0, 1024);
+
+		if (copy_from_user(_gDebugBuf, pBuffer, nCount)) {
+			DBG("copy_from_user() failed\n");
+
+			return -EFAULT;
+		}
+		_gDebugBuf[nCount] = '\0';
+		pStr = _gDebugBuf;
+
+		i = 0;
+		j = 0;
+		k = 0;
+
+		while ((pCh = strsep((char **)&pStr, " ,")) && (i < 2)) {
+			DBG("pCh = %s\n", pCh);
+
+			if ((i % 2) == 0) {
+				_gDebugReg[j] =
+					DrvCommonConvertCharToHexDigit(
+					pCh, strlen(pCh));
+
+				j++;
+			} else {
+				_gDebugRegValue[k] =
+					DrvCommonConvertCharToHexDigit(
+					pCh, strlen(pCh));
+				k++;
+			}
+
+			i++;
+		}
+		_gDebugRegCount = j;
+
+		DBG("_gDebugRegCount = %d\n", _gDebugRegCount);
+
+		DbBusEnterSerialDebugMode();
+		DbBusStopMCU();
+		DbBusIICUseBus();
+		DbBusIICReshape();
+		msleep(100);
+
+		for (i = 0; i < _gDebugRegCount; i++)
+			RegSet16BitValue(_gDebugReg[i], _gDebugRegValue[i]);
+
+		DbBusIICNotUseBus();
+		DbBusNotStopMCU();
+		DbBusExitSerialDebugMode();
+	}
+
+	return nCount;
+}
+
+ssize_t DrvMainProcfsFirmwareSmBusDebugRead(struct file *pFile, char __user
+*pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 i, nLength = 0;
+	u8 szSmBusRxData[MAX_I2C_TRANSACTION_LENGTH_LIMIT] = {0};
+	u8 szOut[MAX_I2C_TRANSACTION_LENGTH_LIMIT*2] = {0};
+	u8 szValue[10] = {0};
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (*pPos != 0)
+		return 0;
+
+
+	if (_gDebugCmdArguCount > 0) {
+		DBG("Execute I2C SMBUS write command\n");
+
+		IicWriteData(SLAVE_I2C_ID_DWI2C,
+			&_gDebugCmdArgu[0], _gDebugCmdArguCount);
+	}
+
+	if (_gDebugReadDataSize > 0) {
+		DBG("Execute I2C SMBUS read command\n");
+
+		IicReadData(SLAVE_I2C_ID_DWI2C,
+			&szSmBusRxData[0], _gDebugReadDataSize);
+	}
+
+	for (i = 0; i < _gDebugReadDataSize; i++) {
+		DBG("szSmBusRxData[%d] = 0x%x\n", i, szSmBusRxData[i]);
+
+		snprintf(szValue,
+			sizeof(szSmBusRxData[i]),
+			"0x%02X", szSmBusRxData[i]);
+		strlcat(szOut, szValue, sizeof(szOut));
+		strlcat(szOut, "\n", sizeof(szOut));
+	}
+
+	nLength = snprintf(pBuffer, sizeof(szOut), "%s\n", szOut);
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsFirmwareSmBusDebugWrite(struct file *pFile, const char
+__user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 i, j;
+	char szCmdType[5] = {0};
+	char *pCh = NULL;
+	char *pStr = NULL;
+	int ret;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (pBuffer != NULL) {
+		DBG("*** pBuffer[0] = %c ***\n", pBuffer[0]);
+		DBG("*** pBuffer[1] = %c ***\n", pBuffer[1]);
+		DBG("*** pBuffer[2] = %c ***\n", pBuffer[2]);
+		DBG("*** pBuffer[3] = %c ***\n", pBuffer[3]);
+		DBG("*** pBuffer[4] = %c ***\n", pBuffer[4]);
+		DBG("*** pBuffer[5] = %c ***\n", pBuffer[5]);
+
+		DBG("nCount = %d\n", (int)nCount);
+
+		memset(_gDebugBuf, 0, 1024);
+
+		if (copy_from_user(_gDebugBuf, pBuffer, nCount)) {
+			DBG("copy_from_user() failed\n");
+
+			return -EFAULT;
+		}
+
+		_gDebugCmdArguCount = 0;
+		_gDebugReadDataSize = 0;
+
+		_gDebugBuf[nCount] = '\0';
+		pStr = _gDebugBuf;
+
+		i = 0;
+		j = 0;
+
+		while ((pCh = strsep((char **)&pStr, " ,"))
+			&& (j <	MAX_DEBUG_COMMAND_ARGUMENT_NUM)) {
+			DBG("pCh = %s\n", pCh);
+
+			if (strcmp(pCh, "w") == 0 || strcmp(pCh, "r") == 0)
+				memcpy(szCmdType, pCh, strlen(pCh));
+			else if (strcmp(szCmdType, "w") == 0) {
+				_gDebugCmdArgu[j] =
+					DrvCommonConvertCharToHexDigit(
+					pCh, strlen(pCh));
+
+				j++;
+
+				_gDebugCmdArguCount = j;
+			} else if (strcmp(szCmdType, "r") == 0)	{
+				ret = sscanf(pCh, "%d%d",
+					&_gDebugReadDataSize,
+					&g_IsEnableReportRate);
+				if (!ret)
+					return -EINVAL;
+				DBG("_gDebugReadDataSize = %d\n",
+					_gDebugReadDataSize);
+			} else
+				DBG("Un-supported adb command format!\n");
+
+			i++;
+		}
+	}
+
+	return nCount;
+}
+
+ssize_t DrvMainProcfsFirmwareSetDQMemValueRead(struct file *pFile, char __user
+*pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 i, nLength = 0;
+	u8 nBank, nAddr;
+	u32 szRegData[MAX_DEBUG_REGISTER_NUM] = {0};
+	u8 szOut[MAX_DEBUG_REGISTER_NUM*25] = {0}, szValue[10] = {0};
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (*pPos != 0)
+		return 0;
+
+	for (i = 0; i < _gDebugRegCount; i++)
+		szRegData[i] = DrvIcFwLyrReadDQMemValue(_gDebugReg[i]);
+
+	for (i = 0; i < _gDebugRegCount; i++) {
+		nBank = (_gDebugReg[i] >> 8) & 0xFF;
+		nAddr = _gDebugReg[i] & 0xFF;
+
+
+		strlcat(szOut, "reg(", sizeof(szOut));
+		snprintf(szValue, sizeof(nBank), "0x%02X", nBank);
+		strlcat(szOut, szValue, sizeof(szOut));
+		strlcat(szOut, ",", sizeof(szOut));
+		snprintf(szValue, sizeof(nAddr), "0x%02X", nAddr);
+		strlcat(szOut, szValue, sizeof(szOut));
+		strlcat(szOut, ")=", sizeof(szOut));
+		snprintf(szValue,
+			sizeof(szRegData[i]), "0x%04X", szRegData[i]);
+		strlcat(szOut, szValue, sizeof(szOut));
+		strlcat(szOut, "\n", sizeof(szOut));
+	}
+
+	nLength = snprintf(pBuffer, sizeof(szOut), "%s\n", szOut);
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsFirmwareSetDQMemValueWrite(struct file *pFile, const char
+__user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 i, j, k;
+	char *pCh = NULL;
+	char *pStr = NULL;
+	u16 nRealDQMemAddr = 0;
+	u32 nRealDQMemValue = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (pBuffer != NULL) {
+		DBG("*** pBuffer[0] = %c ***\n", pBuffer[0]);
+		DBG("*** pBuffer[1] = %c ***\n", pBuffer[1]);
+
+		DBG("nCount = %d\n", (int)nCount);
+
+		memset(_gDebugBuf, 0, 1024);
+
+		if (copy_from_user(_gDebugBuf, pBuffer, nCount))
+			return -EFAULT;
+
+		_gDebugBuf[nCount] = '\0';
+		pStr = _gDebugBuf;
+
+		i = 0;
+		j = 0;
+		k = 0;
+
+		while ((pCh = strsep((char **)&pStr, " ,")) && (i < 2)) {
+			DBG("pCh = %s\n", pCh);
+
+			if ((i % 2) == 0) {
+				_gDebugReg[j] =
+					DrvCommonConvertCharToHexDigit(
+					pCh, strlen(pCh));
+				j++;
+			} else {
+				_gDebugRegValue[k] =
+					DrvCommonConvertCharToHexDigit(
+					pCh, strlen(pCh));
+				k++;
+			}
+
+			i++;
+		}
+		_gDebugRegCount = j;
+
+		DBG("_gDebugRegCount = %d\n", _gDebugRegCount);
+
+		if ((_gDebugReg[0] % 4) == 0) {
+			nRealDQMemAddr = _gDebugReg[0];
+			nRealDQMemValue =
+				DrvIcFwLyrReadDQMemValue(nRealDQMemAddr);
+			_gDebugReg[0] = nRealDQMemAddr;
+			DBG("nRealDQMemValue Raw = %X\n", nRealDQMemValue);
+			nRealDQMemValue &= 0xFFFF0000;
+			nRealDQMemValue |= _gDebugRegValue[0];
+			DrvIcFwLyrWriteDQMemValue(
+				nRealDQMemAddr, nRealDQMemValue);
+		} else if ((_gDebugReg[0] % 4) == 2) {
+			nRealDQMemAddr = _gDebugReg[0] - 2;
+			nRealDQMemValue =
+				DrvIcFwLyrReadDQMemValue(nRealDQMemAddr);
+			_gDebugReg[0] = nRealDQMemAddr;
+			DBG("nRealDQMemValue Raw = %X\n", nRealDQMemValue);
+
+			nRealDQMemValue &= 0x0000FFFF;
+			nRealDQMemValue |= (_gDebugRegValue[0] << 16);
+			DrvIcFwLyrWriteDQMemValue(
+				nRealDQMemAddr, nRealDQMemValue);
+		}
+	}
+
+	return nCount;
+}
+
+/*------------------------------------------------------*/
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+
+ssize_t DrvMainProcfsMpTestRead(struct file *pFile, char __user *pBuffer,
+size_t nCount, loff_t *pPos)
+{
+	u32 nLength = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (*pPos != 0)
+		return 0;
+
+	nLength = snprintf(pBuffer, sizeof(nLength), "%d",
+		DrvIcFwLyrGetMpTestResult());
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsMpTestWrite(struct file *pFile, const char __user
+*pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 nMode = 0;
+	int ret;
+
+	if (pBuffer != NULL) {
+		ret = vsscanf(pBuffer, "%x", &nMode);
+
+		DBG("Mp Test Mode = 0x%x\n", nMode);
+
+		if (nMode == ITO_TEST_MODE_OPEN_TEST) {
+			_gItoTestMode = ITO_TEST_MODE_OPEN_TEST;
+			DrvIcFwLyrScheduleMpTestWork(
+				ITO_TEST_MODE_OPEN_TEST);
+		} else if (nMode == ITO_TEST_MODE_SHORT_TEST) {
+			_gItoTestMode = ITO_TEST_MODE_SHORT_TEST;
+			DrvIcFwLyrScheduleMpTestWork(
+				ITO_TEST_MODE_SHORT_TEST);
+		} else if (nMode == ITO_TEST_MODE_WATERPROOF_TEST) {
+			_gItoTestMode = ITO_TEST_MODE_WATERPROOF_TEST;
+			DrvIcFwLyrScheduleMpTestWork(
+				ITO_TEST_MODE_WATERPROOF_TEST);
+		} else
+			DBG("*** Undefined MP Test Mode ***\n");
+	}
+
+	return nCount;
+}
+
+ssize_t DrvMainProcfsMpTestLogRead(struct file *pFile, char __user *pBuffer,
+size_t nCount, loff_t *pPos)
+{
+	u32 nLength = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (*pPos != 0)
+		return 0;
+
+	DrvIcFwLyrGetMpTestDataLog(
+		_gItoTestMode, pBuffer, &nLength);
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsMpTestLogWrite(struct file *pFile, const char __user
+*pBuffer, size_t nCount, loff_t *pPos)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	return nCount;
+}
+
+ssize_t DrvMainProcfsMpTestFailChannelRead(struct file *pFile, char __user
+*pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 nLength = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (*pPos != 0)
+		return 0;
+
+	DrvIcFwLyrGetMpTestFailChannel(
+		_gItoTestMode, pBuffer, &nLength);
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsMpTestFailChannelWrite(struct file *pFile, const char
+__user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	return nCount;
+}
+
+ssize_t DrvMainProcfsMpTestScopeRead(struct file *pFile, char __user *pBuffer,
+size_t nCount, loff_t *pPos)
+{
+	u32 nLength = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (*pPos != 0)
+		return 0;
+
+	DrvIcFwLyrGetMpTestScope(&g_TestScopeInfo);
+
+	nLength = snprintf(pBuffer,
+			sizeof(g_TestScopeInfo.nMx) * 3,
+			"%d,%d,%d", g_TestScopeInfo.nMx,
+			g_TestScopeInfo.nMy, g_TestScopeInfo.nKeyNum);
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsMpTestScopeWrite(struct file *pFile, const char __user
+					*pBuffer, size_t nCount, loff_t *pPos)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	return nCount;
+}
+
+#endif
+
+/*---------------------------------------------------*/
+
+ssize_t DrvMainProcfsFirmwareModeRead(struct file *pFile, char __user
+*pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 nLength = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (*pPos != 0)
+		return 0;
+
+
+	if (g_ChipType == CHIP_TYPE_MSG28XX) {
+		DrvIcFwLyrGetFirmwareInfo(&g_FirmwareInfo);
+		g_FirmwareMode = g_FirmwareInfo.nFirmwareMode;
+
+	DBG("%s() firmware mode = 0x%x\n",
+		__func__, g_FirmwareInfo.nFirmwareMode);
+
+	nLength = snprintf(pBuffer,
+		sizeof(g_FirmwareInfo.nFirmwareMode), "%x",
+		g_FirmwareInfo.nFirmwareMode);
+	}
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsFirmwareModeWrite(struct file *pFile, const char __user
+*pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 nMode;
+	int ret = 0;
+
+	if (pBuffer != NULL) {
+		ret = sscanf(pBuffer, "%x%d", &nMode, &ret);
+		if (!ret)
+			return -EINVAL;
+
+		DBG("firmware mode = 0x%x\n", nMode);
+
+		g_IsSwitchModeByAPK = 0;
+
+		if (nMode == FIRMWARE_MODE_DEMO_MODE)
+			g_FirmwareMode =
+			DrvIcFwLyrChangeFirmwareMode(FIRMWARE_MODE_DEMO_MODE);
+		else if (nMode == FIRMWARE_MODE_DEBUG_MODE) {
+			g_FirmwareMode =
+				DrvIcFwLyrChangeFirmwareMode(
+				FIRMWARE_MODE_DEBUG_MODE);
+			g_IsSwitchModeByAPK = 1;
+		} else
+			DBG("*** Undefined Firmware Mode ***\n");
+	}
+	return nCount;
+}
+
+ssize_t DrvMainProcfsFirmwareSensorRead(struct file *pFile, char __user
+	*pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 nLength = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (*pPos != 0)
+		return 0;
+
+	if (g_FirmwareInfo.nLogModePacketHeader == 0xA5 ||
+			g_FirmwareInfo.nLogModePacketHeader == 0xAB)
+		nLength = snprintf(pBuffer,
+				sizeof(g_FirmwareInfo.nMx) * 2, "%d,%d",
+				g_FirmwareInfo.nMx,
+				g_FirmwareInfo.nMy);
+	else if (g_FirmwareInfo.nLogModePacketHeader == 0xA7)
+		nLength = snprintf(pBuffer,
+			sizeof(g_FirmwareInfo.nMx) * 4, "%d,%d,%d,%d",
+			g_FirmwareInfo.nMx,
+			g_FirmwareInfo.nMy, g_FirmwareInfo.nSs,
+			g_FirmwareInfo.nSd);
+	else
+		nLength = 0;
+
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsFirmwareSensorWrite(struct file *pFile, const char __user
+*pBuffer, size_t nCount, loff_t *pPos)
+{
+	return nCount;
+}
+
+ssize_t DrvMainProcfsFirmwarePacketHeaderRead(struct file *pFile, char __user
+*pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 nLength = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (*pPos != 0)
+		return 0;
+
+	nLength = snprintf(pBuffer, 2, "%d",
+		g_FirmwareInfo.nLogModePacketHeader);
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsFirmwarePacketHeaderWrite(struct file *pFile, const char
+__user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	return nCount;
+}
+
+ssize_t DrvMainKObjectPacketShow(struct kobject *pKObj, struct kobj_attribute
+*pAttr, char *pBuf)
+{
+	u32 i = 0;
+	u32 nLength = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (strcmp(pAttr->attr.name, "packet") == 0) {
+		if (g_LogModePacket != NULL) {
+			if ((g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE) &&
+				(g_LogModePacket[0] == 0xA5
+					|| g_LogModePacket[0] == 0xAB
+					|| g_LogModePacket[0] == 0xA7)) {
+				for (i = 0; i <
+					g_FirmwareInfo.nLogModePacketLength;
+					i++)
+					pBuf[i] = g_LogModePacket[i];
+
+				nLength = g_FirmwareInfo.nLogModePacketLength;
+				DBG("nLength = %d\n", nLength);
+			}
+
+			DBG("g_LogModePacket is NULL\n");
+
+	}
+		}
+	return nLength;
+}
+
+ssize_t DrvMainKObjectPacketStore(struct kobject *pKObj, struct kobj_attribute
+*pAttr, const char *pBuf, size_t nCount)
+{
+	DBG("*** %s() ***\n", __func__);
+	return nCount;
+}
+
+static struct kobj_attribute packet_attr = __ATTR(packet, 0664,
+DrvMainKObjectPacketShow, DrvMainKObjectPacketStore);
+
+static struct attribute *attrs[] = {
+	&packet_attr.attr,
+	NULL,
+};
+
+/*
+ * An unnamed attribute group will put all of the attributes directly in
+ * the kobject directory. If we specify a name, a subdirectory will be
+ * created for the attributes with the directory being the name of the
+ * attribute group.
+ */
+struct attribute_group attr_group = {
+	.attrs = attrs,
+};
+
+
+
+ssize_t DrvMainProcfsQueryFeatureSupportStatusRead(struct file *pFile, char
+__user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 nLength = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (*pPos != 0)
+		return 0;
+
+	nLength = snprintf(pBuffer,
+		sizeof(_gFeatureSupportStatus), "%d", _gFeatureSupportStatus);
+
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsQueryFeatureSupportStatusWrite(struct file *pFile, const
+char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 nFeature;
+	int ret;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (pBuffer != NULL) {
+		/*g_InterruptCount is no need*/
+		ret = sscanf(pBuffer, "%x%d", &nFeature,
+				&g_InterruptCount);
+		if (!ret)
+			return -EINVAL;
+		DBG("nFeature = 0x%x\n", nFeature);
+
+		if (nFeature == FEATURE_GESTURE_WAKEUP_MODE)
+			_gFeatureSupportStatus =
+			IS_GESTURE_WAKEUP_ENABLED;
+		else if (nFeature == FEATURE_GESTURE_DEBUG_MODE)
+			_gFeatureSupportStatus =
+				IS_GESTURE_DEBUG_MODE_ENABLED;
+		else if (nFeature == FEATURE_GESTURE_INFORMATION_MODE)
+			_gFeatureSupportStatus =
+				IS_GESTURE_INFORMATION_MODE_ENABLED;
+		else if (nFeature == FEATURE_TOUCH_DRIVER_DEBUG_LOG)
+			_gFeatureSupportStatus =
+				TOUCH_DRIVER_DEBUG_LOG_LEVEL;
+		else if (nFeature == FEATURE_FIRMWARE_DATA_LOG) {
+			_gFeatureSupportStatus =
+				IS_FIRMWARE_DATA_LOG_ENABLED;
+
+#ifdef CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+			if (_gFeatureSupportStatus == 1)
+				DrvIcFwLyrGetTouchPacketAddress(
+					&g_FwPacketDataAddress,
+					&g_FwPacketFlagAddress);
+#endif
+		} else if (nFeature == FEATURE_FORCE_TO_UPDATE_FIRMWARE)
+			_gFeatureSupportStatus =
+				IS_FORCE_TO_UPDATE_FIRMWARE_ENABLED;
+		else
+			DBG("*** Undefined Feature ***\n");
+	}
+
+
+	return nCount;
+}
+
+ssize_t DrvMainProcfsChangeFeatureSupportStatusRead(struct file *pFile, char
+__user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 nLength = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (*pPos != 0)
+		return 0;
+
+	nLength = snprintf(pBuffer, sizeof(_gFeatureSupportStatus),
+		"%d", _gFeatureSupportStatus);
+
+	DBG("*** _gFeatureSupportStatus = %d ***\n", _gFeatureSupportStatus);
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsChangeFeatureSupportStatusWrite(struct file *pFile, const
+char __user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 i;
+	u32 nFeature = 0, nNewValue = 0;
+	char *pCh = NULL;
+	char *pStr = NULL;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (pBuffer != NULL) {
+		DBG("nCount = %d\n", (int)nCount);
+
+		memset(_gDebugBuf, 0, 1024);
+
+		if (copy_from_user(_gDebugBuf, pBuffer, nCount)) {
+			DBG("copy_from_user() failed\n");
+
+			return -EFAULT;
+		}
+
+		_gDebugBuf[nCount] = '\0';
+		pStr = _gDebugBuf;
+
+		i = 0;
+
+		while ((pCh = strsep((char **)&pStr, " ,")) && (i < 3)) {
+			DBG("pCh = %s\n", pCh);
+
+			if (i == 0) {
+				nFeature =
+					DrvCommonConvertCharToHexDigit(
+					pCh, strlen(pCh));
+				DBG("nFeature = 0x%04X\n", nFeature);
+			} else if (i == 1) {
+				nNewValue =
+					DrvCommonConvertCharToHexDigit(
+					pCh, strlen(pCh));
+				DBG("nNewValue = %d\n", nNewValue);
+			} else
+				DBG("End of parsing adb command.\n");
+
+			i++;
+		}
+
+		if (nFeature == FEATURE_GESTURE_WAKEUP_MODE) {
+			IS_GESTURE_WAKEUP_ENABLED = nNewValue;
+			_gFeatureSupportStatus =
+				IS_GESTURE_WAKEUP_ENABLED;
+		} else if (nFeature == FEATURE_GESTURE_DEBUG_MODE) {
+			IS_GESTURE_DEBUG_MODE_ENABLED = nNewValue;
+			_gFeatureSupportStatus =
+				IS_GESTURE_DEBUG_MODE_ENABLED;
+		} else if (nFeature == FEATURE_GESTURE_INFORMATION_MODE) {
+			IS_GESTURE_INFORMATION_MODE_ENABLED = nNewValue;
+			_gFeatureSupportStatus =
+				IS_GESTURE_INFORMATION_MODE_ENABLED;
+		} else if (nFeature == FEATURE_TOUCH_DRIVER_DEBUG_LOG) {
+			TOUCH_DRIVER_DEBUG_LOG_LEVEL = nNewValue;
+			_gFeatureSupportStatus =
+				TOUCH_DRIVER_DEBUG_LOG_LEVEL;
+		} else if (nFeature == FEATURE_FIRMWARE_DATA_LOG) {
+			IS_FIRMWARE_DATA_LOG_ENABLED = nNewValue;
+			_gFeatureSupportStatus =
+				IS_FIRMWARE_DATA_LOG_ENABLED;
+		} else if (nFeature == FEATURE_FORCE_TO_UPDATE_FIRMWARE) {
+			IS_FORCE_TO_UPDATE_FIRMWARE_ENABLED = nNewValue;
+			_gFeatureSupportStatus =
+				IS_FORCE_TO_UPDATE_FIRMWARE_ENABLED;
+		}
+	}
+
+	return nCount;
+}
+
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+
+ssize_t DrvMainProcfsGestureWakeupModeRead(struct file *pFile, char __user
+*pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 nLength = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (*pPos != 0)
+		return 0;
+
+#ifdef CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE
+
+	nLength = snprintf(pBuffer, sizeof(g_GestureWakeupMode), "%x,%x",
+		g_GestureWakeupMode[0], g_GestureWakeupMode[1]);
+#else
+	nLength = snprintf(pBuffer, sizeof(g_GestureWakeupMode), "%x",
+		g_GestureWakeupMode[0]);
+#endif
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsGestureWakeupModeWrite(struct file *pFile, const char
+__user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 nLength;
+	u32 nWakeupMode[2] = {0};
+	int ret;
+
+	if (pBuffer != NULL) {
+#ifdef CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE
+		u32 i;
+		char *pCh;
+
+		i = 0;
+		while ((pCh = strsep((char **)&pBuffer, " ,")) && (i < 2)) {
+			DBG("pCh = %s\n", pCh);
+
+			nWakeupMode[i] =
+				DrvCommonConvertCharToHexDigit(
+				pCh, strlen(pCh));
+
+			DBG("nWakeupMode[%d] = 0x%04X\n", i, nWakeupMode[i]);
+			i++;
+		}
+#else
+		ret = vsscanf(pBuffer, "%x", &nWakeupMode[0]);
+		DBG("nWakeupMode = 0x%x\n", nWakeupMode[0]);
+#endif
+
+		nLength = nCount;
+		DBG("nLength = %d\n", nLength);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG) ==
+					GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+				 GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+				(~GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG)
+					== GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG)
+					== GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG)
+					== GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG)
+				== GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+				(~GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG)
+					== GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG)
+					== GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG)
+					== GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG)
+					== GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG)
+					== GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG)
+					== GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG)
+					== GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG)
+					== GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE1_FLAG)
+					== GESTURE_WAKEUP_MODE_RESERVE1_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_RESERVE1_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_RESERVE1_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE2_FLAG)
+					== GESTURE_WAKEUP_MODE_RESERVE2_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_RESERVE2_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_RESERVE2_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE3_FLAG)
+					== GESTURE_WAKEUP_MODE_RESERVE3_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_RESERVE3_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_RESERVE3_FLAG);
+
+#ifdef CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE4_FLAG)
+					== GESTURE_WAKEUP_MODE_RESERVE4_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_RESERVE4_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_RESERVE4_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE5_FLAG)
+					== GESTURE_WAKEUP_MODE_RESERVE5_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_RESERVE5_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_RESERVE5_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE6_FLAG)
+					== GESTURE_WAKEUP_MODE_RESERVE6_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_RESERVE6_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_RESERVE6_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE7_FLAG)
+					== GESTURE_WAKEUP_MODE_RESERVE7_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_RESERVE7_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_RESERVE7_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE8_FLAG)
+					== GESTURE_WAKEUP_MODE_RESERVE8_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_RESERVE8_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_RESERVE8_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE9_FLAG)
+					== GESTURE_WAKEUP_MODE_RESERVE9_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+				GESTURE_WAKEUP_MODE_RESERVE9_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_RESERVE9_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE10_FLAG)
+					== GESTURE_WAKEUP_MODE_RESERVE10_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_RESERVE10_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_RESERVE10_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE11_FLAG)
+					== GESTURE_WAKEUP_MODE_RESERVE11_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_RESERVE11_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_RESERVE11_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE12_FLAG)
+					== GESTURE_WAKEUP_MODE_RESERVE12_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_RESERVE12_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_RESERVE12_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE13_FLAG)
+					== GESTURE_WAKEUP_MODE_RESERVE13_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_RESERVE13_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_RESERVE13_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE14_FLAG) ==
+					GESTURE_WAKEUP_MODE_RESERVE14_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_RESERVE14_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_RESERVE14_FLAG);
+
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE15_FLAG) ==
+				GESTURE_WAKEUP_MODE_RESERVE15_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_RESERVE15_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_RESERVE15_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE16_FLAG) ==
+					GESTURE_WAKEUP_MODE_RESERVE16_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_RESERVE16_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_RESERVE16_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE17_FLAG) ==
+					GESTURE_WAKEUP_MODE_RESERVE17_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_RESERVE17_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_RESERVE17_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE18_FLAG) ==
+					GESTURE_WAKEUP_MODE_RESERVE18_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_RESERVE18_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_RESERVE18_FLAG);
+
+		if ((nWakeupMode[0] & GESTURE_WAKEUP_MODE_RESERVE19_FLAG) ==
+					GESTURE_WAKEUP_MODE_RESERVE19_FLAG)
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] |
+					GESTURE_WAKEUP_MODE_RESERVE19_FLAG;
+		else
+			g_GestureWakeupMode[0] = g_GestureWakeupMode[0] &
+					(~GESTURE_WAKEUP_MODE_RESERVE19_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE20_FLAG) ==
+					GESTURE_WAKEUP_MODE_RESERVE20_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+					GESTURE_WAKEUP_MODE_RESERVE20_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+					(~GESTURE_WAKEUP_MODE_RESERVE20_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE21_FLAG) ==
+					GESTURE_WAKEUP_MODE_RESERVE21_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+					GESTURE_WAKEUP_MODE_RESERVE21_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+					(~GESTURE_WAKEUP_MODE_RESERVE21_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE22_FLAG) ==
+					GESTURE_WAKEUP_MODE_RESERVE22_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+					GESTURE_WAKEUP_MODE_RESERVE22_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+					(~GESTURE_WAKEUP_MODE_RESERVE22_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE23_FLAG) ==
+					GESTURE_WAKEUP_MODE_RESERVE23_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+					GESTURE_WAKEUP_MODE_RESERVE23_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+					(~GESTURE_WAKEUP_MODE_RESERVE23_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE24_FLAG) ==
+					GESTURE_WAKEUP_MODE_RESERVE24_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+					GESTURE_WAKEUP_MODE_RESERVE24_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+					(~GESTURE_WAKEUP_MODE_RESERVE24_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE25_FLAG) ==
+					GESTURE_WAKEUP_MODE_RESERVE25_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+					GESTURE_WAKEUP_MODE_RESERVE25_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+					(~GESTURE_WAKEUP_MODE_RESERVE25_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE26_FLAG) ==
+					GESTURE_WAKEUP_MODE_RESERVE26_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+					GESTURE_WAKEUP_MODE_RESERVE26_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+					(~GESTURE_WAKEUP_MODE_RESERVE26_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE27_FLAG) ==
+					GESTURE_WAKEUP_MODE_RESERVE27_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+					GESTURE_WAKEUP_MODE_RESERVE27_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+					(~GESTURE_WAKEUP_MODE_RESERVE27_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE28_FLAG) ==
+					GESTURE_WAKEUP_MODE_RESERVE28_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+					GESTURE_WAKEUP_MODE_RESERVE28_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+					(~GESTURE_WAKEUP_MODE_RESERVE28_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE29_FLAG) ==
+					GESTURE_WAKEUP_MODE_RESERVE29_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+					GESTURE_WAKEUP_MODE_RESERVE29_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+					(~GESTURE_WAKEUP_MODE_RESERVE29_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE30_FLAG) ==
+					GESTURE_WAKEUP_MODE_RESERVE30_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+					GESTURE_WAKEUP_MODE_RESERVE30_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+					(~GESTURE_WAKEUP_MODE_RESERVE30_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE31_FLAG) ==
+					GESTURE_WAKEUP_MODE_RESERVE31_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+					GESTURE_WAKEUP_MODE_RESERVE31_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+					(~GESTURE_WAKEUP_MODE_RESERVE31_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE32_FLAG) ==
+					GESTURE_WAKEUP_MODE_RESERVE32_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+					GESTURE_WAKEUP_MODE_RESERVE32_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+					(~GESTURE_WAKEUP_MODE_RESERVE32_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE33_FLAG) ==
+					GESTURE_WAKEUP_MODE_RESERVE33_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+				GESTURE_WAKEUP_MODE_RESERVE33_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+					(~GESTURE_WAKEUP_MODE_RESERVE33_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE34_FLAG) ==
+					GESTURE_WAKEUP_MODE_RESERVE34_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+					GESTURE_WAKEUP_MODE_RESERVE34_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+					(~GESTURE_WAKEUP_MODE_RESERVE34_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE35_FLAG) ==
+					GESTURE_WAKEUP_MODE_RESERVE35_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+					GESTURE_WAKEUP_MODE_RESERVE35_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+				(~GESTURE_WAKEUP_MODE_RESERVE35_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE36_FLAG) ==
+					GESTURE_WAKEUP_MODE_RESERVE36_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+					GESTURE_WAKEUP_MODE_RESERVE36_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+					(~GESTURE_WAKEUP_MODE_RESERVE36_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE37_FLAG) ==
+					GESTURE_WAKEUP_MODE_RESERVE37_FLAG)
+			g_GestureWakeupMode[1] =
+					g_GestureWakeupMode[1] |
+					GESTURE_WAKEUP_MODE_RESERVE37_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+(~GESTURE_WAKEUP_MODE_RESERVE37_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE38_FLAG) ==
+GESTURE_WAKEUP_MODE_RESERVE38_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+GESTURE_WAKEUP_MODE_RESERVE38_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+(~GESTURE_WAKEUP_MODE_RESERVE38_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE39_FLAG) ==
+GESTURE_WAKEUP_MODE_RESERVE39_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+GESTURE_WAKEUP_MODE_RESERVE39_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+(~GESTURE_WAKEUP_MODE_RESERVE39_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE40_FLAG) ==
+GESTURE_WAKEUP_MODE_RESERVE40_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+GESTURE_WAKEUP_MODE_RESERVE40_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+(~GESTURE_WAKEUP_MODE_RESERVE40_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE41_FLAG) ==
+GESTURE_WAKEUP_MODE_RESERVE41_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+GESTURE_WAKEUP_MODE_RESERVE41_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+(~GESTURE_WAKEUP_MODE_RESERVE41_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE42_FLAG) ==
+GESTURE_WAKEUP_MODE_RESERVE42_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+GESTURE_WAKEUP_MODE_RESERVE42_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+(~GESTURE_WAKEUP_MODE_RESERVE42_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE43_FLAG) ==
+GESTURE_WAKEUP_MODE_RESERVE43_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+GESTURE_WAKEUP_MODE_RESERVE43_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+(~GESTURE_WAKEUP_MODE_RESERVE43_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE44_FLAG) ==
+GESTURE_WAKEUP_MODE_RESERVE44_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+GESTURE_WAKEUP_MODE_RESERVE44_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+(~GESTURE_WAKEUP_MODE_RESERVE44_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE45_FLAG) ==
+GESTURE_WAKEUP_MODE_RESERVE45_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+GESTURE_WAKEUP_MODE_RESERVE45_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+(~GESTURE_WAKEUP_MODE_RESERVE45_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE46_FLAG) ==
+GESTURE_WAKEUP_MODE_RESERVE46_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+GESTURE_WAKEUP_MODE_RESERVE46_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+(~GESTURE_WAKEUP_MODE_RESERVE46_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE47_FLAG) ==
+GESTURE_WAKEUP_MODE_RESERVE47_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+GESTURE_WAKEUP_MODE_RESERVE47_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+(~GESTURE_WAKEUP_MODE_RESERVE47_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE48_FLAG) ==
+GESTURE_WAKEUP_MODE_RESERVE48_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+GESTURE_WAKEUP_MODE_RESERVE48_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+(~GESTURE_WAKEUP_MODE_RESERVE48_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE49_FLAG) ==
+GESTURE_WAKEUP_MODE_RESERVE49_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+GESTURE_WAKEUP_MODE_RESERVE49_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+(~GESTURE_WAKEUP_MODE_RESERVE49_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE50_FLAG) ==
+GESTURE_WAKEUP_MODE_RESERVE50_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+GESTURE_WAKEUP_MODE_RESERVE50_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+(~GESTURE_WAKEUP_MODE_RESERVE50_FLAG);
+
+		if ((nWakeupMode[1] & GESTURE_WAKEUP_MODE_RESERVE51_FLAG) ==
+GESTURE_WAKEUP_MODE_RESERVE51_FLAG)
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] |
+GESTURE_WAKEUP_MODE_RESERVE51_FLAG;
+		else
+			g_GestureWakeupMode[1] = g_GestureWakeupMode[1] &
+(~GESTURE_WAKEUP_MODE_RESERVE51_FLAG);
+#endif
+
+		DBG("g_GestureWakeupMode = 0x%x,  0x%x\n",
+			g_GestureWakeupMode[0],
+			g_GestureWakeupMode[1]);
+	}
+
+	return nCount;
+}
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+
+ssize_t DrvMainProcfsGestureDebugModeRead(struct file *pFile, char __user
+*pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 nLength = 0;
+
+	DBG("*** %s() ***\n", __func__);
+	if (*pPos != 0)
+		return 0;
+
+	DBG("g_GestureDebugMode = 0x%x\n", g_GestureDebugMode);
+
+	nLength = snprintf(pBuffer, sizeof(g_GestureDebugMode),
+		"%d", g_GestureDebugMode);
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsGestureDebugModeWrite(struct file *pFile, const char
+__user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	u8 ucGestureMode[2];
+	u8 i;
+	char *pCh;
+
+	if (pBuffer != NULL) {
+		i = 0;
+		while ((pCh = strsep((char **)&pBuffer, " ,")) && (i < 2)) {
+			DBG("pCh = %s\n", pCh);
+
+			ucGestureMode[i] =
+				DrvCommonConvertCharToHexDigit(
+				pCh, strlen(pCh));
+
+			DBG("ucGestureMode[%d] = 0x%04X\n", i,
+				ucGestureMode[i]);
+			i++;
+		}
+
+		g_GestureDebugMode = ucGestureMode[0];
+		g_GestureDebugFlag = ucGestureMode[1];
+
+		DBG("Gesture flag = 0x%x\n", g_GestureDebugFlag);
+
+		if (g_GestureDebugMode == 0x01) {
+			DrvIcFwLyrOpenGestureDebugMode(g_GestureDebugFlag);
+
+			input_report_key(g_InputDevice, KEY_POWER, 1);
+			input_sync(g_InputDevice);
+			input_report_key(g_InputDevice, KEY_POWER, 0);
+			input_sync(g_InputDevice);
+		} else if (g_GestureDebugMode == 0x00)
+			DrvIcFwLyrCloseGestureDebugMode();
+	}
+
+	return nCount;
+}
+
+ssize_t DrvMainKObjectGestureDebugShow(struct kobject *pKObj, struct
+kobj_attribute *pAttr, char *pBuf)
+{
+	u32 i = 0;
+	u32 nLength = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (strcmp(pAttr->attr.name, "gesture_debug") == 0) {
+		if (g_LogGestureDebug != NULL) {
+
+			if (g_LogGestureDebug[0] == 0xA7 &&
+				g_LogGestureDebug[3] == 0x51)
+				for (i = 0; i < 0x80; i++)
+					pBuf[i] = g_LogGestureDebug[i];
+
+				nLength = 0x80;
+				DBG("nLength = %d\n", nLength);
+			}
+		}
+
+	}
+
+	return nLength;
+}
+
+ssize_t DrvMainKObjectGestureDebugStore(struct kobject *pKObj, struct
+kobj_attribute *pAttr, const char *pBuf, size_t nCount)
+{
+	DBG("*** %s() ***\n", __func__);
+/*
+	if (strcmp(pAttr->attr.name, "packet") == 0)
+	{
+
+	}
+*/
+	return nCount;
+}
+
+static struct kobj_attribute gesture_attr = __ATTR(gesture_debug, 0664,
+DrvMainKObjectGestureDebugShow, DrvMainKObjectGestureDebugStore);
+
+static struct attribute *gestureattrs[] = {
+	&gesture_attr.attr,
+	NULL,	/* need to NULL terminate the list of attributes */
+};
+
+/*
+ * An unnamed attribute group will put all of the attributes directly in
+ * the kobject directory. If we specify a name, a subdirectory will be
+ * created for the attributes with the directory being the name of the
+ * attribute group.
+ */
+struct attribute_group gestureattr_group = {
+	.attrs = gestureattrs,
+};
+
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+
+ssize_t DrvMainProcfsGestureInforModeRead(struct file *pFile, char __user
+*pBuffer, size_t nCount, loff_t *pPos)
+{
+	u8 szOut[GESTURE_WAKEUP_INFORMATION_PACKET_LENGTH*5] = {0};
+	u8 szValue[10] = {0};
+	u32 szLogGestureInfo[GESTURE_WAKEUP_INFORMATION_PACKET_LENGTH] = {0};
+	u32 i = 0;
+	u32 nLength = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (*pPos != 0)
+		return 0;
+
+	_gLogGestureCount = 0;
+	if (_gLogGestureInforType ==
+		FIRMWARE_GESTURE_INFORMATION_MODE_A) {
+		for (i = 0; i < 2; i++) {
+			szLogGestureInfo[_gLogGestureCount] =
+				g_LogGestureInfor[4 + i];
+			_gLogGestureCount++;
+		}
+
+		for (i = 2; i < 8; i++) {
+			szLogGestureInfo[_gLogGestureCount] =
+				g_LogGestureInfor[4 + i];
+			_gLogGestureCount++;
+		}
+	} else if (_gLogGestureInforType ==
+		FIRMWARE_GESTURE_INFORMATION_MODE_B) {
+		for (i = 0; i < 2; i++) {
+			szLogGestureInfo[_gLogGestureCount] =
+				g_LogGestureInfor[4 + i];
+			_gLogGestureCount++;
+		}
+
+		for (i = 0; i < g_LogGestureInfor[5]*2 ; i++) {
+			szLogGestureInfo[_gLogGestureCount] =
+				g_LogGestureInfor[12 + i];
+			_gLogGestureCount++;
+		}
+	} else if (_gLogGestureInforType ==
+			FIRMWARE_GESTURE_INFORMATION_MODE_C) {
+		for (i = 0; i < 6; i++) {
+			szLogGestureInfo[_gLogGestureCount] =
+				g_LogGestureInfor[i];
+			_gLogGestureCount++;
+		}
+
+		for (i = 6; i < 86; i++) {
+			szLogGestureInfo[_gLogGestureCount] =
+				g_LogGestureInfor[i];
+			_gLogGestureCount++;
+		}
+
+		szLogGestureInfo[_gLogGestureCount] =
+			g_LogGestureInfor[86];
+		_gLogGestureCount++;
+		szLogGestureInfo[_gLogGestureCount] =
+			g_LogGestureInfor[87];
+		_gLogGestureCount++;
+	}
+
+	for (i = 0; i < _gLogGestureCount; i++) {
+		snprintf(szValue, sizeof(szLogGestureInfo),
+			"%d", szLogGestureInfo[i]);
+		strlcat(szOut, szValue);
+		strlcat(szOut, ",");
+	}
+
+	nLength = snprintf(pBuffer, sizeof(szOut), "%s\n", szOut);
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsGestureInforModeWrite(struct file *pFile, const char
+__user *pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 nMode;
+	int ret;
+
+
+	if (pBuffer != NULL) {
+		ret = sscanf(pBuffer, "%x%d", &nMode,
+			&g_IsEnableReportRate);
+		if (!ret)
+			return -EINVAL;
+		_gLogGestureInforType = nMode;
+	}
+
+
+	return nCount;
+}
+
+#endif
+
+#endif
+
+/*--------------------------------------------------------------------------*/
+
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+ssize_t DrvMainProcfsReportRateRead(struct file *pFile, char __user *pBuffer,
+size_t nCount, loff_t *pPos)
+{
+	struct timeval tEndTime;
+	suseconds_t nStartTime, nEndTime, nElapsedTime;
+	u32 nLength = 0;
+
+	if (*pPos != 0)
+		return 0;
+
+	do_gettimeofday(&tEndTime);
+
+	nStartTime =
+		g_StartTime.tv_sec + g_StartTime.tv_usec / 1000000;
+	nEndTime = tEndTime.tv_sec + tEndTime.tv_usec / 1000000;
+
+	nElapsedTime = nEndTime - nStartTime;
+
+	DBG("Elapsed time : %lu sec\n", nElapsedTime);
+
+	if (nElapsedTime != 0) {
+		g_InterruptReportRate = g_InterruptCount / nElapsedTime;
+		g_ValidTouchReportRate = g_ValidTouchCount / nElapsedTime;
+	} else {
+		g_InterruptReportRate = 0;
+		g_ValidTouchReportRate = 0;
+	}
+
+	DBG("g_InterruptReportRate = %d, g_ValidTouchReportRate = %d\n",
+g_InterruptReportRate, g_ValidTouchReportRate);
+
+	g_InterruptCount = 0;
+	g_ValidTouchCount = 0;
+
+	nLength = snprintf(pBuffer,
+		sizeof(g_InterruptReportRate) * 2, "%d,%d",
+		g_InterruptReportRate,
+		g_ValidTouchReportRate);
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t
+	DrvMainProcfsReportRateWrite(
+	struct file *pFile, const char __user *pBuffer,
+	size_t nCount, loff_t *pPos)
+{
+	if (pBuffer != NULL) {
+		if (sscanf(pBuffer, "%d%d",
+			&g_IsEnableReportRate, &g_InterruptCount) != 1)
+			return -EINVAL;
+
+		DBG("g_IsEnableReportRate = %d\n", g_IsEnableReportRate);
+
+		g_InterruptCount = 0;
+		g_ValidTouchCount = 0;
+	}
+
+	return nCount;
+}
+#endif
+
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+ssize_t DrvMainProcfsGloveModeRead(struct file *pFile, char __user *pBuffer,
+size_t nCount, loff_t *pPos)
+{
+	u32 nLength = 0;
+	u8 ucGloveMode = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (*pPos != 0)
+		return 0;
+
+	if (g_ChipType == CHIP_TYPE_MSG28XX) {
+		DrvPlatformLyrDisableFingerTouchReport();
+
+		DrvIcFwLyrGetGloveInfo(&ucGloveMode);
+
+		DrvPlatformLyrEnableFingerTouchReport();
+
+		DBG("Glove Mode = 0x%x\n", ucGloveMode);
+
+		nLength = snprintf(pBuffer, sizeof(ucGloveMode),
+			"%x", ucGloveMode);
+	}
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsGloveModeWrite(struct file *pFile, const char __user
+*pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 nGloveMode = 0;
+	u32 i = 0;
+	char *pCh = NULL;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (pBuffer != NULL) {
+		i = 0;
+		while ((pCh = strsep((char **)&pBuffer, ",")) && (i < 1)) {
+			DBG("pCh = %s\n", pCh);
+
+			nGloveMode =
+				DrvCommonConvertCharToHexDigit(
+				pCh, strlen(pCh));
+
+			i++;
+		}
+
+		DBG("Glove Mode = 0x%x\n", nGloveMode);
+
+		DrvPlatformLyrDisableFingerTouchReport();
+
+		if (nGloveMode == 0x01) {
+			DrvIcFwLyrOpenGloveMode();
+			g_IsEnableGloveMode = 1;
+		} else if (nGloveMode == 0x00) {
+			DrvIcFwLyrCloseGloveMode();
+			g_IsEnableGloveMode = 0;
+		}
+
+
+		DrvPlatformLyrEnableFingerTouchReport();
+	}
+
+	return nCount;
+}
+
+ssize_t DrvMainProcfsOpenGloveModeRead(struct file *pFile, char __user
+*pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 nLength = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (*pPos != 0)
+		return 0;
+
+	if (g_ChipType == CHIP_TYPE_MSG28XX) {
+		DrvPlatformLyrDisableFingerTouchReport();
+
+		DrvIcFwLyrOpenGloveMode();
+		g_IsEnableGloveMode = 1;
+
+		DrvPlatformLyrEnableFingerTouchReport();
+	}
+	DBG("g_IsEnableGloveMode = 0x%x\n", g_IsEnableGloveMode);
+
+	*pPos += nLength;
+
+	return nLength;
+}
+
+ssize_t DrvMainProcfsCloseGloveModeRead(struct file *pFile, char __user
+*pBuffer, size_t nCount, loff_t *pPos)
+{
+	u32 nLength = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (*pPos != 0)
+		return 0;
+
+	if (g_ChipType == CHIP_TYPE_MSG28XX) {
+		DrvPlatformLyrDisableFingerTouchReport();
+
+		DrvIcFwLyrCloseGloveMode();
+		g_IsEnableGloveMode = 0;
+
+		DrvPlatformLyrEnableFingerTouchReport();
+	}
+	DBG("g_IsEnableGloveMode = 0x%x\n", g_IsEnableGloveMode);
+
+	*pPos += nLength;
+
+	return nLength;
+}
+#endif
+
+#ifdef MAOYQ
+static bool debug_addr_is_valid(int addr)
+{
+	if (addr < 0 || addr > 0xFF) {
+		pr_err("mms reg address is invalid: 0x%x\n", addr);
+		return false;
+	}
+
+	return true;
+}
+
+static int msg28xx_debug_data_set(void *_data, u64 val)
+{
+	mutex_lock(&g_Mutex);
+
+	if (debug_addr_is_valid(MSG_addr))
+		pr_err("Writing into mstar registers not supported\n");
+
+	mutex_unlock(&g_Mutex);
+
+	return 0;
+}
+
+static int msg28xx_debug_data_get(void *_data, u64 *val)
+{
+
+	int rc;
+	u8 readbuf;
+
+	mutex_lock(&g_Mutex);
+
+	if (debug_addr_is_valid(MSG_addr)) {
+		readbuf = MSG_addr;
+
+		rc = IicReadData(SLAVE_I2C_ID_DWI2C, &readbuf, 1);
+		if (rc < 0)
+			pr_err("read register  failed (%d)\n", rc);
+		else
+			*val = readbuf;
+
+	}
+
+	mutex_unlock(&g_Mutex);
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(debug_data_fops, msg28xx_debug_data_get,
+			msg28xx_debug_data_set, "0x%02llX\n");
+
+static int msg28xx_debug_addr_set(void *_data, u64 val)
+{
+	if (debug_addr_is_valid(val)) {
+		mutex_lock(&g_Mutex);
+		MSG_addr = val;
+		mutex_unlock(&g_Mutex);
+	}
+
+	return 0;
+}
+
+static int msg28xx_debug_addr_get(void *_data, u64 *val)
+{
+	mutex_lock(&g_Mutex);
+
+	if (debug_addr_is_valid(MSG_addr))
+		*val = MSG_addr;
+
+	mutex_unlock(&g_Mutex);
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(debug_addr_fops, msg28xx_debug_addr_get,
+			msg28xx_debug_addr_set, "0x%02llX\n");
+
+static int msg28xx_debug_suspend_set(void *_data, u64 val)
+{
+	mutex_lock(&g_Mutex);
+
+	if (!val) {
+		#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+			DrvPlatformLyrTouchDeviceRegulatorPowerOn(true);
+		#endif
+			DrvPlatformLyrTouchDevicePowerOn();
+
+
+		} else {
+			DrvPlatformLyrFingerTouchReleased(0, 0, 0);
+
+			DrvPlatformLyrTouchDevicePowerOff();
+			}
+
+
+	mutex_unlock(&g_Mutex);
+
+	return 0;
+}
+
+static int msg28xx_debug_suspend_get(void *_data, u64 *val)
+{
+	mutex_lock(&g_Mutex);
+	*val = _MsgSuspended;
+	mutex_unlock(&g_Mutex);
+
+	return 0;
+}
+DEFINE_SIMPLE_ATTRIBUTE(debug_suspend_fops, msg28xx_debug_suspend_get,
+			msg28xx_debug_suspend_set, "%lld\n");
+
+static int msg28xx_debug_dump_info(struct seq_file *m, void *v)
+{
+	seq_printf(m, "%s\n", ts_info);
+
+	return 0;
+}
+
+static int debugfs_dump_info_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, msg28xx_debug_dump_info, inode->i_private);
+}
+
+static const struct file_operations debug_dump_info_fops = {
+	.owner		= THIS_MODULE,
+	.open		= debugfs_dump_info_open,
+	.read		= seq_read,
+	.release	= single_release,
+};
+
+
+static int Msg_debugfs_init(void)
+{
+	msg_debug_base = debugfs_create_dir(MSG_DEBUGFS_DIR, NULL);
+	if (IS_ERR_OR_NULL(msg_debug_base)) {
+		pr_err("Failed to create debugfs dir.\n");
+		return -EINVAL;
+	}
+
+	if ((IS_ERR_OR_NULL(debugfs_create_file(MSG_DEBUGFS_FILE_SUSPEND,
+						S_IWUSR | S_IWGRP | S_IRUSR |
+						S_IRGRP, msg_debug_base, 0,
+						&debug_suspend_fops)))) {
+		pr_err("Failed to create suspend file.\n");
+		debugfs_remove_recursive(msg_debug_base);
+		return -EINVAL;
+	}
+
+	if ((IS_ERR_OR_NULL(debugfs_create_file(MSG_DEBUGFS_FILE_DATA,
+						S_IWUSR | S_IWGRP | S_IRUSR |
+						S_IRGRP, msg_debug_base, 0,
+						&debug_data_fops)))) {
+		pr_err("Failed to create data file.\n");
+		debugfs_remove_recursive(msg_debug_base);
+		return -EINVAL;
+	}
+
+	if ((IS_ERR_OR_NULL(debugfs_create_file(MSG_DEBUGFS_FILE_ADDR,
+						S_IWUSR | S_IWGRP | S_IRUSR |
+						S_IRGRP, msg_debug_base, 0,
+						&debug_addr_fops)))) {
+		pr_err("Failed to create addr file.\n");
+		debugfs_remove_recursive(msg_debug_base);
+		return -EINVAL;
+	}
+
+	if ((IS_ERR_OR_NULL(debugfs_create_file(MSG_DEBUGFS_FILE_DUMP_INFO,
+						S_IWUSR | S_IWGRP | S_IRUSR |
+						S_IRGRP, msg_debug_base, 0,
+						&debug_dump_info_fops)))) {
+		pr_err("Failed to create dump info file.\n");
+		debugfs_remove_recursive(msg_debug_base);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+#endif
+
+
+
+
+s32 DrvMainTouchDeviceInitialize(void)
+{
+	u8 nRetVal = 0;
+	 u16 nMajor = 0, nMinor = 0;
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+#endif
+
+	DBG("*** %s() ***\n", __func__);
+
+	_DrvMainCreateProcfsDirEntry();
+#ifdef MAOYQ
+
+	nRetVal = sysfs_create_group(&g_I2cClient->dev.kobj,
+				&msg_attr_grp);
+		if (nRetVal < 0)
+			pr_err("sys file creation failed.\n");
+
+
+	nRetVal = Msg_debugfs_init();
+
+		ts_info = devm_kzalloc(&g_I2cClient->dev,
+					INFO_MAX_LEN, GFP_KERNEL);
+
+
+	    DrvIcFwLyrGetCustomerFirmwareVersion(&nMajor,
+			&nMinor, &_gFwVersion);
+		STORE_TS_INFO(ts_info, "Mstar",
+			MAX_TOUCH_NUM, *_gFwVersion);
+#endif
+
+
+#ifdef CONFIG_ENABLE_JNI_INTERFACE
+	CreateMsgToolMem();
+#endif
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+	DrvIcFwLyrCreateMpTestWorkQueue();
+#endif
+
+	g_ChipType = DrvIcFwLyrGetChipType();
+
+
+	if (g_ChipType == 0) {
+		SLAVE_I2C_ID_DBBUS = (0xB2>>1);
+		g_ChipType = DrvIcFwLyrGetChipType();
+	}
+
+	DrvPlatformLyrTouchDeviceResetHw();
+
+	if (g_ChipType != 0) {
+		memset(&g_FirmwareInfo, 0x0, sizeof(struct FirmwareInfo_t));
+
+		DrvIcFwLyrVariableInitialize();
+
+#ifdef CONFIG_ENABLE_CHARGER_DETECTION
+		{
+			u8 szChargerStatus[20] = {0};
+
+			DrvCommonReadFile(
+				"/sys/class/power_supply/battery/status",
+				szChargerStatus, 20);
+
+
+		if (strnstr(szChargerStatus, "Charging") != NULL ||
+			strnstr(szChargerStatus, "Full") != NULL ||
+			strnstr(szChargerStatus, "Fullycharged") != NULL)
+				DrvFwCtrlChargerDetection(1);
+		else
+				DrvFwCtrlChargerDetection(0);
+
+		}
+#endif
+
+	} else
+		nRetVal = -ENODEV;
+
+	return nRetVal;
+}
+
+void DrvMainRemoveProcfsDirEntry(void)
+{
+	DBG("*** %s() ***\n", __func__);
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+	if (_gProcGloveModeEntry != NULL) {
+		remove_proc_entry(PROC_NODE_GLOVE_MODE,
+			_gProcDeviceEntry);
+		_gProcGloveModeEntry = NULL;
+	}
+
+	if (_gProcOpenGloveModeEntry != NULL) {
+		remove_proc_entry(PROC_NODE_OPEN_GLOVE_MODE,
+			_gProcDeviceEntry);
+		_gProcOpenGloveModeEntry = NULL;
+	}
+
+	if (_gProcCloseGloveModeEntry != NULL) {
+		remove_proc_entry(PROC_NODE_CLOSE_GLOVE_MODE,
+			_gProcDeviceEntry);
+		_gProcCloseGloveModeEntry = NULL;
+	}
+#endif
+
+#ifdef CONFIG_ENABLE_JNI_INTERFACE
+	if (_gProcJniMethodEntry != NULL) {
+		remove_proc_entry(PROC_NODE_JNI_NODE,
+			_gProcDeviceEntry);
+		_gProcJniMethodEntry = NULL;
+	}
+#endif
+
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+	if (_gProcReportRateEntry != NULL) {
+		remove_proc_entry(PROC_NODE_REPORT_RATE,
+			_gProcDeviceEntry);
+		_gProcReportRateEntry = NULL;
+	}
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+	if (_gProcGestureWakeupModeEntry != NULL) {
+		remove_proc_entry(PROC_NODE_GESTURE_WAKEUP_MODE,
+			_gProcDeviceEntry);
+		_gProcGestureWakeupModeEntry = NULL;
+	}
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+	if (_gProcGestureDebugModeEntry != NULL) {
+		remove_proc_entry(PROC_NODE_GESTURE_DEBUG_MODE,
+			_gProcDeviceEntry);
+		_gProcGestureDebugModeEntry = NULL;
+	}
+#endif
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+	if (_gProcGestureInforModeEntry != NULL) {
+		remove_proc_entry(PROC_NODE_GESTURE_INFORMATION_MODE,
+			_gProcDeviceEntry);
+		_gProcGestureInforModeEntry = NULL;
+	}
+#endif
+#endif
+
+	if (_gProcFirmwareModeEntry != NULL) {
+		remove_proc_entry(PROC_NODE_FIRMWARE_MODE,
+			_gProcDeviceEntry);
+		_gProcFirmwareModeEntry = NULL;
+	}
+
+	if (_gProcFirmwareSensorEntry != NULL) {
+		remove_proc_entry(PROC_NODE_FIRMWARE_SENSOR,
+			_gProcDeviceEntry);
+		_gProcFirmwareSensorEntry = NULL;
+	}
+
+	if (_gProcFirmwarePacketHeaderEntry != NULL) {
+		remove_proc_entry(PROC_NODE_FIRMWARE_PACKET_HEADER,
+			_gProcDeviceEntry);
+		_gProcFirmwarePacketHeaderEntry = NULL;
+	}
+
+	if (_gProcQueryFeatureSupportStatusEntry != NULL) {
+		remove_proc_entry(
+			PROC_NODE_QUERY_FEATURE_SUPPORT_STATUS,
+			_gProcDeviceEntry);
+		_gProcQueryFeatureSupportStatusEntry = NULL;
+	}
+
+	if (_gProcChangeFeatureSupportStatusEntry != NULL) {
+		remove_proc_entry(
+			PROC_NODE_CHANGE_FEATURE_SUPPORT_STATUS,
+			_gProcDeviceEntry);
+		_gProcChangeFeatureSupportStatusEntry = NULL;
+	}
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+	if (_gProcMpTestEntry != NULL) {
+		remove_proc_entry(PROC_NODE_MP_TEST,
+			_gProcDeviceEntry);
+		_gProcMpTestEntry = NULL;
+	}
+
+	if (_gProcMpTestLogEntry != NULL) {
+		remove_proc_entry(PROC_NODE_MP_TEST_LOG,
+			_gProcDeviceEntry);
+		_gProcMpTestLogEntry = NULL;
+	}
+
+	if (_gProcMpTestFailChannelEntry != NULL) {
+		remove_proc_entry(PROC_NODE_MP_TEST_FAIL_CHANNEL,
+			_gProcDeviceEntry);
+		_gProcMpTestFailChannelEntry = NULL;
+	}
+
+	if (_gProcMpTestScopeEntry != NULL) {
+		remove_proc_entry(PROC_NODE_MP_TEST_SCOPE,
+			_gProcDeviceEntry);
+		_gProcMpTestScopeEntry = NULL;
+	}
+#endif
+
+	if (_gProcFirmwareSetDQMemValueEntry != NULL) {
+		remove_proc_entry(PROC_NODE_FIRMWARE_SET_DQMEM_VALUE,
+			_gProcDeviceEntry);
+		_gProcFirmwareSetDQMemValueEntry = NULL;
+	}
+
+	if (_gProcFirmwareSmBusDebugEntry != NULL) {
+		remove_proc_entry(PROC_NODE_FIRMWARE_SMBUS_DEBUG,
+			_gProcDeviceEntry);
+		_gProcFirmwareSmBusDebugEntry = NULL;
+	}
+
+	if (_gProcFirmwareSetDebugValueEntry != NULL) {
+		remove_proc_entry(PROC_NODE_FIRMWARE_SET_DEBUG_VALUE,
+				_gProcDeviceEntry);
+		_gProcFirmwareSetDebugValueEntry = NULL;
+	}
+
+	if (_gProcFirmwareDebugEntry != NULL) {
+		remove_proc_entry(PROC_NODE_FIRMWARE_DEBUG,
+			_gProcDeviceEntry);
+		_gProcFirmwareDebugEntry = NULL;
+	}
+
+	if (_gProcSdCardFirmwareUpdateEntry != NULL) {
+		remove_proc_entry(
+			PROC_NODE_SD_CARD_FIRMWARE_UPDATE,
+			_gProcDeviceEntry);
+		_gProcSdCardFirmwareUpdateEntry = NULL;
+	}
+
+	if (_gProcSeLinuxLimitFirmwareUpdateEntry != NULL) {
+		remove_proc_entry(
+			PROC_NODE_SELINUX_LIMIT_FIRMWARE_UPDATE,
+			_gProcDeviceEntry);
+		_gProcSeLinuxLimitFirmwareUpdateEntry = NULL;
+
+	}
+
+	if (_gProcDeviceDriverVersionEntry != NULL) {
+		remove_proc_entry(PROC_NODE_DEVICE_DRIVER_VERSION,
+			_gProcDeviceEntry);
+		_gProcDeviceDriverVersionEntry = NULL;
+	}
+
+	if (_gProcPlatformFirmwareVersionEntry != NULL) {
+		remove_proc_entry(PROC_NODE_PLATFORM_FIRMWARE_VERSION,
+				_gProcDeviceEntry);
+		_gProcPlatformFirmwareVersionEntry = NULL;
+	}
+
+	if (_gProcCustomerFirmwareVersionEntry != NULL) {
+		remove_proc_entry(PROC_NODE_CUSTOMER_FIRMWARE_VERSION,
+			_gProcDeviceEntry);
+		_gProcCustomerFirmwareVersionEntry = NULL;
+	}
+
+	if (_gProcApkFirmwareUpdateEntry != NULL) {
+		remove_proc_entry(PROC_NODE_FIRMWARE_UPDATE,
+			_gProcDeviceEntry);
+		_gProcApkFirmwareUpdateEntry = NULL;
+	}
+
+	if (_gProcFirmwareDataEntry != NULL) {
+		remove_proc_entry(PROC_NODE_FIRMWARE_DATA,
+			_gProcDeviceEntry);
+		_gProcFirmwareDataEntry = NULL;
+	}
+
+	if (_gProcChipTypeEntry != NULL) {
+		remove_proc_entry(PROC_NODE_CHIP_TYPE,
+			_gProcDeviceEntry);
+		_gProcChipTypeEntry = NULL;
+	}
+
+	if (_gProcDeviceEntry != NULL) {
+		remove_proc_entry(PROC_NODE_DEVICE,
+			_gProcMsTouchScreenMsg20xxEntry);
+		_gProcDeviceEntry = NULL;
+
+	}
+
+	if (_gProcMsTouchScreenMsg20xxEntry != NULL) {
+		remove_proc_entry(PROC_NODE_MS_TOUCHSCREEN_MSG20XX,
+			_gProcClassEntry);
+		_gProcMsTouchScreenMsg20xxEntry = NULL;
+	}
+
+	if (_gProcClassEntry != NULL) {
+		remove_proc_entry(PROC_NODE_CLASS, NULL);
+		_gProcClassEntry = NULL;
+	}
+}
+
+
+static s32 _DrvMainCreateProcfsDirEntry(void)
+{
+	s32 nRetVal = 0;
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+	u8 *pGesturePath = NULL;
+#endif
+#endif
+	u8 *pDevicePath = NULL;
+
+	DBG("*** %s() ***\n", __func__);
+
+	_gProcClassEntry = proc_mkdir(PROC_NODE_CLASS, NULL);
+
+	_gProcMsTouchScreenMsg20xxEntry =
+			proc_mkdir(PROC_NODE_MS_TOUCHSCREEN_MSG20XX,
+			_gProcClassEntry);
+
+	_gProcDeviceEntry = proc_mkdir(PROC_NODE_DEVICE,
+		_gProcMsTouchScreenMsg20xxEntry);
+
+	_gProcChipTypeEntry =
+		proc_create(PROC_NODE_CHIP_TYPE, PROCFS_AUTHORITY,
+		_gProcDeviceEntry, &_gProcChipType);
+
+
+	_gProcFirmwareDataEntry =
+		proc_create(PROC_NODE_FIRMWARE_DATA,
+		PROCFS_AUTHORITY, _gProcDeviceEntry,
+		&_gProcFirmwareData);
+
+	_gProcApkFirmwareUpdateEntry =
+		proc_create(PROC_NODE_FIRMWARE_UPDATE,
+		PROCFS_AUTHORITY, _gProcDeviceEntry,
+		&_gProcApkFirmwareUpdate);
+
+	_gProcCustomerFirmwareVersionEntry =
+		proc_create(PROC_NODE_CUSTOMER_FIRMWARE_VERSION,
+		PROCFS_AUTHORITY,
+		_gProcDeviceEntry,
+		&_gProcCustomerFirmwareVersion);
+
+
+	_gProcPlatformFirmwareVersionEntry =
+			proc_create(PROC_NODE_PLATFORM_FIRMWARE_VERSION,
+			PROCFS_AUTHORITY,
+			_gProcDeviceEntry,
+			&_gProcPlatformFirmwareVersion);
+
+	_gProcDeviceDriverVersionEntry =
+			proc_create(PROC_NODE_DEVICE_DRIVER_VERSION,
+			PROCFS_AUTHORITY,
+			_gProcDeviceEntry,
+			&_gProcDeviceDriverVersion);
+
+
+	_gProcSdCardFirmwareUpdateEntry =
+		proc_create(PROC_NODE_SD_CARD_FIRMWARE_UPDATE,
+		PROCFS_AUTHORITY,
+		_gProcDeviceEntry,
+		&_gProcSdCardFirmwareUpdate);
+
+
+	_gProcFirmwareDebugEntry =
+		proc_create(PROC_NODE_FIRMWARE_DEBUG,
+		PROCFS_AUTHORITY, _gProcDeviceEntry,
+		&_gProcFirmwareDebug);
+	_gProcFirmwareSetDebugValueEntry =
+			proc_create(PROC_NODE_FIRMWARE_SET_DEBUG_VALUE,
+			PROCFS_AUTHORITY,
+			_gProcDeviceEntry,
+			&_gProcFirmwareSetDebugValue);
+
+	_gProcFirmwareSmBusDebugEntry =
+			proc_create(PROC_NODE_FIRMWARE_SMBUS_DEBUG,
+			PROCFS_AUTHORITY,
+			_gProcDeviceEntry, &_gProcFirmwareSmBusDebug);
+
+	_gProcFirmwareSetDQMemValueEntry =
+		proc_create(PROC_NODE_FIRMWARE_SET_DQMEM_VALUE,
+		PROCFS_AUTHORITY,
+		_gProcDeviceEntry, &_gProcFirmwareSetDQMemValue);
+
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+	_gProcMpTestEntry =
+		proc_create(PROC_NODE_MP_TEST, PROCFS_AUTHORITY,
+		_gProcDeviceEntry, &_gProcMpTest);
+
+
+	_gProcMpTestLogEntry =
+		proc_create(PROC_NODE_MP_TEST_LOG,
+		PROCFS_AUTHORITY, _gProcDeviceEntry,
+		&_gProcMpTestLog);
+
+	_gProcMpTestFailChannelEntry =
+		proc_create(PROC_NODE_MP_TEST_FAIL_CHANNEL,
+		PROCFS_AUTHORITY, _gProcDeviceEntry,
+		&_gProcMpTestFailChannel);
+
+
+	_gProcMpTestScopeEntry =
+		proc_create(PROC_NODE_MP_TEST_SCOPE,
+		PROCFS_AUTHORITY, _gProcDeviceEntry,
+		&_gProcMpTestScope);
+#endif
+
+
+	_gProcFirmwareModeEntry =
+		proc_create(PROC_NODE_FIRMWARE_MODE,
+		PROCFS_AUTHORITY, _gProcDeviceEntry,
+		&_gProcFirmwareMode);
+
+	_gProcFirmwareSensorEntry =
+		proc_create(PROC_NODE_FIRMWARE_SENSOR,
+		PROCFS_AUTHORITY, _gProcDeviceEntry,
+		&_gProcFirmwareSensor);
+
+	_gProcFirmwarePacketHeaderEntry =
+		proc_create(PROC_NODE_FIRMWARE_PACKET_HEADER,
+		PROCFS_AUTHORITY,
+		_gProcDeviceEntry,
+		&_gProcFirmwarePacketHeader);
+
+
+	g_TouchKSet = kset_create_and_add("kset_example",
+		NULL, kernel_kobj);
+	if (!g_TouchKSet)
+		nRetVal = -ENOMEM;
+
+	g_TouchKObj = kobject_create();
+	if (!g_TouchKObj) {
+		DBG("*** kobject_create() failed, nRetVal = %d ***\n", nRetVal);
+
+		nRetVal = -ENOMEM;
+		kset_unregister(g_TouchKSet);
+		g_TouchKSet = NULL;
+	}
+
+	g_TouchKObj->kset = g_TouchKSet;
+
+	nRetVal = kobject_add(g_TouchKObj, NULL, "%s", "kobject_example");
+	if (nRetVal != 0) {
+		DBG("*** kobject_add() failed, nRetVal = %d ***\n", nRetVal);
+
+		kobject_put(g_TouchKObj);
+		g_TouchKObj = NULL;
+		kset_unregister(g_TouchKSet);
+		g_TouchKSet = NULL;
+	}
+
+	/* create the files associated with this kobject */
+	nRetVal = sysfs_create_group(g_TouchKObj, &attr_group);
+	if (nRetVal != 0) {
+		kobject_put(g_TouchKObj);
+		g_TouchKObj = NULL;
+		kset_unregister(g_TouchKSet);
+		g_TouchKSet = NULL;
+	}
+
+	pDevicePath = kobject_get_path(g_TouchKObj, GFP_KERNEL);
+	DBG("DEVPATH = %s\n", pDevicePath);
+
+
+	_gProcQueryFeatureSupportStatusEntry =
+proc_create(PROC_NODE_QUERY_FEATURE_SUPPORT_STATUS,
+	PROCFS_AUTHORITY,
+	_gProcDeviceEntry,
+	&_gProcQueryFeatureSupportStatus);
+
+	_gProcChangeFeatureSupportStatusEntry =
+proc_create(PROC_NODE_CHANGE_FEATURE_SUPPORT_STATUS, PROCFS_AUTHORITY,
+_gProcDeviceEntry, &_gProcChangeFeatureSupportStatus);
+	if (NULL == _gProcChangeFeatureSupportStatusEntry)
+		DBG("Failed to create procfs file node(%s)!\n",
+PROC_NODE_CHANGE_FEATURE_SUPPORT_STATUS);
+	else
+		DBG("Create procfs file node(%s) OK!\n",
+PROC_NODE_CHANGE_FEATURE_SUPPORT_STATUS);
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+	_gProcGestureWakeupModeEntry = proc_create(
+		PROC_NODE_GESTURE_WAKEUP_MODE,
+		PROCFS_AUTHORITY, _gProcDeviceEntry,
+		&_gProcGestureWakeupMode);
+	if (NULL == _gProcGestureWakeupModeEntry)
+		DBG("Failed to create procfs file node(%s)!\n",
+PROC_NODE_GESTURE_WAKEUP_MODE);
+	else
+		DBG("Create procfs file node(%s) OK!\n",
+PROC_NODE_GESTURE_WAKEUP_MODE);
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+	_gProcGestureDebugModeEntry = proc_create(PROC_NODE_GESTURE_DEBUG_MODE,
+PROCFS_AUTHORITY, _gProcDeviceEntry, &_gProcGestureDebugMode);
+	if (NULL == _gProcGestureDebugModeEntry)
+		DBG("Failed to create procfs file node(%s)!\n",
+PROC_NODE_GESTURE_DEBUG_MODE);
+	else
+		DBG("Create procfs file node(%s) OK!\n",
+PROC_NODE_GESTURE_DEBUG_MODE);
+
+	g_GestureKSet = kset_create_and_add("kset_gesture",
+		NULL, kernel_kobj);
+	if (!g_GestureKSet)
+		nRetVal = -ENOMEM;
+
+	g_GestureKObj = kobject_create();
+	if (!g_GestureKObj) {
+		DBG("*** kobject_create() failed, nRetVal = %d ***\n", nRetVal);
+
+		nRetVal = -ENOMEM;
+		kset_unregister(g_GestureKSet);
+		g_GestureKSet = NULL;
+	}
+
+	g_GestureKObj->kset = g_GestureKSet;
+
+	nRetVal = kobject_add(g_GestureKObj, NULL, "%s", "kobject_gesture");
+	if (nRetVal != 0) {
+		DBG("*** kobject_add() failed, nRetVal = %d ***\n", nRetVal);
+
+		kobject_put(g_GestureKObj);
+		g_GestureKObj = NULL;
+		kset_unregister(g_GestureKSet);
+		g_GestureKSet = NULL;
+	}
+
+	/* create the files associated with this g_GestureKObj */
+	nRetVal = sysfs_create_group(g_GestureKObj,
+	&gestureattr_group);
+
+	if (nRetVal != 0) {
+		kobject_put(g_GestureKObj);
+		g_GestureKObj = NULL;
+		kset_unregister(g_GestureKSet);
+		g_GestureKSet = NULL;
+	}
+
+	pGesturePath = kobject_get_path(g_GestureKObj, GFP_KERNEL);
+	DBG("DEVPATH = %s\n", pGesturePath);
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+	_gProcGestureInforModeEntry =
+proc_create(PROC_NODE_GESTURE_INFORMATION_MODE,
+	PROCFS_AUTHORITY,
+	_gProcDeviceEntry, &_gProcGestureInforMode);
+
+#endif
+#endif
+
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+	_gProcReportRateEntry = proc_create(
+		PROC_NODE_REPORT_RATE,
+		PROCFS_AUTHORITY, _gProcDeviceEntry,
+		&_gProcReportRate);
+#endif
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+	_gProcGloveModeEntry = proc_create(PROC_NODE_GLOVE_MODE,
+		PROCFS_AUTHORITY,
+		_gProcDeviceEntry, &_gProcGloveMode);
+	_gProcOpenGloveModeEntry = proc_create(
+		PROC_NODE_OPEN_GLOVE_MODE,
+		PROCFS_AUTHORITY, _gProcDeviceEntry,
+		&_gProcOpenGloveMode);
+	if (NULL == _gProcOpenGloveModeEntry)
+		DBG("Failed to create procfs file node(%s)!\n",
+		PROC_NODE_OPEN_GLOVE_MODE);
+	else
+		DBG("Create procfs file node(%s) OK!\n",
+		PROC_NODE_OPEN_GLOVE_MODE);
+
+	_gProcCloseGloveModeEntry = proc_create(
+		PROC_NODE_CLOSE_GLOVE_MODE,
+		PROCFS_AUTHORITY, _gProcDeviceEntry,
+		&_gProcCloseGloveMode);
+
+#endif
+
+#ifdef CONFIG_ENABLE_JNI_INTERFACE
+	_gProcJniMethodEntry = proc_create(
+	PROC_NODE_JNI_NODE, PROCFS_AUTHORITY,
+	_gProcDeviceEntry, &_gProcJniMethod);
+
+	if (NULL == _gProcJniMethodEntry)
+		DBG("Failed to create procfs file node(%s)!\n",
+		PROC_NODE_JNI_NODE);
+	else
+		DBG("Create procfs file node(%s) OK!\n", PROC_NODE_JNI_NODE);
+#endif
+
+	_gProcSeLinuxLimitFirmwareUpdateEntry =
+proc_create(PROC_NODE_SELINUX_LIMIT_FIRMWARE_UPDATE, PROCFS_AUTHORITY,
+_gProcDeviceEntry, &_gProcSeLinuxLimitFirmwareUpdate);
+	if (NULL == _gProcSeLinuxLimitFirmwareUpdateEntry)
+		DBG("Failed to create procfs file node(%s)!\n",
+PROC_NODE_SELINUX_LIMIT_FIRMWARE_UPDATE);
+	else
+		DBG("Create procfs file node(%s) OK!\n",
+PROC_NODE_SELINUX_LIMIT_FIRMWARE_UPDATE);
+
+	return nRetVal;
+}
+
diff --git a/drivers/input/touchscreen/msg28xx/mstar_drv_main.h b/drivers/input/touchscreen/msg28xx/mstar_drv_main.h
new file mode 100644
index 0000000..bca8867
--- /dev/null
+++ b/drivers/input/touchscreen/msg28xx/mstar_drv_main.h
@@ -0,0 +1,273 @@
+/***********************************************************
+//
+// Copyright (c) 2006-2016 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages,
+// losses, costs and expenses resulting therefrom.
+//
+*************************************************************/
+/**
+ *
+ * @file    mstar_drv_main.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+#ifndef __MSTAR_DRV_MAIN_H__
+#define __MSTAR_DRV_MAIN_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include "mstar_drv_common.h"
+#include "mstar_drv_main.h"
+#include "mstar_drv_utility_adaption.h"
+#include "mstar_drv_platform_porting_layer.h"
+#include "mstar_drv_ic_fw_porting_layer.h"
+
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR CONSTANT DEFINITION                                         */
+/*--------------------------------------------------------------------------*/
+
+#define PROC_NODE_CLASS                       "class"
+#define PROC_NODE_MS_TOUCHSCREEN_MSG20XX      "ms-touchscreen-msg20xx"
+#define PROC_NODE_DEVICE                      "device"
+#define PROC_NODE_CHIP_TYPE                   "chip_type"
+#define PROC_NODE_FIRMWARE_DATA               "data"
+#define PROC_NODE_FIRMWARE_UPDATE             "update"
+#define PROC_NODE_CUSTOMER_FIRMWARE_VERSION   "version"
+#define PROC_NODE_PLATFORM_FIRMWARE_VERSION   "platform_version"
+#define PROC_NODE_DEVICE_DRIVER_VERSION       "driver_version"
+#define PROC_NODE_SD_CARD_FIRMWARE_UPDATE     "sdcard_update"
+#define PROC_NODE_FIRMWARE_DEBUG              "debug"
+#define PROC_NODE_FIRMWARE_SET_DEBUG_VALUE    "set_debug_value"
+#define PROC_NODE_FIRMWARE_SMBUS_DEBUG        "smbus_debug"
+
+#define PROC_NODE_FIRMWARE_SET_DQMEM_VALUE    "set_dqmem_value"
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+#define PROC_NODE_MP_TEST                     "test"
+#define PROC_NODE_MP_TEST_LOG                 "test_log"
+#define PROC_NODE_MP_TEST_FAIL_CHANNEL        "test_fail_channel"
+#define PROC_NODE_MP_TEST_SCOPE               "test_scope"
+#endif
+
+#define PROC_NODE_FIRMWARE_MODE               "mode"
+#define PROC_NODE_FIRMWARE_SENSOR             "sensor"
+#define PROC_NODE_FIRMWARE_PACKET_HEADER      "header"
+
+#define PROC_NODE_QUERY_FEATURE_SUPPORT_STATUS   "query_feature_support_status"
+#define PROC_NODE_CHANGE_FEATURE_SUPPORT_STATUS  "change_feature_support_status"
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#define PROC_NODE_GESTURE_WAKEUP_MODE         "gesture_wakeup_mode"
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+#define PROC_NODE_GESTURE_DEBUG_MODE          "gesture_debug"
+#endif
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+#define PROC_NODE_GESTURE_INFORMATION_MODE    "gesture_infor"
+#endif
+#endif
+
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+#define PROC_NODE_REPORT_RATE                 "report_rate"
+#endif
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+#define PROC_NODE_GLOVE_MODE                  "glove_mode"
+#define PROC_NODE_OPEN_GLOVE_MODE             "open_glove_mode"
+#define PROC_NODE_CLOSE_GLOVE_MODE            "close_glove_mode"
+#endif
+
+#ifdef CONFIG_ENABLE_JNI_INTERFACE
+#define PROC_NODE_JNI_NODE                    "msgtool"
+#endif
+
+#define PROC_NODE_SELINUX_LIMIT_FIRMWARE_UPDATE     "selinux_limit_update"
+
+extern struct mutex g_Mutex;
+extern struct input_dev *g_InputDevice;
+
+extern struct i2c_client *g_I2cClient;
+
+extern struct FirmwareInfo_t g_FirmwareInfo;
+extern u8 g_LogModePacket[DEBUG_MODE_PACKET_LENGTH];
+extern u16 g_FirmwareMode;
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern u32 g_GestureWakeupMode[2];
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+extern u8 g_LogGestureDebug[128];
+extern u8 g_GestureDebugFlag;
+extern u8 g_GestureDebugMode;
+
+extern struct input_dev *g_InputDevice;
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+extern u32
+	g_LogGestureInfor[GESTURE_WAKEUP_INFORMATION_PACKET_LENGTH];
+#endif
+#endif
+
+extern u8 g_ChipType;
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+extern TestScopeInfo_t g_TestScopeInfo;
+#endif
+
+extern ssize_t DrvMainProcfsChipTypeRead(struct file *pFile, char __user
+	*pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsChipTypeWrite(struct file *pFile, const char __user
+	*pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareDataRead(struct file *pFile, char __user
+	*pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareDataWrite(struct file *pFile, const char
+	__user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareUpdateRead(struct file *pFile, char __user
+	*pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareUpdateWrite(struct file *pFile, const char
+__user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsCustomerFirmwareVersionRead(struct file *pFile,
+	char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsCustomerFirmwareVersionWrite(struct file *pFile,
+	const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsPlatformFirmwareVersionRead(struct file *pFile,
+	char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsPlatformFirmwareVersionWrite(struct file *pFile,
+	const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsDeviceDriverVersionRead(struct file *pFile, char
+	__user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsDeviceDriverVersionWrite(struct file *pFile, const
+	char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsSdCardFirmwareUpdateRead(struct file *pFile, char
+	__user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsSdCardFirmwareUpdateWrite(struct file *pFile, const
+	char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareDebugRead(struct file *pFile, char __user
+	*pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareDebugWrite(struct file *pFile, const char
+	__user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareSetDebugValueRead(struct file *pFile, char
+	__user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareSetDebugValueWrite(struct file *pFile,
+	const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareSmBusDebugRead(struct file *pFile, char
+	__user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareSmBusDebugWrite(struct file *pFile, const
+	char __user *pBuffer, size_t nCount, loff_t *pPos);
+
+extern ssize_t DrvMainProcfsFirmwareSetDQMemValueRead(struct file *pFile, char
+	__user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareSetDQMemValueWrite(struct file *pFile,
+	const char __user *pBuffer, size_t nCount, loff_t *pPos);
+
+#ifdef CONFIG_ENABLE_ITO_MP_TEST
+extern ssize_t DrvMainProcfsMpTestRead(struct file *pFile, char __user
+	*pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsMpTestWrite(struct file *pFile, const char __user
+	*pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsMpTestLogRead(struct file *pFile, char __user
+	*pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsMpTestLogWrite(struct file *pFile, const char
+	__user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsMpTestFailChannelRead(struct file *pFile, char
+	__user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsMpTestFailChannelWrite(struct file *pFile, const
+	char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsMpTestScopeRead(struct file *pFile, char __user
+	*pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsMpTestScopeWrite(struct file *pFile, const char
+	__user *pBuffer, size_t nCount, loff_t *pPos);
+#endif
+
+extern ssize_t DrvMainProcfsFirmwareModeRead(struct file *pFile, char __user
+	*pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareModeWrite(struct file *pFile, const char
+	__user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareSensorRead(struct file *pFile, char __user
+	*pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwareSensorWrite(struct file *pFile, const char
+	__user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwarePacketHeaderRead(struct file *pFile, char
+	__user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsFirmwarePacketHeaderWrite(struct file *pFile, const
+	char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainKObjectPacketShow(struct kobject *pKObj, struct
+	kobj_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainKObjectPacketStore(struct kobject *pKObj, struct
+	kobj_attribute *pAttr, const char *pBuf, size_t nCount);
+
+extern ssize_t DrvMainProcfsQueryFeatureSupportStatusRead(struct file *pFile,
+	char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsQueryFeatureSupportStatusWrite(struct file *pFile,
+	const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsChangeFeatureSupportStatusRead(struct file *pFile,
+	char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsChangeFeatureSupportStatusWrite(struct file *pFile,
+	const char __user *pBuffer, size_t nCount, loff_t *pPos);
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern ssize_t DrvMainProcfsGestureWakeupModeRead(struct file *pFile, char
+	__user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsGestureWakeupModeWrite(struct file *pFile, const
+	char __user *pBuffer, size_t nCount, loff_t *pPos);
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+extern ssize_t DrvMainProcfsGestureDebugModeRead(struct file *pFile, char
+	__user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsGestureDebugModeWrite(struct file *pFile, const
+	char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainKObjectGestureDebugShow(struct kobject *pKObj, struct
+	kobj_attribute *pAttr, char *pBuf);
+extern ssize_t DrvMainKObjectGestureDebugStore(struct kobject *pKObj, struct
+	kobj_attribute *pAttr, const char *pBuf, size_t nCount);
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+extern ssize_t DrvMainProcfsGestureInforModeRead(struct file *pFile, char
+__user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsGestureInforModeWrite(struct file *pFile, const
+char __user *pBuffer, size_t nCount, loff_t *pPos);
+#endif
+#endif
+
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+extern ssize_t DrvMainProcfsReportRateRead(struct file *pFile,
+			char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsReportRateWrite(struct file *pFile,
+	const char __user *pBuffer, size_t nCount, loff_t *pPos);
+#endif
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+extern ssize_t DrvMainProcfsGloveModeRead(struct file *pFile,
+	char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsGloveModeWrite(struct file *pFile,
+	const char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsOpenGloveModeRead(struct file *pFile,
+			char __user *pBuffer, size_t nCount, loff_t *pPos);
+extern ssize_t DrvMainProcfsCloseGloveModeRead(struct file *pFile,
+			char __user *pBuffer, size_t nCount, loff_t *pPos);
+#endif
+
+extern ssize_t DrvMainProcfsSeLinuxLimitFirmwareUpdateRead(struct file *pFile,
+char __user *pBuffer, size_t nCount, loff_t *pPos);
+
+extern s32 DrvMainTouchDeviceInitialize(void);
+extern void DrvMainRemoveProcfsDirEntry(void);
+
+#endif  /* __MSTAR_DRV_MAIN_H__ */
diff --git a/drivers/input/touchscreen/msg28xx/mstar_drv_mutual_fw_control.c b/drivers/input/touchscreen/msg28xx/mstar_drv_mutual_fw_control.c
new file mode 100644
index 0000000..1ba7f64
--- /dev/null
+++ b/drivers/input/touchscreen/msg28xx/mstar_drv_mutual_fw_control.c
@@ -0,0 +1,5287 @@
+/********************************************************************
+//
+// Copyright (c) 2006-2016 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses,
+// costs and expenses resulting therefrom.
+//
+*************************************************************************/
+/**
+ *
+ * @file	mstar_drv_mutual_fw_control.c
+ *
+ * @brief	This file defines the interface of touch screen
+ *
+ *
+ */
+
+
+#include "mstar_drv_mutual_fw_control.h"
+#include "mstar_drv_utility_adaption.h"
+#include "mstar_drv_platform_porting_layer.h"
+#include <linux/errno.h>
+
+
+static u8 _gOneDimenFwData[MSG28XX_FIRMWARE_WHOLE_SIZE*1024] = {0};
+
+static u8 _gFwDataBuf[MSG28XX_FIRMWARE_WHOLE_SIZE*1024] = {0};
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+#include "msg28xx_xxxx_update_bin.h"
+#include "msg28xx_yyyy_update_bin.h"
+
+static u32 _gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+static u32 _gIsUpdateInfoBlockFirst;
+static struct work_struct _gUpdateFirmwareBySwIdWork;
+static struct workqueue_struct *_gUpdateFirmwareBySwIdWorkQueue;
+static u8 _gTempData[1024];
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+static u32 _gGestureWakeupValue[2] = {0};
+#endif
+
+#ifdef CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+static u8 _gTouchPacketFlag[2] = {0};
+#endif
+
+#ifdef CONFIG_ENABLE_CHARGER_DETECTION
+static u8 _gChargerPlugIn;
+#endif
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+static u8 _gPreviousTouch[MAX_TOUCH_NUM] = {0};
+static u8 _gCurrentTouch[MAX_TOUCH_NUM] = {0};
+#endif
+
+static u8 _gIsDisableFinagerTouch;
+
+static u16 _gSFR_ADDR3_BYTE0_1_VALUE = 0x0000;
+static u16 _gSFR_ADDR3_BYTE2_3_VALUE = 0x0000;
+u8 g_ChipType = 0;
+u8 g_DemoModePacket[DEMO_MODE_PACKET_LENGTH] = {0};
+
+
+struct FirmwareInfo_t g_FirmwareInfo;
+u8 g_LogModePacket[DEBUG_MODE_PACKET_LENGTH] = {0};
+u16 g_FirmwareMode;
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+
+#if defined(CONFIG_ENABLE_GESTURE_DEBUG_MODE)
+u8 _gGestureWakeupPacket[GESTURE_DEBUG_MODE_PACKET_LENGTH] = {0};
+#elif defined(CONFIG_ENABLE_GESTURE_INFORMATION_MODE)
+u8
+_gGestureWakeupPacket[GESTURE_WAKEUP_INFORMATION_PACKET_LENGTH] = {0};
+#else
+u8
+_gGestureWakeupPacket[GESTURE_WAKEUP_PACKET_LENGTH] = {0};
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+u8 g_GestureDebugFlag = 0x00;
+u8 g_GestureDebugMode = 0x00;
+u8 g_LogGestureDebug[GESTURE_DEBUG_MODE_PACKET_LENGTH] = {0};
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+u32 g_LogGestureInfor[GESTURE_WAKEUP_INFORMATION_PACKET_LENGTH] = {0};
+#endif
+
+#ifdef CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE
+u32 g_GestureWakeupMode[2] = {0xFFFFFFFF, 0xFFFFFFFF};
+#else
+u32 g_GestureWakeupMode[2] = {0x0000FFFF, 0x00000000};
+#endif
+
+u8 g_GestureWakeupFlag = 0;
+#endif
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+u8 g_EnableTpProximity = 0;
+
+u8 g_FaceClosingTp = 0;
+
+#endif
+
+#ifdef CONFIG_ENABLE_CHARGER_DETECTION
+u8 g_ForceUpdate = 0;
+#endif
+
+u8 g_IsUpdateFirmware = 0x00;
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+static void
+_DrvFwCtrlUpdateFirmwareBySwIdDoWork(struct work_struct *pWork);
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+static void
+_DrvFwCtrlCoordinate(u8 *pRawData, u32 *pTranX, u32 *pTranY);
+#endif
+#endif
+
+
+static s32
+_DrvFwCtrlParsePacket(
+u8 *pPacket, u16 nLength, struct TouchInfo_t *pInfo)
+{
+	u32 i;
+	u8 nCheckSum = 0;
+	u32 nX = 0, nY = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+	if (g_IsEnableReportRate == 1) {
+		if (g_InterruptCount == 4294967296) {
+			g_InterruptCount = 0;
+			DBG("g_InterruptCount reset to 0\n");
+		}
+
+		if (g_InterruptCount == 0)
+			do_gettimeofday(&g_StartTime);
+
+
+		g_InterruptCount++;
+
+		DBG("g_InterruptCount = %d\n", g_InterruptCount);
+	}
+#endif
+
+	nCheckSum = DrvCommonCalculateCheckSum(&pPacket[0],
+	(nLength-1));
+	if (pPacket[nLength-1] != nCheckSum) {
+		DBG("WRONG CHECKSUM\n");
+		return -EINVAL;
+	}
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+	if (g_GestureWakeupFlag == 1) {
+		u8 nWakeupMode = 0;
+		u8 bIsCorrectFormat = 0;
+
+		if (pPacket[0] == 0xA7 && pPacket[1] ==
+			0x00 && pPacket[2] == 0x06 &&
+			pPacket[3] == PACKET_TYPE_GESTURE_WAKEUP) {
+			nWakeupMode = pPacket[4];
+			bIsCorrectFormat = 1;
+		}
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+		else if (pPacket[0] ==
+			0xA7 && pPacket[1] ==
+			0x00 && pPacket[2] == 0x80
+			&& pPacket[3] == PACKET_TYPE_GESTURE_DEBUG)	{
+			u32 a = 0;
+
+			nWakeupMode = pPacket[4];
+			bIsCorrectFormat = 1;
+
+			for (a = 0; a < 0x80; a++)
+				g_LogGestureDebug[a] = pPacket[a];
+
+
+			if (!(pPacket[5] >> 7)) {
+				nWakeupMode = 0xFE;
+				DBG("gesture debug mode LCM flag = 0\n");
+			}
+		}
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+		else if (pPacket[0] == 0xA7 && pPacket[1]
+			== 0x00 && pPacket[2] == 0x80
+			&& pPacket[3] == PACKET_TYPE_GESTURE_INFORMATION) {
+			u32 a = 0;
+			u32 nTmpCount = 0;
+
+			nWakeupMode = pPacket[4];
+			bIsCorrectFormat = 1;
+
+			for (a = 0; a < 6; a++) {
+				g_LogGestureInfor[nTmpCount] = pPacket[a];
+				nTmpCount++;
+			}
+
+			for (a = 6; a < 126; a = a+3) {
+				u32 nTranX = 0;
+				u32 nTranY = 0;
+
+				_DrvFwCtrlCoordinate(&pPacket[a],
+					&nTranX, &nTranY);
+				g_LogGestureInfor[nTmpCount] = nTranX;
+				nTmpCount++;
+				g_LogGestureInfor[nTmpCount] = nTranY;
+				nTmpCount++;
+			}
+
+			g_LogGestureInfor[nTmpCount] = pPacket[126];
+			nTmpCount++;
+			g_LogGestureInfor[nTmpCount] = pPacket[127];
+			nTmpCount++;
+		}
+#endif
+
+		if (bIsCorrectFormat) {
+			DBG("nWakeupMode = 0x%x\n", nWakeupMode);
+
+			switch (nWakeupMode) {
+			case 0x58:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_DOUBLE_CLICK_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x60:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_UP_DIRECT_FLAG;
+
+					input_report_key(
+					g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+					g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x61:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_DOWN_DIRECT_FLAG;
+
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x62:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_LEFT_DIRECT_FLAG;
+
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x63:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_RIGHT_DIRECT_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x64:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_m_CHARACTER_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x65:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_W_CHARACTER_FLAG;
+
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x66:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_C_CHARACTER_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x67:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_e_CHARACTER_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x68:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_V_CHARACTER_FLAG;
+
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x69:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_O_CHARACTER_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x6A:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_S_CHARACTER_FLAG;
+
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x6B:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_Z_CHARACTER_FLAG;
+
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x6C:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_RESERVE1_FLAG;
+
+
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x6D:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_RESERVE2_FLAG;
+
+
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x6E:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_RESERVE3_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+#ifdef CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE
+			case 0x6F:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_RESERVE4_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x70:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_RESERVE5_FLAG;
+
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x71:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_RESERVE6_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x72:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_RESERVE7_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x73:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_RESERVE8_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x74:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_RESERVE9_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x75:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_RESERVE10_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x76:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_RESERVE11_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x77:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_RESERVE12_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x78:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_RESERVE13_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x79:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_RESERVE14_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x7A:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_RESERVE15_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x7B:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_RESERVE16_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x7C:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_RESERVE17_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x7D:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_RESERVE18_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x7E:
+					_gGestureWakeupValue[0] =
+					GESTURE_WAKEUP_MODE_RESERVE19_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x7F:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE20_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x80:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE21_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x81:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE22_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x82:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE23_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x83:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE24_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x84:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE25_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x85:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE26_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x86:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE27_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x87:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE28_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x88:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE29_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x89:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE30_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x8A:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE31_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x8B:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE32_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x8C:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE33_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x8D:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE34_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x8E:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE35_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x8F:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE36_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x90:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE37_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x91:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE38_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x92:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE39_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x93:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE40_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x94:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE41_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x95:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE42_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x96:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE43_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x97:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE44_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x98:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE45_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x99:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE46_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x9A:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE47_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x9B:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE48_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x9C:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE49_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x9D:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE50_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+			case 0x9E:
+					_gGestureWakeupValue[1] =
+					GESTURE_WAKEUP_MODE_RESERVE51_FLAG;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+			case 0xFF:
+					_gGestureWakeupValue[1] = 0xFF;
+
+					input_report_key(
+						g_InputDevice, KEY_POWER, 1);
+					input_sync(g_InputDevice);
+					input_report_key(
+						g_InputDevice, KEY_POWER, 0);
+					input_sync(g_InputDevice);
+					break;
+#endif
+
+			default:
+					_gGestureWakeupValue[0] = 0;
+					_gGestureWakeupValue[1] = 0;
+
+					break;
+			}
+
+
+		}
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+		if (g_GestureKObj != NULL && pPacket[3] ==
+			PACKET_TYPE_GESTURE_DEBUG) {
+			char *pEnvp[2];
+			s32 nRetVal = 0;
+
+			pEnvp[0] = "STATUS=GET_GESTURE_DEBUG";
+			pEnvp[1] = NULL;
+
+			nRetVal = kobject_uevent_env(g_GestureKObj,
+				KOBJ_CHANGE, pEnvp);
+
+		}
+#endif
+
+		return -EINVAL;
+	}
+#endif
+
+
+	if (IS_FIRMWARE_DATA_LOG_ENABLED) {
+		if (g_FirmwareMode == FIRMWARE_MODE_DEMO_MODE &&
+			pPacket[0] != 0x5A) {
+
+				DBG("WRONG DEMO MODE HEADER\n");
+				return -EINVAL;
+
+		} else if (g_FirmwareMode ==
+			FIRMWARE_MODE_DEBUG_MODE && pPacket[0] !=
+				0xA5 && pPacket[0] != 0xAB && (pPacket[0] !=
+				0xA7 && pPacket[3]
+				!= PACKET_TYPE_TOOTH_PATTERN)) {
+			DBG("WRONG DEBUG MODE HEADER\n");
+			return -EINVAL;
+		}
+	} else {
+		if (pPacket[0] != 0x5A) {
+				DBG("WRONG DEMO MODE HEADER\n");
+				return -EINVAL;
+		}
+	}
+
+	if (pPacket[0] == 0x5A) {
+		for (i = 0; i < MAX_TOUCH_NUM; i++) {
+			if ((pPacket[(4 * i) + 1] == 0xFF) &&
+					(pPacket[(4 * i) + 2] == 0xFF) &&
+					(pPacket[(4 * i) + 3] == 0xFF)) {
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+					_gCurrentTouch[i] = 0;
+#endif
+
+					continue;
+				}
+
+				nX = (((pPacket[(4*i)+1] & 0xF0) << 4) |
+					(pPacket[(4*i)+2]));
+				nY = (((pPacket[(4*i)+1] & 0x0F) << 8) |
+					(pPacket[(4*i)+3]));
+
+				pInfo->tPoint[pInfo->nCount].nX =
+					nX * TOUCH_SCREEN_X_MAX / TPD_WIDTH;
+				pInfo->tPoint[pInfo->nCount].nY =
+					nY * TOUCH_SCREEN_Y_MAX / TPD_HEIGHT;
+				pInfo->tPoint[pInfo->nCount].nP =
+					pPacket[4*(i+1)];
+				pInfo->tPoint[pInfo->nCount].nId = i;
+
+				DBG("[x,y]=[%d,%d]\n", nX, nY);
+
+				pInfo->nCount++;
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+				_gCurrentTouch[i] = 1;
+#endif
+			}
+
+	} else if (pPacket[0] == 0xA5 || pPacket[0] == 0xAB) {
+		for (i = 0; i < MAX_TOUCH_NUM; i++) {
+			if ((pPacket[(3 * i) + 4] == 0xFF) &&
+				(pPacket[(3 * i) + 5] == 0xFF) &&
+				(pPacket[(3 * i) + 6] == 0xFF)) {
+		#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+				_gCurrentTouch[i] = 0;
+#endif
+
+				continue;
+			}
+
+			nX = (((pPacket[(3 * i) + 4] & 0xF0) << 4) |
+				(pPacket[(3 * i) + 5]));
+			nY = (((pPacket[(3 * i) + 4] & 0x0F) << 8) |
+				(pPacket[(3 * i) + 6]));
+
+			pInfo->tPoint[pInfo->nCount].nX =
+				nX * TOUCH_SCREEN_X_MAX / TPD_WIDTH;
+			pInfo->tPoint[pInfo->nCount].nY =
+				nY * TOUCH_SCREEN_Y_MAX / TPD_HEIGHT;
+			pInfo->tPoint[pInfo->nCount].nP = 1;
+			pInfo->tPoint[pInfo->nCount].nId = i;
+
+			DBG("[x,y]=[%d,%d]\n", nX, nY);
+
+			pInfo->nCount++;
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+			_gCurrentTouch[i] = 1;
+#endif
+		}
+
+		if (g_TouchKObj != NULL) {
+			char *pEnvp[2];
+			s32 nRetVal = 0;
+
+			pEnvp[0] = "STATUS=GET_DEBUG_MODE_PACKET";
+			pEnvp[1] = NULL;
+
+			nRetVal =
+				kobject_uevent_env(g_TouchKObj,
+				KOBJ_CHANGE, pEnvp);
+			DBG("kobject_uevent_env() nRetVal = %d\n", nRetVal);
+		}
+	} else if (pPacket[0] ==
+			0xA7 && pPacket[3] ==
+			PACKET_TYPE_TOOTH_PATTERN) {
+		for (i = 0; i < MAX_TOUCH_NUM; i++) {
+			if ((pPacket[(3*i)+5] == 0xFF) &&
+				(pPacket[(3*i)+6] == 0xFF) &&
+						(pPacket[(3*i)+7] == 0xFF)) {
+		#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+				_gCurrentTouch[i] = 0;
+#endif
+
+				continue;
+			}
+
+			nX = (((pPacket[(3*i)+5] & 0xF0) << 4) |
+				(pPacket[(3*i)+6]));
+			nY = (((pPacket[(3*i)+5] & 0x0F) << 8) |
+				(pPacket[(3*i)+7]));
+
+			pInfo->tPoint[pInfo->nCount].nX =
+				nX * TOUCH_SCREEN_X_MAX / TPD_WIDTH;
+			pInfo->tPoint[pInfo->nCount].nY =
+				nY * TOUCH_SCREEN_Y_MAX / TPD_HEIGHT;
+			pInfo->tPoint[pInfo->nCount].nP = 1;
+			pInfo->tPoint[pInfo->nCount].nId = i;
+
+			DBG("[x,y]=[%d,%d]\n", nX, nY);
+
+			pInfo->nCount++;
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+			_gCurrentTouch[i] = 1;
+#endif
+		}
+
+		if (g_TouchKObj != NULL) {
+			char *pEnvp[2];
+			s32 nRetVal = 0;
+
+			pEnvp[0] = "STATUS=GET_DEBUG_MODE_PACKET";
+			pEnvp[1] = NULL;
+
+			nRetVal =
+				kobject_uevent_env(g_TouchKObj,
+				KOBJ_CHANGE, pEnvp);
+			DBG("kobject_uevent_env() nRetVal = %d\n", nRetVal);
+		}
+	}
+
+
+#ifdef CONFIG_TP_HAVE_KEY
+	if (pPacket[0] == 0x5A) {
+		u8 nButton = pPacket[nLength-2];
+
+		if (nButton != 0xFF) {
+			DBG("button = %x\n", nButton);
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+		if (g_EnableTpProximity && ((pPacket[nLength-2] == 0x80) ||
+					(pPacket[nLength-2] == 0x40))) {
+				if (pPacket[nLength-2] == 0x80) {
+					g_FaceClosingTp = 1;
+
+					input_report_abs(g_ProximityInputDevice,
+						ABS_DISTANCE, 0);
+					input_sync(g_ProximityInputDevice);
+				} else if (pPacket[nLength-2] == 0x40) {
+					g_FaceClosingTp = 0;
+
+					input_report_abs(g_ProximityInputDevice,
+						ABS_DISTANCE, 1);
+					input_sync(g_ProximityInputDevice);
+				}
+
+
+				return -EINVAL;
+			}
+
+#endif
+
+			for (i = 0; i < MAX_KEY_NUM; i++) {
+				if ((nButton & (1 << i)) == (1 << i)) {
+					if (pInfo->nKeyCode == 0)
+						pInfo->nKeyCode = i;
+					else
+						pInfo->nKeyCode = 0xFF;
+				}
+			}
+		} else
+			pInfo->nKeyCode = 0xFF;
+	} else if (pPacket[0] == 0xA5 ||
+				pPacket[0] == 0xAB ||
+				(pPacket[0] == 0xA7
+				&& pPacket[3] == PACKET_TYPE_TOOTH_PATTERN)) {
+
+		if (pPacket[0] == 0xAB ||
+			(pPacket[0] == 0xA7 &&
+			pPacket[3] == PACKET_TYPE_TOOTH_PATTERN)) {
+			u8 nButton = 0xFF;
+
+			if (pPacket[0] == 0xAB)
+				nButton = pPacket[3];
+			else if (pPacket[0] == 0xA7 &&
+				pPacket[3] == PACKET_TYPE_TOOTH_PATTERN)
+				nButton = pPacket[4];
+
+		if (nButton != 0xFF) {
+			for (i = 0; i < MAX_KEY_NUM; i++) {
+				if ((nButton & (1<<i)) == (1<<i)) {
+					if (pInfo->nKeyCode == 0)
+						pInfo->nKeyCode = i;
+					else
+						pInfo->nKeyCode = 0xFF;
+					}
+				}
+			} else
+				pInfo->nKeyCode = 0xFF;
+		}
+	}
+#endif
+
+	return 0;
+}
+
+static void
+	_DrvFwCtrlStoreFirmwareData(u8 *pBuf, u32 nSize)
+{
+	u32 nCount = nSize / 1024;
+	u32 nRemainder = nSize % 1024;
+	u32 i;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (nCount > 0) {
+		for (i = 0; i < nCount; i++) {
+			memcpy(g_FwData[g_FwDataCount],
+				pBuf + (i * 1024), 1024);
+
+			g_FwDataCount++;
+		}
+
+		if (nRemainder > 0) {
+			DBG("nRemainder = %d\n", nRemainder);
+
+			memcpy(g_FwData[g_FwDataCount],
+				pBuf + (i * 1024), nRemainder);
+
+			g_FwDataCount++;
+		}
+	} else {
+		if (nSize > 0) {
+			memcpy(g_FwData[g_FwDataCount], pBuf, nSize);
+
+			g_FwDataCount++;
+		}
+	}
+
+	DBG("*** g_FwDataCount = %d ***\n", g_FwDataCount);
+
+}
+/*
+static u16 _DrvFwCtrlMsg26xxmGetSwId(EmemType_e eEmemType)
+{
+	u16 nRetVal = 0;
+	u16 nRegData = 0;
+	u8 szDbBusTxData[5] = {0};
+	u8 szDbBusRxData[4] = {0};
+
+	DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+	DbBusEnterSerialDebugMode();
+	DbBusStopMCU();
+	DbBusIICUseBus();
+	DbBusIICReshape();
+	mdelay(100);
+
+	RegSetLByteValue(0x0FE6, 0x01);
+
+	RegSet16BitValue(0x3C60, 0xAA55);
+
+	RegSet16BitValue(0x3CE4, 0xA4AB);
+
+	RegSet16BitValue(0x1E04, 0x7d60);
+	RegSet16BitValue(0x1E04, 0x829F);
+
+	RegSetLByteValue(0x0FE6, 0x00);
+
+	mdelay(100);
+
+	do {
+		nRegData = RegGet16BitValue(0x3CE4);
+	} while (nRegData != 0x5B58);
+
+	szDbBusTxData[0] = 0x72;
+	if (eEmemType == EMEM_MAIN) {
+		szDbBusTxData[1] = 0x00;
+		szDbBusTxData[2] = 0x2A;
+	} else if (eEmemType == EMEM_INFO) {
+		szDbBusTxData[1] = 0x80;
+		szDbBusTxData[2] = 0x04;
+	}
+	szDbBusTxData[3] = 0x00;
+	szDbBusTxData[4] = 0x04;
+
+	IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 5);
+	IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 4);
+
+
+	nRetVal = szDbBusRxData[1];
+	nRetVal = (nRetVal << 8) | szDbBusRxData[0];
+
+	DBG("SW ID = 0x%x\n", nRetVal);
+
+	DbBusIICNotUseBus();
+	DbBusNotStopMCU();
+	DbBusExitSerialDebugMode();
+
+	return nRetVal;
+}
+
+static s32
+_DrvFwCtrlMsg26xxmUpdateFirmware(u8 szFwData[][1024],
+EmemType_e eEmemType)
+{
+	u32 i, j;
+	u32 nCrcMain, nCrcMainTp;
+	u32 nCrcInfo, nCrcInfoTp;
+	u16 nRegData = 0;
+
+	nCrcMain = 0xffffffff;
+	nCrcInfo = 0xffffffff;
+
+	DBG("erase 0\n");
+
+	DrvPlatformLyrTouchDeviceResetHw();
+
+	DbBusEnterSerialDebugMode();
+	DbBusStopMCU();
+	DbBusIICUseBus();
+	DbBusIICReshape();
+	mdelay(100);
+
+	DBG("erase 1\n");
+
+	RegSetLByteValue(0x0FE6, 0x01);
+
+	RegSet16BitValue(0x3C60, 0xAA55);
+
+	RegSet16BitValue(0x161A, 0xABBA);
+
+	RegSetLByteValue(0x1618, 0x80);
+	DBG("erase 2\n");
+	RegSetLByteValue(0x1618, 0x40);
+
+	mdelay(10);
+
+	RegSetLByteValue(0x1618, 0x80);
+	DBG("erase 3\n");
+	if (eEmemType == EMEM_ALL)
+		RegSetLByteValue(0x160E, 0x08);
+	else
+		RegSetLByteValue(0x160E, 0x04);
+	DbBusIICNotUseBus();
+	DbBusNotStopMCU();
+	DbBusExitSerialDebugMode();
+
+	mdelay(1000);
+	DBG("erase OK\n");
+
+	DBG("program 0\n");
+
+	DrvPlatformLyrTouchDeviceResetHw();
+
+	DbBusEnterSerialDebugMode();
+	DbBusStopMCU();
+	DbBusIICUseBus();
+	DbBusIICReshape();
+	mdelay(100);
+
+	DBG("program 1\n");
+
+	do {
+		nRegData = RegGet16BitValue(0x3CE4);
+
+	} while (nRegData != 0x1C70);
+
+	DBG("program 2\n");
+
+	RegSet16BitValue(0x3CE4, 0xE38F);
+	mdelay(100);
+
+	do {
+		nRegData = RegGet16BitValue(0x3CE4);
+	} while (nRegData != 0x2F43);
+
+	DBG("program 3\n");
+
+	DrvCommonCrcInitTable();
+
+	for (i = 0; i <
+		MSG26XXM_FIRMWARE_WHOLE_SIZE; i ++) {
+		if (i > 31) {
+			for (j = 0; j < 1024; j ++)
+				nCrcInfo =
+				DrvCommonCrcGetValue(szFwData[i][j], nCrcInfo);
+		} else if (i < 31) {
+			for (j = 0; j < 1024; j ++)
+				nCrcMain =
+				DrvCommonCrcGetValue(szFwData[i][j], nCrcMain);
+		} else {
+			szFwData[i][1014] = 0x5A;
+			szFwData[i][1015] = 0xA5;
+
+			for (j = 0; j < 1016; j++)
+
+				nCrcMain =
+				DrvCommonCrcGetValue(szFwData[i][j], nCrcMain);
+
+		}
+
+		for (j = 0; j < 8; j++)
+			IicWriteData(SLAVE_I2C_ID_DWI2C,
+			&szFwData[i][j*128], 128);
+		mdelay(100);
+
+		do {
+			nRegData = RegGet16BitValue(0x3CE4);
+		} while (nRegData != 0xD0BC);
+
+		RegSet16BitValue(0x3CE4, 0x2F43);
+	}
+
+	DBG("program 4\n");
+
+	RegSet16BitValue(0x3CE4, 0x1380);
+	mdelay(100);
+
+	DBG("program 5\n");
+
+	do	{
+	   nRegData = RegGet16BitValue(0x3CE4);
+	} while (nRegData != 0x9432);
+
+	DBG("program 6\n");
+
+	nCrcMain = nCrcMain ^ 0xffffffff;
+	nCrcInfo = nCrcInfo ^ 0xffffffff;
+
+	nCrcMainTp = RegGet16BitValue(0x3C80);
+	nCrcMainTp = (nCrcMainTp << 16) | RegGet16BitValue(0x3C82);
+	nCrcInfoTp = RegGet16BitValue(0x3CA0);
+	nCrcInfoTp = (nCrcInfoTp << 16) | RegGet16BitValue(0x3CA2);
+
+	g_FwDataCount = 0;
+
+	DbBusIICNotUseBus();
+	DbBusNotStopMCU();
+	DbBusExitSerialDebugMode();
+
+	DrvPlatformLyrTouchDeviceResetHw();
+	mdelay(300);
+
+	if ((nCrcMainTp != nCrcMain) || (nCrcInfoTp != nCrcInfo)) {
+		DBG("Update FAILED\n");
+
+		return -1;
+	}
+
+	DBG("Update SUCCESS\n");
+
+	return 0;
+}*/
+
+static void
+_DrvFwCtrlMsg28xxConvertFwDataTwoDimenToOneDimen(u8
+			szTwoDimenFwData[][1024], u8 *pOneDimenFwData)
+{
+	u32 i, j;
+
+	DBG("*** %s() ***\n", __func__);
+
+	for (i = 0; i < MSG28XX_FIRMWARE_WHOLE_SIZE;
+		i++) {
+		for (j = 0; j < 1024; j++)
+			pOneDimenFwData[i*1024+j] = szTwoDimenFwData[i][j];
+	}
+}
+
+static u32
+	_DrvFwCtrlMsg28xxCalculateCrc(
+	u8 *pFwData, u32 nOffset, u32 nSize)
+{
+	u32 i;
+	u32 nData = 0, nCrc = 0;
+	u32 nCrcRule = 0x0C470C06;
+
+	for (i = 0; i < nSize; i += 4) {
+		nData =
+			(pFwData[nOffset+i]) | (pFwData[nOffset+i+1] << 8) |
+			(pFwData[nOffset+i+2] << 16) |
+			(pFwData[nOffset+i+3] << 24);
+		nCrc =
+			(nCrc >> 1) ^ (nCrc << 1) ^ (nCrc & nCrcRule) ^ nData;
+	}
+
+	return nCrc;
+}
+
+static void _DrvFwCtrlMsg28xxAccessEFlashInit(void)
+{
+	RegSetLByteValue(0x3C60, 0x55);
+	RegSetLByteValue(0x3C61, 0xAA);
+
+	RegSetLByteValue(0x1606, 0x20);
+	RegSetLByteValue(0x1608, 0x20);
+
+	RegSet16BitValue(0x1618, 0xA55A);
+}
+
+static void
+	_DrvFwCtrlMsg28xxIspBurstWriteEFlashStart(u16 nStartAddr, u8
+		*pFirstData, u32 nBlockSize, u16 nPageNum,
+		enum EmemType_e eEmemType)
+{
+	u16 nWriteAddr = nStartAddr/4;
+	u8	szDbBusTxData[3] = {0};
+
+
+	RegSetLByteValue(0x1608, 0x20);
+	RegSetLByteValue(0x1606, 0x20);
+
+	RegSet16BitValue(0x1606, 0x0080);
+
+	RegSetLByteValue(0x1640, 0x01);
+
+	if (eEmemType == EMEM_INFO)
+		RegSetLByteValue(0x1607, 0x08);
+
+	RegSetLByteValue(0x1604, 0x01);
+
+	RegSet16BitValue(0x161A, nPageNum);
+
+	RegSetLByteValue(0x1606, 0x81);
+
+	RegSetLByteValue(0x1602, pFirstData[0]);
+	RegSetLByteValue(0x1602, pFirstData[1]);
+	RegSetLByteValue(0x1602, pFirstData[2]);
+	RegSetLByteValue(0x1602, pFirstData[3]);
+
+	RegSet16BitValue(0x1600, nWriteAddr);
+
+	RegSet16BitValue(0x1600, nWriteAddr);
+
+	RegSetLByteValue(0x1608, 0x21);
+
+	szDbBusTxData[0] = 0x10;
+	szDbBusTxData[1] = 0x16;
+	szDbBusTxData[2] = 0x02;
+	IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3);
+
+	szDbBusTxData[0] = 0x20;
+	IicWriteData(SLAVE_I2C_ID_DBBUS,
+		&szDbBusTxData[0], 1);
+}
+
+static void _DrvFwCtrlMsg28xxIspBurstWriteEFlashDoWrite(u8 *pBufferData, u32
+								nLength)
+{
+	u32 i;
+	u8	szDbBusTxData[3 + MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE]
+		= {0};
+
+	DBG("*** %s() nLength = %d ***\n", __func__, nLength);
+
+	szDbBusTxData[0] = 0x10;
+	szDbBusTxData[1] = 0x16;
+	szDbBusTxData[2] = 0x02;
+
+	for (i = 0; i < nLength; i++)
+		szDbBusTxData[3+i] = pBufferData[i];
+	IicWriteData(SLAVE_I2C_ID_DBBUS,
+		&szDbBusTxData[0], 3+nLength);
+}
+
+static void
+	_DrvFwCtrlMsg28xxIspBurstWriteEFlashEnd(void)
+{
+	u8 szDbBusTxData[1] = {0};
+
+	DBG("*** %s() ***\n", __func__);
+
+	szDbBusTxData[0] = 0x21;
+	IicWriteData(SLAVE_I2C_ID_DBBUS,
+		&szDbBusTxData[0], 1);
+
+	szDbBusTxData[0] = 0x7E;
+	IicWriteData(SLAVE_I2C_ID_DBBUS,
+		&szDbBusTxData[0], 1);
+
+	RegSetLByteValue(0x1608, 0x20);
+}
+
+static void _DrvFwCtrlMsg28xxWriteEFlashStart(u16 nStartAddr, u8 *pFirstData,
+					enum EmemType_e eEmemType)
+{
+	u16 nWriteAddr = nStartAddr/4;
+
+	RegSetLByteValue(0x1608, 0x20);
+	RegSetLByteValue(0x1606, 0x20);
+
+	RegSet16BitValue(0x1606, 0x0040);
+
+	RegSetLByteValue(0x1640, 0x01);
+
+	if (eEmemType == EMEM_INFO)
+		RegSetLByteValue(0x1607, 0x08);
+
+	RegSetLByteValue(0x1604, 0x01);
+
+	RegSetLByteValue(0x1606, 0x81);
+
+	RegSetLByteValue(0x1602, pFirstData[0]);
+	RegSetLByteValue(0x1602, pFirstData[1]);
+	RegSetLByteValue(0x1602, pFirstData[2]);
+	RegSetLByteValue(0x1602, pFirstData[3]);
+
+	RegSet16BitValue(0x1600, nWriteAddr);
+
+	RegSet16BitValue(0x1600, nWriteAddr);
+}
+
+static void _DrvFwCtrlMsg28xxWriteEFlashDoWrite(u16 nStartAddr, u8 *pBufferData)
+{
+	u16 nWriteAddr = nStartAddr/4;
+
+	DBG("*** %s() nWriteAddr = %d ***\n", __func__, nWriteAddr);
+
+	RegSetLByteValue(0x1602, pBufferData[0]);
+	RegSetLByteValue(0x1602, pBufferData[1]);
+	RegSetLByteValue(0x1602, pBufferData[2]);
+	RegSetLByteValue(0x1602, pBufferData[3]);
+
+	RegSet16BitValue(0x1600, nWriteAddr);
+}
+
+static void _DrvFwCtrlMsg28xxWriteEFlashEnd(void)
+{
+	DBG("*** %s() ***\n", __func__);
+}
+
+static void
+	_DrvFwCtrlMsg28xxReadEFlashStart(
+	u16 nStartAddr, enum EmemType_e eEmemType)
+{
+	DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+	RegSetLByteValue(0x1608, 0x20);
+	RegSetLByteValue(0x1606, 0x20);
+
+	RegSetLByteValue(0x1606, 0x02);
+
+	RegSet16BitValue(0x1600, nStartAddr);
+
+	if (eEmemType == EMEM_MAIN) {
+		RegSetLByteValue(0x1607, 0x00);
+
+		RegSetLByteValue(0x1604, 0x01);
+
+		RegSet16BitValue(0x1606, 0x0001);
+	} else if (eEmemType == EMEM_INFO) {
+		RegSetLByteValue(0x1607, 0x08);
+
+		RegSetLByteValue(0x1604, 0x01);
+
+		RegSet16BitValue(0x1606, 0x0801);
+	}
+}
+
+static void _DrvFwCtrlMsg28xxReadEFlashDoRead(u16 nReadAddr, u8 *pReadData)
+{
+	u16 nRegData1 = 0, nRegData2 = 0;
+
+	DBG("*** %s() nReadAddr = 0x%x ***\n", __func__, nReadAddr);
+
+	RegSet16BitValue(0x1600, nReadAddr);
+
+	nRegData1 = RegGet16BitValue(0x160A);
+	nRegData2 = RegGet16BitValue(0x160C);
+
+	pReadData[0] = nRegData1 & 0xFF;
+	pReadData[1] = (nRegData1 >> 8) & 0xFF;
+	pReadData[2] = nRegData2 & 0xFF;
+	pReadData[3] = (nRegData2 >> 8) & 0xFF;
+}
+
+static void _DrvFwCtrlMsg28xxReadEFlashEnd(void)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	RegSetLByteValue(0x1606, 0x02);
+
+	RegSetLByteValue(0x1607, 0x00);
+
+	RegSet16BitValue(0x1600, 0x0000);
+}
+
+/*
+static void _DrvFwCtrlMsg28xxGetTpVendorCode(u8 *pTpVendorCode)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	if (g_ChipType == CHIP_TYPE_MSG28XX)
+	{
+		u16 nReadAddr = 0;
+		u8	szTmpData[4] = {0};
+
+		DbBusEnterSerialDebugMode();
+		DbBusStopMCU();
+		DbBusIICUseBus();
+		DbBusIICReshape();
+		mdelay(100);
+
+
+		RegSetLByteValue(0x0FE6, 0x01);
+
+		RegSet16BitValue(0x3C60, 0xAA55);
+
+		_DrvFwCtrlMsg28xxReadEFlashStart(0x81FA, EMEM_INFO);
+		nReadAddr = 0x81FA;
+
+		_DrvFwCtrlMsg28xxReadEFlashDoRead(nReadAddr, &szTmpData[0]);
+
+		_DrvFwCtrlMsg28xxReadEFlashEnd();
+
+		pTpVendorCode[0] = szTmpData[1];
+		pTpVendorCode[1] = szTmpData[2];
+		pTpVendorCode[2] = szTmpData[3];
+
+
+		DbBusIICNotUseBus();
+		DbBusNotStopMCU();
+		DbBusExitSerialDebugMode();
+	}
+}
+*/
+
+static void _DrvFwCtrlMsg28xxGetSfrAddr3Value(void)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	RegSetLByteValue(0x1608, 0x20);
+	RegSetLByteValue(0x1606, 0x20);
+
+	RegSetLByteValue(0x1606, 0x01);
+	RegSetLByteValue(0x1610, 0x01);
+	RegSetLByteValue(0x1607, 0x20);
+
+	RegSetLByteValue(0x1600, 0x03);
+	RegSetLByteValue(0x1601, 0x00);
+
+	_gSFR_ADDR3_BYTE0_1_VALUE = RegGet16BitValue(0x160A);
+	_gSFR_ADDR3_BYTE2_3_VALUE = RegGet16BitValue(0x160C);
+
+}
+
+static void _DrvFwCtrlMsg28xxUnsetProtectBit(void)
+{
+	u8 nB0, nB1, nB2, nB3;
+
+	DBG("*** %s() ***\n", __func__);
+
+	_DrvFwCtrlMsg28xxGetSfrAddr3Value();
+
+	nB0 = _gSFR_ADDR3_BYTE0_1_VALUE & 0xFF;
+	nB1 = (_gSFR_ADDR3_BYTE0_1_VALUE & 0xFF00) >> 8;
+
+	nB2 = _gSFR_ADDR3_BYTE2_3_VALUE & 0xFF;
+	nB3 = (_gSFR_ADDR3_BYTE2_3_VALUE & 0xFF00) >> 8;
+
+
+	nB2 = nB2 & 0xBF;
+	nB3 = nB3 & 0xFC;
+
+
+	RegSetLByteValue(0x1608, 0x20);
+	RegSetLByteValue(0x1606, 0x20);
+	RegSetLByteValue(0x1610, 0x80);
+	RegSetLByteValue(0x1607, 0x10);
+
+	RegSetLByteValue(0x1606, 0x01);
+
+	RegSetLByteValue(0x1602, nB0);
+	RegSetLByteValue(0x1602, nB1);
+	RegSetLByteValue(0x1602, nB2);
+	RegSetLByteValue(0x1602, nB3);
+
+	RegSetLByteValue(0x1600, 0x03);
+	RegSetLByteValue(0x1601, 0x00);
+
+	RegSetLByteValue(0x1607, 0x00);
+}
+
+static void _DrvFwCtrlMsg28xxSetProtectBit(void)
+{
+	u8 nB0, nB1, nB2, nB3;
+
+	DBG("*** %s() ***\n", __func__);
+
+	nB0 = _gSFR_ADDR3_BYTE0_1_VALUE & 0xFF;
+	nB1 = (_gSFR_ADDR3_BYTE0_1_VALUE & 0xFF00) >> 8;
+
+	nB2 = _gSFR_ADDR3_BYTE2_3_VALUE & 0xFF;
+	nB3 = (_gSFR_ADDR3_BYTE2_3_VALUE & 0xFF00) >> 8;
+
+	RegSetLByteValue(0x1608, 0x20);
+	RegSetLByteValue(0x1606, 0x20);
+	RegSetLByteValue(0x1610, 0x80);
+	RegSetLByteValue(0x1607, 0x10);
+
+	RegSetLByteValue(0x1606, 0x01);
+
+	RegSetLByteValue(0x1602, nB0);
+	RegSetLByteValue(0x1602, nB1);
+	RegSetLByteValue(0x1602, nB2);
+	RegSetLByteValue(0x1602, nB3);
+
+	RegSetLByteValue(0x1600, 0x03);
+	RegSetLByteValue(0x1601, 0x00);
+	RegSetLByteValue(0x1606, 0x02);
+}
+
+static void _DrvFwCtrlMsg28xxEraseEmem(enum EmemType_e eEmemType)
+{
+	u32 nInfoAddr = 0x20;
+	u32 nTimeOut = 0;
+	u8 nRegData = 0;
+
+	DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+	DrvPlatformLyrTouchDeviceResetHw();
+
+	DbBusEnterSerialDebugMode();
+	DbBusStopMCU();
+	DbBusIICUseBus();
+	DbBusIICReshape();
+	msleep(100);
+
+	DBG("Erase start\n");
+
+	_DrvFwCtrlMsg28xxAccessEFlashInit();
+
+	RegSetLByteValue(0x0FE6, 0x01);
+
+	RegSet16BitValue(0x1618, 0x5AA5);
+	_DrvFwCtrlMsg28xxUnsetProtectBit();
+
+	if (eEmemType == EMEM_MAIN) {
+		DBG("Erase main block\n");
+
+		RegSetLByteValue(0x1607, 0x00);
+
+		RegSetLByteValue(0x1606, 0xC0);
+
+		RegSetLByteValue(0x1607, 0x03);
+
+		RegSetLByteValue(0x1606, 0xC1);
+
+		nTimeOut = 0;
+		while (1) {
+			nRegData = RegGetLByteValue(0x160E);
+			nRegData = (nRegData & BIT3);
+
+			DBG("Wait erase done flag nRegData = 0x%x\n", nRegData);
+
+			if (nRegData == BIT3)
+				break;
+
+			msleep(20);
+
+			if ((nTimeOut++) > 10) {
+				DBG("Erase main block failed. Timeout.\n");
+
+				goto EraseEnd;
+			}
+		}
+	} else if (eEmemType == EMEM_INFO) {
+		DBG("Erase info block\n");
+
+		RegSetLByteValue(0x1607, 0x08);
+
+		RegSetLByteValue(0x1604, 0x01);
+
+		RegSetLByteValue(0x1606, 0xC0);
+
+		RegSetLByteValue(0x1607, 0x09);
+
+		for (nInfoAddr = 0x20; nInfoAddr <= MSG28XX_EMEM_INFO_MAX_ADDR;
+						nInfoAddr += 0x20) {
+			DBG("nInfoAddr = 0x%x\n", nInfoAddr);
+
+			RegSet16BitValue(0x1600, nInfoAddr);
+
+			RegSetLByteValue(0x1606, 0xC1);
+
+			nTimeOut = 0;
+			while (1) {
+				nRegData = RegGetLByteValue(0x160E);
+				nRegData = (nRegData & BIT3);
+
+				if (nRegData == BIT3)
+					break;
+
+				msleep(20);
+
+				if ((nTimeOut++) > 10) {
+					RegSetLByteValue(0x1607, 0x00);
+
+					goto EraseEnd;
+				}
+			}
+		}
+
+		RegSetLByteValue(0x1607, 0x00);
+	}
+
+EraseEnd:
+
+	_DrvFwCtrlMsg28xxSetProtectBit();
+
+	RegSetLByteValue(0x1606, 0x00);
+	RegSetLByteValue(0x1607, 0x00);
+
+	RegSet16BitValue(0x1618, 0xA55A);
+
+	DBG("Erase end\n");
+
+	DbBusIICNotUseBus();
+	DbBusNotStopMCU();
+	DbBusExitSerialDebugMode();
+}
+
+static void
+	_DrvFwCtrlMsg28xxProgramEmem(enum EmemType_e eEmemType)
+{
+	u32 i, j;
+	u32 nPageNum = 0, nLength = 0, nIndex = 0, nWordNum = 0;
+	u32 nRetryTime = 0;
+	u8	nRegData = 0;
+	u8	szFirstData[MSG28XX_EMEM_SIZE_BYTES_ONE_WORD] = {0};
+	u8	szBufferData[MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE] = {0};
+
+	DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+
+	DrvPlatformLyrTouchDeviceResetHw();
+
+	DbBusEnterSerialDebugMode();
+	DbBusStopMCU();
+	DbBusIICUseBus();
+	DbBusIICReshape();
+	msleep(100);
+
+	DBG("Program start\n");
+
+	_DrvFwCtrlMsg28xxAccessEFlashInit();
+
+	RegSetLByteValue(0x0FE6, 0x01);
+
+	RegSet16BitValue(0x1618, 0x5AA5);
+
+	_DrvFwCtrlMsg28xxUnsetProtectBit();
+
+	if (eEmemType == EMEM_MAIN) {
+		DBG("Program main block\n");
+
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_8_BYTE_EACH_TIME
+		nPageNum = (MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE * 1024) / 8;
+#else
+		nPageNum = (MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE * 1024) /
+				MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE;
+#endif
+
+		nIndex = 0;
+
+		for (i = 0; i < nPageNum; i++) {
+			if (i == 0) {
+				nLength = MSG28XX_EMEM_SIZE_BYTES_ONE_WORD;
+
+				szFirstData[0] = g_FwData[0][0];
+				szFirstData[1] = g_FwData[0][1];
+				szFirstData[2] = g_FwData[0][2];
+				szFirstData[3] = g_FwData[0][3];
+
+			_DrvFwCtrlMsg28xxIspBurstWriteEFlashStart(
+					nIndex,
+					&szFirstData[0],
+					MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE * 1024,
+					nPageNum, EMEM_MAIN);
+
+				nIndex += nLength;
+
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_8_BYTE_EACH_TIME
+				nLength = 8 - MSG28XX_EMEM_SIZE_BYTES_ONE_WORD;
+#else
+				nLength =
+					MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE -
+					MSG28XX_EMEM_SIZE_BYTES_ONE_WORD;
+		#endif
+
+				for (j = 0; j < nLength; j++)
+					szBufferData[j] = g_FwData[0][4+j];
+			} else {
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_8_BYTE_EACH_TIME
+				nLength = 8;
+#else
+				nLength = MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE;
+#endif
+
+				for (j = 0; j < nLength; j++) {
+#ifdef CONFIG_ENABLE_UPDATE_FIRMWARE_WITH_8_BYTE_EACH_TIME
+					szBufferData[j] =
+					g_FwData[i / 128][8 *
+					(i - (128 * (i / 128))) + j];
+#else
+				szBufferData[j] =
+					g_FwData[i/8]
+					[MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE *
+					(i - (8 * (i / 8))) + j];
+#endif
+				}
+			}
+
+			_DrvFwCtrlMsg28xxIspBurstWriteEFlashDoWrite(
+				&szBufferData[0], nLength);
+
+			udelay(2000);
+
+			nIndex += nLength;
+		}
+
+		_DrvFwCtrlMsg28xxIspBurstWriteEFlashEnd();
+
+		RegSet16BitValueOn(0x1606, BIT2);
+
+		nRegData = RegGetLByteValue(0x160E);
+		nRetryTime = 0;
+		while ((nRegData & BIT3) != BIT3) {
+			msleep(20);
+
+			nRegData = RegGetLByteValue(0x160E);
+
+			if (nRetryTime++ > 100) {
+				DBG("main block can't wait write to done.\n");
+
+				goto ProgramEnd;
+			}
+		}
+	} else if (eEmemType == EMEM_INFO) {
+		DBG("Program info block\n");
+
+		nPageNum = (MSG28XX_FIRMWARE_INFO_BLOCK_SIZE * 1024) /
+					MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE;
+				nIndex = 0;
+		nIndex += MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE;
+
+	for (i = 1; i < (nPageNum - 1); i++) {
+		if (i == 1) {
+			nLength = MSG28XX_EMEM_SIZE_BYTES_ONE_WORD;
+
+			szFirstData[0] =
+				g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE]
+				[MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE];
+			szFirstData[1] =
+				g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE]
+				[MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE + 1];
+			szFirstData[2] =
+				g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE]
+				[MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE + 2];
+			szFirstData[3] =
+				g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE]
+				[MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE + 3];
+
+			_DrvFwCtrlMsg28xxIspBurstWriteEFlashStart(
+				nIndex,
+				&szFirstData[0],
+				MSG28XX_FIRMWARE_INFO_BLOCK_SIZE * 1024,
+				nPageNum - 1, EMEM_INFO);
+
+				nIndex += nLength;
+
+			nLength = MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE -
+					MSG28XX_EMEM_SIZE_BYTES_ONE_WORD;
+
+		for (j = 0; j < nLength; j++)
+			szBufferData[j] =
+				g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE]
+				[MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE +
+				4 + j];
+		} else {
+				nLength = MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE;
+
+		if (i < 8) {
+			for (j = 0; j < nLength; j++)
+				szBufferData[j] =
+				g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE]
+				[MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE * i + j];
+		} else {
+			for (j = 0; j < nLength; j++)
+				szBufferData[j] =
+				g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE + 1]
+				[MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE *
+				(i - 8) + j];
+
+				}
+			}
+
+			_DrvFwCtrlMsg28xxIspBurstWriteEFlashDoWrite(
+				&szBufferData[0], nLength);
+
+			udelay(2000);
+			nIndex += nLength;
+		}
+
+		_DrvFwCtrlMsg28xxIspBurstWriteEFlashEnd();
+
+		RegSet16BitValueOn(0x1606, BIT2);
+
+		nRegData = RegGetLByteValue(0x160E);
+		nRetryTime = 0;
+
+		while ((nRegData & BIT3) != BIT3) {
+			msleep(20);
+
+			nRegData = RegGetLByteValue(0x160E);
+
+			if (nRetryTime++ > 100)
+				goto ProgramEnd;
+		}
+
+		RegSet16BitValueOff(0x1EBE, BIT15);
+
+		nIndex = 15 * MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE;
+		nWordNum = MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE /
+				MSG28XX_EMEM_SIZE_BYTES_ONE_WORD;
+		nLength = MSG28XX_EMEM_SIZE_BYTES_ONE_WORD;
+
+	for (i = 0; i < nWordNum; i++) {
+		if (i == 0) {
+			szFirstData[0] =
+				g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE + 1]
+				[7 * MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE];
+			szFirstData[1] =
+				g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE + 1]
+				[7 * MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE + 1];
+			szFirstData[2] =
+				g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE + 1]
+				[7 * MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE + 2];
+			szFirstData[3] =
+				g_FwData[MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE + 1]
+				[7 * MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE + 3];
+
+				_DrvFwCtrlMsg28xxWriteEFlashStart(
+					nIndex, &szFirstData[0], EMEM_INFO);
+	} else {
+		for (j = 0; j < nLength; j++)
+			szFirstData[j] =
+				g_FwData[
+				MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE + 1]
+				[7 * MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE +
+				(4 * i) + j];
+
+
+				_DrvFwCtrlMsg28xxWriteEFlashDoWrite(
+					nIndex, &szFirstData[0]);
+			}
+
+			udelay(2000);
+
+			nIndex += nLength;
+		}
+
+		_DrvFwCtrlMsg28xxWriteEFlashEnd();
+
+		RegSet16BitValueOn(0x1606, BIT2);
+
+		nRegData = RegGetLByteValue(0x160E);
+		nRetryTime = 0;
+
+		while ((nRegData & BIT3) != BIT3) {
+			msleep(20);
+
+			nRegData = RegGetLByteValue(0x160E);
+
+			if (nRetryTime++ > 100)
+				goto ProgramEnd;
+		}
+	}
+
+ProgramEnd:
+
+	_DrvFwCtrlMsg28xxSetProtectBit();
+
+	RegSet16BitValue(0x1618, 0xA55A);
+
+	DBG("Program end\n");
+
+	DbBusIICNotUseBus();
+	DbBusNotStopMCU();
+	DbBusExitSerialDebugMode();
+}
+
+static u16
+	_DrvFwCtrlMsg28xxGetSwId(enum EmemType_e eEmemType)
+{
+	u16 nRetVal = 0;
+	u16 nReadAddr = 0;
+	u8	szTmpData[4] = {0};
+
+	DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+	DbBusEnterSerialDebugMode();
+	DbBusStopMCU();
+	DbBusIICUseBus();
+	DbBusIICReshape();
+	msleep(100);
+
+	RegSetLByteValue(0x0FE6, 0x01);
+
+	RegSet16BitValue(0x3C60, 0xAA55);
+
+	if (eEmemType == EMEM_MAIN) {
+		_DrvFwCtrlMsg28xxReadEFlashStart(0x7FFD, EMEM_MAIN);
+		nReadAddr = 0x7FFD;
+	} else if (eEmemType == EMEM_INFO) {
+		_DrvFwCtrlMsg28xxReadEFlashStart(0x81FB, EMEM_INFO);
+		nReadAddr = 0x81FB;
+	}
+
+	_DrvFwCtrlMsg28xxReadEFlashDoRead(nReadAddr, &szTmpData[0]);
+
+	_DrvFwCtrlMsg28xxReadEFlashEnd();
+
+	/*
+	  Ex. SW ID in Main Block :
+		  Major low byte at address 0x7FFD
+
+		  SW ID in Info Block :
+		  Major low byte at address 0x81FB
+	*/
+
+	nRetVal = (szTmpData[1] << 8);
+	nRetVal |= szTmpData[0];
+	DBG("SW ID = 0x%x\n", nRetVal);
+
+	DbBusIICNotUseBus();
+	DbBusNotStopMCU();
+	DbBusExitSerialDebugMode();
+
+	return nRetVal;
+}
+
+static u32
+	_DrvFwCtrlMsg28xxGetFirmwareCrcByHardware(
+	enum EmemType_e eEmemType)
+{
+	u32 nRetVal = 0;
+	u32 nRetryTime = 0;
+	u32 nCrcEndAddr = 0;
+	u16 nCrcDown = 0;
+
+	DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+	DrvPlatformLyrTouchDeviceResetHw();
+
+	DbBusEnterSerialDebugMode();
+	DbBusStopMCU();
+	DbBusIICUseBus();
+	DbBusIICReshape();
+	msleep(100);
+
+	_DrvFwCtrlMsg28xxAccessEFlashInit();
+
+	if (eEmemType == EMEM_MAIN) {
+		RegSetLByteValue(0x1608, 0x20);
+		RegSetLByteValue(0x1606, 0x20);
+
+		RegSet16BitValue(0x1610, 0x0001);
+
+		RegSet16BitValue(0x1606, 0x0000);
+
+		RegSet16BitValue(0x1620, 0x0002);
+
+		RegSet16BitValue(0x1620, 0x0000);
+
+		RegSet16BitValue(0x1600, 0x0000);
+
+		nCrcEndAddr =
+			(MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE * 1024) / 4 - 2;
+
+		RegSet16BitValue(0x1622, nCrcEndAddr);
+
+		RegSet16BitValue(0x1620, 0x0001);
+
+		nCrcDown = RegGet16BitValue(0x1620);
+
+		nRetryTime = 0;
+		while ((nCrcDown >> 15) == 0) {
+			msleep(20);
+
+			nCrcDown = RegGet16BitValue(0x1620);
+			nRetryTime++;
+
+			if (nRetryTime > 30) {
+				DBG("Wait main block nCrcDown failed.\n");
+				break;
+			}
+		}
+
+		nRetVal = RegGet16BitValue(0x1626);
+		nRetVal = (nRetVal << 16) | RegGet16BitValue(0x1624);
+	} else if (eEmemType == EMEM_INFO) {
+		RegSetLByteValue(0x1608, 0x20);
+		RegSetLByteValue(0x1606, 0x20);
+
+		RegSet16BitValue(0x1610, 0x0001);
+
+		RegSet16BitValue(0x1606, 0x0800);
+
+		RegSetLByteValue(0x1604, 0x01);
+
+		RegSet16BitValue(0x1620, 0x0002);
+
+		RegSet16BitValue(0x1620, 0x0000);
+
+		RegSet16BitValue(0x1600, 0x0020);
+		RegSet16BitValue(0x1622, 0x01FE);
+
+		RegSet16BitValue(0x1620, 0x0001);
+
+		nCrcDown = RegGet16BitValue(0x1620);
+
+		nRetryTime = 0;
+		while ((nCrcDown >> 15) == 0) {
+			msleep(20);
+
+			nCrcDown = RegGet16BitValue(0x1620);
+			nRetryTime++;
+
+			if (nRetryTime > 30) {
+				DBG("Wait info block nCrcDown failed.\n");
+				break;
+			}
+		}
+
+		nRetVal = RegGet16BitValue(0x1626);
+		nRetVal = (nRetVal << 16) | RegGet16BitValue(0x1624);
+	}
+
+	DBG("Hardware CRC = 0x%x\n", nRetVal);
+
+	DbBusIICNotUseBus();
+	DbBusNotStopMCU();
+	DbBusExitSerialDebugMode();
+
+	return nRetVal;
+}
+
+static u32
+		_DrvFwCtrlMsg28xxRetrieveFirmwareCrcFromEFlash(
+		enum EmemType_e eEmemType)
+{
+	u32 nRetVal = 0;
+	u16 nReadAddr = 0;
+	u8	szTmpData[4] = {0};
+
+	DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+	DbBusEnterSerialDebugMode();
+	DbBusStopMCU();
+	DbBusIICUseBus();
+	DbBusIICReshape();
+	msleep(100);
+
+	RegSetLByteValue(0x0FE6, 0x01);
+
+	RegSet16BitValue(0x3C60, 0xAA55);
+
+	if (eEmemType == EMEM_MAIN) {
+		_DrvFwCtrlMsg28xxReadEFlashStart(0x7FFF, EMEM_MAIN);
+		nReadAddr = 0x7FFF;
+	} else if (eEmemType == EMEM_INFO) {
+		_DrvFwCtrlMsg28xxReadEFlashStart(0x81FF, EMEM_INFO);
+		nReadAddr = 0x81FF;
+	}
+
+	_DrvFwCtrlMsg28xxReadEFlashDoRead(nReadAddr, &szTmpData[0]);
+
+	DBG("szTmpData[0] = 0x%x\n", szTmpData[0]);
+	DBG("szTmpData[1] = 0x%x\n", szTmpData[1]);
+	DBG("szTmpData[2] = 0x%x\n", szTmpData[2]);
+	DBG("szTmpData[3] = 0x%x\n", szTmpData[3]);
+
+	_DrvFwCtrlMsg28xxReadEFlashEnd();
+
+	nRetVal = (szTmpData[3] << 24);
+	nRetVal |= (szTmpData[2] << 16);
+	nRetVal |= (szTmpData[1] << 8);
+	nRetVal |= szTmpData[0];
+
+	DBG("CRC = 0x%x\n", nRetVal);
+
+	DbBusIICNotUseBus();
+	DbBusNotStopMCU();
+	DbBusExitSerialDebugMode();
+
+	return nRetVal;
+}
+
+static u32 _DrvFwCtrlMsg28xxRetrieveFrimwareCrcFromBinFile(u8 szTmpBuf[][1024],
+					enum EmemType_e eEmemType)
+		{
+	u32 nRetVal = 0;
+
+	DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+	if (szTmpBuf != NULL) {
+		if (eEmemType == EMEM_MAIN) {
+			nRetVal = szTmpBuf[127][1023];
+			nRetVal = (nRetVal << 8) | szTmpBuf[127][1022];
+			nRetVal = (nRetVal << 8) | szTmpBuf[127][1021];
+			nRetVal = (nRetVal << 8) | szTmpBuf[127][1020];
+		} else if (eEmemType == EMEM_INFO) {
+			nRetVal = szTmpBuf[129][1023];
+			nRetVal = (nRetVal << 8) | szTmpBuf[129][1022];
+			nRetVal = (nRetVal << 8) | szTmpBuf[129][1021];
+			nRetVal = (nRetVal << 8) | szTmpBuf[129][1020];
+		}
+	}
+
+	return nRetVal;
+}
+
+static s32 _DrvFwCtrlMsg28xxCheckFirmwareBinIntegrity(u8 szFwData[][1024])
+{
+	u32 nCrcMain = 0, nCrcMainBin = 0;
+	u32 nCrcInfo = 0, nCrcInfoBin = 0;
+	u32 nRetVal = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	_DrvFwCtrlMsg28xxConvertFwDataTwoDimenToOneDimen(
+		szFwData, _gOneDimenFwData);
+
+	/* Calculate main block CRC & info block CRC by device driver itself */
+	nCrcMain = _DrvFwCtrlMsg28xxCalculateCrc(_gOneDimenFwData, 0,
+				MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE * 1024 -
+				MSG28XX_EMEM_SIZE_BYTES_ONE_WORD);
+	nCrcInfo = _DrvFwCtrlMsg28xxCalculateCrc(_gOneDimenFwData,
+				MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE*1024 +
+				MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE,
+				MSG28XX_FIRMWARE_INFO_BLOCK_SIZE*1024 -
+				MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE -
+				MSG28XX_EMEM_SIZE_BYTES_ONE_WORD);
+
+	/* Read main block CRC & info block CRC from firmware bin file */
+	nCrcMainBin =
+		_DrvFwCtrlMsg28xxRetrieveFrimwareCrcFromBinFile(
+		szFwData, EMEM_MAIN);
+	nCrcInfoBin =
+		_DrvFwCtrlMsg28xxRetrieveFrimwareCrcFromBinFile(
+		szFwData, EMEM_INFO);
+
+	if ((nCrcMainBin != nCrcMain) || (nCrcInfoBin != nCrcInfo))
+		nRetVal = -1;
+	else
+		nRetVal = 0;
+
+	return nRetVal;
+}
+
+static s32 _DrvFwCtrlMsg28xxUpdateFirmware(
+	u8 szFwData[][1024], enum EmemType_e eEmemType)
+{
+	u32 nCrcMain = 0, nCrcMainHardware = 0, nCrcMainEflash = 0;
+	u32 nCrcInfo = 0, nCrcInfoHardware = 0, nCrcInfoEflash = 0;
+
+	if (_DrvFwCtrlMsg28xxCheckFirmwareBinIntegrity(szFwData) < 0) {
+		g_FwDataCount = 0;
+
+		DrvPlatformLyrTouchDeviceResetHw();
+
+		return -EINVAL;
+	}
+
+	g_IsUpdateFirmware = 0x01;
+
+	if (eEmemType == EMEM_ALL) {
+		_DrvFwCtrlMsg28xxEraseEmem(EMEM_MAIN);
+		_DrvFwCtrlMsg28xxEraseEmem(EMEM_INFO);
+	} else if (eEmemType == EMEM_MAIN) {
+		_DrvFwCtrlMsg28xxEraseEmem(EMEM_MAIN);
+	} else if (eEmemType == EMEM_INFO) {
+		_DrvFwCtrlMsg28xxEraseEmem(EMEM_INFO);
+	}
+
+	DBG("erase OK\n");
+
+
+	if (eEmemType == EMEM_ALL) {
+		_DrvFwCtrlMsg28xxProgramEmem(EMEM_MAIN);
+		_DrvFwCtrlMsg28xxProgramEmem(EMEM_INFO);
+	} else if (eEmemType == EMEM_MAIN) {
+		_DrvFwCtrlMsg28xxProgramEmem(EMEM_MAIN);
+	} else if (eEmemType == EMEM_INFO) {
+		_DrvFwCtrlMsg28xxProgramEmem(EMEM_INFO);
+	}
+
+	DBG("program OK\n");
+
+	/* Calculate main block CRC & info block CRC by device driver itself */
+	_DrvFwCtrlMsg28xxConvertFwDataTwoDimenToOneDimen(
+	szFwData, _gOneDimenFwData);
+
+	/* Read main block CRC & info block CRC from TP */
+	if (eEmemType == EMEM_ALL) {
+		nCrcMain =
+			_DrvFwCtrlMsg28xxCalculateCrc(_gOneDimenFwData, 0,
+			MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE * 1024 -
+			MSG28XX_EMEM_SIZE_BYTES_ONE_WORD);
+		nCrcInfo =
+			_DrvFwCtrlMsg28xxCalculateCrc(_gOneDimenFwData,
+			MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE * 1024 +
+			MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE,
+			MSG28XX_FIRMWARE_INFO_BLOCK_SIZE * 1024 -
+			MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE -
+			MSG28XX_EMEM_SIZE_BYTES_ONE_WORD);
+
+		nCrcMainHardware =
+			_DrvFwCtrlMsg28xxGetFirmwareCrcByHardware(EMEM_MAIN);
+		nCrcInfoHardware =
+			_DrvFwCtrlMsg28xxGetFirmwareCrcByHardware(EMEM_INFO);
+
+		nCrcMainEflash =
+			_DrvFwCtrlMsg28xxRetrieveFirmwareCrcFromEFlash(
+			EMEM_MAIN);
+		nCrcInfoEflash =
+			_DrvFwCtrlMsg28xxRetrieveFirmwareCrcFromEFlash(
+			EMEM_INFO);
+	} else if (eEmemType == EMEM_MAIN) {
+		nCrcMain =
+			_DrvFwCtrlMsg28xxCalculateCrc(_gOneDimenFwData, 0,
+			MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE * 1024 -
+			MSG28XX_EMEM_SIZE_BYTES_ONE_WORD);
+		nCrcMainHardware =
+			_DrvFwCtrlMsg28xxGetFirmwareCrcByHardware(EMEM_MAIN);
+		nCrcMainEflash =
+			_DrvFwCtrlMsg28xxRetrieveFirmwareCrcFromEFlash(
+			EMEM_MAIN);
+	} else if (eEmemType == EMEM_INFO) {
+		nCrcInfo =
+				_DrvFwCtrlMsg28xxCalculateCrc(_gOneDimenFwData,
+				MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE * 1024 +
+				MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE,
+				MSG28XX_FIRMWARE_INFO_BLOCK_SIZE * 1024 -
+				MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE -
+				MSG28XX_EMEM_SIZE_BYTES_ONE_WORD);
+		nCrcInfoHardware =
+			_DrvFwCtrlMsg28xxGetFirmwareCrcByHardware(
+			EMEM_INFO);
+		nCrcInfoEflash =
+			_DrvFwCtrlMsg28xxRetrieveFirmwareCrcFromEFlash(
+			EMEM_INFO);
+	}
+
+
+	g_FwDataCount = 0;
+
+	g_IsUpdateFirmware = 0x00;
+
+	DrvPlatformLyrTouchDeviceResetHw();
+	msleep(300);
+
+	if (eEmemType == EMEM_ALL) {
+		if ((nCrcMainHardware != nCrcMain) ||
+				(nCrcInfoHardware != nCrcInfo) ||
+				(nCrcMainEflash != nCrcMain) ||
+				(nCrcInfoEflash != nCrcInfo)) {
+			DBG("Update FAILED\n");
+
+			return -EINVAL;
+		}
+	} else if (eEmemType == EMEM_MAIN) {
+		if ((nCrcMainHardware != nCrcMain) ||
+			(nCrcMainEflash != nCrcMain)) {
+			DBG("Update FAILED\n");
+
+			return -EINVAL;
+		}
+	} else if (eEmemType == EMEM_INFO) {
+		if ((nCrcInfoHardware != nCrcInfo) ||
+			(nCrcInfoEflash != nCrcInfo)) {
+			DBG("Update FAILED\n");
+
+			return -EINVAL;
+		}
+	}
+
+	DBG("Update SUCCESS\n");
+
+	return 0;
+}
+
+static s32 _DrvFwCtrlUpdateFirmwareCash(
+	u8 szFwData[][1024], enum EmemType_e eEmemType)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	DBG("chip type = 0x%x\n", g_ChipType);
+
+	if (g_ChipType == CHIP_TYPE_MSG28XX) {
+		if (IS_FORCE_TO_UPDATE_FIRMWARE_ENABLED)
+			return _DrvFwCtrlMsg28xxUpdateFirmware(
+			szFwData, EMEM_MAIN);
+
+		else {
+			u16 eSwId = 0x0000;
+			u16 eVendorId = 0x0000;
+
+			eVendorId = szFwData[129][1005] << 8 |
+				szFwData[129][1004];
+			eSwId = _DrvFwCtrlMsg28xxGetSwId(EMEM_INFO);
+			if (eSwId != eVendorId) {
+				DrvPlatformLyrTouchDeviceResetHw();
+
+				return -EINVAL;
+			} else
+				return _DrvFwCtrlMsg28xxUpdateFirmware(
+					szFwData, EMEM_MAIN);
+		}
+	} else {
+		DBG("Undefined chip type.\n");
+		g_FwDataCount = 0;
+
+		return -EINVAL;
+	}
+}
+
+static s32 _DrvFwCtrlUpdateFirmwareBySdCard(const char *pFilePath)
+{
+	s32 nRetVal = 0;
+	struct file *pfile = NULL;
+	struct inode *inode;
+	s32 fsize = 0;
+	mm_segment_t old_fs;
+	loff_t pos;
+	u16 eSwId = 0x0000;
+	u16 eVendorId = 0x0000;
+
+	DBG("*** %s() ***\n", __func__);
+
+	/*pfile = filp_open(pFilePath, O_RDONLY, 0);*/
+
+	if (IS_ERR(pfile))
+		return -EINVAL;
+
+	inode = pfile->f_dentry->d_inode;
+	fsize = inode->i_size;
+
+	DBG("fsize = %d\n", fsize);
+
+	if (fsize <= 0) {
+		filp_close(pfile, NULL);
+		return -EINVAL;
+	}
+
+	memset(_gFwDataBuf, 0, MSG28XX_FIRMWARE_WHOLE_SIZE*1024);
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+
+	pos = 0;
+	vfs_read(pfile, _gFwDataBuf, fsize, &pos);
+
+	filp_close(pfile, NULL);
+	set_fs(old_fs);
+
+	_DrvFwCtrlStoreFirmwareData(_gFwDataBuf, fsize);
+
+	DrvPlatformLyrDisableFingerTouchReport();
+
+	if (g_ChipType == CHIP_TYPE_MSG28XX) {
+		eVendorId = g_FwData[129][1005] << 8 |
+			g_FwData[129][1004];
+		eSwId = _DrvFwCtrlMsg28xxGetSwId(EMEM_INFO);
+	}
+
+	if ((eSwId == eVendorId) ||
+		(IS_FORCE_TO_UPDATE_FIRMWARE_ENABLED)) {
+		if (g_ChipType == CHIP_TYPE_MSG28XX &&
+			fsize == 133120)
+				nRetVal = _DrvFwCtrlUpdateFirmwareCash(
+						g_FwData, EMEM_MAIN);
+		else
+			nRetVal = -1;
+	} else
+		nRetVal = -1;
+
+	g_FwDataCount = 0;
+
+	DrvPlatformLyrEnableFingerTouchReport();
+
+	return nRetVal;
+}
+
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+
+void DrvFwCtrlOpenGestureWakeup(u32 *pMode)
+{
+	u8 szDbBusTxData[4] = {0};
+	u32 i = 0;
+	s32 rc;
+
+	DBG("*** %s() ***\n", __func__);
+
+	DBG("wakeup mode 0 = 0x%x\n", pMode[0]);
+	DBG("wakeup mode 1 = 0x%x\n", pMode[1]);
+
+#ifdef CONFIG_SUPPORT_64_TYPES_GESTURE_WAKEUP_MODE
+	szDbBusTxData[0] = 0x59;
+	szDbBusTxData[1] = 0x00;
+	szDbBusTxData[2] = ((pMode[1] & 0xFF000000) >> 24);
+	szDbBusTxData[3] = ((pMode[1] & 0x00FF0000) >> 16);
+
+	while (i < 5) {
+		msleep(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+		rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 4);
+		if (rc > 0)	{
+			DBG("Enable gesture wakeup index 0 success\n");
+			break;
+		}
+
+		i++;
+	}
+	if (i == 5)
+		DBG("Enable gesture wakeup index 0 failed\n");
+
+	szDbBusTxData[0] = 0x59;
+	szDbBusTxData[1] = 0x01;
+	szDbBusTxData[2] = ((pMode[1] & 0x0000FF00) >> 8);
+	szDbBusTxData[3] = ((pMode[1] & 0x000000FF) >> 0);
+
+	while (i < 5) {
+		msleep(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+		rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 4);
+		if (rc > 0) {
+			DBG("Enable gesture wakeup index 1 success\n");
+			break;
+		}
+
+		i++;
+	}
+	if (i == 5)
+		DBG("Enable gesture wakeup index 1 failed\n");
+
+	szDbBusTxData[0] = 0x59;
+	szDbBusTxData[1] = 0x02;
+	szDbBusTxData[2] = ((pMode[0] & 0xFF000000) >> 24);
+	szDbBusTxData[3] = ((pMode[0] & 0x00FF0000) >> 16);
+
+	while (i < 5) {
+		msleep(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+		rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 4);
+		if (rc > 0)	{
+			DBG("Enable gesture wakeup index 2 success\n");
+			break;
+		}
+
+		i++;
+	}
+	if (i == 5)
+		DBG("Enable gesture wakeup index 2 failed\n");
+
+	szDbBusTxData[0] = 0x59;
+	szDbBusTxData[1] = 0x03;
+	szDbBusTxData[2] = ((pMode[0] & 0x0000FF00) >> 8);
+	szDbBusTxData[3] = ((pMode[0] & 0x000000FF) >> 0);
+
+	while (i < 5) {
+		msleep(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+		rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 4);
+		if (rc > 0) {
+			DBG("Enable gesture wakeup index 3 success\n");
+			break;
+		}
+
+		i++;
+	}
+	if (i == 5)
+		DBG("Enable gesture wakeup index 3 failed\n");
+
+	g_GestureWakeupFlag = 1;
+
+#else
+
+	szDbBusTxData[0] = 0x58;
+	szDbBusTxData[1] = ((pMode[0] & 0x0000FF00) >> 8);
+	szDbBusTxData[2] = ((pMode[0] & 0x000000FF) >> 0);
+
+	while (i < 5) {
+		msleep(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+		rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+		if (rc > 0) {
+			DBG("Enable gesture wakeup success\n");
+			break;
+		}
+
+		i++;
+	}
+	if (i == 5)
+		DBG("Enable gesture wakeup failed\n");
+
+	g_GestureWakeupFlag = 1;
+#endif
+}
+
+void DrvFwCtrlCloseGestureWakeup(void)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	g_GestureWakeupFlag = 0;
+}
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+void DrvFwCtrlOpenGestureDebugMode(u8 nGestureFlag)
+{
+	u8 szDbBusTxData[3] = {0};
+	s32 rc;
+
+	DBG("*** %s() ***\n", __func__);
+
+	DBG("Gesture Flag = 0x%x\n", nGestureFlag);
+
+	szDbBusTxData[0] = 0x30;
+	szDbBusTxData[1] = 0x01;
+	szDbBusTxData[2] = nGestureFlag;
+
+	msleep(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+	rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+	if (rc < 0)
+		DBG("Enable gesture debug mode failed\n");
+	else {
+		g_GestureDebugMode = 1;
+
+		DBG("Enable gesture debug mode success\n");
+	}
+}
+
+void DrvFwCtrlCloseGestureDebugMode(void)
+{
+	u8 szDbBusTxData[3] = {0};
+	s32 rc;
+
+	DBG("*** %s() ***\n", __func__);
+
+	szDbBusTxData[0] = 0x30;
+	szDbBusTxData[1] = 0x00;
+	szDbBusTxData[2] = 0x00;
+
+	msleep(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+	rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+	if (rc < 0)
+		DBG("Disable gesture debug mode failed\n");
+	else {
+		g_GestureDebugMode = 0;
+
+		DBG("Disable gesture debug mode success\n");
+	}
+}
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+static void _DrvFwCtrlCoordinate(u8 *pRawData, u32 *pTranX, u32 *pTranY)
+{
+	u32 nX;
+	u32 nY;
+#ifdef CONFIG_SWAP_X_Y
+	u32 nTempX;
+	u32 nTempY;
+#endif
+
+	nX = (((pRawData[0] & 0xF0) << 4) | pRawData[1]);
+	nY = (((pRawData[0] & 0x0F) << 8) | pRawData[2]);
+
+	DBG("[x,y]=[%d,%d]\n", nX, nY);
+
+#ifdef CONFIG_SWAP_X_Y
+	nTempY = nX;
+	nTempX = nY;
+	nX = nTempX;
+	nY = nTempY;
+#endif
+
+#ifdef CONFIG_REVERSE_X
+	nX = 2047 - nX;
+#endif
+
+#ifdef CONFIG_REVERSE_Y
+	nY = 2047 - nY;
+#endif
+
+	/*
+	 * pRawData[0]~pRawData[2] : the point abs,
+	 * pRawData[0]~pRawData[2] all are 0xFF, release touch
+	 */
+	if ((pRawData[0] == 0xFF) &&
+		(pRawData[1] == 0xFF) &&
+		(pRawData[2] == 0xFF)) {
+		*pTranX = 0;
+		*pTranY = 0;
+	} else {
+		  /* one touch point */
+		*pTranX = (nX * TOUCH_SCREEN_X_MAX) / TPD_WIDTH;
+		*pTranY = (nY * TOUCH_SCREEN_Y_MAX) / TPD_HEIGHT;
+		DBG("[%s]: [x,y]=[%d,%d]\n", __func__, nX, nY);
+		DBG("[%s]: point[x,y]=[%d,%d]\n", __func__, *pTranX, *pTranY);
+	}
+}
+#endif
+
+#endif
+
+static void _DrvFwCtrlReadReadDQMemStart(void)
+{
+	u8 nParCmdSelUseCfg = 0x7F;
+	u8 nParCmdAdByteEn0 = 0x50;
+	u8 nParCmdAdByteEn1 = 0x51;
+	u8 nParCmdDaByteEn0 = 0x54;
+	u8 nParCmdUSetSelB0 = 0x80;
+	u8 nParCmdUSetSelB1 = 0x82;
+	u8 nParCmdSetSelB2	= 0x85;
+	u8 nParCmdIicUse	= 0x35;
+
+	DBG("*** %s() ***\n", __func__);
+
+	IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdSelUseCfg, 1);
+	IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdAdByteEn0, 1);
+	IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdAdByteEn1, 1);
+	IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdDaByteEn0, 1);
+	IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdUSetSelB0, 1);
+	IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdUSetSelB1, 1);
+	IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdSetSelB2,	1);
+	IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdIicUse,	1);
+}
+
+static void _DrvFwCtrlReadReadDQMemEnd(void)
+{
+	u8 nParCmdNSelUseCfg = 0x7E;
+
+	IicWriteData(SLAVE_I2C_ID_DBBUS, &nParCmdNSelUseCfg, 1);
+}
+
+u32 DrvFwCtrlReadDQMemValue(u16 nAddr)
+{
+	u8 tx_data[3] = {0x10, (nAddr >> 8) & 0xFF, nAddr & 0xFF};
+	u8 rx_data[4] = {0};
+
+	DBG("*** %s() ***\n", __func__);
+
+	DBG("DQMem Addr = 0x%x\n", nAddr);
+
+	DbBusEnterSerialDebugMode();
+	DbBusStopMCU();
+	DbBusIICUseBus();
+	DbBusIICReshape();
+	msleep(100);
+	RegSetLByteValue(0x0FE6, 0x01);
+	msleep(100);
+
+	_DrvFwCtrlReadReadDQMemStart();
+
+	IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 3);
+	IicReadData(SLAVE_I2C_ID_DBBUS, &rx_data[0], 4);
+
+	_DrvFwCtrlReadReadDQMemEnd();
+
+	RegSetLByteValue(0x0FE6, 0x00);
+	DbBusIICNotUseBus();
+	DbBusNotStopMCU();
+	DbBusExitSerialDebugMode();
+
+	return (rx_data[3] << 24 | rx_data[2] << 16 |
+		rx_data[1] << 8 | rx_data[0]);
+}
+
+void DrvFwCtrlWriteDQMemValue(u16 nAddr, u32 nData)
+{
+	u8 szDbBusTxData[7] = {0};
+
+	DBG("*** %s() ***\n", __func__);
+
+	DBG("DQMem Addr = 0x%x\n", nAddr);
+
+	DbBusEnterSerialDebugMode();
+	DbBusStopMCU();
+	DbBusIICUseBus();
+	DbBusIICReshape();
+	msleep(100);
+	RegSetLByteValue(0x0FE6, 0x01);
+	msleep(100);
+
+	_DrvFwCtrlReadReadDQMemStart();
+	szDbBusTxData[0] = 0x10;
+	szDbBusTxData[1] = ((nAddr >> 8) & 0xff);
+	szDbBusTxData[2] = (nAddr & 0xff);
+	szDbBusTxData[3] = nData & 0x000000FF;
+	szDbBusTxData[4] = ((nData & 0x0000FF00) >> 8);
+	szDbBusTxData[5] = ((nData & 0x00FF0000) >> 16);
+	szDbBusTxData[6] = ((nData & 0xFF000000) >> 24);
+	IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 7);
+
+	_DrvFwCtrlReadReadDQMemEnd();
+
+	RegSetLByteValue(0x0FE6, 0x00);
+	msleep(100);
+
+	DbBusIICNotUseBus();
+	DbBusNotStopMCU();
+	DbBusExitSerialDebugMode();
+}
+
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+
+static u32 _DrvFwCtrlMsg26xxmCalculateFirmwareCrcFromEFlash(enum EmemType_e
+				eEmemType, u8 nIsNeedResetHW)
+{
+	u32 nRetVal = 0;
+	u16 nRegData = 0;
+
+
+	if (1 == nIsNeedResetHW)
+		DrvPlatformLyrTouchDeviceResetHw();
+
+	DbBusEnterSerialDebugMode();
+	DbBusStopMCU();
+	DbBusIICUseBus();
+	DbBusIICReshape();
+	msleep(100);
+
+	RegSetLByteValue(0x0FE6, 0x01);
+
+	RegSet16BitValue(0x3C60, 0xAA55);
+
+	RegSet16BitValue(0x3CE4, 0xDF4C);
+	RegSet16BitValue(0x1E04, 0x7d60);
+	RegSet16BitValue(0x1E04, 0x829F);
+
+	RegSetLByteValue(0x0FE6, 0x00);
+
+	msleep(100);
+
+	do {
+		nRegData = RegGet16BitValue(0x3CE4);
+	} while (nRegData != 0x9432);
+
+	if (eEmemType == EMEM_MAIN)	{
+		nRetVal = RegGet16BitValue(0x3C80);
+		nRetVal = (nRetVal << 16) | RegGet16BitValue(0x3C82);
+
+		DBG("Main Block CRC = 0x%x\n", nRetVal);
+	} else if (eEmemType == EMEM_INFO) {
+		nRetVal = RegGet16BitValue(0x3CA0);
+		nRetVal = (nRetVal << 16) | RegGet16BitValue(0x3CA2);
+
+		DBG("Info Block CRC = 0x%x\n", nRetVal);
+	}
+
+	DbBusIICNotUseBus();
+	DbBusNotStopMCU();
+	DbBusExitSerialDebugMode();
+
+	return nRetVal;
+}
+
+static u32
+	_DrvFwCtrlMsg26xxmRetrieveFirmwareCrcFromMainBlock(
+	enum EmemType_e eEmemType)
+{
+	u32 nRetVal = 0;
+	u16 nRegData = 0;
+	u8 szDbBusTxData[5] = {0};
+	u8 szDbBusRxData[4] = {0};
+
+	DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+	DrvPlatformLyrTouchDeviceResetHw();
+
+	DbBusEnterSerialDebugMode();
+	DbBusStopMCU();
+	DbBusIICUseBus();
+	DbBusIICReshape();
+	msleep(100);
+
+	RegSetLByteValue(0x0FE6, 0x01);
+
+	RegSet16BitValue(0x3C60, 0xAA55);
+
+	RegSet16BitValue(0x3CE4, 0xA4AB);
+
+	RegSet16BitValue(0x1E04, 0x7d60);
+	RegSet16BitValue(0x1E04, 0x829F);
+
+	RegSetLByteValue(0x0FE6, 0x00);
+
+	msleep(100);
+
+	do {
+		nRegData = RegGet16BitValue(0x3CE4);
+	} while (nRegData != 0x5B58);
+
+	szDbBusTxData[0] = 0x72;
+	if (eEmemType == EMEM_MAIN) {
+		szDbBusTxData[1] = 0x7F;
+		szDbBusTxData[2] = 0xF8;
+	} else if (eEmemType == EMEM_INFO) {
+		szDbBusTxData[1] = 0x7F;
+		szDbBusTxData[2] = 0xFC;
+	}
+	szDbBusTxData[3] = 0x00;
+	szDbBusTxData[4] = 0x04;
+
+	IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 5);
+	IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 4);
+
+	/*
+	  The order of 4 bytes [ 0 : 1 : 2 : 3 ]
+	  Ex. CRC32 = 0x12345678
+		  0x7FF8 = 0x78, 0x7FF9 = 0x56,
+		  0x7FFA = 0x34, 0x7FFB = 0x12
+	*/
+
+	nRetVal = szDbBusRxData[3];
+	nRetVal = (nRetVal << 8) | szDbBusRxData[2];
+	nRetVal = (nRetVal << 8) | szDbBusRxData[1];
+	nRetVal = (nRetVal << 8) | szDbBusRxData[0];
+
+	DBG("CRC = 0x%x\n", nRetVal);
+
+	DbBusIICNotUseBus();
+	DbBusNotStopMCU();
+	DbBusExitSerialDebugMode();
+
+	return nRetVal;
+}
+
+static u32 _DrvFwCtrlMsg26xxmRetrieveInfoCrcFromInfoBlock(void)
+{
+	u32 nRetVal = 0;
+	u16 nRegData = 0;
+	u8 szDbBusTxData[5] = {0};
+	u8 szDbBusRxData[4] = {0};
+
+	DBG("*** %s() ***\n", __func__);
+
+	DrvPlatformLyrTouchDeviceResetHw();
+
+	DbBusEnterSerialDebugMode();
+	DbBusStopMCU();
+	DbBusIICUseBus();
+	DbBusIICReshape();
+	msleep(100);
+
+	RegSetLByteValue(0x0FE6, 0x01);
+
+	RegSet16BitValue(0x3C60, 0xAA55);
+
+	RegSet16BitValue(0x3CE4, 0xA4AB);
+
+	RegSet16BitValue(0x1E04, 0x7d60);
+	RegSet16BitValue(0x1E04, 0x829F);
+
+	RegSetLByteValue(0x0FE6, 0x00);
+
+	msleep(100);
+
+	do {
+		nRegData = RegGet16BitValue(0x3CE4);
+	} while (nRegData != 0x5B58);
+
+
+	szDbBusTxData[0] = 0x72;
+	szDbBusTxData[1] = 0x80;
+	szDbBusTxData[2] = 0x00;
+	szDbBusTxData[3] = 0x00;
+	szDbBusTxData[4] = 0x04;
+
+	IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 5);
+	IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 4);
+
+	nRetVal = szDbBusRxData[3];
+	nRetVal = (nRetVal << 8) | szDbBusRxData[2];
+	nRetVal = (nRetVal << 8) | szDbBusRxData[1];
+	nRetVal = (nRetVal << 8) | szDbBusRxData[0];
+
+	DBG("CRC = 0x%x\n", nRetVal);
+
+	DbBusIICNotUseBus();
+	DbBusNotStopMCU();
+	DbBusExitSerialDebugMode();
+
+	return nRetVal;
+}
+
+static u32 _DrvFwCtrlMsg26xxmRetrieveFrimwareCrcFromBinFile(u8
+				szTmpBuf[][1024], enum EmemType_e eEmemType)
+{
+	u32 nRetVal = 0;
+
+	DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+	if (szTmpBuf != NULL) {
+		if (eEmemType == EMEM_MAIN)	{
+			nRetVal = szTmpBuf[31][1019];
+			nRetVal = (nRetVal << 8) | szTmpBuf[31][1018];
+			nRetVal = (nRetVal << 8) | szTmpBuf[31][1017];
+			nRetVal = (nRetVal << 8) | szTmpBuf[31][1016];
+		} else if (eEmemType == EMEM_INFO) {
+			nRetVal = szTmpBuf[31][1023];
+			nRetVal = (nRetVal << 8) | szTmpBuf[31][1022];
+			nRetVal = (nRetVal << 8) | szTmpBuf[31][1021];
+			nRetVal = (nRetVal << 8) | szTmpBuf[31][1020];
+		}
+	}
+
+	return nRetVal;
+}
+
+static u32 _DrvFwCtrlMsg26xxmCalculateInfoCrcByDeviceDriver(void)
+{
+	u32 nRetVal = 0xffffffff;
+	u32 i, j;
+	u16 nRegData = 0;
+	u8 szDbBusTxData[5] = {0};
+
+	DBG("*** %s() ***\n", __func__);
+
+
+	DrvPlatformLyrTouchDeviceResetHw();
+
+	DbBusEnterSerialDebugMode();
+	DbBusStopMCU();
+	DbBusIICUseBus();
+	DbBusIICReshape();
+	msleep(100);
+
+	RegSetLByteValue(0x0FE6, 0x01);
+
+	RegSet16BitValue(0x3C60, 0xAA55);
+
+	RegSet16BitValue(0x3CE4, 0xA4AB);
+
+	RegSet16BitValue(0x1E04, 0x7d60);
+	RegSet16BitValue(0x1E04, 0x829F);
+
+	RegSetLByteValue(0x0FE6, 0x00);
+
+	msleep(100);
+
+	do {
+		nRegData = RegGet16BitValue(0x3CE4);
+	} while (nRegData != 0x5B58);
+
+	DrvCommonCrcInitTable();
+
+	szDbBusTxData[0] = 0x72;
+	szDbBusTxData[3] = 0x00;
+	szDbBusTxData[4] = 0x80;
+
+	for (i = 0; i < 8; i++) {
+		for (j = 0; j < 8; j++) {
+			szDbBusTxData[1] = 0x80 + (i*0x04) +
+				(((j*128)&0xff00)>>8);
+			szDbBusTxData[2] = (j*128)&0x00ff;
+
+			IicWriteData(SLAVE_I2C_ID_DWI2C,
+				&szDbBusTxData[0], 5);
+
+			IicReadData(SLAVE_I2C_ID_DWI2C,
+				&_gTempData[j*128], 128);
+		}
+
+		if (i == 0) {
+			for (j = 4; j < 1024; j++)
+				nRetVal =
+				DrvCommonCrcGetValue(_gTempData[j], nRetVal);
+		} else {
+			for (j = 0; j < 1024; j++)
+				nRetVal =
+				DrvCommonCrcGetValue(
+				_gTempData[j], nRetVal);
+		}
+	}
+
+	nRetVal = nRetVal ^ 0xffffffff;
+
+	DBG("Info(8K-4) CRC = 0x%x\n", nRetVal);
+
+	DbBusIICNotUseBus();
+	DbBusNotStopMCU();
+	DbBusExitSerialDebugMode();
+
+	return nRetVal;
+}
+
+static s32 _DrvFwCtrlMsg26xxmCompare8BytesForCrc(u8 szTmpBuf[][1024])
+{
+	s32 nRetVal = -1;
+	u16 nRegData = 0;
+	u8 szDbBusTxData[5] = {0};
+	u8 szDbBusRxData[8] = {0};
+	u8 crc[8] = {0};
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (szTmpBuf != NULL) {
+		crc[0] = szTmpBuf[31][1016];
+		crc[1] = szTmpBuf[31][1017];
+		crc[2] = szTmpBuf[31][1018];
+		crc[3] = szTmpBuf[31][1019];
+		crc[4] = szTmpBuf[31][1020];
+		crc[5] = szTmpBuf[31][1021];
+		crc[6] = szTmpBuf[31][1022];
+		crc[7] = szTmpBuf[31][1023];
+	}
+
+	DbBusEnterSerialDebugMode();
+	DbBusStopMCU();
+	DbBusIICUseBus();
+	DbBusIICReshape();
+	msleep(100);
+
+	RegSetLByteValue(0x0FE6, 0x01);
+
+	RegSet16BitValue(0x3C60, 0xAA55);
+
+	RegSet16BitValue(0x3CE4, 0xA4AB);
+
+	RegSet16BitValue(0x1E04, 0x7d60);
+	RegSet16BitValue(0x1E04, 0x829F);
+
+	RegSetLByteValue(0x0FE6, 0x00);
+
+	msleep(100);
+
+	do {
+		nRegData = RegGet16BitValue(0x3CE4);
+	} while (nRegData != 0x5B58);
+
+	szDbBusTxData[0] = 0x72;
+	szDbBusTxData[1] = 0x7F;
+	szDbBusTxData[2] = 0xF8;
+	szDbBusTxData[3] = 0x00;
+	szDbBusTxData[4] = 0x08;
+
+	IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 5);
+	IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 8);
+
+	DbBusIICNotUseBus();
+	DbBusNotStopMCU();
+	DbBusExitSerialDebugMode();
+
+	if (crc[0] == szDbBusRxData[0]
+		&& crc[1] == szDbBusRxData[1]
+		&& crc[2] == szDbBusRxData[2]
+		&& crc[3] == szDbBusRxData[3]
+		&& crc[4] == szDbBusRxData[4]
+		&& crc[5] == szDbBusRxData[5]
+		&& crc[6] == szDbBusRxData[6]
+		&& crc[7] == szDbBusRxData[7])
+		nRetVal = 0;
+	else
+		nRetVal = -1;
+
+	DBG("compare 8bytes for CRC = %d\n", nRetVal);
+
+	return nRetVal;
+}
+
+static void _DrvFwCtrlMsg26xxmEraseFirmwareOnEFlash(enum EmemType_e eEmemType)
+{
+	DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+	DBG("erase 0\n");
+
+	DbBusEnterSerialDebugMode();
+	DbBusStopMCU();
+	DbBusIICUseBus();
+	DbBusIICReshape();
+	msleep(100);
+
+	RegSetLByteValue(0x0FE6, 0x01);
+
+	RegSet16BitValue(0x3C60, 0xAA55);
+
+	RegSet16BitValue(0x3CE4, 0x78C5);
+
+	RegSet16BitValue(0x1E04, 0x7d60);
+	RegSet16BitValue(0x1E04, 0x829F);
+
+	RegSetLByteValue(0x0FE6, 0x00);
+
+	msleep(100);
+
+	DBG("erase 1\n");
+
+	RegSetLByteValue(0x0FE6, 0x01);
+
+	RegSet16BitValue(0x3C60, 0xAA55);
+
+	RegSet16BitValue(0x161A, 0xABBA);
+
+	if (eEmemType == EMEM_INFO)
+		RegSet16BitValue(0x1600, 0x8000);
+
+	RegSetLByteValue(0x1618, 0x80);
+
+	DBG("erase 2\n");
+
+	RegSetLByteValue(0x1618, 0x40);
+
+	msleep(20);
+	RegSetLByteValue(0x1618, 0x80);
+
+	DBG("erase 3\n");
+
+	if (eEmemType == EMEM_ALL)
+		RegSetLByteValue(0x160E, 0x08);
+	else if (eEmemType == EMEM_MAIN || eEmemType == EMEM_INFO)
+		RegSetLByteValue(0x160E, 0x04);
+
+	DbBusIICNotUseBus();
+	DbBusNotStopMCU();
+	DbBusExitSerialDebugMode();
+	msleep(200);
+
+	DBG("erase OK\n");
+}
+
+static void _DrvFwCtrlMsg26xxmProgramFirmwareOnEFlash(enum EmemType_e eEmemType)
+{
+	u32 nStart = 0, nEnd = 0;
+	u32 i, j;
+	u16 nRegData = 0;
+
+	DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+
+	DBG("program 0\n");
+
+	DbBusEnterSerialDebugMode();
+	DbBusStopMCU();
+	DbBusIICUseBus();
+	DbBusIICReshape();
+	msleep(100);
+
+	if (eEmemType == EMEM_INFO || eEmemType == EMEM_MAIN) {
+		RegSetLByteValue(0x0FE6, 0x01);
+
+		RegSet16BitValue(0x3C60, 0xAA55);
+
+		RegSet16BitValue(0x3CE4, 0x78C5);
+
+		RegSet16BitValue(0x1E04, 0x7d60);
+		RegSet16BitValue(0x1E04, 0x829F);
+
+		nRegData = RegGet16BitValue(0x1618);
+
+		nRegData |= 0x40;
+
+		RegSetLByteValue(0x1618, nRegData);
+		RegSetLByteValue(0x0FE6, 0x00);
+
+		msleep(100);
+	}
+
+	DBG("program 1\n");
+
+	RegSet16BitValue(0x0F52, 0xDB00);
+
+	do {
+		nRegData = RegGet16BitValue(0x3CE4);
+
+	} while (nRegData != 0x1C70);
+
+	DBG("program 2\n");
+
+	if (eEmemType == EMEM_ALL) {
+		RegSet16BitValue(0x3CE4, 0xE38F);
+
+		nStart = 0;
+		nEnd = MSG26XXM_FIRMWARE_WHOLE_SIZE;
+	} else if (eEmemType == EMEM_MAIN) {
+		RegSet16BitValue(0x3CE4, 0x7731);
+
+		nStart = 0;
+		nEnd = MSG26XXM_FIRMWARE_MAIN_BLOCK_SIZE;
+	} else if (eEmemType == EMEM_INFO) {
+		RegSet16BitValue(0x3CE4, 0xB9D6);
+
+		nStart = MSG26XXM_FIRMWARE_MAIN_BLOCK_SIZE;
+		nEnd = MSG26XXM_FIRMWARE_MAIN_BLOCK_SIZE +
+			MSG26XXM_FIRMWARE_INFO_BLOCK_SIZE;
+	}
+
+	do {
+		nRegData = RegGet16BitValue(0x3CE4);
+	} while (nRegData != 0x2F43);
+
+	DBG("program 3\n");
+
+	for (i = nStart; i < nEnd; i++) {
+		for (j = 0; j < 8; j++)
+			IicWriteData(SLAVE_I2C_ID_DWI2C,
+			&g_FwData[i][j*128], 128);
+
+		msleep(100);
+
+		do {
+			nRegData = RegGet16BitValue(0x3CE4);
+		} while (nRegData != 0xD0BC);
+
+		RegSet16BitValue(0x3CE4, 0x2F43);
+	}
+
+	DBG("program 4\n");
+
+	RegSet16BitValue(0x3CE4, 0x1380);
+	msleep(100);
+
+	DBG("program 5\n");
+
+	do {
+		nRegData = RegGet16BitValue(0x3CE4);
+	} while (nRegData != 0x9432);
+
+	DBG("program 6\n");
+
+	g_FwDataCount = 0;
+
+	DbBusIICNotUseBus();
+	DbBusNotStopMCU();
+	DbBusExitSerialDebugMode();
+
+	msleep(300);
+
+	DBG("program OK\n");
+}
+
+static s32 _DrvFwCtrlMsg26xxmUpdateFirmwareBySwId(void)
+{
+	s32 nRetVal = -1;
+	u32 nCrcInfoA = 0, nCrcInfoB = 0, nCrcMainA = 0, nCrcMainB = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+if (_gIsUpdateInfoBlockFirst == 1) {
+	if ((g_IsUpdateFirmware & 0x10) == 0x10) {
+		_DrvFwCtrlMsg26xxmEraseFirmwareOnEFlash(EMEM_INFO);
+		_DrvFwCtrlMsg26xxmProgramFirmwareOnEFlash(EMEM_INFO);
+
+		nCrcInfoA =
+			_DrvFwCtrlMsg26xxmRetrieveFrimwareCrcFromBinFile(
+			g_FwData, EMEM_INFO);
+		nCrcInfoB =
+			_DrvFwCtrlMsg26xxmCalculateFirmwareCrcFromEFlash(
+			EMEM_INFO, 0);
+
+		if (nCrcInfoA == nCrcInfoB)	{
+			_DrvFwCtrlMsg26xxmEraseFirmwareOnEFlash(
+				EMEM_MAIN);
+			_DrvFwCtrlMsg26xxmProgramFirmwareOnEFlash(
+				EMEM_MAIN);
+
+		nCrcMainA =
+			_DrvFwCtrlMsg26xxmRetrieveFrimwareCrcFromBinFile(
+			g_FwData, EMEM_MAIN);
+		nCrcMainB =
+			_DrvFwCtrlMsg26xxmCalculateFirmwareCrcFromEFlash(
+			EMEM_MAIN, 0);
+
+
+			if (nCrcMainA == nCrcMainB)	{
+				nRetVal =
+					_DrvFwCtrlMsg26xxmCompare8BytesForCrc(
+					g_FwData);
+
+				if (nRetVal == 0)
+					g_IsUpdateFirmware = 0x00;
+				else
+					g_IsUpdateFirmware = 0x11;
+			} else
+					g_IsUpdateFirmware = 0x01;
+		} else
+				g_IsUpdateFirmware = 0x11;
+	} else if ((g_IsUpdateFirmware & 0x01) == 0x01) {
+		_DrvFwCtrlMsg26xxmEraseFirmwareOnEFlash(EMEM_MAIN);
+		_DrvFwCtrlMsg26xxmProgramFirmwareOnEFlash(EMEM_MAIN);
+
+		nCrcMainA =
+			_DrvFwCtrlMsg26xxmRetrieveFrimwareCrcFromBinFile(
+			g_FwData, EMEM_MAIN);
+		nCrcMainB =
+			_DrvFwCtrlMsg26xxmCalculateFirmwareCrcFromEFlash(
+			EMEM_MAIN, 0);
+
+			if (nCrcMainA == nCrcMainB)	{
+				nRetVal =
+					_DrvFwCtrlMsg26xxmCompare8BytesForCrc(
+					g_FwData);
+
+				if (nRetVal == 0)
+					g_IsUpdateFirmware = 0x00;
+				else
+					g_IsUpdateFirmware = 0x11;
+			} else
+				g_IsUpdateFirmware = 0x01;
+		}
+} else {
+	if ((g_IsUpdateFirmware & 0x10) == 0x10) {
+		_DrvFwCtrlMsg26xxmEraseFirmwareOnEFlash(EMEM_MAIN);
+		_DrvFwCtrlMsg26xxmProgramFirmwareOnEFlash(EMEM_MAIN);
+
+		nCrcMainA =
+			_DrvFwCtrlMsg26xxmRetrieveFrimwareCrcFromBinFile(
+			g_FwData, EMEM_MAIN);
+		nCrcMainB =
+			_DrvFwCtrlMsg26xxmCalculateFirmwareCrcFromEFlash(
+			EMEM_MAIN, 0);
+
+
+	if (nCrcMainA == nCrcMainB)	{
+		_DrvFwCtrlMsg26xxmEraseFirmwareOnEFlash(EMEM_INFO);
+		_DrvFwCtrlMsg26xxmProgramFirmwareOnEFlash(EMEM_INFO);
+
+		nCrcInfoA =
+			_DrvFwCtrlMsg26xxmRetrieveFrimwareCrcFromBinFile(
+			g_FwData, EMEM_INFO);
+		nCrcInfoB =
+			_DrvFwCtrlMsg26xxmCalculateFirmwareCrcFromEFlash(
+			EMEM_INFO, 0);
+
+
+			if (nCrcInfoA == nCrcInfoB) {
+				nRetVal =
+					_DrvFwCtrlMsg26xxmCompare8BytesForCrc(
+					g_FwData);
+				if (nRetVal == 0)
+						g_IsUpdateFirmware = 0x00;
+					else
+						g_IsUpdateFirmware = 0x11;
+				} else
+					g_IsUpdateFirmware = 0x01;
+			} else
+				g_IsUpdateFirmware = 0x11;
+		} else if (
+			(g_IsUpdateFirmware & 0x01) == 0x01) {
+			_DrvFwCtrlMsg26xxmEraseFirmwareOnEFlash(
+				EMEM_INFO);
+			_DrvFwCtrlMsg26xxmProgramFirmwareOnEFlash(
+				EMEM_INFO);
+
+		nCrcInfoA =
+			_DrvFwCtrlMsg26xxmRetrieveFrimwareCrcFromBinFile(
+			g_FwData, EMEM_INFO);
+		nCrcInfoB =
+			_DrvFwCtrlMsg26xxmCalculateFirmwareCrcFromEFlash(
+			EMEM_INFO, 0);
+
+
+			if (nCrcInfoA == nCrcInfoB)	{
+				nRetVal =
+					_DrvFwCtrlMsg26xxmCompare8BytesForCrc(
+					g_FwData);
+
+				if (nRetVal == 0)
+					g_IsUpdateFirmware = 0x00;
+				else
+					g_IsUpdateFirmware = 0x11;
+			} else
+				g_IsUpdateFirmware = 0x01;
+		}
+	}
+
+	return nRetVal;
+}
+
+void _DrvFwCtrlMsg26xxmCheckFirmwareUpdateBySwId(void)
+{
+	u32 nCrcMainA, nCrcInfoA, nCrcMainB, nCrcInfoB;
+	u32 i;
+	u16 nUpdateBinMajor = 0, nUpdateBinMinor = 0;
+	u16 nMajor = 0, nMinor = 0;
+	u8 *pVersion = NULL;
+	Msg26xxmSwId_e eSwId = MSG26XXM_SW_ID_UNDEFINED;
+
+	DBG("*** %s() ***\n", __func__);
+
+	DrvPlatformLyrDisableFingerTouchReport();
+
+	nCrcMainA =
+		_DrvFwCtrlMsg26xxmCalculateFirmwareCrcFromEFlash(EMEM_MAIN, 1);
+	nCrcMainB =
+		_DrvFwCtrlMsg26xxmRetrieveFirmwareCrcFromMainBlock(EMEM_MAIN);
+
+	nCrcInfoA =
+		_DrvFwCtrlMsg26xxmCalculateFirmwareCrcFromEFlash(EMEM_INFO, 1);
+	nCrcInfoB =
+		_DrvFwCtrlMsg26xxmRetrieveFirmwareCrcFromMainBlock(EMEM_INFO);
+
+	_gUpdateFirmwareBySwIdWorkQueue =
+		create_singlethread_workqueue("update_firmware_by_sw_id");
+	INIT_WORK(&_gUpdateFirmwareBySwIdWork,
+		_DrvFwCtrlUpdateFirmwareBySwIdDoWork);
+
+
+	if (nCrcMainA == nCrcMainB && nCrcInfoA == nCrcInfoB) {
+		eSwId = _DrvFwCtrlMsg26xxmGetSwId(EMEM_MAIN);
+
+		DBG("eSwId=0x%x\n", eSwId);
+
+		if (eSwId == MSG26XXM_SW_ID_XXXX) {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY
+			nUpdateBinMajor =
+				msg26xxm_xxxx_update_bin[0][0x2B]<<8 |
+				msg26xxm_xxxx_update_bin[0][0x2A];
+			nUpdateBinMinor =
+				msg26xxm_xxxx_update_bin[0][0x2D]<<8 |
+				msg26xxm_xxxx_update_bin[0][0x2C];
+#else
+			nUpdateBinMajor =
+				msg26xxm_xxxx_update_bin[0x002B]<<8 |
+				msg26xxm_xxxx_update_bin[0x002A];
+			nUpdateBinMinor =
+				msg26xxm_xxxx_update_bin[0x002D]<<8 |
+				msg26xxm_xxxx_update_bin[0x002C];
+#endif
+		} else if (eSwId == MSG26XXM_SW_ID_YYYY) {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY
+			nUpdateBinMajor =
+				msg26xxm_yyyy_update_bin[0][0x2B]<<8 |
+				msg26xxm_yyyy_update_bin[0][0x2A];
+			nUpdateBinMinor =
+				msg26xxm_yyyy_update_bin[0][0x2D]<<8 |
+				msg26xxm_yyyy_update_bin[0][0x2C];
+#else
+			nUpdateBinMajor =
+				msg26xxm_yyyy_update_bin[0x002B]<<8 |
+				msg26xxm_yyyy_update_bin[0x002A];
+			nUpdateBinMinor =
+				msg26xxm_yyyy_update_bin[0x002D]<<8 |
+				msg26xxm_yyyy_update_bin[0x002C];
+#endif
+		} else {
+			DBG("SwId = 0x%x is an undefined\n", eSwId);
+
+			eSwId = MSG26XXM_SW_ID_UNDEFINED;
+			nUpdateBinMajor = 0;
+			nUpdateBinMinor = 0;
+		}
+
+		DrvFwCtrlGetCustomerFirmwareVersion(
+			&nMajor, &nMinor, &pVersion);
+
+
+	if (nUpdateBinMinor > nMinor) {
+		if (eSwId == MSG26XXM_SW_ID_XXXX) {
+			for (i = 0; i <
+				MSG26XXM_FIRMWARE_WHOLE_SIZE; i++) {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY
+					_DrvFwCtrlStoreFirmwareData(
+						msg26xxm_xxxx_update_bin[i],
+						1024);
+#else
+				_DrvFwCtrlStoreFirmwareData(&
+					(msg26xxm_xxxx_update_bin[i*1024]),
+					1024);
+#endif
+				}
+			} else if (eSwId == MSG26XXM_SW_ID_YYYY) {
+				for (i = 0; i <
+					MSG26XXM_FIRMWARE_WHOLE_SIZE; i++) {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY
+					_DrvFwCtrlStoreFirmwareData(
+						msg26xxm_yyyy_update_bin[i],
+						1024);
+#else
+				_DrvFwCtrlStoreFirmwareData(&
+					(msg26xxm_yyyy_update_bin[i*1024]),
+					1024);
+#endif
+				}
+			} else {
+				DBG("SwId = 0x%x is an undefined.\n", eSwId);
+
+				eSwId = MSG26XXM_SW_ID_UNDEFINED;
+			}
+
+			if (eSwId < MSG26XXM_SW_ID_UNDEFINED &&
+				eSwId != 0x0000 && eSwId != 0xFFFF)	{
+				g_FwDataCount = 0;
+
+				_gUpdateRetryCount =
+					UPDATE_FIRMWARE_RETRY_COUNT;
+				_gIsUpdateInfoBlockFirst = 1;
+				g_IsUpdateFirmware = 0x11;
+				queue_work(_gUpdateFirmwareBySwIdWorkQueue,
+					&_gUpdateFirmwareBySwIdWork);
+				return;
+			}
+		} else
+			DBG("Go to normal boot up process.\n");
+
+	} else if (nCrcMainA == nCrcMainB && nCrcInfoA != nCrcInfoB) {
+		eSwId = _DrvFwCtrlMsg26xxmGetSwId(EMEM_MAIN);
+
+		DBG("eSwId=0x%x\n", eSwId);
+
+		if (eSwId == MSG26XXM_SW_ID_XXXX) {
+			for (i = 0; i <
+				MSG26XXM_FIRMWARE_WHOLE_SIZE; i++) {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY
+				_DrvFwCtrlStoreFirmwareData(
+					msg26xxm_xxxx_update_bin[i],
+					1024);
+#else
+				_DrvFwCtrlStoreFirmwareData(&
+					(msg26xxm_xxxx_update_bin[i*1024]),
+					1024);
+#endif
+			}
+		} else if (eSwId == MSG26XXM_SW_ID_YYYY) {
+			for (i = 0; i <
+				MSG26XXM_FIRMWARE_WHOLE_SIZE; i++)	{
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY
+				_DrvFwCtrlStoreFirmwareData(
+					msg26xxm_yyyy_update_bin[i],
+					1024);
+#else
+				_DrvFwCtrlStoreFirmwareData(&
+					(msg26xxm_yyyy_update_bin[i*1024]),
+					1024);
+#endif
+			}
+		} else {
+			DBG("eSwId = 0x%x is an undefined SW ID.\n", eSwId);
+
+			eSwId = MSG26XXM_SW_ID_UNDEFINED;
+		}
+
+		if (eSwId < MSG26XXM_SW_ID_UNDEFINED &&
+			eSwId != 0x0000 && eSwId != 0xFFFF) {
+			g_FwDataCount = 0;
+
+			_gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+			_gIsUpdateInfoBlockFirst = 1;
+			g_IsUpdateFirmware = 0x11;
+			queue_work(_gUpdateFirmwareBySwIdWorkQueue,
+				&_gUpdateFirmwareBySwIdWork);
+			return;
+		}
+
+	} else {
+		nCrcInfoA =
+			_DrvFwCtrlMsg26xxmRetrieveInfoCrcFromInfoBlock();
+		nCrcInfoB =
+			_DrvFwCtrlMsg26xxmCalculateInfoCrcByDeviceDriver();
+
+		if (nCrcInfoA == nCrcInfoB) {
+			eSwId = _DrvFwCtrlMsg26xxmGetSwId(EMEM_INFO);
+
+			DBG("eSwId=0x%x\n", eSwId);
+
+		if (eSwId == MSG26XXM_SW_ID_XXXX) {
+			for (i = 0; i <
+				MSG26XXM_FIRMWARE_WHOLE_SIZE; i++)	{
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY
+					_DrvFwCtrlStoreFirmwareData(
+						msg26xxm_xxxx_update_bin[i],
+						1024);
+#else
+				_DrvFwCtrlStoreFirmwareData(&
+					(msg26xxm_xxxx_update_bin[i*1024]),
+					1024);
+#endif
+				}
+			} else if (eSwId == MSG26XXM_SW_ID_YYYY) {
+				for (i = 0; i <
+					MSG26XXM_FIRMWARE_WHOLE_SIZE; i++) {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY
+					_DrvFwCtrlStoreFirmwareData(
+						msg26xxm_yyyy_update_bin[i],
+						1024);
+#else
+				_DrvFwCtrlStoreFirmwareData(&
+					(msg26xxm_yyyy_update_bin[i*1024]),
+						1024);
+#endif
+				}
+			} else
+				eSwId = MSG26XXM_SW_ID_UNDEFINED;
+
+			if (eSwId < MSG26XXM_SW_ID_UNDEFINED &&
+				eSwId != 0x0000 && eSwId != 0xFFFF) {
+				g_FwDataCount = 0;
+
+				_gUpdateRetryCount =
+					UPDATE_FIRMWARE_RETRY_COUNT;
+				_gIsUpdateInfoBlockFirst = 0;
+				g_IsUpdateFirmware = 0x11;
+				queue_work(_gUpdateFirmwareBySwIdWorkQueue,
+					&_gUpdateFirmwareBySwIdWork);
+				return;
+			}
+		}
+	}
+
+	DrvPlatformLyrTouchDeviceResetHw();
+
+	DrvPlatformLyrEnableFingerTouchReport();
+}
+
+/*
+static s32 _DrvFwCtrlMsg28xxUpdateFirmwareBySwId(void)
+{
+	s32 nRetVal = -1;
+	u32 nCrcInfoA = 0, nCrcInfoB = 0, nCrcMainA = 0, nCrcMainB = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+
+	if (_gIsUpdateInfoBlockFirst == 1) {
+		if ((g_IsUpdateFirmware & 0x10) == 0x10) {
+			_DrvFwCtrlMsg28xxEraseEmem(EMEM_INFO);
+			_DrvFwCtrlMsg28xxProgramEmem(EMEM_INFO);
+			if (nCrcInfoA == nCrcInfoB) {
+				_DrvFwCtrlMsg28xxEraseEmem(EMEM_MAIN);
+				_DrvFwCtrlMsg28xxProgramEmem(EMEM_MAIN);
+
+				if (nCrcMainA == nCrcMainB)	{
+					g_IsUpdateFirmware = 0x00;
+					nRetVal = 0;
+				} else
+					g_IsUpdateFirmware = 0x01;
+
+			} else
+				g_IsUpdateFirmware = 0x11;
+		} else if ((g_IsUpdateFirmware & 0x01) == 0x01) {
+			_DrvFwCtrlMsg28xxEraseEmem(EMEM_MAIN);
+			_DrvFwCtrlMsg28xxProgramEmem(EMEM_MAIN);
+
+
+			if (nCrcMainA == nCrcMainB) {
+				g_IsUpdateFirmware = 0x00;
+				nRetVal = 0;
+			} else
+				g_IsUpdateFirmware = 0x01;
+		}
+	} else {
+		if ((g_IsUpdateFirmware & 0x10) == 0x10)	{
+			_DrvFwCtrlMsg28xxEraseEmem(EMEM_MAIN);
+			_DrvFwCtrlMsg28xxProgramEmem(EMEM_MAIN);
+			if (nCrcMainA == nCrcMainB) {
+				_DrvFwCtrlMsg28xxEraseEmem(EMEM_INFO);
+				_DrvFwCtrlMsg28xxProgramEmem(EMEM_INFO);
+
+
+				if (nCrcInfoA == nCrcInfoB) {
+					g_IsUpdateFirmware = 0x00;
+					nRetVal = 0;
+				} else
+					g_IsUpdateFirmware = 0x01;
+			} else
+				g_IsUpdateFirmware = 0x11;
+		} else if ((g_IsUpdateFirmware & 0x01) == 0x01) {
+			_DrvFwCtrlMsg28xxEraseEmem(EMEM_INFO);
+			_DrvFwCtrlMsg28xxProgramEmem(EMEM_INFO);
+
+			if (nCrcInfoA == nCrcInfoB) {
+				g_IsUpdateFirmware = 0x00;
+				nRetVal = 0;
+			} else
+				g_IsUpdateFirmware = 0x01;
+		}
+	}
+
+	return nRetVal;
+}
+*/
+
+void _DrvFwCtrlMsg28xxCheckFirmwareUpdateBySwId(void)
+{
+	u32 nCrcMainA, nCrcMainB;
+	u32 i;
+	u16 nUpdateBinMajor = 0, nUpdateBinMinor = 0;
+	u16 nMajor = 0, nMinor = 0;
+	u8 *pVersion = NULL;
+	Msg28xxSwId_e eMainSwId = MSG28XX_SW_ID_UNDEFINED;
+	Msg28xxSwId_e eInfoSwId = MSG28XX_SW_ID_UNDEFINED;
+	Msg28xxSwId_e eSwId = MSG28XX_SW_ID_UNDEFINED;
+
+	DrvPlatformLyrDisableFingerTouchReport();
+	nCrcMainA =
+		_DrvFwCtrlMsg28xxGetFirmwareCrcByHardware(
+		EMEM_MAIN);
+	nCrcMainB =
+		_DrvFwCtrlMsg28xxRetrieveFirmwareCrcFromEFlash(
+		EMEM_MAIN);
+
+#ifdef CONFIG_ENABLE_CODE_FOR_DEBUG
+	if (nCrcMainA != nCrcMainB) {
+		for (i = 0; i < 5; i++) {
+			nCrcMainA =
+				_DrvFwCtrlMsg28xxGetFirmwareCrcByHardware(
+				EMEM_MAIN);
+			nCrcMainB =
+				_DrvFwCtrlMsg28xxRetrieveFirmwareCrcFromEFlash(
+				EMEM_MAIN);
+			if (nCrcMainA == nCrcMainB)
+				break;
+
+			msleep(50);
+		}
+	}
+#endif
+
+	_gUpdateFirmwareBySwIdWorkQueue =
+	create_singlethread_workqueue("update_firmware_by_sw_id");
+	INIT_WORK(&_gUpdateFirmwareBySwIdWork,
+		_DrvFwCtrlUpdateFirmwareBySwIdDoWork);
+
+	if (nCrcMainA == nCrcMainB) {
+		eMainSwId = _DrvFwCtrlMsg28xxGetSwId(EMEM_MAIN);
+
+		DBG("eMainSwId=0x%x\n", eMainSwId);
+
+		eSwId = eMainSwId;
+
+		if (eSwId == MSG28XX_SW_ID_XXXX) {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY
+			nUpdateBinMajor =
+				msg28xx_xxxx_update_bin[127][1013]<<8 |
+				msg28xx_xxxx_update_bin[127][1012];
+			nUpdateBinMinor =
+				msg28xx_xxxx_update_bin[127][1015]<<8 |
+				msg28xx_xxxx_update_bin[127][1014];
+#else
+			nUpdateBinMajor =
+				msg28xx_xxxx_update_bin[0x1FFF5]<<8 |
+				msg28xx_xxxx_update_bin[0x1FFF4];
+			nUpdateBinMinor =
+				msg28xx_xxxx_update_bin[0x1FFF7]<<8 |
+				msg28xx_xxxx_update_bin[0x1FFF6];
+#endif
+		} else if (eSwId == MSG28XX_SW_ID_YYYY)	{
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY
+			nUpdateBinMajor =
+				msg28xx_yyyy_update_bin[127][1013]<<8 |
+				msg28xx_yyyy_update_bin[127][1012];
+			nUpdateBinMinor =
+				msg28xx_yyyy_update_bin[127][1015]<<8 |
+				msg28xx_yyyy_update_bin[127][1014];
+#else
+			nUpdateBinMajor =
+				msg28xx_yyyy_update_bin[0x1FFF5]<<8 |
+				msg28xx_yyyy_update_bin[0x1FFF4];
+			nUpdateBinMinor =
+				msg28xx_yyyy_update_bin[0x1FFF7]<<8 |
+				msg28xx_yyyy_update_bin[0x1FFF6];
+#endif
+		} else {
+			DBG("eSwId = 0x%x is an undefined SW ID.\n", eSwId);
+
+			eSwId = MSG28XX_SW_ID_UNDEFINED;
+			nUpdateBinMajor = 0;
+			nUpdateBinMinor = 0;
+		}
+
+		DrvFwCtrlGetCustomerFirmwareVersionByDbBus(
+			EMEM_MAIN, &nMajor, &nMinor, &pVersion);
+
+
+		if (nUpdateBinMinor > nMinor) {
+			if (eSwId == MSG28XX_SW_ID_XXXX) {
+				for (i = 0; i <
+					MSG28XX_FIRMWARE_WHOLE_SIZE; i++) {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY
+					_DrvFwCtrlStoreFirmwareData(
+					msg28xx_xxxx_update_bin[i], 1024);
+#else
+					_DrvFwCtrlStoreFirmwareData(&
+					(msg28xx_xxxx_update_bin[i*1024]),
+					1024);
+#endif
+				}
+			} else if (eSwId == MSG28XX_SW_ID_YYYY) {
+				for (i = 0; i <
+					MSG28XX_FIRMWARE_WHOLE_SIZE; i++) {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY
+					_DrvFwCtrlStoreFirmwareData(
+					msg28xx_yyyy_update_bin[i], 1024);
+#else
+					_DrvFwCtrlStoreFirmwareData(
+					&(msg28xx_yyyy_update_bin[i*1024]),
+					1024);
+#endif
+				}
+			} else {
+				DBG("eSwId = 0x%x undefined SW ID.\n", eSwId);
+
+				eSwId = MSG28XX_SW_ID_UNDEFINED;
+			}
+
+			if (eSwId < MSG28XX_SW_ID_UNDEFINED &&
+				eSwId != 0x0000 && eSwId != 0xFFFF) {
+				g_FwDataCount = 0;
+
+				_gUpdateRetryCount =
+					UPDATE_FIRMWARE_RETRY_COUNT;
+				_gIsUpdateInfoBlockFirst = 1;
+				g_IsUpdateFirmware = 0x11;
+				queue_work(_gUpdateFirmwareBySwIdWorkQueue,
+					&_gUpdateFirmwareBySwIdWork);
+				return;
+			}
+		} else
+			DBG("Go to normal boot up process.\n");
+	} else {
+		eSwId = _DrvFwCtrlMsg28xxGetSwId(EMEM_INFO);
+
+		DBG("eSwId=0x%x\n", eSwId);
+
+		if (eSwId == MSG28XX_SW_ID_XXXX) {
+			for (i = 0; i < MSG28XX_FIRMWARE_WHOLE_SIZE; i++) {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY
+				_DrvFwCtrlStoreFirmwareData(
+				msg28xx_xxxx_update_bin[i], 1024);
+#else
+				_DrvFwCtrlStoreFirmwareData(&
+				(msg28xx_xxxx_update_bin[i*1024]), 1024);
+#endif
+			}
+		} else if (eSwId == MSG28XX_SW_ID_YYYY) {
+			for (i = 0; i < MSG28XX_FIRMWARE_WHOLE_SIZE; i++) {
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_TWO_DIMENSIONAL_ARRAY
+				_DrvFwCtrlStoreFirmwareData(
+				msg28xx_yyyy_update_bin[i], 1024);
+#else
+				_DrvFwCtrlStoreFirmwareData(&
+				(msg28xx_yyyy_update_bin[i*1024]),
+				1024);
+#endif
+			}
+		} else {
+			DBG("eSwId = 0x%x is an undefined SW ID.\n", eSwId);
+
+			eSwId = MSG28XX_SW_ID_UNDEFINED;
+		}
+
+		if (eSwId < MSG28XX_SW_ID_UNDEFINED &&
+			eSwId != 0x0000 && eSwId != 0xFFFF) {
+			g_FwDataCount = 0;
+
+			_gUpdateRetryCount = UPDATE_FIRMWARE_RETRY_COUNT;
+			_gIsUpdateInfoBlockFirst = 0;
+			g_IsUpdateFirmware = 0x11;
+			queue_work(_gUpdateFirmwareBySwIdWorkQueue,
+				&_gUpdateFirmwareBySwIdWork);
+			return;
+		}
+	}
+
+	DrvPlatformLyrTouchDeviceResetHw();
+
+	DrvPlatformLyrEnableFingerTouchReport();
+}
+
+
+static void _DrvFwCtrlUpdateFirmwareBySwIdDoWork(struct work_struct *pWork)
+{
+	s32 nRetVal = 0;
+
+	if (g_ChipType == CHIP_TYPE_MSG28XX)
+		nRetVal = _DrvFwCtrlMsg28xxUpdateFirmware(g_FwData, EMEM_MAIN);
+	else {
+		DBG("(0x%x) does not support update\n", g_ChipType);
+
+		DrvPlatformLyrTouchDeviceResetHw();
+
+		DrvPlatformLyrEnableFingerTouchReport();
+
+		nRetVal = -1;
+		return;
+	}
+
+	if (nRetVal == 0) {
+		DBG("update firmware by sw id success\n");
+
+		_gIsUpdateInfoBlockFirst = 0;
+		g_IsUpdateFirmware = 0x00;
+
+		DrvPlatformLyrTouchDeviceResetHw();
+
+		DrvPlatformLyrEnableFingerTouchReport();
+	} else {
+		_gUpdateRetryCount--;
+		if (_gUpdateRetryCount > 0)	{
+			DBG("_gUpdateRetryCount = %d\n", _gUpdateRetryCount);
+			queue_work(_gUpdateFirmwareBySwIdWorkQueue,
+				&_gUpdateFirmwareBySwIdWork);
+		} else {
+			DBG("update firmware by sw id failed\n");
+
+			_gIsUpdateInfoBlockFirst = 0;
+			g_IsUpdateFirmware = 0x00;
+
+			DrvPlatformLyrTouchDeviceResetHw();
+
+			DrvPlatformLyrEnableFingerTouchReport();
+		}
+	}
+}
+
+#endif
+
+void DrvFwCtrlVariableInitialize(void)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	if (g_ChipType == CHIP_TYPE_MSG28XX) {
+		FIRMWARE_MODE_UNKNOWN_MODE = MSG28XX_FIRMWARE_MODE_UNKNOWN_MODE;
+		FIRMWARE_MODE_DEMO_MODE = MSG28XX_FIRMWARE_MODE_DEMO_MODE;
+		FIRMWARE_MODE_DEBUG_MODE = MSG28XX_FIRMWARE_MODE_DEBUG_MODE;
+/*FIRMWARE_MODE_RAW_DATA_MODE = MSG28XX_FIRMWARE_MODE_RAW_DATA_MODE;*/
+
+		g_FirmwareMode = FIRMWARE_MODE_DEMO_MODE;
+	}
+}
+
+void DrvFwCtrlOptimizeCurrentConsumption(void)
+{
+	u32 i;
+	u8 szDbBusTxData[35] = {0};
+
+	DBG("g_ChipType = 0x%x\n", g_ChipType);
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+	if (g_GestureWakeupFlag == 1)
+		return;
+#endif
+
+	if (g_ChipType == CHIP_TYPE_MSG28XX) {
+		DBG("*** %s() ***\n", __func__);
+
+		mutex_lock(&g_Mutex);
+
+
+		DrvPlatformLyrTouchDeviceResetHw();
+
+		DbBusEnterSerialDebugMode();
+		DbBusStopMCU();
+		DbBusIICUseBus();
+		DbBusIICReshape();
+
+		RegSetLByteValue(0x1608, 0x21);
+
+		szDbBusTxData[0] = 0x10;
+		szDbBusTxData[1] = 0x15;
+		szDbBusTxData[2] = 0x20;
+
+		for (i = 0; i < 8; i++)
+			szDbBusTxData[i+3] = 0xFF;
+
+		IicWriteData(SLAVE_I2C_ID_DBBUS,
+			&szDbBusTxData[0], 3+8);
+
+		szDbBusTxData[0] = 0x10;
+		szDbBusTxData[1] = 0x15;
+		szDbBusTxData[2] = 0x28;
+
+		for (i = 0; i < 16; i++)
+			szDbBusTxData[i+3] = 0x00;
+
+		IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3+16);
+
+		szDbBusTxData[0] = 0x10;
+		szDbBusTxData[1] = 0x21;
+		szDbBusTxData[2] = 0x40;
+
+		for (i = 0; i < 8; i++)
+			szDbBusTxData[i+3] = 0xFF;
+
+		IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3+8);
+
+		szDbBusTxData[0] = 0x10;
+		szDbBusTxData[1] = 0x21;
+		szDbBusTxData[2] = 0x20;
+
+		for (i = 0; i < 32; i++)
+			szDbBusTxData[i+3] = 0xFF;
+
+		IicWriteData(SLAVE_I2C_ID_DBBUS, &szDbBusTxData[0], 3+32);
+
+		RegSetLByteValue(0x1608, 0x20);
+
+		DbBusIICNotUseBus();
+		DbBusNotStopMCU();
+		DbBusExitSerialDebugMode();
+
+		mutex_unlock(&g_Mutex);
+	}
+}
+
+u8 DrvFwCtrlGetChipType(void)
+{
+	s32 rc = 0;
+	u8 nChipType = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	rc = DbBusEnterSerialDebugMode();
+	if (rc < 0) {
+		DBG("failed, rc = %d ***\n", rc);
+		return nChipType;
+	}
+	DbBusStopMCU();
+	DbBusIICUseBus();
+	DbBusIICReshape();
+
+	RegSetLByteValue(0x0FE6, 0x01);
+
+	RegSet16BitValue(0x3C60, 0xAA55);
+
+	nChipType = RegGet16BitValue(0x1ECC) & 0xFF;
+
+	if (nChipType != CHIP_TYPE_MSG28XX)
+		nChipType = 0;
+
+	DBG("*** Chip Type = 0x%x ***\n", nChipType);
+
+	/*DbBusIICNotUseBus();
+	DbBusNotStopMCU();
+	DbBusExitSerialDebugMode();*/
+	return nChipType;
+}
+
+void DrvFwCtrlGetCustomerFirmwareVersionByDbBus(enum EmemType_e eEmemType, u16
+				*pMajor, u16 *pMinor, u8 **ppVersion)
+{
+	u16 nReadAddr = 0;
+	u8	szTmpData[4] = {0};
+
+	DBG("*** %s() eEmemType = %d ***\n", __func__, eEmemType);
+
+	if (g_ChipType == CHIP_TYPE_MSG28XX) {
+		DbBusEnterSerialDebugMode();
+		DbBusStopMCU();
+		DbBusIICUseBus();
+		DbBusIICReshape();
+		msleep(100);
+
+		RegSetLByteValue(0x0FE6, 0x01);
+
+		RegSet16BitValue(0x3C60, 0xAA55);
+
+		if (eEmemType == EMEM_MAIN)	{
+			_DrvFwCtrlMsg28xxReadEFlashStart(0x7FFD, EMEM_MAIN);
+			nReadAddr = 0x7FFD;
+		} else if (eEmemType == EMEM_INFO) {
+			_DrvFwCtrlMsg28xxReadEFlashStart(0x81FB, EMEM_INFO);
+			nReadAddr = 0x81FB;
+		}
+
+		_DrvFwCtrlMsg28xxReadEFlashDoRead(nReadAddr, &szTmpData[0]);
+
+		_DrvFwCtrlMsg28xxReadEFlashEnd();
+
+		/*
+		  Ex. Major in Main Block :
+			  Major low byte at address 0x7FFD
+
+			  Major in Info Block :
+			  Major low byte at address 0x81FB
+		*/
+
+		*pMajor = (szTmpData[1] << 8);
+		*pMajor |= szTmpData[0];
+		*pMinor = (szTmpData[3] << 8);
+		*pMinor |= szTmpData[2];
+
+		if (*ppVersion == NULL)
+			*ppVersion = kzalloc(sizeof(u8)*6, GFP_KERNEL);
+
+		snprintf(*ppVersion, sizeof(*pMajor) * 2,
+			"%03d%03d", *pMajor, *pMinor);
+
+		DbBusIICNotUseBus();
+		DbBusNotStopMCU();
+		DbBusExitSerialDebugMode();
+	}
+}
+
+void DrvFwCtrlGetCustomerFirmwareVersion(
+	u16 *pMajor, u16 *pMinor, u8 **ppVersion)
+{
+	u8 szDbBusTxData[3] = {0};
+	u8 szDbBusRxData[4] = {0};
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (g_ChipType == CHIP_TYPE_MSG28XX) {
+		szDbBusTxData[0] = 0x03;
+
+		mutex_lock(&g_Mutex);
+
+		DrvPlatformLyrTouchDeviceResetHw();
+
+		IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 1);
+		IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 4);
+
+		mutex_unlock(&g_Mutex);
+	}
+
+	DBG("szDbBusRxData[0] = 0x%x\n", szDbBusRxData[0]);
+	DBG("szDbBusRxData[1] = 0x%x\n", szDbBusRxData[1]);
+	DBG("szDbBusRxData[2] = 0x%x\n", szDbBusRxData[2]);
+	DBG("szDbBusRxData[3] = 0x%x\n", szDbBusRxData[3]);
+
+	*pMajor = (szDbBusRxData[1]<<8) + szDbBusRxData[0];
+	*pMinor = (szDbBusRxData[3]<<8) + szDbBusRxData[2];
+
+	DBG("*** major = %d ***\n", *pMajor);
+	DBG("*** minor = %d ***\n", *pMinor);
+
+	if (*ppVersion == NULL)
+		*ppVersion = kzalloc(sizeof(u8)*6, GFP_KERNEL);
+
+	snprintf(*ppVersion, sizeof(*pMajor) * 2,
+		"%03d%03d", *pMajor, *pMinor);
+}
+
+void DrvFwCtrlGetPlatformFirmwareVersion(u8 **ppVersion)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	if (g_ChipType == CHIP_TYPE_MSG28XX) {
+		u8 szDbBusTxData[1] = {0};
+		u8 szDbBusRxData[10] = {0};
+
+		szDbBusTxData[0] = 0x04;
+
+		mutex_lock(&g_Mutex);
+
+		DrvPlatformLyrTouchDeviceResetHw();
+
+
+		IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 1);
+		IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 10);
+
+		mutex_unlock(&g_Mutex);
+		if (*ppVersion == NULL)
+			*ppVersion = kzalloc(sizeof(u8)*10, GFP_KERNEL);
+
+		snprintf(*ppVersion, sizeof(szDbBusRxData),
+			"%.10s", szDbBusRxData);
+	}
+
+	DBG("*** platform firmware version = %s ***\n", *ppVersion);
+}
+
+s32 DrvFwCtrlUpdateFirmware(u8 szFwData[][1024], enum EmemType_e eEmemType)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	return _DrvFwCtrlUpdateFirmwareCash(szFwData, eEmemType);
+}
+
+s32 DrvFwCtrlUpdateFirmwareBySdCard(const char *pFilePath)
+{
+	s32 nRetVal = -1;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (g_ChipType == CHIP_TYPE_MSG28XX)
+		nRetVal = _DrvFwCtrlUpdateFirmwareBySdCard(pFilePath);
+	else
+		DBG("(0x%x) does not support update firmware\n", g_ChipType);
+
+	return nRetVal;
+}
+
+
+u16 DrvFwCtrlGetFirmwareMode(void)
+{
+	u16 nMode = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	return nMode;
+}
+
+u16 DrvFwCtrlChangeFirmwareMode(u16 nMode)
+{
+	DBG("*** %s() *** nMode = 0x%x\n", __func__, nMode);
+
+	if (g_ChipType == CHIP_TYPE_MSG28XX) {
+		u8 szDbBusTxData[2] = {0};
+		u32 i = 0;
+		s32 rc;
+
+		_gIsDisableFinagerTouch = 1;
+
+		szDbBusTxData[0] = 0x02;
+		szDbBusTxData[1] = (u8)nMode;
+
+		mutex_lock(&g_Mutex);
+		while (i < 5) {
+			msleep(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+			rc = IicWriteData(SLAVE_I2C_ID_DWI2C,
+				&szDbBusTxData[0], 2);
+			if (rc > 0)	{
+				DBG("Change firmware mode success\n");
+				break;
+			}
+
+			i++;
+		}
+		if (i == 5)
+			DBG("Change firmware mode failed, rc = %d\n", rc);
+
+		DBG("*** %s() *** mutex_unlock(&g_Mutex)\n", __func__);
+		mutex_unlock(&g_Mutex);
+
+		_gIsDisableFinagerTouch = 0;
+	}
+
+	return nMode;
+}
+
+void DrvFwCtrlGetFirmwareInfo(struct FirmwareInfo_t *pInfo)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	if (g_ChipType == CHIP_TYPE_MSG28XX) {
+		u8 szDbBusTxData[1] = {0};
+		u8 szDbBusRxData[10] = {0};
+		u32 i = 0;
+		s32 rc;
+
+		_gIsDisableFinagerTouch = 1;
+
+		szDbBusTxData[0] = 0x01;
+
+		mutex_lock(&g_Mutex);
+		DBG("*** %s() *** mutex_lock(&g_Mutex)\n", __func__);
+
+		while (i < 5) {
+			msleep(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+			rc = IicWriteData(SLAVE_I2C_ID_DWI2C,
+				&szDbBusTxData[0], 1);
+
+			msleep(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+			rc = IicReadData(SLAVE_I2C_ID_DWI2C,
+				&szDbBusRxData[0], 10);
+			if (rc > 0) {
+				if (szDbBusRxData[1]
+					== FIRMWARE_MODE_DEMO_MODE ||
+					szDbBusRxData[1] ==
+					FIRMWARE_MODE_DEBUG_MODE)
+					break;
+
+			}
+
+			i++;
+		}
+		if (i == 5)
+			DBG("Get firmware info failed, rc = %d\n", rc);
+
+		DBG("*** %s() *** mutex_unlock(&g_Mutex)\n", __func__);
+		mutex_unlock(&g_Mutex);
+
+		if ((szDbBusRxData[1] ==
+			FIRMWARE_MODE_DEBUG_MODE && szDbBusRxData[2]
+			== 0xA7 && szDbBusRxData[5]
+			== PACKET_TYPE_TOOTH_PATTERN)
+			|| (szDbBusRxData[1]
+			== FIRMWARE_MODE_DEMO_MODE &&
+			szDbBusRxData[2] == 0x5A)) {
+			pInfo->nFirmwareMode = szDbBusRxData[1];
+			DBG("pInfo->nFirmwareMode = 0x%x\n",
+				pInfo->nFirmwareMode);
+
+			pInfo->nLogModePacketHeader = szDbBusRxData[2];
+			pInfo->nLogModePacketLength =
+				(szDbBusRxData[3]<<8) + szDbBusRxData[4];
+			pInfo->nType = szDbBusRxData[5];
+			pInfo->nMy = szDbBusRxData[6];
+			pInfo->nMx = szDbBusRxData[7];
+			pInfo->nSd = szDbBusRxData[8];
+			pInfo->nSs = szDbBusRxData[9];
+
+			DBG("pInfo->nLogModePacketHeader = 0x%x\n",
+				pInfo->nLogModePacketHeader);
+			DBG("pInfo->nLogModePacketLength = %d\n",
+				pInfo->nLogModePacketLength);
+			DBG("pInfo->nType = 0x%x\n", pInfo->nType);
+			DBG("pInfo->nMy = %d\n", pInfo->nMy);
+			DBG("pInfo->nMx = %d\n", pInfo->nMx);
+			DBG("pInfo->nSd = %d\n", pInfo->nSd);
+			DBG("pInfo->nSs = %d\n", pInfo->nSs);
+		} else {
+			DBG("Firmware info before correcting :\n");
+
+			DBG("FirmwareMode = 0x%x\n", szDbBusRxData[1]);
+			DBG("LogModePacketHeader = 0x%x\n", szDbBusRxData[2]);
+			DBG("LogModePacketLength = %d\n",
+				(szDbBusRxData[3]<<8) + szDbBusRxData[4]);
+			DBG("Type = 0x%x\n", szDbBusRxData[5]);
+			DBG("My = %d\n", szDbBusRxData[6]);
+			DBG("Mx = %d\n", szDbBusRxData[7]);
+			DBG("Sd = %d\n", szDbBusRxData[8]);
+			DBG("Ss = %d\n", szDbBusRxData[9]);
+
+			pInfo->nFirmwareMode = FIRMWARE_MODE_DEMO_MODE;
+			pInfo->nLogModePacketHeader = 0x5A;
+			pInfo->nLogModePacketLength = DEMO_MODE_PACKET_LENGTH;
+			pInfo->nType = 0;
+			pInfo->nMy = 0;
+			pInfo->nMx = 0;
+			pInfo->nSd = 0;
+			pInfo->nSs = 0;
+
+			DBG("Firmware info after correcting :\n");
+
+			DBG("pInfo->nFirmwareMode = 0x%x\n",
+				pInfo->nFirmwareMode);
+			DBG("pInfo->nLogModePacketHeader = 0x%x\n",
+				pInfo->nLogModePacketHeader);
+			DBG("pInfo->nLogModePacketLength = %d\n",
+				pInfo->nLogModePacketLength);
+			DBG("pInfo->nType = 0x%x\n", pInfo->nType);
+			DBG("pInfo->nMy = %d\n", pInfo->nMy);
+			DBG("pInfo->nMx = %d\n", pInfo->nMx);
+			DBG("pInfo->nSd = %d\n", pInfo->nSd);
+			DBG("pInfo->nSs = %d\n", pInfo->nSs);
+		}
+
+		_gIsDisableFinagerTouch = 0;
+	}
+}
+
+void DrvFwCtrlRestoreFirmwareModeToLogDataMode(void)
+{
+	if (g_ChipType == CHIP_TYPE_MSG28XX) {
+		if (g_IsSwitchModeByAPK == 1) {
+			struct FirmwareInfo_t tInfo;
+
+			memset(&tInfo, 0x0, sizeof(struct FirmwareInfo_t));
+
+			DrvFwCtrlGetFirmwareInfo(&tInfo);
+
+
+			if (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE &&
+				FIRMWARE_MODE_DEBUG_MODE != tInfo.nFirmwareMode)
+				g_FirmwareMode =
+				DrvFwCtrlChangeFirmwareMode(
+				FIRMWARE_MODE_DEBUG_MODE);
+			else
+				DBG("firmware mode is not restored\n");
+		}
+	}
+}
+
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+
+void DrvFwCtrlCheckFirmwareUpdateBySwId(void)
+{
+	if (g_ChipType == CHIP_TYPE_MSG28XX)
+		_DrvFwCtrlMsg28xxCheckFirmwareUpdateBySwId();
+}
+#endif
+
+
+#ifdef CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+void DrvFwCtrlGetTouchPacketAddress(u16 *pDataAddress, u16 *pFlagAddress)
+{
+	s32 rc = 0;
+	u32 i = 0;
+	u8 szDbBusTxData[1] = {0};
+	u8 szDbBusRxData[4] = {0};
+
+	DBG("*** %s() ***\n", __func__);
+
+	szDbBusTxData[0] = 0x05;
+
+	mutex_lock(&g_Mutex);
+	DBG("*** %s() *** mutex_lock(&g_Mutex)\n", __func__);
+
+	while (i < 5) {
+		msleep(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+		rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 1);
+		if (rc > 0)
+			DBG("Get touch packet address success\n");
+
+		msleep(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+		rc = IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 4);
+		if (rc > 0) {
+			DBG("Get touch packet address IicReadData() success\n");
+			break;
+		}
+
+		i++;
+	}
+	if (i == 5)
+		DBG("Get touch packet address failed, rc = %d\n", rc);
+
+	if (rc < 0)
+		g_FwSupportSegment = 0;
+	else {
+		*pDataAddress = (szDbBusRxData[0]<<8) + szDbBusRxData[1];
+		*pFlagAddress = (szDbBusRxData[2]<<8) + szDbBusRxData[3];
+
+		g_FwSupportSegment = 1;
+
+		DBG("*** *pDataAddress = 0x%2X ***\n", *pDataAddress);
+		DBG("*** *pFlagAddress = 0x%2X ***\n", *pFlagAddress);
+	}
+
+	DBG("*** %s() *** mutex_unlock(&g_Mutex)\n", __func__);
+	mutex_unlock(&g_Mutex);
+}
+
+static int _DrvFwCtrlCheckFingerTouchPacketFlagBit1(void)
+{
+	u8 szDbBusTxData[3] = {0};
+	s32 nRetVal;
+
+	DBG("*** %s() ***\n", __func__);
+
+	szDbBusTxData[0] = 0x53;
+	szDbBusTxData[1] = (g_FwPacketFlagAddress >> 8) & 0xFF;
+	szDbBusTxData[2] = g_FwPacketFlagAddress & 0xFF;
+
+	IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+	IicReadData(SLAVE_I2C_ID_DWI2C, &_gTouchPacketFlag[0], 2);
+
+	if ((_gTouchPacketFlag[0] & BIT1) == 0x00)
+		nRetVal = 0;
+	else
+		nRetVal = 1;
+	DBG("Bit1 = %d\n", nRetVal);
+
+	return nRetVal;
+}
+
+static void _DrvFwCtrlResetFingerTouchPacketFlagBit1(void)
+{
+	u8 szDbBusTxData[4] = {0};
+
+	DBG("*** %s() ***\n", __func__);
+
+	szDbBusTxData[0] = 0x52;
+	szDbBusTxData[1] = (g_FwPacketFlagAddress >> 8) & 0xFF;
+	szDbBusTxData[2] = g_FwPacketFlagAddress & 0xFF;
+	szDbBusTxData[3] = _gTouchPacketFlag[0] | BIT1;
+
+	IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 4);
+}
+#endif
+
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+
+s32 DrvFwCtrlEnableProximity(void)
+{
+	u8 szDbBusTxData[4] = {0};
+	s32 rc;
+
+	DBG("*** %s() ***\n", __func__);
+
+	szDbBusTxData[0] = 0x52;
+	szDbBusTxData[1] = 0x00;
+
+	if (g_ChipType == CHIP_TYPE_MSG28XX)
+		szDbBusTxData[2] = 0x47;
+	else
+		return -EINVAL;
+
+	szDbBusTxData[3] = 0xa0;
+
+	mutex_lock(&g_Mutex);
+
+	msleep(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+	rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 4);
+	if (rc > 0) {
+		g_EnableTpProximity = 1;
+
+		DBG("Enable proximity detection success\n");
+	} else
+		DBG("Enable proximity detection failed\n");
+
+	mutex_unlock(&g_Mutex);
+
+	return rc;
+}
+
+s32 DrvFwCtrlDisableProximity(void)
+{
+	u8 szDbBusTxData[4] = {0};
+	s32 rc;
+
+	DBG("*** %s() ***\n", __func__);
+
+	szDbBusTxData[0] = 0x52;
+	szDbBusTxData[1] = 0x00;
+
+	if (g_ChipType == CHIP_TYPE_MSG28XX)
+		szDbBusTxData[2] = 0x47;
+	else
+		return -EINVAL;
+
+	szDbBusTxData[3] = 0xa1;
+
+	mutex_lock(&g_Mutex);
+
+	msleep(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+	rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 4);
+	if (rc > 0)
+		g_EnableTpProximity = 0;
+	else
+		DBG("Disable proximity detection failed\n");
+
+	g_FaceClosingTp = 0;
+
+	mutex_unlock(&g_Mutex);
+
+	return rc;
+}
+
+#endif
+
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+void DrvFwCtrlOpenGloveMode(void)
+{
+	s32 rc = 0;
+	u8 szDbBusTxData[3] = {0};
+	u32 i = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	_gIsDisableFinagerTouch = 1;
+
+	szDbBusTxData[0] = 0x06;
+	szDbBusTxData[1] = 0x01;
+	szDbBusTxData[2] = 0x01;
+
+	mutex_lock(&g_Mutex);
+
+	while (i < 5) {
+		msleep(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+		rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+		if (rc > 0) {
+			DBG("Open glove mode success\n");
+			break;
+		}
+
+		i++;
+	}
+	if (i == 5)
+		DBG("Open glove mode failed, rc = %d\n", rc);
+
+	mutex_unlock(&g_Mutex);
+
+	_gIsDisableFinagerTouch = 0;
+}
+
+void DrvFwCtrlCloseGloveMode(void)
+{
+	s32 rc = 0;
+	u8 szDbBusTxData[3] = {0};
+	u32 i = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	_gIsDisableFinagerTouch = 1;
+
+	szDbBusTxData[0] = 0x06;
+	szDbBusTxData[1] = 0x01;
+	szDbBusTxData[2] = 0x00;
+
+	mutex_lock(&g_Mutex);
+
+	while (i < 5) {
+		msleep(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+		rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+		if (rc > 0)
+			break;
+
+		i++;
+	}
+	if (i == 5)
+		DBG("Close glove mode failed, rc = %d\n", rc);
+
+	mutex_unlock(&g_Mutex);
+
+	_gIsDisableFinagerTouch = 0;
+}
+
+void DrvFwCtrlGetGloveInfo(u8 *pGloveMode)
+{
+	u8 szDbBusTxData[3] = {0};
+	u8 szDbBusRxData[2] = {0};
+	u32 i = 0;
+	s32 rc;
+
+	_gIsDisableFinagerTouch = 1;
+
+	szDbBusTxData[0] = 0x06;
+	szDbBusTxData[1] = 0x01;
+	szDbBusTxData[2] = 0x02;
+
+	mutex_lock(&g_Mutex);
+
+	while (i < 5) {
+		msleep(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+		rc = IicWriteData(SLAVE_I2C_ID_DWI2C, &szDbBusTxData[0], 3);
+		if (rc > 0)
+			DBG("Get glove info IicWriteData() success\n");
+
+		msleep(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+		rc = IicReadData(SLAVE_I2C_ID_DWI2C, &szDbBusRxData[0], 1);
+		if (rc > 0) {
+			DBG("Get glove info IicReadData() success\n");
+
+			if (szDbBusRxData[0] == 0x00 ||
+				szDbBusRxData[0] == 0x01)
+				break;
+			/*else
+				i = 0;*/
+		}
+
+		i++;
+	}
+	if (i == 5)
+		DBG("Get glove info failed, rc = %d\n", rc);
+
+	mutex_unlock(&g_Mutex);
+
+	*pGloveMode = szDbBusRxData[0];
+
+	DBG("pGloveMode = 0x%x\n", *pGloveMode);
+
+	_gIsDisableFinagerTouch = 0;
+}
+
+#endif
+
+#ifdef CONFIG_ENABLE_CHARGER_DETECTION
+
+void DrvFwCtrlChargerDetection(u8 nChargerStatus)
+{
+	u32 i = 0;
+	u8 szDbBusTxData[2] = {0};
+	s32 rc = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+
+	mutex_lock(&g_Mutex);
+
+	szDbBusTxData[0] = 0x09;
+
+	if (nChargerStatus) {
+		if (_gChargerPlugIn == 0 || g_ForceUpdate == 1)	{
+			szDbBusTxData[1] = 0xA5;
+
+			while (i < 5) {
+				msleep(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+				rc = IicWriteData(SLAVE_I2C_ID_DWI2C,
+					&szDbBusTxData[0], 2);
+				if (rc > 0) {
+					_gChargerPlugIn = 1;
+
+					DBG("Update success.\n");
+					break;
+				}
+
+				i++;
+			}
+			if (i == 5)
+				DBG("Update failed, rc = %d\n", rc);
+
+			g_ForceUpdate = 0;
+		}
+	} else {
+		if (_gChargerPlugIn == 1 || g_ForceUpdate == 1)	{
+			szDbBusTxData[1] = 0x5A;
+
+			while (i < 5) {
+				msleep(I2C_WRITE_COMMAND_DELAY_FOR_FIRMWARE);
+				rc = IicWriteData(SLAVE_I2C_ID_DWI2C,
+					&szDbBusTxData[0], 2);
+				if (rc > 0)	{
+					_gChargerPlugIn = 0;
+
+					break;
+				}
+
+				i++;
+			}
+			if (i == 5)
+				DBG("Update status failed, rc = %d\n", rc);
+
+			g_ForceUpdate = 0;
+		}
+	}
+
+	mutex_unlock(&g_Mutex);
+}
+
+#endif
+
+
+static s32 _DrvFwCtrlReadFingerTouchData(u8 *pPacket, u16 nReportPacketLength)
+{
+	s32 rc;
+
+	if (IS_FIRMWARE_DATA_LOG_ENABLED) {
+		if (g_FirmwareMode == FIRMWARE_MODE_DEMO_MODE) {
+			rc = IicReadData(SLAVE_I2C_ID_DWI2C,
+				&pPacket[0], nReportPacketLength);
+			if (rc < 0)
+				return -EINVAL;
+		} else if (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE) {
+#ifdef CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+
+			if (g_FwSupportSegment == 0)
+				return -EINVAL;
+
+			if (_gIsDisableFinagerTouch == 1)
+				return -EINVAL;
+
+			rc = IicSegmentReadDataBySmBus(g_FwPacketDataAddress,
+					&pPacket[0], nReportPacketLength,
+					MAX_I2C_TRANSACTION_LENGTH_LIMIT);
+
+			_DrvFwCtrlCheckFingerTouchPacketFlagBit1();
+			_DrvFwCtrlResetFingerTouchPacketFlagBit1();
+
+			if (rc < 0) {
+				DBG("I2C read  failed, rc = %d\n", rc);
+				return -EINVAL;
+			}
+
+#else
+			rc = IicReadData(SLAVE_I2C_ID_DWI2C,
+			&pPacket[0], nReportPacketLength);
+			if (rc < 0) {
+				DBG("read data failed, rc = %d\n", rc);
+				return -EINVAL;
+			}
+#endif
+		} else {
+			DBG("WRONG FIRMWARE MODE : 0x%x\n", g_FirmwareMode);
+			return -EINVAL;
+		}
+	} else {
+		rc = IicReadData(SLAVE_I2C_ID_DWI2C,
+			&pPacket[0], nReportPacketLength);
+		if (rc < 0) {
+			DBG("I2C read packet data failed, rc = %d\n", rc);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+
+void DrvFwCtrlHandleFingerTouch(void)
+{
+	struct TouchInfo_t tInfo;
+	u32 i = 0;
+	static u32 nLastKeyCode = 0xFF;
+	static u32 nLastCount;
+	u8 *pPacket = NULL;
+	u16 nReportPacketLength = 0;
+
+	if (_gIsDisableFinagerTouch == 1) {
+		DBG("Skip finger touch  or change firmware mode\n");
+		return;
+	}
+
+	mutex_lock(&g_Mutex);
+	DBG("*** %s() *** mutex_lock(&g_Mutex)\n", __func__);
+
+	memset(&tInfo, 0x0, sizeof(struct TouchInfo_t));
+
+	if (IS_FIRMWARE_DATA_LOG_ENABLED) {
+		if (g_FirmwareMode == FIRMWARE_MODE_DEMO_MODE) {
+				DBG("FIRMWARE_MODE_DEMO_MODE\n");
+
+				nReportPacketLength = DEMO_MODE_PACKET_LENGTH;
+				pPacket = g_DemoModePacket;
+		} else if (g_FirmwareMode == FIRMWARE_MODE_DEBUG_MODE) {
+			DBG("FIRMWARE_MODE_DEBUG_MODE\n");
+
+		if (g_FirmwareInfo.nLogModePacketHeader != 0xA5 &&
+			g_FirmwareInfo.nLogModePacketHeader != 0xAB &&
+			g_FirmwareInfo.nLogModePacketHeader != 0xA7)
+				goto TouchHandleEnd;
+
+			{
+				nReportPacketLength =
+					g_FirmwareInfo.nLogModePacketLength;
+				pPacket = g_LogModePacket;
+			}
+		} else {
+			DBG("WRONG FIRMWARE MODE : 0x%x\n", g_FirmwareMode);
+			goto TouchHandleEnd;
+		}
+	} else {
+		{
+			DBG("FIRMWARE_MODE_DEMO_MODE\n");
+
+			nReportPacketLength = DEMO_MODE_PACKET_LENGTH;
+			pPacket = g_DemoModePacket;
+		}
+	}
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+	if (g_GestureDebugMode == 1 && g_GestureWakeupFlag == 1) {
+		DBG("Set gesture debug mode g_ChipType=%d\n", g_ChipType);
+
+		if (g_ChipType == CHIP_TYPE_MSG28XX) {
+			nReportPacketLength = GESTURE_DEBUG_MODE_PACKET_LENGTH;
+			pPacket = _gGestureWakeupPacket;
+		} else {
+			DBG("not support gesture debug mode.\n");
+			goto TouchHandleEnd;
+		}
+	} else if (g_GestureWakeupFlag == 1) {
+		DBG("Set gesture wakeup packet length\n");
+
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+		nReportPacketLength = GESTURE_WAKEUP_INFORMATION_PACKET_LENGTH;
+#else
+		nReportPacketLength = GESTURE_WAKEUP_PACKET_LENGTH;
+#endif
+
+		pPacket = _gGestureWakeupPacket;
+	}
+
+#else
+
+	if (g_GestureWakeupFlag == 1) {
+		DBG("Set gesture wakeup packet length\n");
+
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+		nReportPacketLength = GESTURE_WAKEUP_INFORMATION_PACKET_LENGTH;
+#else
+		nReportPacketLength = GESTURE_WAKEUP_PACKET_LENGTH;
+#endif
+
+		pPacket = _gGestureWakeupPacket;
+	}
+#endif
+
+#endif
+
+	if (0 != _DrvFwCtrlReadFingerTouchData(&pPacket[0],
+		nReportPacketLength))
+		goto TouchHandleEnd;
+
+	if (0 == _DrvFwCtrlParsePacket(pPacket, nReportPacketLength, &tInfo)) {
+#ifdef CONFIG_TP_HAVE_KEY
+		if (tInfo.nKeyCode != 0xFF) {
+			if (tInfo.nKeyCode < MAX_KEY_NUM) {
+				if (tInfo.nKeyCode != nLastKeyCode)	{
+					DBG("key touch pressed\n");
+
+					input_report_key(g_InputDevice,
+						BTN_TOUCH, 1);
+				input_report_key(g_InputDevice,
+					g_TpVirtualKey[tInfo.nKeyCode], 1);
+
+					input_sync(g_InputDevice);
+
+					nLastKeyCode = tInfo.nKeyCode;
+				} else
+					DBG("REPEATED KEY\n");
+			} else
+				DBG("WRONG KEY\n");
+		} else {
+			if (nLastKeyCode != 0xFF) {
+				DBG("key touch released\n");
+
+				input_report_key(g_InputDevice, BTN_TOUCH, 0);
+				input_report_key(g_InputDevice,
+					g_TpVirtualKey[nLastKeyCode], 0);
+
+				input_sync(g_InputDevice);
+
+				nLastKeyCode = 0xFF;
+			}
+		}
+#endif
+
+		DBG("tInfo.nCount = %d, nLastCount = %d\n",
+			tInfo.nCount, nLastCount);
+
+		if (tInfo.nCount > 0) {
+			for (i = 0; i < tInfo.nCount; i++)
+				DrvPlatformLyrFingerTouchPressed(
+						tInfo.tPoint[i].nX,
+						tInfo.tPoint[i].nY,
+						tInfo.tPoint[i].nP,
+						tInfo.tPoint[i].nId);
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+		for (i = 0; i < MAX_TOUCH_NUM; i++) {
+			if (_gCurrentTouch[i] == 0 && _gPreviousTouch[i] == 1)
+				DrvPlatformLyrFingerTouchReleased(0, 0, i);
+			_gPreviousTouch[i] = _gCurrentTouch[i];
+		}
+
+			input_mt_sync_frame(g_InputDevice);
+#endif
+
+			input_sync(g_InputDevice);
+
+			nLastCount = tInfo.nCount;
+		} else {
+		if (nLastCount > 0) {
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+			for (i = 0; i < MAX_TOUCH_NUM; i++) {
+				if (_gCurrentTouch[i] == 0
+					&& _gPreviousTouch[i] == 1)
+					DrvPlatformLyrFingerTouchReleased(
+						0, 0, i);
+					_gPreviousTouch[i] = _gCurrentTouch[i];
+			}
+
+				input_mt_sync_frame(g_InputDevice);
+#else
+				DrvPlatformLyrFingerTouchReleased(0, 0, 0);
+#endif
+
+				input_sync(g_InputDevice);
+
+				nLastCount = 0;
+			}
+		}
+
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+		if (g_IsEnableReportRate == 1) {
+			if (g_ValidTouchCount == 4294967296) {
+				g_ValidTouchCount = 0;
+				DBG("g_ValidTouchCount reset to 0\n");
+			}
+
+			g_ValidTouchCount++;
+
+			DBG("g_ValidTouchCount = %d\n", g_ValidTouchCount);
+		}
+#endif
+	}
+
+TouchHandleEnd:
+	DBG("*** %s() *** mutex_unlock(&g_Mutex)\n", __func__);
+	mutex_unlock(&g_Mutex);
+}
diff --git a/drivers/input/touchscreen/msg28xx/mstar_drv_mutual_fw_control.h b/drivers/input/touchscreen/msg28xx/mstar_drv_mutual_fw_control.h
new file mode 100644
index 0000000..63d2684
--- /dev/null
+++ b/drivers/input/touchscreen/msg28xx/mstar_drv_mutual_fw_control.h
@@ -0,0 +1,251 @@
+/************************************************************
+//
+// Copyright (c) 2006-2016 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses,
+//costs and expenses resulting therefrom.
+//
+********************************************************************/
+
+/**
+ *
+ * @file	mstar_drv_mutual_fw_control.h
+ *
+ * @brief	This file defines the interface of touch screen
+ *
+ *
+ */
+
+#ifndef __MSTAR_DRV_MUTUAL_FW_CONTROL_H__
+#define __MSTAR_DRV_MUTUAL_FW_CONTROL_H__
+
+
+#include "mstar_drv_common.h"
+
+#define DEMO_MODE_PACKET_LENGTH    (43)
+#define MAX_TOUCH_NUM			(10)
+
+#define MSG26XXM_FIRMWARE_MAIN_BLOCK_SIZE (32) /*32K*/
+#define MSG26XXM_FIRMWARE_INFO_BLOCK_SIZE (8)
+#define MSG26XXM_FIRMWARE_WHOLE_SIZE	\
+	(MSG26XXM_FIRMWARE_MAIN_BLOCK_SIZE + \
+	MSG26XXM_FIRMWARE_INFO_BLOCK_SIZE)
+
+#define MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE (128)
+#define MSG28XX_FIRMWARE_INFO_BLOCK_SIZE (2)
+#define MSG28XX_FIRMWARE_WHOLE_SIZE\
+	(MSG28XX_FIRMWARE_MAIN_BLOCK_SIZE +\
+	MSG28XX_FIRMWARE_INFO_BLOCK_SIZE)
+
+#define MSG28XX_EMEM_SIZE_BYTES_PER_ONE_PAGE  (128)
+#define MSG28XX_EMEM_SIZE_BYTES_ONE_WORD  (4)
+
+#define MSG28XX_EMEM_MAIN_MAX_ADDR	(0x3FFF)
+#define MSG28XX_EMEM_INFO_MAX_ADDR	(0x1FF)
+
+
+#define MSG26XXM_FIRMWARE_MODE_UNKNOWN_MODE (0xFFFF)
+#define MSG26XXM_FIRMWARE_MODE_DEMO_MODE	(0x0005)
+#define MSG26XXM_FIRMWARE_MODE_DEBUG_MODE	(0x0105)
+
+#define MSG28XX_FIRMWARE_MODE_UNKNOWN_MODE (0xFF)
+#define MSG28XX_FIRMWARE_MODE_DEMO_MODE    (0x00)
+#define MSG28XX_FIRMWARE_MODE_DEBUG_MODE   (0x01)
+
+
+#define DEBUG_MODE_PACKET_LENGTH	(1280)
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+#define UPDATE_FIRMWARE_RETRY_COUNT (2)
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#ifdef CONFIG_ENABLE_GESTURE_INFORMATION_MODE
+#define FIRMWARE_GESTURE_INFORMATION_MODE_A	(0x00)
+#define FIRMWARE_GESTURE_INFORMATION_MODE_B	(0x01)
+#define FIRMWARE_GESTURE_INFORMATION_MODE_C	(0x02)
+#endif
+#endif
+
+
+struct TouchPoint_t {
+	u16 nId;
+	u16 nX;
+	u16 nY;
+	u16 nP;
+};
+
+struct TouchInfo_t {
+	u8 nCount;
+	u8 nKeyCode;
+	struct TouchPoint_t tPoint[MAX_TOUCH_NUM];
+};
+
+struct FirmwareInfo_t {
+	u16 nFirmwareMode;
+	u8 nType;
+	u8 nLogModePacketHeader;
+	u8 nMy;
+	u8 nMx;
+	u8 nSd;
+	u8 nSs;
+	u16 nLogModePacketLength;
+};
+
+
+extern u32 SLAVE_I2C_ID_DBBUS;
+extern u32 SLAVE_I2C_ID_DWI2C;
+
+#ifdef CONFIG_TP_HAVE_KEY
+extern const int g_TpVirtualKey[];
+
+#endif
+
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+extern struct input_dev *g_ProximityInputDevice;
+#endif
+
+
+extern struct input_dev *g_InputDevice;
+
+extern u8 g_FwData[MAX_UPDATE_FIRMWARE_BUFFER_SIZE][1024];
+extern u32 g_FwDataCount;
+
+extern struct mutex g_Mutex;
+
+extern u16 FIRMWARE_MODE_UNKNOWN_MODE;
+extern u16 FIRMWARE_MODE_DEMO_MODE;
+extern u16 FIRMWARE_MODE_DEBUG_MODE;
+extern u16 FIRMWARE_MODE_RAW_DATA_MODE;
+
+extern struct kobject *g_TouchKObj;
+extern u8 g_IsSwitchModeByAPK;
+
+extern u8 IS_FIRMWARE_DATA_LOG_ENABLED;
+extern u8 IS_FORCE_TO_UPDATE_FIRMWARE_ENABLED;
+
+#ifdef CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+extern u16 g_FwPacketDataAddress;
+extern u16 g_FwPacketFlagAddress;
+
+extern u8 g_FwSupportSegment;
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+extern struct kobject *g_GestureKObj;
+#endif
+#endif
+
+#ifdef CONFIG_ENABLE_COUNT_REPORT_RATE
+extern u32 g_IsEnableReportRate;
+extern u32 g_InterruptCount;
+extern u32 g_ValidTouchCount;
+
+extern struct timeval g_StartTime;
+#endif
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+/*
+ * Note.
+ * 0x0000 and 0xFFFF are not allowed to be defined as SW ID.
+ * SW_ID_UNDEFINED is a reserved enum value, do not delete it or modify it.
+ * Please modify the SW ID of the below enum
+ * value depends on the TP vendor that you are using.
+ */
+/*typedef enum {
+	MSG26XXM_SW_ID_XXXX = 0x0001,
+	MSG26XXM_SW_ID_YYYY = 0x0002,
+	MSG26XXM_SW_ID_UNDEFINED
+} Msg26xxmSwId_e;*/
+enum Msg26xxmSwId_e {
+		MSG26XXM_SW_ID_XXXX = 0x0001,
+		MSG26XXM_SW_ID_YYYY = 0x0002,
+		MSG26XXM_SW_ID_UNDEFINED
+};
+
+/*
+ * Note.
+ * 0x0000 and 0xFFFF are not allowed to be defined as SW ID.
+ * SW_ID_UNDEFINED is a reserved enum value, do not delete it or modify it.
+ * Please modify the SW ID of the below enum
+ * value depends on the TP vendor that you are using.
+ */
+enum Msg28xxSwId_e {
+	MSG28XX_SW_ID_XXXX = 0x0001,
+	MSG28XX_SW_ID_YYYY = 0x0002,
+	MSG28XX_SW_ID_UNDEFINED
+};
+#endif
+
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern void DrvFwCtrlOpenGestureWakeup(u32 *pMode);
+extern void DrvFwCtrlCloseGestureWakeup(void);
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+extern void DrvFwCtrlOpenGestureDebugMode(u8 nGestureFlag);
+extern void DrvFwCtrlCloseGestureDebugMode(void);
+#endif
+
+#endif
+
+extern u32 DrvFwCtrlReadDQMemValue(u16 nAddr);
+extern void DrvFwCtrlWriteDQMemValue(u16 nAddr, u32 nData);
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+extern void DrvFwCtrlCheckFirmwareUpdateBySwId(void);
+#endif
+
+extern u16 DrvFwCtrlChangeFirmwareMode(u16 nMode);
+extern void DrvFwCtrlGetFirmwareInfo(struct FirmwareInfo_t *pInfo);
+extern u16 DrvFwCtrlGetFirmwareMode(void);
+extern void DrvFwCtrlRestoreFirmwareModeToLogDataMode(void);
+
+#ifdef CONFIG_ENABLE_SEGMENT_READ_FINGER_TOUCH_DATA
+extern void DrvFwCtrlGetTouchPacketAddress(
+		u16 *pDataAddress, u16 *pFlagAddress);
+#endif
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+extern s32 DrvFwCtrlEnableProximity(void);
+extern s32 DrvFwCtrlDisableProximity(void);
+#endif
+
+extern void DrvFwCtrlVariableInitialize(void);
+extern void DrvFwCtrlOptimizeCurrentConsumption(void);
+extern u8 DrvFwCtrlGetChipType(void);
+extern void DrvFwCtrlGetCustomerFirmwareVersionByDbBus(
+	enum EmemType_e eEmemType,
+	u16 *pMajor, u16 *pMinor, u8 **ppVersion);
+extern void DrvFwCtrlGetCustomerFirmwareVersion(u16 *pMajor,
+			u16 *pMinor, u8 **ppVersion);
+extern void DrvFwCtrlGetPlatformFirmwareVersion(u8 **ppVersion);
+extern void DrvFwCtrlHandleFingerTouch(void);
+extern s32 DrvFwCtrlUpdateFirmware(u8 szFwData[][1024],
+	enum EmemType_e eEmemType);
+extern s32 DrvFwCtrlUpdateFirmwareBySdCard(const char *pFilePath);
+
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+extern void DrvFwCtrlOpenGloveMode(void);
+extern void DrvFwCtrlCloseGloveMode(void);
+extern void DrvFwCtrlGetGloveInfo(u8 *pGloveMode);
+#endif
+
+#ifdef CONFIG_ENABLE_CHARGER_DETECTION
+extern void DrvFwCtrlChargerDetection(u8 nChargerStatus);
+#endif
+
+
+#endif	/* __MSTAR_DRV_MUTUAL_FW_CONTROL_H__ */
diff --git a/drivers/input/touchscreen/msg28xx/mstar_drv_platform_interface.c b/drivers/input/touchscreen/msg28xx/mstar_drv_platform_interface.c
new file mode 100644
index 0000000..c154f59
--- /dev/null
+++ b/drivers/input/touchscreen/msg28xx/mstar_drv_platform_interface.c
@@ -0,0 +1,305 @@
+/*************************************************************
+//
+// Copyright (c) 2006-2016 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses,
+// costs and expenses resulting therefrom.
+//
+**************************************************************/
+
+/**
+ *
+ * @file	mstar_drv_platform_interface.c
+ *
+ * @brief	This file defines the interface of touch screen
+ *
+ *
+ */
+
+
+#include "mstar_drv_platform_interface.h"
+#include "mstar_drv_main.h"
+#include "mstar_drv_ic_fw_porting_layer.h"
+#include "mstar_drv_platform_porting_layer.h"
+#include "mstar_drv_utility_adaption.h"
+
+
+#ifdef CONFIG_ENABLE_NOTIFIER_FB
+int MsDrvInterfaceTouchDeviceFbNotifierCallback(struct notifier_block *pSelf,
+					unsigned long nEvent, void *pData)
+{
+	struct fb_event *pEventData = pData;
+	int *pBlank;
+
+	if (pEventData && pEventData->data && nEvent == FB_EVENT_BLANK) {
+		pBlank = pEventData->data;
+
+		if (*pBlank == FB_BLANK_UNBLANK) {
+			DBG("*** %s() TP Resume ***\n", __func__);
+#ifdef MAOYQ
+				_MsgSuspended = 0;
+#endif
+
+			if (g_IsUpdateFirmware != 0)
+				return 0;
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+			if (g_EnableTpProximity == 1)
+				return 0;
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+			{
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+			if (g_GestureDebugMode == 1)
+				DrvIcFwLyrCloseGestureDebugMode();
+#endif
+
+			if (g_GestureWakeupFlag == 1)
+				DrvIcFwLyrCloseGestureWakeup();
+			else
+				DrvPlatformLyrEnableFingerTouchReport();
+			}
+#endif
+
+			{
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+				DrvPlatformLyrTouchDeviceRegulatorPowerOn(true);
+#endif
+				DrvPlatformLyrTouchDevicePowerOn();
+			}
+
+#ifdef CONFIG_ENABLE_CHARGER_DETECTION
+			{
+				u8 szChargerStatus[20] = {0};
+
+				DrvCommonReadFile(
+					"/sys/class/power_supply/battery/status",
+					szChargerStatus, 20);
+
+				g_ForceUpdate = 1;
+
+		if (strnstr(szChargerStatus, "Charging") != NULL ||
+			strnstr(szChargerStatus, "Full") != NULL ||
+			strnstr(szChargerStatus, "Fullycharged") != NULL)
+				DrvFwCtrlChargerDetection(1);
+		else
+				DrvFwCtrlChargerDetection(0);
+				g_ForceUpdate = 0;
+			}
+#endif
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+			if (g_IsEnableGloveMode == 1)
+				DrvIcFwLyrOpenGloveMode();
+#endif
+
+			if (IS_FIRMWARE_DATA_LOG_ENABLED)
+				DrvIcFwLyrRestoreFirmwareModeToLogDataMode();
+
+#ifndef CONFIG_ENABLE_GESTURE_WAKEUP
+			DrvPlatformLyrEnableFingerTouchReport();
+#endif
+		} else if (*pBlank == FB_BLANK_POWERDOWN) {
+			DBG("*** %s() TP Suspend ***\n", __func__);
+
+#ifdef MAOYQ
+				_MsgSuspended = 1;
+#endif
+			if (g_IsUpdateFirmware != 0)
+				return 0;
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+			if (g_EnableTpProximity == 1)
+				return 0;
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+		{
+			if (g_GestureWakeupMode[0] != 0x00000000
+				|| g_GestureWakeupMode[1] != 0x00000000) {
+				DrvIcFwLyrOpenGestureWakeup(
+					&g_GestureWakeupMode[0]);
+				return 0;
+			}
+		}
+#endif
+
+			DrvPlatformLyrFingerTouchReleased(0, 0, 0);
+			input_sync(g_InputDevice);
+
+			DrvPlatformLyrDisableFingerTouchReport();
+
+			DrvPlatformLyrTouchDevicePowerOff();
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+			DrvPlatformLyrTouchDeviceRegulatorPowerOn(false);
+#endif
+		}
+	}
+
+	return 0;
+}
+
+#else
+
+void MsDrvInterfaceTouchDeviceSuspend(struct early_suspend *pSuspend)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	if (g_IsUpdateFirmware != 0)
+		return;
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+	if (g_EnableTpProximity == 1) {
+		DBG("g_EnableTpProximity = %d\n", g_EnableTpProximity);
+		return;
+	}
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+	{
+		if (g_GestureWakeupMode[0] != 0x00000000
+			|| g_GestureWakeupMode[1] != 0x00000000) {
+			DrvIcFwLyrOpenGestureWakeup(&g_GestureWakeupMode[0]);
+			return;
+		}
+	}
+#endif
+
+
+
+	DrvPlatformLyrFingerTouchReleased(0, 0, 0);
+	input_sync(g_InputDevice);
+
+	DrvPlatformLyrDisableFingerTouchReport();
+
+		DrvPlatformLyrTouchDevicePowerOff();
+}
+
+void MsDrvInterfaceTouchDeviceResume(struct early_suspend *pSuspend)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	if (g_IsUpdateFirmware != 0)
+		return;
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+	if (g_EnableTpProximity == 1) {
+		DBG("g_EnableTpProximity = %d\n", g_EnableTpProximity);
+		return;
+	}
+#endif
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+	{
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+		if (g_GestureDebugMode == 1)
+			DrvIcFwLyrCloseGestureDebugMode();
+#endif
+
+		if (g_GestureWakeupFlag == 1)
+			DrvIcFwLyrCloseGestureWakeup();
+		else
+			DrvPlatformLyrEnableFingerTouchReport();
+	}
+#endif
+
+	{
+		DrvPlatformLyrTouchDevicePowerOn();
+	}
+
+#ifdef CONFIG_ENABLE_CHARGER_DETECTION
+	{
+		u8 szChargerStatus[20] = {0};
+
+		DrvCommonReadFile("/sys/class/power_supply/battery/status",
+			szChargerStatus, 20);
+
+		DBG("*** Battery Status : %s ***\n", szChargerStatus);
+
+		g_ForceUpdate = 1;
+
+		if (strnstr(szChargerStatus, "Charging") != NULL ||
+			strnstr(szChargerStatus, "Full") != NULL ||
+			strnstr(szChargerStatus, "Fullycharged") != NULL)
+			DrvFwCtrlChargerDetection(1);
+		else
+			DrvFwCtrlChargerDetection(0);
+
+		g_ForceUpdate = 0;
+	}
+#endif
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+	if (g_IsEnableGloveMode == 1)
+		DrvIcFwLyrOpenGloveMode();
+#endif
+
+	if (IS_FIRMWARE_DATA_LOG_ENABLED)
+		DrvIcFwLyrRestoreFirmwareModeToLogDataMode();
+
+#ifndef CONFIG_ENABLE_GESTURE_WAKEUP
+	DrvPlatformLyrEnableFingerTouchReport();
+#endif
+}
+
+#endif
+
+/* probe function is used for matching and initializing input device */
+s32 MsDrvInterfaceTouchDeviceProbe(struct i2c_client *pClient,
+			const struct i2c_device_id *pDeviceId)
+{
+	s32 nRetVal = 0;
+
+	DBG("*** %s() ***\n", __func__);
+	DrvPlatformLyrInputDeviceInitialize(pClient);
+	DrvPlatformLyrTouchDeviceRequestGPIO(pClient);
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+	DrvPlatformLyrTouchDeviceRegulatorPowerOn(true);
+#endif
+
+	DrvPlatformLyrTouchDevicePowerOn();
+
+
+	nRetVal = DrvMainTouchDeviceInitialize();
+	if (nRetVal == -ENODEV) {
+		DrvPlatformLyrTouchDeviceRemove(pClient);
+		return nRetVal;
+	}
+	DrvPlatformLyrTouchDeviceRegisterFingerTouchInterruptHandler();
+
+	DrvPlatformLyrTouchDeviceRegisterEarlySuspend();
+
+#ifdef CONFIG_UPDATE_FIRMWARE_BY_SW_ID
+	DrvIcFwLyrCheckFirmwareUpdateBySwId();
+#endif
+
+	DBG("*** MStar touch driver registered ***\n");
+
+	return nRetVal;
+}
+
+s32 MsDrvInterfaceTouchDeviceRemove(struct i2c_client *pClient)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	return DrvPlatformLyrTouchDeviceRemove(pClient);
+}
+
+void
+MsDrvInterfaceTouchDeviceSetIicDataRate(
+struct i2c_client *pClient, u32 nIicDataRate)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	DrvPlatformLyrSetIicDataRate(pClient, nIicDataRate);
+}
diff --git a/drivers/input/touchscreen/msg28xx/mstar_drv_platform_interface.h b/drivers/input/touchscreen/msg28xx/mstar_drv_platform_interface.h
new file mode 100644
index 0000000..2c855f5
--- /dev/null
+++ b/drivers/input/touchscreen/msg28xx/mstar_drv_platform_interface.h
@@ -0,0 +1,87 @@
+/*******************************************************************
+//
+// Copyright (c) 2006-2016 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages,
+// losses, costs and expenses resulting therefrom.
+//
+***********************************************************************/
+/**
+ *
+ * @file    mstar_drv_platform_interface.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+#ifndef __MSTAR_DRV_PLATFORM_INTERFACE_H__
+#define __MSTAR_DRV_PLATFORM_INTERFACE_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include "mstar_drv_common.h"
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL FUNCTION DECLARATION                                              */
+/*--------------------------------------------------------------------------*/
+#ifdef MAOYQ
+extern u8 _MsgSuspended;
+
+#endif
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+extern u32 g_GestureWakeupMode[2];
+extern u8 g_GestureWakeupFlag;
+
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+extern u8 g_GestureDebugFlag;
+extern u8 g_GestureDebugMode;
+#endif
+
+#endif
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+extern u8 g_EnableTpProximity;
+#endif
+
+#ifdef CONFIG_ENABLE_GLOVE_MODE
+extern u8 g_IsEnableGloveMode;
+#endif
+
+extern u8 g_IsUpdateFirmware;
+
+extern struct input_dev *g_InputDevice;
+
+
+#ifdef CONFIG_ENABLE_CHARGER_DETECTION
+extern u8 g_ForceUpdate;
+#endif
+
+extern u8 IS_FIRMWARE_DATA_LOG_ENABLED;
+
+extern s32 MsDrvInterfaceTouchDeviceProbe(struct i2c_client
+*pClient, const struct i2c_device_id *pDeviceId);
+extern s32 MsDrvInterfaceTouchDeviceRemove(struct i2c_client *pClient);
+#ifdef CONFIG_ENABLE_NOTIFIER_FB
+extern int MsDrvInterfaceTouchDeviceFbNotifierCallback(struct notifier_block
+		*pSelf, unsigned long nEvent, void *pData);
+#else
+extern void MsDrvInterfaceTouchDeviceResume(struct early_suspend *pSuspend);
+extern void MsDrvInterfaceTouchDeviceSuspend(struct early_suspend *pSuspend);
+#endif
+extern void MsDrvInterfaceTouchDeviceSetIicDataRate(struct i2c_client *pClient,
+		u32 nIicDataRate);
+
+#endif  /* __MSTAR_DRV_PLATFORM_INTERFACE_H__ */
diff --git a/drivers/input/touchscreen/msg28xx/mstar_drv_platform_porting_layer.c b/drivers/input/touchscreen/msg28xx/mstar_drv_platform_porting_layer.c
new file mode 100644
index 0000000..484d2a6
--- /dev/null
+++ b/drivers/input/touchscreen/msg28xx/mstar_drv_platform_porting_layer.c
@@ -0,0 +1,810 @@
+/*****************************************************
+//
+// Copyright (c) 2006-2016 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses,
+// costs and expenses resulting therefrom.
+//
+******************************************************/
+/**
+ *
+ * @file	mstar_drv_platform_porting_layer.c
+ *
+ * @brief	This file defines the interface of touch screen
+ *
+ *
+ */
+#include "mstar_drv_ic_fw_porting_layer.h"
+#include "mstar_drv_platform_interface.h"
+#include "mstar_drv_utility_adaption.h"
+#include "mstar_drv_main.h"
+
+
+#ifdef CONFIG_ENABLE_JNI_INTERFACE
+#include "mstar_drv_jni_interface.h"
+#endif
+
+
+struct mutex g_Mutex;
+spinlock_t _gIrqLock;
+
+static struct work_struct _gFingerTouchWork;
+static int _gInterruptFlag;
+
+#ifdef CONFIG_ENABLE_NOTIFIER_FB
+static struct notifier_block _gFbNotifier;
+#else
+static struct early_suspend _gEarlySuspend;
+#endif
+
+#ifdef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+static int _gGpioReset;
+static int _gGpioIrq;
+static int MS_TS_MSG_IC_GPIO_RST;
+static int MS_TS_MSG_IC_GPIO_INT;
+
+static struct pinctrl *_gTsPinCtrl;
+static struct pinctrl_state *_gPinCtrlStateActive;
+static struct pinctrl_state *_gPinCtrlStateSuspend;
+static struct pinctrl_state *_gPinCtrlStateRelease;
+#endif
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+static struct sensors_classdev _gProximityCdev;
+
+static struct sensors_classdev sensors_proximity_cdev = {
+	.name = "msg2xxx-proximity",
+	.vendor = "MStar",
+	.version = 1,
+	.handle = SENSORS_PROXIMITY_HANDLE,
+	.type = SENSOR_TYPE_PROXIMITY,
+	.max_range = "5.0",
+	.resolution = "5.0",
+	.sensor_power = "0.1",
+	.min_delay = 0,
+	.fifo_reserved_event_count = 0,
+	.fifo_max_event_count = 0,
+	.enabled = 0,
+	.delay_msec = 200,
+	.sensors_enable = NULL,
+	.sensors_poll_delay = NULL,
+};
+#endif
+
+#ifdef CONFIG_TP_HAVE_KEY
+const int g_TpVirtualKey[] = {
+		TOUCH_KEY_MENU, TOUCH_KEY_HOME,
+		TOUCH_KEY_BACK, TOUCH_KEY_SEARCH
+};
+
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+struct kobject *g_PropertiesKObj = NULL;
+#endif
+#endif
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+struct input_dev *g_ProximityInputDevice = NULL;
+#endif
+
+struct input_dev *g_InputDevice = NULL;
+static int _gIrq = -1;
+
+/*#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+int DrvPlatformLyrTpPsEnable(struct sensors_classdev *pProximityCdev,
+unsigned int nEnable);
+#endif*/
+
+static void _DrvPlatformLyrFingerTouchDoWork(struct work_struct *pWork)
+{
+	unsigned long nIrqFlag;
+
+	DBG("*** %s() ***\n", __func__);
+
+	DrvIcFwLyrHandleFingerTouch(NULL, 0);
+
+	DBG("*** %s() _gInterruptFlag = %d ***\n", __func__, _gInterruptFlag);
+
+	spin_lock_irqsave(&_gIrqLock, nIrqFlag);
+
+
+	if (_gInterruptFlag == 0) {
+		enable_irq(_gIrq);
+
+		_gInterruptFlag = 1;
+	}
+
+
+	spin_unlock_irqrestore(&_gIrqLock, nIrqFlag);
+}
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+
+static ssize_t _DrvPlatformLyrProximityDetectionShow(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, "%s\n", g_EnableTpProximity ? "open" : "close");
+}
+
+static ssize_t _DrvPlatformLyrProximityDetectionStore(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	if (buf != NULL) {
+		if (sysfs_streq(buf, "1"))
+			DrvPlatformLyrTpPsEnable(&_gProximityCdev, 1);
+		else if (sysfs_streq(buf, "0"))
+			DrvPlatformLyrTpPsEnable(&_gProximityCdev, 0);
+	}
+
+	return size;
+}
+
+static struct device_attribute proximity_attribute =
+		__ATTR(proximity, 0666/*0664*/,
+		_DrvPlatformLyrProximityDetectionShow,
+		_DrvPlatformLyrProximityDetectionStore);
+
+static struct attribute *proximity_detection_attrs[] = {
+	&proximity_attribute.attr,
+	NULL
+};
+
+static struct attribute_group proximity_detection_attribute_group = {
+	.name = "Driver",
+	.attrs = proximity_detection_attrs,
+};
+
+static int _DrvPlatformLyrProximityInputDeviceInit(struct i2c_client *pClient)
+{
+	int nRetVal = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	g_ProximityInputDevice = input_allocate_device();
+	if (g_ProximityInputDevice == NULL) {
+		DBG("*** Failed to allocate proximity input device ***\n");
+		nRetVal = -ENOMEM;
+		goto ERROR_INPUT_DEVICE_ALLOCATE_FAILED;
+	}
+
+	g_ProximityInputDevice->name = "msg2xxx-ps";
+	g_ProximityInputDevice->phys = "I2C";
+	g_ProximityInputDevice->dev.parent = &pClient->dev;
+	g_ProximityInputDevice->id.bustype = BUS_I2C;
+
+	set_bit(EV_ABS, g_ProximityInputDevice->evbit);
+
+	input_set_abs_params(g_ProximityInputDevice, ABS_DISTANCE, 0, 1, 0, 0);
+
+	nRetVal = input_register_device(g_ProximityInputDevice);
+	if (nRetVal < 0) {
+		DBG("*** Unable to register nRetVal=%d\n", nRetVal);
+		goto ERROR_INPUT_DEVICE_REGISTER_FAILED;
+	}
+
+	/*mdelay(10);*/
+	msleep(20);
+	nRetVal = sysfs_create_group(&g_ProximityInputDevice->dev.kobj,
+			&proximity_detection_attribute_group);
+	if (nRetVal < 0) {
+		DBG("*** Failed to proximity nRetVal=%d\n", nRetVal);
+		goto ERROR_SYSFS_CREATE_GROUP_FAILED;
+	}
+
+	input_set_drvdata(g_ProximityInputDevice, NULL);
+
+	sensors_proximity_cdev.sensors_enable = DrvPlatformLyrTpPsEnable;
+	nRetVal =
+	sensors_classdev_register(&pClient->dev, &sensors_proximity_cdev);
+	if (nRetVal < 0) {
+		DBG("*** Failed for proximity *** nRetVal=%d\n", nRetVal);
+		goto ERROR_SENSORS_CLASSDEV_REGISTER_FAILED;
+	}
+
+	return 0;
+
+ERROR_SENSORS_CLASSDEV_REGISTER_FAILED:
+ERROR_SYSFS_CREATE_GROUP_FAILED:
+	if (g_ProximityInputDevice) {
+		input_unregister_device(g_ProximityInputDevice);
+		g_ProximityInputDevice = NULL;
+	}
+ERROR_INPUT_DEVICE_REGISTER_FAILED:
+	if (g_ProximityInputDevice) {
+		input_free_device(g_ProximityInputDevice);
+		g_ProximityInputDevice = NULL;
+	}
+ERROR_INPUT_DEVICE_ALLOCATE_FAILED:
+
+	return nRetVal;
+}
+
+static int _DrvPlatformLyrProximityInputDeviceUnInit(void)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	if (g_ProximityInputDevice)	{
+		input_unregister_device(g_ProximityInputDevice);
+		g_ProximityInputDevice = NULL;
+	}
+
+	return 0;
+}
+
+#endif
+
+
+#ifdef CONFIG_TP_HAVE_KEY
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+static ssize_t _DrvPlatformLyrVirtualKeysShow(struct kobject *kobj,
+			struct kobj_attribute *attr, char *buf)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	return snprintf(buf,
+		__stringify(EV_KEY) ":"
+		__stringify(KEY_HOMEPAGE) ":50:1330:100:100:"
+		__stringify(EV_KEY) ":"
+		__stringify(KEY_MENU) ":150:1330:100:100:"
+		__stringify(EV_KEY) ":"
+		__stringify(KEY_BACK) ":250:1330:100:100:"
+		__stringify(EV_KEY) ":"
+		__stringify(KEY_SEARCH) ":350:1330:100:100\n");
+}
+
+static struct kobj_attribute virtual_keys_attr = {
+	.attr = {
+		.name = "virtualkeys.msg2xxx_ts",
+		.mode = S_IRUGO,
+	},
+	.show = &_DrvPlatformLyrVirtualKeysShow,
+};
+
+static struct attribute *properties_attrs[] = {
+	&virtual_keys_attr.attr,
+	NULL
+};
+
+static struct attribute_group properties_attr_group = {
+	.attrs = properties_attrs,
+};
+
+static void _DrvPlatformLyrVirtualKeysInit(void)
+{
+	s32 nRetVal = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	g_PropertiesKObj = kobject_create_and_add("board_properties", NULL);
+	if (g_PropertiesKObj == NULL)
+		return;
+
+	nRetVal = sysfs_create_group(g_PropertiesKObj, &properties_attr_group);
+	if (nRetVal < 0) {
+		kobject_put(g_PropertiesKObj);
+		g_PropertiesKObj = NULL;
+	}
+}
+
+static void _DrvPlatformLyrVirtualKeysUnInit(void)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	if (g_PropertiesKObj) {
+		kobject_put(g_PropertiesKObj);
+		g_PropertiesKObj = NULL;
+	}
+}
+#endif
+#endif
+
+#ifdef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+static s32 _DrvPlatformLyrTouchPinCtrlInit(struct i2c_client *pClient)
+{
+	s32 nRetVal = 0;
+	u32 nFlag = 0;
+	struct device_node *pDeviceNode = pClient->dev.of_node;
+
+	DBG("*** %s() ***\n", __func__);
+	_gGpioReset = of_get_named_gpio_flags(pDeviceNode,
+			"mstar,reset-gpio", 0, &nFlag);
+	MS_TS_MSG_IC_GPIO_RST = _gGpioReset;
+
+	if (_gGpioReset < 0)
+		return _gGpioReset;
+
+	_gGpioIrq = of_get_named_gpio_flags(pDeviceNode,
+				"mstar,irq-gpio", 0, &nFlag);
+
+	MS_TS_MSG_IC_GPIO_INT = _gGpioIrq;
+
+	DBG("_gGpioReset = %d, _gGpioIrq = %d\n", _gGpioReset, _gGpioIrq);
+
+	if (_gGpioIrq < 0)
+		return _gGpioIrq;
+
+	/* Get pinctrl if target uses pinctrl */
+	_gTsPinCtrl = devm_pinctrl_get(&(pClient->dev));
+	if (IS_ERR_OR_NULL(_gTsPinCtrl)) {
+		nRetVal = PTR_ERR(_gTsPinCtrl);
+		DBG("Target does not use pinctrl nRetVal=%d\n", nRetVal);
+		goto ERROR_PINCTRL_GET;
+	}
+
+	_gPinCtrlStateActive =
+		pinctrl_lookup_state(_gTsPinCtrl, PINCTRL_STATE_ACTIVE);
+	if (IS_ERR_OR_NULL(_gPinCtrlStateActive)) {
+		nRetVal = PTR_ERR(_gPinCtrlStateActive);
+		goto ERROR_PINCTRL_LOOKUP;
+	}
+
+	_gPinCtrlStateSuspend =
+		pinctrl_lookup_state(_gTsPinCtrl, PINCTRL_STATE_SUSPEND);
+	if (IS_ERR_OR_NULL(_gPinCtrlStateSuspend)) {
+		nRetVal = PTR_ERR(_gPinCtrlStateSuspend);
+		goto ERROR_PINCTRL_LOOKUP;
+	}
+
+	_gPinCtrlStateRelease =
+		pinctrl_lookup_state(_gTsPinCtrl, PINCTRL_STATE_RELEASE);
+	if (IS_ERR_OR_NULL(_gPinCtrlStateRelease)) {
+		nRetVal = PTR_ERR(_gPinCtrlStateRelease);
+		DBG("Can not lookup %s pinstate nRetVal=%d\n",
+				PINCTRL_STATE_RELEASE, nRetVal);
+	}
+
+	pinctrl_select_state(_gTsPinCtrl, _gPinCtrlStateActive);
+
+	return 0;
+
+ERROR_PINCTRL_LOOKUP:
+	devm_pinctrl_put(_gTsPinCtrl);
+ERROR_PINCTRL_GET:
+	_gTsPinCtrl = NULL;
+
+	return nRetVal;
+}
+
+static void _DrvPlatformLyrTouchPinCtrlUnInit(void)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	if (_gTsPinCtrl) {
+		devm_pinctrl_put(_gTsPinCtrl);
+		_gTsPinCtrl = NULL;
+	}
+}
+#endif
+
+/* The interrupt service routine will be triggered when interrupt occurred */
+static irqreturn_t
+_DrvPlatformLyrFingerTouchInterruptHandler(s32 nIrq, void *pDeviceId)
+{
+	unsigned long nIrqFlag;
+
+	DBG("*** %s() ***\n", __func__);
+
+	spin_lock_irqsave(&_gIrqLock, nIrqFlag);
+
+	if (_gInterruptFlag == 1) {
+		disable_irq_nosync(g_I2cClient->irq);
+		_gInterruptFlag = 0;
+
+		schedule_work(&_gFingerTouchWork);
+	}
+
+	spin_unlock_irqrestore(&_gIrqLock, nIrqFlag);
+
+	return IRQ_HANDLED;
+}
+
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+void DrvPlatformLyrTouchDeviceRegulatorPowerOn(bool nFlag)
+{
+	s32 nRetVal = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (nFlag == true) {
+		nRetVal = regulator_enable(g_ReguVdd);
+		/*mdelay(20);*/
+		msleep(20);
+
+		nRetVal = regulator_enable(g_ReguVcc_i2c);
+		/*mdelay(20);*/
+		msleep(20);
+	} else {
+		nRetVal = regulator_disable(g_ReguVdd);
+		/*mdelay(20);*/
+		msleep(20);
+
+		nRetVal = regulator_disable(g_ReguVcc_i2c);
+		/*mdelay(20);*/
+		msleep(20);
+	}
+}
+#endif
+
+void DrvPlatformLyrTouchDevicePowerOn(void)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	gpio_direction_output(MS_TS_MSG_IC_GPIO_RST, 1);
+	udelay(100);
+	gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 0);
+	udelay(100);
+	gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 1);
+	/*mdelay(25);*/
+	msleep(25);
+}
+
+void DrvPlatformLyrTouchDevicePowerOff(void)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	DrvIcFwLyrOptimizeCurrentConsumption();
+
+	gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 0);
+}
+
+void DrvPlatformLyrTouchDeviceResetHw(void)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	gpio_direction_output(MS_TS_MSG_IC_GPIO_RST, 1);
+	udelay(100);
+	gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 0);
+	udelay(100);
+	gpio_set_value(MS_TS_MSG_IC_GPIO_RST, 1);
+	msleep(25);
+}
+
+void DrvPlatformLyrDisableFingerTouchReport(void)
+{
+	unsigned long nIrqFlag;
+
+	DBG("*** %s() ***\n", __func__);
+
+	DBG("*** %s() _gInterruptFlag = %d ***\n", __func__, _gInterruptFlag);
+
+	spin_lock_irqsave(&_gIrqLock, nIrqFlag);
+
+
+		if (_gInterruptFlag == 1) {
+			disable_irq(_gIrq);
+
+			_gInterruptFlag = 0;
+		}
+
+	spin_unlock_irqrestore(&_gIrqLock, nIrqFlag);
+}
+
+void DrvPlatformLyrEnableFingerTouchReport(void)
+{
+	unsigned long nIrqFlag;
+
+	DBG("*** %s() ***\n", __func__);
+
+	DBG("*** %s() _gInterruptFlag = %d ***\n", __func__, _gInterruptFlag);
+
+	spin_lock_irqsave(&_gIrqLock, nIrqFlag);
+
+
+	if (_gInterruptFlag == 0) {
+		enable_irq(_gIrq);
+
+		_gInterruptFlag = 1;
+	}
+
+	spin_unlock_irqrestore(&_gIrqLock, nIrqFlag);
+}
+
+void DrvPlatformLyrFingerTouchPressed(s32 nX, s32 nY, s32 nPressure, s32 nId)
+{
+	DBG("*** %s() ***\n", __func__);
+	DBG("point touch pressed\n");
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+	input_mt_slot(g_InputDevice, nId);
+	input_mt_report_slot_state(g_InputDevice, MT_TOOL_FINGER, true);
+	input_report_abs(g_InputDevice, ABS_MT_TOUCH_MAJOR, 1);
+	input_report_abs(g_InputDevice, ABS_MT_WIDTH_MAJOR, 1);
+	input_report_abs(g_InputDevice, ABS_MT_POSITION_X, nX);
+	input_report_abs(g_InputDevice, ABS_MT_POSITION_Y, nY);
+#ifdef CONFIG_ENABLE_FORCE_TOUCH
+	input_report_abs(g_InputDevice, ABS_MT_PRESSURE, nPressure);
+#endif
+
+#else
+	input_report_key(g_InputDevice, BTN_TOUCH, 1);
+	input_report_abs(g_InputDevice, ABS_MT_TRACKING_ID, nId);
+	input_report_abs(g_InputDevice, ABS_MT_TOUCH_MAJOR, 1);
+	input_report_abs(g_InputDevice, ABS_MT_WIDTH_MAJOR, 1);
+	input_report_abs(g_InputDevice, ABS_MT_POSITION_X, nX);
+	input_report_abs(g_InputDevice, ABS_MT_POSITION_Y, nY);
+#ifdef CONFIG_ENABLE_FORCE_TOUCH
+	input_report_abs(g_InputDevice, ABS_MT_PRESSURE, nPressure);
+#endif
+
+	input_mt_sync(g_InputDevice);
+#endif
+
+
+}
+
+void DrvPlatformLyrFingerTouchReleased(s32 nX, s32 nY, s32 nId)
+{
+	DBG("*** %s() ***\n", __func__);
+	DBG("point touch released\n");
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+	input_mt_slot(g_InputDevice, nId);
+	input_mt_report_slot_state(g_InputDevice, MT_TOOL_FINGER, false);
+
+#else
+	input_report_key(g_InputDevice, BTN_TOUCH, 0);
+	input_mt_sync(g_InputDevice);
+#endif
+
+
+}
+
+s32 DrvPlatformLyrInputDeviceInitialize(struct i2c_client *pClient)
+{
+	s32 nRetVal = 0;
+#ifdef CONFIG_TP_HAVE_KEY
+		u32 i;
+#endif
+	DBG("*** %s() ***\n", __func__);
+
+	mutex_init(&g_Mutex);
+	spin_lock_init(&_gIrqLock);
+
+	/* allocate an input device */
+	g_InputDevice = input_allocate_device();
+	if (g_InputDevice == NULL) {
+		DBG("*** Failed to allocate touch input device ***\n");
+		return -ENOMEM;
+	}
+
+	g_InputDevice->name = pClient->name;
+	g_InputDevice->phys = "I2C";
+	g_InputDevice->dev.parent = &pClient->dev;
+	g_InputDevice->id.bustype = BUS_I2C;
+
+	/* set the supported event type for input device */
+	set_bit(EV_ABS, g_InputDevice->evbit);
+	set_bit(EV_SYN, g_InputDevice->evbit);
+	set_bit(EV_KEY, g_InputDevice->evbit);
+	set_bit(BTN_TOUCH, g_InputDevice->keybit);
+	set_bit(INPUT_PROP_DIRECT, g_InputDevice->propbit);
+
+#ifdef CONFIG_TP_HAVE_KEY
+		for (i = 0; i < MAX_KEY_NUM; i++)
+			input_set_capability(g_InputDevice,
+					EV_KEY, g_TpVirtualKey[i]);
+
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+	_DrvPlatformLyrVirtualKeysInit();
+#endif
+#endif
+
+/*
+#ifdef CONFIG_TP_HAVE_KEY
+	// Method 2.
+	set_bit(TOUCH_KEY_MENU, g_InputDevice->keybit); //Menu
+	set_bit(TOUCH_KEY_HOME, g_InputDevice->keybit); //Home
+	set_bit(TOUCH_KEY_BACK, g_InputDevice->keybit); //Back
+	set_bit(TOUCH_KEY_SEARCH, g_InputDevice->keybit); //Search
+#endif
+*/
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+	input_set_capability(g_InputDevice, EV_KEY, KEY_POWER);
+	input_set_capability(g_InputDevice, EV_KEY, KEY_UP);
+	input_set_capability(g_InputDevice, EV_KEY, KEY_DOWN);
+	input_set_capability(g_InputDevice, EV_KEY, KEY_LEFT);
+	input_set_capability(g_InputDevice, EV_KEY, KEY_RIGHT);
+	input_set_capability(g_InputDevice, EV_KEY, KEY_W);
+	input_set_capability(g_InputDevice, EV_KEY, KEY_Z);
+	input_set_capability(g_InputDevice, EV_KEY, KEY_V);
+	input_set_capability(g_InputDevice, EV_KEY, KEY_O);
+	input_set_capability(g_InputDevice, EV_KEY, KEY_M);
+	input_set_capability(g_InputDevice, EV_KEY, KEY_C);
+	input_set_capability(g_InputDevice, EV_KEY, KEY_E);
+	input_set_capability(g_InputDevice, EV_KEY, KEY_S);
+#endif
+	input_set_abs_params(g_InputDevice, ABS_MT_TRACKING_ID, 0,
+						(MAX_TOUCH_NUM-1), 0, 0);
+	input_set_abs_params(g_InputDevice, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(g_InputDevice, ABS_MT_WIDTH_MAJOR, 0, 15, 0, 0);
+	input_set_abs_params(g_InputDevice, ABS_MT_POSITION_X,
+			TOUCH_SCREEN_X_MIN, TOUCH_SCREEN_X_MAX, 0, 0);
+	input_set_abs_params(g_InputDevice, ABS_MT_POSITION_Y,
+			TOUCH_SCREEN_Y_MIN, TOUCH_SCREEN_Y_MAX, 0, 0);
+#ifdef CONFIG_ENABLE_FORCE_TOUCH
+	input_set_abs_params(g_InputDevice, ABS_MT_PRESSURE, 0, 255, 0, 0);
+#endif
+
+#ifdef CONFIG_ENABLE_TYPE_B_PROTOCOL
+	input_mt_init_slots(g_InputDevice,
+		MAX_TOUCH_NUM, INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);
+#endif
+
+	/* register the input device to input sub-system */
+	nRetVal = input_register_device(g_InputDevice);
+	if (nRetVal < 0) {
+		DBG("*** Unable to register nRetVal=%d\n", nRetVal);
+		return nRetVal;
+	}
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+	nRetVal = _DrvPlatformLyrProximityInputDeviceInit(pClient);
+#endif
+
+	return nRetVal;
+}
+
+s32 DrvPlatformLyrTouchDeviceRequestGPIO(struct i2c_client *pClient)
+{
+	s32 nRetVal = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+
+#ifdef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+	_DrvPlatformLyrTouchPinCtrlInit(pClient);
+#endif
+
+	nRetVal = gpio_request(MS_TS_MSG_IC_GPIO_RST, "C_TP_RST");
+
+	nRetVal = gpio_request(MS_TS_MSG_IC_GPIO_INT, "C_TP_INT");
+	return nRetVal;
+}
+
+s32 DrvPlatformLyrTouchDeviceRegisterFingerTouchInterruptHandler(void)
+{
+	s32 nRetVal = 0;
+
+	DBG("*** %s() ***\n", __func__);
+
+	if (DrvIcFwLyrIsRegisterFingerTouchInterruptHandler()) {
+		INIT_WORK(&_gFingerTouchWork, _DrvPlatformLyrFingerTouchDoWork);
+		_gIrq = gpio_to_irq(MS_TS_MSG_IC_GPIO_INT);
+
+		/* request an irq and register the isr */
+
+		nRetVal = request_threaded_irq(_gIrq, NULL,
+			_DrvPlatformLyrFingerTouchInterruptHandler,
+			IRQF_TRIGGER_RISING | IRQF_ONESHOT,
+					"msg2xxx", NULL);
+
+
+		_gInterruptFlag = 1;
+
+	}
+
+	return nRetVal;
+}
+void DrvPlatformLyrTouchDeviceRegisterEarlySuspend(void)
+{
+	DBG("*** %s() ***\n", __func__);
+
+#ifdef CONFIG_ENABLE_NOTIFIER_FB
+	_gFbNotifier.notifier_call =
+		MsDrvInterfaceTouchDeviceFbNotifierCallback;
+	fb_register_client(&_gFbNotifier);
+#else
+	_gEarlySuspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
+	_gEarlySuspend.suspend = MsDrvInterfaceTouchDeviceSuspend;
+	_gEarlySuspend.resume = MsDrvInterfaceTouchDeviceResume;
+	register_early_suspend(&_gEarlySuspend);
+#endif
+}
+
+s32 DrvPlatformLyrTouchDeviceRemove(struct i2c_client *pClient)
+{
+	DBG("*** %s() ***\n", __func__);
+
+	free_irq(_gIrq, g_InputDevice);
+	gpio_free(MS_TS_MSG_IC_GPIO_INT);
+	gpio_free(MS_TS_MSG_IC_GPIO_RST);
+
+	if (g_InputDevice) {
+		input_unregister_device(g_InputDevice);
+		g_InputDevice = NULL;
+	}
+
+#ifdef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+	_DrvPlatformLyrTouchPinCtrlUnInit();
+#endif
+
+#ifdef CONFIG_TP_HAVE_KEY
+#ifdef CONFIG_ENABLE_REPORT_KEY_WITH_COORDINATE
+	_DrvPlatformLyrVirtualKeysUnInit();
+#endif
+#endif
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+	_DrvPlatformLyrProximityInputDeviceUnInit();
+#endif
+
+	if (IS_FIRMWARE_DATA_LOG_ENABLED) {
+		if (g_TouchKSet) {
+			kset_unregister(g_TouchKSet);
+			g_TouchKSet = NULL;
+		}
+
+		if (g_TouchKObj) {
+			kobject_put(g_TouchKObj);
+			g_TouchKObj = NULL;
+		}
+	}
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+	if (g_GestureKSet) {
+		kset_unregister(g_GestureKSet);
+		g_GestureKSet = NULL;
+	}
+
+	if (g_GestureKObj) {
+		kobject_put(g_GestureKObj);
+		g_GestureKObj = NULL;
+	}
+#endif
+#endif
+
+	DrvMainRemoveProcfsDirEntry();
+
+
+#ifdef CONFIG_ENABLE_JNI_INTERFACE
+	DeleteMsgToolMem();
+#endif
+
+
+	return 0;
+}
+
+void DrvPlatformLyrSetIicDataRate(struct i2c_client *pClient, u32 nIicDataRate)
+{
+	DBG("*** %s() nIicDataRate = %d ***\n", __func__, nIicDataRate);
+
+}
+
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+
+int DrvPlatformLyrGetTpPsData(void)
+{
+	DBG("*** %s() g_FaceClosingTp = %d ***\n", __func__, g_FaceClosingTp);
+	return g_FaceClosingTp;
+}
+
+int DrvPlatformLyrTpPsEnable(struct sensors_classdev *pProximityCdev, unsigned
+						int nEnable)
+{
+	DBG("*** %s() nEnable = %d ***\n", __func__, nEnable);
+
+	if (nEnable)
+		DrvIcFwLyrEnableProximity();
+	else
+		DrvIcFwLyrDisableProximity();
+
+	return 0;
+}
+
+#endif
+
+
diff --git a/drivers/input/touchscreen/msg28xx/mstar_drv_platform_porting_layer.h b/drivers/input/touchscreen/msg28xx/mstar_drv_platform_porting_layer.h
new file mode 100644
index 0000000..bae8a79
--- /dev/null
+++ b/drivers/input/touchscreen/msg28xx/mstar_drv_platform_porting_layer.h
@@ -0,0 +1,139 @@
+/*********************************************************
+//
+// Copyright (c) 2006-2016 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages,
+// losses, costs and expenses resulting therefrom.
+//
+*************************************************************************/
+/**
+ *
+ * @file    mstar_drv_platform_porting_layer.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+#ifndef __MSTAR_DRV_PLATFORM_PORTING_LAYER_H__
+#define __MSTAR_DRV_PLATFORM_PORTING_LAYER_H__
+
+/*--------------------------------------------------------------------------*/
+/* INCLUDE FILE                                                             */
+/*--------------------------------------------------------------------------*/
+
+#include "mstar_drv_common.h"
+
+#include <linux/of_gpio.h>
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+#include <linux/regulator/consumer.h>
+#endif
+
+#ifdef CONFIG_ENABLE_NOTIFIER_FB
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#endif
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+#include <linux/sensors.h>
+#endif
+
+#ifdef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+#include <linux/pinctrl/consumer.h>
+#endif
+
+
+/*--------------------------------------------------------------------------*/
+/* PREPROCESSOR CONSTANT DEFINITION                                         */
+/*--------------------------------------------------------------------------*/
+
+/*
+ * Note.
+ * Please change the below GPIO pin setting to follow the platform that you are
+ * using(EX. MediaTek, Spreadtrum, Qualcomm).
+ */
+
+#ifndef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+#define MS_TS_MSG_IC_GPIO_RST   0
+#define MS_TS_MSG_IC_GPIO_INT   1
+#endif
+
+#ifdef CONFIG_ENABLE_TOUCH_PIN_CONTROL
+#define PINCTRL_STATE_ACTIVE	"pmx_ts_active"
+#define PINCTRL_STATE_SUSPEND	"pmx_ts_suspend"
+#define PINCTRL_STATE_RELEASE	"pmx_ts_release"
+#endif
+
+#ifdef CONFIG_TP_HAVE_KEY
+#define TOUCH_KEY_MENU (139)
+#define TOUCH_KEY_HOME (172)
+#define TOUCH_KEY_BACK (158)
+#define TOUCH_KEY_SEARCH (217)
+
+#define MAX_KEY_NUM (4)
+#endif
+
+extern u8 IS_FIRMWARE_DATA_LOG_ENABLED;
+extern struct i2c_client *g_I2cClient;
+
+extern struct kset *g_TouchKSet;
+extern struct kobject *g_TouchKObj;
+
+#ifdef CONFIG_ENABLE_GESTURE_WAKEUP
+#ifdef CONFIG_ENABLE_GESTURE_DEBUG_MODE
+extern struct kset *g_GestureKSet;
+extern struct kobject *g_GestureKObj;
+#endif
+#endif
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+extern u8 g_FaceClosingTp;
+extern u8 g_EnableTpProximity;
+#endif
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+extern struct regulator *g_ReguVdd;
+extern struct regulator *g_ReguVcc_i2c;
+#endif
+
+
+/*--------------------------------------------------------------------------*/
+/* GLOBAL FUNCTION DECLARATION                                              */
+/*--------------------------------------------------------------------------*/
+
+extern void DrvPlatformLyrDisableFingerTouchReport(void);
+extern void DrvPlatformLyrEnableFingerTouchReport(void);
+extern void DrvPlatformLyrFingerTouchPressed(s32 nX,
+			s32 nY, s32 nPressure, s32 nId);
+extern void DrvPlatformLyrFingerTouchReleased(s32 nX, s32 nY, s32 nId);
+extern s32 DrvPlatformLyrInputDeviceInitialize(struct i2c_client *pClient);
+extern void DrvPlatformLyrSetIicDataRate(struct i2c_client *pClient, u32
+				nIicDataRate);
+extern void DrvPlatformLyrTouchDevicePowerOff(void);
+extern void DrvPlatformLyrTouchDevicePowerOn(void);
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+extern void DrvPlatformLyrTouchDeviceRegulatorPowerOn(bool nFlag);
+#endif
+extern void DrvPlatformLyrTouchDeviceRegisterEarlySuspend(void);
+extern s32 DrvPlatformLyrTouchDeviceRegisterFingerTouchInterruptHandler(void);
+extern s32 DrvPlatformLyrTouchDeviceRemove(struct i2c_client *pClient);
+extern s32 DrvPlatformLyrTouchDeviceRequestGPIO(struct i2c_client *pClient);
+extern void DrvPlatformLyrTouchDeviceResetHw(void);
+
+#ifdef CONFIG_ENABLE_PROXIMITY_DETECTION
+extern int DrvPlatformLyrGetTpPsData(void);
+extern int DrvPlatformLyrTpPsEnable(struct sensors_classdev *pProximityCdev,
+		unsigned int nEnable);
+#endif
+
+#endif  /* __MSTAR_DRV_PLATFORM_PORTING_LAYER_H__ */
diff --git a/drivers/input/touchscreen/msg28xx/mstar_drv_qcom.c b/drivers/input/touchscreen/msg28xx/mstar_drv_qcom.c
new file mode 100644
index 0000000..ccba7f5
--- /dev/null
+++ b/drivers/input/touchscreen/msg28xx/mstar_drv_qcom.c
@@ -0,0 +1,137 @@
+/**************************************************************
+//
+// Copyright (c) 2006-2016 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses,
+// costs and expenses resulting therefrom.
+//
+**********************************************************************/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/kobject.h>
+#include <asm/irq.h>
+#include <linux/io.h>
+#include "mstar_drv_platform_interface.h"
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+#include <linux/regulator/consumer.h>
+#endif
+
+
+#define MSG_TP_IC_NAME "msg2xxx"
+
+struct i2c_client *g_I2cClient = NULL;
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+struct regulator *g_ReguVdd = NULL;
+struct regulator *g_ReguVcc_i2c = NULL;
+#endif
+
+static int touch_driver_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+	int ret = 0;
+	const char *vdd_name = "vdd";
+	const char *vcc_i2c_name = "vcc_i2c";
+#endif
+
+	DBG("*** %s ***\n", __func__);
+
+	if (client == NULL) {
+		DBG("i2c client is NULL\n");
+		return -EINVAL;
+	}
+	g_I2cClient = client;
+
+#ifdef CONFIG_ENABLE_REGULATOR_POWER_ON
+	g_ReguVdd = regulator_get(&g_I2cClient->dev, vdd_name);
+
+	ret = regulator_set_voltage(g_ReguVdd, 2800000, 3300000);
+	if (ret)
+		DBG("Could not set to 2800mv.\n");
+
+	g_ReguVcc_i2c = regulator_get(&g_I2cClient->dev, vcc_i2c_name);
+
+	ret = regulator_set_voltage(g_ReguVcc_i2c, 1800000, 1800000);
+	if (ret)
+		DBG("Could not set to 1800mv.\n");
+#endif
+
+	return MsDrvInterfaceTouchDeviceProbe(g_I2cClient, id);
+}
+
+/* remove function is triggered when the input
+device is removed from input sub-system */
+static int touch_driver_remove(struct i2c_client *client)
+{
+	return MsDrvInterfaceTouchDeviceRemove(client);
+}
+
+/* The I2C device list is used for matching
+	 I2C device and I2C device driver. */
+static const struct i2c_device_id touch_device_id[] = {
+	{MSG_TP_IC_NAME, 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, touch_device_id);
+
+static struct of_device_id touch_match_table[] = {
+	{ .compatible = "mstar,msg2xxx",},
+	{},
+};
+
+static struct i2c_driver touch_device_driver = {
+	.driver = {
+		.name = MSG_TP_IC_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = touch_match_table,
+	},
+	.probe = touch_driver_probe,
+	.remove = touch_driver_remove,
+	.id_table = touch_device_id,
+};
+
+static int __init touch_driver_init(void)
+{
+	int ret;
+
+	/* register driver */
+	ret = i2c_add_driver(&touch_device_driver);
+	if (ret < 0) {
+		DBG("add touch device driver i2c driver failed.\n");
+		return -ENODEV;
+	}
+	DBG("add touch device driver i2c driver.\n");
+
+	return ret;
+}
+
+static void __exit touch_driver_exit(void)
+{
+	DBG("remove touch device driver i2c driver.\n");
+
+	i2c_del_driver(&touch_device_driver);
+}
+module_init(touch_driver_init);
+module_exit(touch_driver_exit);
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/msg28xx/mstar_drv_utility_adaption.c b/drivers/input/touchscreen/msg28xx/mstar_drv_utility_adaption.c
new file mode 100644
index 0000000..ece9bea
--- /dev/null
+++ b/drivers/input/touchscreen/msg28xx/mstar_drv_utility_adaption.c
@@ -0,0 +1,525 @@
+/**********************************************************************
+//
+// Copyright (c) 2006-2016 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses,
+//  costs and expenses resulting therefrom.
+//
+****************************************************************/
+/**
+ *
+ * @file	mstar_drv_utility_adaption.c
+ *
+ * @brief	This file defines the interface of touch screen
+ *
+ *
+ */
+
+#include "mstar_drv_utility_adaption.h"
+
+
+
+u16 RegGet16BitValue(u16 nAddr)
+{
+	u8 tx_data[3] = {0x10, (nAddr >> 8) & 0xFF, nAddr & 0xFF};
+	u8 rx_data[2] = {0};
+
+	IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 3);
+	IicReadData(SLAVE_I2C_ID_DBBUS, &rx_data[0], 2);
+
+	return (rx_data[1] << 8 | rx_data[0]);
+}
+
+u8 RegGetLByteValue(u16 nAddr)
+{
+	u8 tx_data[3] = {0x10, (nAddr >> 8) & 0xFF, nAddr & 0xFF};
+	u8 rx_data = {0};
+
+	IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 3);
+	IicReadData(SLAVE_I2C_ID_DBBUS, &rx_data, 1);
+
+	return rx_data;
+}
+
+u8 RegGetHByteValue(u16 nAddr)
+{
+	u8 tx_data[3] = {0x10, (nAddr >> 8) & 0xFF, (nAddr & 0xFF) + 1};
+	u8 rx_data = 0;
+
+	IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 3);
+	IicReadData(SLAVE_I2C_ID_DBBUS, &rx_data, 1);
+
+	return rx_data;
+}
+
+void RegGetXBitValue(u16 nAddr, u8 *pRxData,
+		u16 nLength, u16 nMaxI2cLengthLimit)
+{
+	u16 nReadAddr = nAddr;
+	u16 nReadSize = 0;
+	u16 nLeft = nLength;
+	u16 nOffset = 0;
+	u8 tx_data[3] = {0};
+
+	tx_data[0] = 0x10;
+
+	mutex_lock(&g_Mutex);
+
+
+	while (nLeft > 0) {
+		if (nLeft >= nMaxI2cLengthLimit) {
+			nReadSize = nMaxI2cLengthLimit;
+
+			tx_data[1] = (nReadAddr >> 8) & 0xFF;
+			tx_data[2] = nReadAddr & 0xFF;
+
+			IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 3);
+			IicReadData(SLAVE_I2C_ID_DBBUS,
+					&pRxData[nOffset], nReadSize);
+
+			nReadAddr = nReadAddr + nReadSize;
+			nLeft = nLeft - nReadSize;
+			nOffset = nOffset + nReadSize;
+		} else {
+			nReadSize = nLeft;
+
+			tx_data[1] = (nReadAddr >> 8) & 0xFF;
+			tx_data[2] = nReadAddr & 0xFF;
+
+			IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 3);
+			IicReadData(SLAVE_I2C_ID_DBBUS,
+				&pRxData[nOffset], nReadSize);
+
+			nLeft = 0;
+			nOffset = nOffset + nReadSize;
+		}
+	}
+
+	mutex_unlock(&g_Mutex);
+}
+
+void RegSet16BitValue(u16 nAddr, u16 nData)
+{
+	u8 tx_data[5] = {0x10, (nAddr >> 8) & 0xFF,
+			nAddr & 0xFF, nData & 0xFF, nData >> 8};
+
+	IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 5);
+}
+
+void RegSetLByteValue(u16 nAddr, u8 nData)
+{
+	u8 tx_data[4] = {0x10, (nAddr >> 8) & 0xFF, nAddr & 0xFF, nData};
+
+	IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 4);
+}
+
+void RegSetHByteValue(u16 nAddr, u8 nData)
+{
+	u8 tx_data[4] = {0x10, (nAddr >> 8) & 0xFF, (nAddr & 0xFF) + 1, nData};
+
+	IicWriteData(SLAVE_I2C_ID_DBBUS, &tx_data[0], 4);
+}
+
+void RegSet16BitValueOn(u16 nAddr, u16 nData)
+{
+	u16 rData = RegGet16BitValue(nAddr);
+
+	rData |= nData;
+	RegSet16BitValue(nAddr, rData);
+}
+
+void RegSet16BitValueOff(u16 nAddr, u16 nData)
+{
+	u16 rData = RegGet16BitValue(nAddr);
+
+	rData &= (~nData);
+	RegSet16BitValue(nAddr, rData);
+}
+
+u16 RegGet16BitValueByAddressMode(u16 nAddr,
+	enum AddressMode_e eAddressMode)
+{
+	u16 nData = 0;
+
+	if (eAddressMode == ADDRESS_MODE_16BIT)
+		nAddr = nAddr - (nAddr & 0xFF) + ((nAddr & 0xFF) << 1);
+
+	nData = RegGet16BitValue(nAddr);
+
+	return nData;
+}
+
+void RegSet16BitValueByAddressMode(u16 nAddr, u16 nData,
+			enum AddressMode_e eAddressMode)
+{
+	if (eAddressMode == ADDRESS_MODE_16BIT)
+		nAddr = nAddr - (nAddr & 0xFF) + ((nAddr & 0xFF) << 1);
+
+	RegSet16BitValue(nAddr, nData);
+}
+
+void RegMask16BitValue(u16 nAddr, u16 nMask, u16 nData,
+			enum AddressMode_e eAddressMode)
+{
+	u16 nTmpData = 0;
+
+	if (nData > nMask)
+		return;
+
+	nTmpData = RegGet16BitValueByAddressMode(nAddr, eAddressMode);
+	nTmpData = (nTmpData & (~nMask));
+	nTmpData = (nTmpData | nData);
+	RegSet16BitValueByAddressMode(nAddr, nTmpData, eAddressMode);
+}
+
+s32 DbBusEnterSerialDebugMode(void)
+{
+	s32 rc = 0;
+	u8 data[5];
+
+	data[0] = 0x53;
+	data[1] = 0x45;
+	data[2] = 0x52;
+	data[3] = 0x44;
+	data[4] = 0x42;
+
+	rc = IicWriteData(SLAVE_I2C_ID_DBBUS, data, 5);
+
+	return rc;
+}
+
+void DbBusExitSerialDebugMode(void)
+{
+	u8 data[1];
+
+	data[0] = 0x45;
+
+	IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+
+}
+
+void DbBusIICUseBus(void)
+{
+	u8 data[1];
+
+	data[0] = 0x35;
+
+	IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+}
+
+void DbBusIICNotUseBus(void)
+{
+	u8 data[1];
+
+	data[0] = 0x34;
+	IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+}
+
+void DbBusIICReshape(void)
+{
+	u8 data[1];
+
+	data[0] = 0x71;
+
+	IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+}
+
+void DbBusStopMCU(void)
+{
+	u8 data[1];
+
+	data[0] = 0x37;
+
+	IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+}
+
+void DbBusNotStopMCU(void)
+{
+	u8 data[1];
+
+	data[0] = 0x36;
+
+	IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+}
+
+void DbBusResetSlave(void)
+{
+	u8 data[1];
+
+	data[0] = 0x00;
+
+	IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+}
+
+void DbBusWaitMCU(void)
+{
+	u8 data[1];
+
+	data[0] = 0x37;
+
+	IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+
+	data[0] = 0x61;
+	IicWriteData(SLAVE_I2C_ID_DBBUS, data, 1);
+}
+
+s32 IicWriteData(u8 nSlaveId, u8 *pBuf, u16 nSize)
+{
+	s32 rc = 0;
+
+	struct i2c_msg msgs[] =	{
+		{
+			.addr = nSlaveId,
+			.flags = 0,
+			.len = nSize,
+			.buf = pBuf,
+		},
+	};
+
+	/* If everything went ok (i.e. 1 msg transmitted), return #bytes
+	   transmitted, else error code. */
+	if (g_I2cClient != NULL) {
+		if (g_ChipType == CHIP_TYPE_MSG28XX &&
+			nSlaveId == SLAVE_I2C_ID_DWI2C &&
+			(g_IsUpdateFirmware != 0 ||
+			g_IsBypassHotknot != 0)) {
+			pr_err("Not allow to execute SmBus command.\n");
+		} else {
+			rc = i2c_transfer(g_I2cClient->adapter, msgs, 1);
+			if (rc == 1)
+				rc = nSize;
+		}
+	}
+	return rc;
+}
+
+s32 IicReadData(u8 nSlaveId, u8 *pBuf, u16 nSize)
+{
+	s32 rc = 0;
+
+	struct i2c_msg msgs[] =	{
+		{
+			.addr = nSlaveId,
+			.flags = I2C_M_RD,
+			.len = nSize,
+			.buf = pBuf,
+		},
+	};
+	/* If everything went ok (i.e. 1 msg transmitted), return #bytes
+	   transmitted, else error code. */
+		if (g_I2cClient != NULL) {
+			if (g_ChipType == CHIP_TYPE_MSG28XX &&
+				nSlaveId == SLAVE_I2C_ID_DWI2C &&
+				(g_IsUpdateFirmware != 0 ||
+				g_IsBypassHotknot != 0)) {
+				pr_err("Not allow update firmware.\n");
+			} else {
+				rc = i2c_transfer(
+					g_I2cClient->adapter, msgs, 1);
+
+				if (rc == 1)
+					rc = nSize;
+			}
+		}
+
+		return rc;
+
+}
+
+s32 IicSegmentReadDataByDbBus(u8 nRegBank, u8 nRegAddr,
+			u8 *pBuf, u16 nSize, u16 nMaxI2cLengthLimit)
+{
+	s32 rc = 0;
+	u16 nLeft = nSize;
+	u16 nOffset = 0;
+	u16 nSegmentLength = 0;
+	u16 nReadSize = 0;
+	u16 nOver = 0;
+	u8	szWriteBuf[3] = {0};
+	u8	nNextRegBank = nRegBank;
+	u8	nNextRegAddr = nRegAddr;
+
+	struct i2c_msg msgs[2] = {
+		{
+			.addr = SLAVE_I2C_ID_DBBUS,
+			.flags = 0,
+			.len = 3,
+			.buf = szWriteBuf,
+		},
+		{
+			.addr = SLAVE_I2C_ID_DBBUS,
+			.flags =  I2C_M_RD,
+		},
+	};
+
+	if (g_I2cClient != NULL) {
+		if (nMaxI2cLengthLimit >= 256)
+			nSegmentLength = 256;
+		else
+			nSegmentLength = 128;
+
+		pr_err("nSegmentLength = %d\n", nSegmentLength);
+
+		while (nLeft > 0) {
+			szWriteBuf[0] = 0x10;
+			nRegBank = nNextRegBank;
+			szWriteBuf[1] = nRegBank;
+			nRegAddr = nNextRegAddr;
+			szWriteBuf[2] = nRegAddr;
+
+			pr_err("nRegBank = 0x%x\n", nRegBank);
+			pr_err("nRegAddr = 0x%x\n", nRegAddr);
+
+			msgs[1].buf = &pBuf[nOffset];
+
+			if (nLeft > nSegmentLength) {
+				if ((nRegAddr + nSegmentLength) <
+					MAX_TOUCH_IC_REGISTER_BANK_SIZE) {
+					nNextRegAddr = nRegAddr +
+							nSegmentLength;
+
+					msgs[1].len = nSegmentLength;
+					nLeft -= nSegmentLength;
+					nOffset += msgs[1].len;
+				} else if ((nRegAddr + nSegmentLength)
+					== MAX_TOUCH_IC_REGISTER_BANK_SIZE) {
+					nNextRegAddr = 0x00;
+					nNextRegBank = nRegBank + 1;
+
+					msgs[1].len = nSegmentLength;
+					nLeft -= nSegmentLength;
+					nOffset += msgs[1].len;
+				} else {
+					nNextRegAddr = 0x00;
+					nNextRegBank = nRegBank + 1;
+					nOver = (nRegAddr + nSegmentLength) -
+						MAX_TOUCH_IC_REGISTER_BANK_SIZE;
+
+					pr_err("nOver = 0x%x\n", nOver);
+
+					msgs[1].len = nSegmentLength - nOver;
+					nLeft -= msgs[1].len;
+					nOffset += msgs[1].len;
+				}
+			} else {
+				if ((nRegAddr + nLeft) <
+					MAX_TOUCH_IC_REGISTER_BANK_SIZE) {
+					nNextRegAddr = nRegAddr + nLeft;
+
+					msgs[1].len = nLeft;
+					nLeft = 0;
+				} else if ((nRegAddr + nLeft) ==
+					MAX_TOUCH_IC_REGISTER_BANK_SIZE) {
+					nNextRegAddr = 0x00;
+					nNextRegBank = nRegBank + 1;
+					msgs[1].len = nLeft;
+					nLeft = 0;
+				} else {
+					nNextRegAddr = 0x00;
+					nNextRegBank = nRegBank + 1;
+
+					nOver = (nRegAddr + nLeft) -
+						MAX_TOUCH_IC_REGISTER_BANK_SIZE;
+
+					pr_err("nOver = 0x%x\n", nOver);
+
+					msgs[1].len = nLeft - nOver;
+					nLeft -= msgs[1].len;
+					nOffset += msgs[1].len;
+				}
+			}
+
+			rc = i2c_transfer(g_I2cClient->adapter, &msgs[0], 2);
+			if (rc == 2)
+				nReadSize = nReadSize + msgs[1].len;
+			else {
+				pr_err("i2c_transfer() error %d\n", rc);
+
+				return rc;
+			}
+		}
+	} else
+		pr_err("i2c client is NULL\n");
+
+
+	return nReadSize;
+}
+
+s32 IicSegmentReadDataBySmBus(u16 nAddr, u8 *pBuf,
+		u16 nSize, u16 nMaxI2cLengthLimit)
+{
+	s32 rc = 0;
+	u16 nLeft = nSize;
+	u16 nOffset = 0;
+	u16 nReadSize = 0;
+	u8	szWriteBuf[3] = {0};
+
+	struct i2c_msg msgs[2] = {
+		{
+			.addr = SLAVE_I2C_ID_DWI2C,
+			.flags = 0,
+			.len = 3,
+			.buf = szWriteBuf,
+		},
+		{
+			.addr = SLAVE_I2C_ID_DWI2C,
+			.flags =  I2C_M_RD,
+		},
+	};
+
+	if (g_I2cClient != NULL) {
+		while (nLeft > 0) {
+			szWriteBuf[0] = 0x53;
+			szWriteBuf[1] = ((nAddr + nOffset) >> 8) & 0xFF;
+			szWriteBuf[2] = (nAddr + nOffset) & 0xFF;
+
+			msgs[1].buf = &pBuf[nOffset];
+
+			if (nLeft > nMaxI2cLengthLimit) {
+				msgs[1].len = nMaxI2cLengthLimit;
+				nLeft -= nMaxI2cLengthLimit;
+				nOffset += msgs[1].len;
+			} else {
+				msgs[1].len = nLeft;
+				nLeft = 0;
+			}
+
+			rc = i2c_transfer(g_I2cClient->adapter, &msgs[0], 2);
+			if (rc == 2)
+				nReadSize = nReadSize + msgs[1].len;
+			else {
+				pr_err("i2c_transfer() error %d\n", rc);
+				return rc;
+			}
+		}
+	} else
+		pr_err("i2c client is NULL\n");
+
+	return nReadSize;
+}
+
+void mstpMemSet(void *pDst, s8 nVal, u32 nSize)
+{
+	memset(pDst, nVal, nSize);
+}
+
+void mstpMemCopy(void *pDst, void *pSource, u32 nSize)
+{
+	memcpy(pDst, pSource, nSize);
+}
+
+void mstpDelay(u32 nTime)
+{
+	/*mdelay(nTime);*/
+	msleep(nTime);
+}
+
diff --git a/drivers/input/touchscreen/msg28xx/mstar_drv_utility_adaption.h b/drivers/input/touchscreen/msg28xx/mstar_drv_utility_adaption.h
new file mode 100644
index 0000000..340eabe
--- /dev/null
+++ b/drivers/input/touchscreen/msg28xx/mstar_drv_utility_adaption.h
@@ -0,0 +1,93 @@
+/************************************************************
+//
+// Copyright (c) 2006-2016 MStar Semiconductor, Inc.
+// All rights reserved.
+//
+// Unless otherwise stipulated in writing, any and all information contained
+// herein regardless in any format shall remain the sole proprietary of
+// MStar Semiconductor Inc. and be kept in strict confidence
+// (??MStar Confidential Information??) by the recipient.
+// Any unauthorized act including without limitation unauthorized disclosure,
+// copying, use, reproduction, sale, distribution, modification, disassembling,
+// reverse engineering and compiling of the contents of MStar Confidential
+// Information is unlawful and strictly prohibited. MStar hereby reserves the
+// rights to any and all damages, losses,
+// costs and expenses resulting therefrom.
+//
+*******************************************************************/
+
+/**
+ *
+ * @file    mstar_drv_utility_adaption.h
+ *
+ * @brief   This file defines the interface of touch screen
+ *
+ *
+ */
+
+#ifndef __MSTAR_DRV_UTILITY_ADAPTION_H__
+#define __MSTAR_DRV_UTILITY_ADAPTION_H__ (1)
+#include "mstar_drv_common.h"
+#define BK_REG8_WL(addr, val)    (RegSetLByteValue(addr, val))
+#define BK_REG8_WH(addr, val)    (RegSetHByteValue(addr, val))
+#define BK_REG16_W(addr, val)    (RegSet16BitValue(addr, val))
+#define BK_REG8_RL(addr)        (RegGetLByteValue(addr))
+#define BK_REG8_RH(addr)        (RegGetHByteValue(addr))
+#define BK_REG16_R(addr)        (RegGet16BitValue(addr))
+
+/*#define PRINTF_EMERG(fmt, ...)  printk(KERN_EMERG pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_ALERT(fmt, ...)  printk(KERN_ALERT pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_CRIT(fmt, ...)   printk(KERN_CRIT pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_ERR(fmt, ...)    printk(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_WARN(fmt, ...)   printk(KERN_WARNING pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_NOTICE(fmt, ...) printk(KERN_NOTICE pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_INFO(fmt, ...)   printk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)
+#define PRINTF_DEBUG(fmt, ...)	printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__*/
+
+extern u32 SLAVE_I2C_ID_DBBUS;
+extern u32 SLAVE_I2C_ID_DWI2C;
+
+extern struct i2c_client *g_I2cClient;
+extern struct input_dev *g_InputDevice;
+extern struct mutex g_Mutex;
+
+extern u8 g_ChipType;
+extern u8 g_IsUpdateFirmware;
+extern u8 g_IsBypassHotknot;
+
+extern u16 RegGet16BitValue(u16 nAddr);
+extern u8 RegGetLByteValue(u16 nAddr);
+extern u8 RegGetHByteValue(u16 nAddr);
+extern void RegGetXBitValue(u16 nAddr, u8 *pRxData, u16 nLength,
+		u16 nMaxI2cLengthLimit);
+extern void RegSet16BitValue(u16 nAddr, u16 nData);
+extern void RegSetLByteValue(u16 nAddr, u8 nData);
+extern void RegSetHByteValue(u16 nAddr, u8 nData);
+extern void RegSet16BitValueOn(u16 nAddr, u16 nData);
+extern void RegSet16BitValueOff(u16 nAddr, u16 nData);
+extern u16  RegGet16BitValueByAddressMode(u16 nAddr,
+			enum AddressMode_e eAddressMode);
+extern void RegSet16BitValueByAddressMode(u16 nAddr, u16 nData,
+		enum AddressMode_e eAddressMode);
+extern void RegMask16BitValue(u16 nAddr, u16 nMask, u16 nData,
+		enum AddressMode_e eAddressMode);
+extern s32 DbBusEnterSerialDebugMode(void);
+extern void DbBusExitSerialDebugMode(void);
+extern void DbBusIICUseBus(void);
+extern void DbBusIICNotUseBus(void);
+extern void DbBusIICReshape(void);
+extern void DbBusStopMCU(void);
+extern void DbBusNotStopMCU(void);
+extern void DbBusResetSlave(void);
+extern void DbBusWaitMCU(void);
+extern s32 IicWriteData(u8 nSlaveId, u8 *pBuf, u16 nSize);
+extern s32 IicReadData(u8 nSlaveId, u8 *pBuf, u16 nSize);
+extern s32 IicSegmentReadDataByDbBus(u8 nRegBank, u8 nRegAddr, u8 *pBuf,
+			u16 nSize, u16 nMaxI2cLengthLimit);
+extern s32 IicSegmentReadDataBySmBus(u16 nAddr, u8 *pBuf,
+			u16 nSize, u16 nMaxI2cLengthLimit);
+extern void mstpMemSet(void *pDst, s8 nVal, u32 nSize);
+extern void mstpMemCopy(void *pDst, void *pSource, u32 nSize);
+extern void mstpDelay(u32 nTime);
+
+#endif
-- 
1.9.1

