From fabd7e9a06b588315f1b763cb04cf180a1afad6e Mon Sep 17 00:00:00 2001
From: yanqy <yanqy0911@thundersoft.com>
Date: Mon, 4 May 2015 15:14:28 +0800
Subject: [PATCH 3/3] input:touchscreen: support ctp zhongheng st1633

Add CTP ZHONGHENG@JH3114@ST1633 driver

Change-Id: Iffae4bac3421587e7d11506ed9e58cee66fb91e4
Signed-off-by: Qiyang Yan <yanqy0911@thundersoft.com>
---
 drivers/input/touchscreen/st1232.c         | 2709 +++++++++++++++++++++++++---
 include/linux/platform_data/st1232_pdata.h |  234 ++-
 2 files changed, 2727 insertions(+), 216 deletions(-)

diff --git a/drivers/input/touchscreen/st1232.c b/drivers/input/touchscreen/st1232.c
index 1740a24..42e1aa8 100644
--- a/drivers/input/touchscreen/st1232.c
+++ b/drivers/input/touchscreen/st1232.c
@@ -1,310 +1,2601 @@
 /*
- * ST1232 Touchscreen Controller Driver
+ * drivers/input/touchscreen/sitronix_i2c_touch.c
  *
- * Copyright (C) 2010 Renesas Solutions Corp.
- *	Tony SIM <chinyeow.sim.xt@renesas.com>
+ * Touchscreen driver for Sitronix (I2C bus)
  *
- * Using code from:
- *  - android.git.kernel.org: projects/kernel/common.git: synaptics_i2c_rmi.c
- *	Copyright (C) 2007 Google, Inc.
+ * Copyright (C) 2014-2015 Sitronix Technology Co., Ltd.
  *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
  */
 
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
 #include <linux/delay.h>
-#include <linux/gpio.h>
 #include <linux/i2c.h>
 #include <linux/input.h>
 #include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/of_gpio.h>
-#include <linux/pm_qos.h>
 #include <linux/slab.h>
-#include <linux/types.h>
+#include <linux/gpio.h>
+#include <mach/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/regulator/consumer.h>
+#include <linux/firmware.h>
+#include <linux/debugfs.h>
+/*#include "sitronix_i2c_touch.h"*/
 #include <linux/platform_data/st1232_pdata.h>
 
-#define ST1232_TS_NAME	"st1232-ts"
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+#ifdef SITRONIX_FW_UPGRADE_FEATURE
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#ifdef SITRONIX_PERMISSION_THREAD
+#include <linux/fs.h>
+#include <linux/fcntl.h>
+#include <linux/syscalls.h>
+#endif
+#endif
+
+#ifdef SITRONIX_SUPPORT_MT_SLOT
+#include <linux/input/mt.h>
+#endif
+
+#ifdef SITRONIX_MONITOR_THREAD
+#include <linux/kthread.h>
+#endif
 
-#define MIN_X		0x00
-#define MIN_Y		0x00
-#define MAX_X		0x31f	/* (800 - 1) */
-#define MAX_Y		0x1df	/* (480 - 1) */
-#define MAX_AREA	0xff
-#define MAX_FINGERS	2
+#define DRIVER_AUTHOR           "Sitronix, Inc."
+#define DRIVER_NAME             "sitronix"
+#define DRIVER_DESC             "Sitronix I2C touch"
+#define DRIVER_DATE             "20150328"
+#define DRIVER_MAJOR            2
+#define DRIVER_MINOR            9
+#define DRIVER_PATCHLEVEL       13
+#define SI_VTG_MIN_UV		2700000
+#define SI_VTG_MAX_UV		3600000
+#define SI_I2C_VTG_MIN_UV	1800000
+#define SI_I2C_VTG_MAX_UV	1800000
+#define MAX_BUTTONS          4
+#define SI_COORDS_ARR_SIZE  4
+#define SI_INFO_MAX_LEN     512
+#define SI_DRIVER_VERSION   1
+#define SI_FW_NAME_MAX_LEN  50
+#define SITRONIX_MAJOR      0
+#define SITRONIX_ZERO      0
 
-struct st1232_ts_finger {
-	u16 x;
-	u16 y;
-	u8 t;
-	bool is_valid;
-};
+#define SI_STORE_TS_INFO(buf, id, name, max_tch, group_id, fw_vkey_support, \
+			fw_name, fw_maj, fw_min, fw_sub_min, fw_thd_min) \
+			snprintf(buf, SI_INFO_MAX_LEN, \
+				"controller\t= Sitronix\n" \
+				"model\t\t= 0x%x\n" \
+				"name\t\t= %s\n" \
+				"max_touches\t= %d\n" \
+				"drv_ver\t\t= 0x%x\n" \
+				"group_id\t= 0x%x\n" \
+				"fw_vkey_support\t= %s\n" \
+				"fw_name\t\t= %s\n" \
+				"fw_ver\t\t= %d.%d.%d.%d\n", id, name, \
+				max_tch, SI_DRIVER_VERSION, group_id, \
+				fw_vkey_support, fw_name, fw_maj, fw_min, \
+				fw_sub_min, fw_thd_min)
 
-struct st1232_ts_data {
+#define SI_DEBUG_DIR_NAME	"ts_debug"
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void sitronix_ts_early_suspend(struct early_suspend *h);
+static void sitronix_ts_late_resume(struct early_suspend *h);
+#else
+static int sitronix_ts_normal_suspend(struct device *dev);
+static int sitronix_ts_normal_resume(struct device *dev);
+#endif
+
+static int sitronix_ts_resume(struct i2c_client *client);
+static int sitronix_ts_suspend(struct i2c_client *client, pm_message_t mesg);
+static void sitronix_ts_reprobe(void);
+
+static void sitronix_ts_reset_ic(void);
+
+struct sitronix_ts_platform_data {
+	const char *name;
+	const char *fw_name;
+	u32 irqflags;
+	u32 irq_gpio;
+	u32 irq_gpio_flags;
+	u32 reset_gpio;
+	u32 reset_gpio_flags;
+	u32 family_id;
+	u32 x_max;
+	u32 y_max;
+	u32 x_min;
+	u32 y_min;
+	u32 panel_minx;
+	u32 panel_miny;
+	u32 panel_maxx;
+	u32 panel_maxy;
+	u32 group_id;
+	u32 hard_rst_dly;
+	u32 soft_rst_dly;
+	u32 num_max_touches;
+	u32 num_buttons;
+	u32 button_map[MAX_BUTTONS];
+	bool fw_vkey_support;
+	bool no_force_update;
+	bool i2c_pull_up;
+	bool ignore_id_check;
+	int (*power_init) (bool);
+	int (*power_on) (bool);
+};
+struct sitronix_ts_data {
 	struct i2c_client *client;
 	struct input_dev *input_dev;
-	struct st1232_ts_finger finger[MAX_FINGERS];
-	struct dev_pm_qos_request low_latency_req;
-	int reset_gpio;
+	struct input_dev *keyevent_input;
+	struct sitronix_ts_platform_data *pdata;
+	struct regulator *vdd;
+	struct regulator *vcc_i2c;
+	struct dentry *dir;
+	char fw_name[SI_FW_NAME_MAX_LEN];
+	char *ts_info;
+	u16 addr;
+	bool enable;
+	int use_irq;
+#ifndef SITRONIX_INT_POLLING_MODE
+	struct work_struct work;
+#else
+	struct delayed_work work;
+#endif
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend early_suspend;
+#endif
+	uint8_t fw_revision[4];
+	int resolution_x;
+	int resolution_y;
+	uint8_t max_touches;
+	uint8_t touch_protocol_type;
+	uint8_t pixel_length;
+	uint8_t chip_id;
+#ifdef SITRONIX_MONITOR_THREAD
+	uint8_t enable_monitor_thread;
+	uint8_t RawCRC_enabled;
+	int (*sitronix_mt_fp) (void *);
+#endif
+	uint8_t Num_X;
+	uint8_t Num_Y;
+	uint8_t sensing_mode;
+	int suspend_state;
+};
+
+static int i2cErrorCount = SITRONIX_ZERO;
+static struct sitronix_ts_data sitronix_ts_gpts = { 0 };
+static atomic_t sitronix_ts_irq_on = ATOMIC_INIT(0);
+static atomic_t sitronix_ts_in_int = ATOMIC_INIT(0);
+
+char sitronix_sensor_key_status = SITRONIX_ZERO;
+struct sitronix_sensor_key_t sitronix_sensor_key_array[] = {
+	{KEY_MENU},		/* bit 0 */
+	{KEY_HOMEPAGE},		/* bit 1 */
+	{KEY_BACK},		/* bit 2 */
+};
+
+#ifdef SITRONIX_AA_KEY
+char sitronix_aa_key_status = SITRONIX_ZERO;
+
+#ifdef SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY
+/* max of X value in displa     y area */
+#define SITRONIX_TOUCH_RESOLUTION_X 720
+/* max of Y value in di     splay area */
+#define SITRONIX_TOUCH_RESOLUTION_Y 1280
+/* Gap between bottom of displa y and top of touch key */
+#define SITRONIX_TOUCH_GAP_Y	30
+/* resolution of y axis of touc h ic */
+#define SITRONIX_TOUCH_MAX_Y 1360
+
+struct sitronix_AA_key sitronix_aa_key_array[] = {
+	{60, 220, SITRONIX_TOUCH_RESOLUTION_Y + SITRONIX_TOUCH_GAP_Y,
+			SITRONIX_TOUCH_MAX_Y, KEY_MENU},	/* MENU */
+	{280, 440, SITRONIX_TOUCH_RESOLUTION_Y + SITRONIX_TOUCH_GAP_Y,
+			SITRONIX_TOUCH_MAX_Y, KEY_HOME},
+	{500, 660, SITRONIX_TOUCH_RESOLUTION_Y + SITRONIX_TOUCH_GAP_Y,
+			SITRONIX_TOUCH_MAX_Y, KEY_BACK},	/* KEY_EXIT */
 };
+#else
+#define SCALE_KEY_HIGH_Y 15
+struct sitronix_AA_key sitronix_aa_key_array[] = {
+	{0, 0, 0, 0, KEY_MENU},	/* MENU */
+	{0, 0, 0, 0, KEY_HOME},
+	{0, 0, 0, 0, KEY_BACK},	/* KEY_EXIT */
+	{0, 0, 0, 0, KEY_SEARCH},
+};
+#endif
+#endif
+
+#ifdef SITRONIX_MONITOR_THREAD
+static struct task_struct *SitronixMonitorThread = SITRONIX_ZERO;
+static int gMonitorThreadSleepInterval = 300;	/* 0.3 sec */
+static atomic_t iMonitorThreadPostpone = ATOMIC_INIT(0);
 
-static int st1232_ts_read_data(struct st1232_ts_data *ts)
+static uint8_t PreCheckData[4];
+static int StatusCheckCount = SITRONIX_ZERO;
+static int sitronix_ts_delay_monitor_thread_start =
+		DELAY_MONITOR_THREAD_START_PROBE;
+#endif
+
+#ifdef SITRONIX_FW_UPGRADE_FEATURE
+#ifdef SITRONIX_PERMISSION_THREAD
+static struct task_struct *SitronixPermissionThread = SITRONIX_ZERO;
+static int sitronix_ts_delay_permission_thread_start = 1000;
+
+static int sitronix_ts_permission_thread(void *data)
 {
-	struct st1232_ts_finger *finger = ts->finger;
-	struct i2c_client *client = ts->client;
-	struct i2c_msg msg[2];
-	int error;
-	u8 start_reg;
-	u8 buf[10];
+	int ret = 0;
+	int retry = 0;
+	mm_segment_t fs = get_fs();
+	set_fs(KERNEL_DS);
 
-	/* read touchscreen data from ST1232 */
-	msg[0].addr = client->addr;
-	msg[0].flags = 0;
-	msg[0].len = 1;
-	msg[0].buf = &start_reg;
-	start_reg = 0x10;
+	DbgMsg("%s start\n", __func__);
+	do {
+		DbgMsg("delay %d ms\n",
+		       sitronix_ts_delay_permission_thread_start);
+		msleep(sitronix_ts_delay_permission_thread_start);
+		ret =
+		    sys_fchmodat(AT_FDCWD, "/dev/" SITRONIX_I2C_TOUCH_DEV_NAME,
+				 0666);
+		if (ret < 0)
+			pr_info("fail to execute sys_fchmodat, ret = %d\n",
+					ret);
+		if (retry++ > 10)
+			break;
+	} while (ret == -ENOENT);
 
-	msg[1].addr = ts->client->addr;
-	msg[1].flags = I2C_M_RD;
-	msg[1].len = sizeof(buf);
-	msg[1].buf = buf;
+	set_fs(fs);
+	DbgMsg("%s exit\n", __func__);
+	return 0;
+}
+#endif
 
-	error = i2c_transfer(client->adapter, msg, 2);
-	if (error < 0)
-		return error;
+static struct cdev sitronix_cdev;
+static struct class *sitronix_class;
+static int sitronix_major = SITRONIX_MAJOR;
 
-	/* get "valid" bits */
-	finger[0].is_valid = buf[2] >> 7;
-	finger[1].is_valid = buf[5] >> 7;
+int sitronix_open(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+EXPORT_SYMBOL(sitronix_open);
 
-	/* get xy coordinate */
-	if (finger[0].is_valid) {
-		finger[0].x = ((buf[2] & 0x0070) << 4) | buf[3];
-		finger[0].y = ((buf[2] & 0x0007) << 8) | buf[4];
-		finger[0].t = buf[8];
-	}
+int sitronix_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+EXPORT_SYMBOL(sitronix_release);
+
+ssize_t sitronix_write(struct file *file, const char *buf, size_t count,
+		       loff_t *ppos)
+{
+	int ret;
+	char *tmp;
+
+	if (!(sitronix_ts_gpts.client))
+		return -EIO;
+
+	if (count > 8192)
+		count = 8192;
 
-	if (finger[1].is_valid) {
-		finger[1].x = ((buf[5] & 0x0070) << 4) | buf[6];
-		finger[1].y = ((buf[5] & 0x0007) << 8) | buf[7];
-		finger[1].t = buf[9];
+	tmp = kmalloc(count, GFP_KERNEL);
+	if (tmp == NULL)
+		return -ENOMEM;
+	if (copy_from_user(tmp, buf, count)) {
+		kfree(tmp);
+		return -EFAULT;
 	}
+	UpgradeMsg("writing %zu bytes.\n", count);
 
-	return 0;
+	ret = i2c_master_send(sitronix_ts_gpts.client, tmp, count);
+	kfree(tmp);
+	return ret;
 }
+EXPORT_SYMBOL(sitronix_write);
 
-static irqreturn_t st1232_ts_irq_handler(int irq, void *dev_id)
+ssize_t sitronix_read(struct file *file, char *buf, size_t count,
+		      loff_t *ppos)
 {
-	struct st1232_ts_data *ts = dev_id;
-	struct st1232_ts_finger *finger = ts->finger;
-	struct input_dev *input_dev = ts->input_dev;
-	int count = 0;
-	int i, ret;
+	char *tmp;
+	int ret;
 
-	ret = st1232_ts_read_data(ts);
-	if (ret < 0)
-		goto end;
+	if (!(sitronix_ts_gpts.client))
+		return -EIO;
+
+	if (count > 8192)
+		count = 8192;
+
+	tmp = kmalloc(count, GFP_KERNEL);
+	if (tmp == NULL)
+		return -ENOMEM;
+
+	UpgradeMsg("reading %zu bytes.\n", count);
+
+	ret = i2c_master_recv(sitronix_ts_gpts.client, tmp, count);
+	if (ret >= 0)
+		ret = copy_to_user(buf, tmp, count) ? -EFAULT : ret;
+	kfree(tmp);
+	return ret;
+}
+EXPORT_SYMBOL(sitronix_read);
 
-	/* multi touch protocol */
-	for (i = 0; i < MAX_FINGERS; i++) {
-		if (!finger[i].is_valid)
-			continue;
+long sitronix_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int err = 0;
+	int retval = 0;
+	uint8_t temp[4];
+
+	if (!(sitronix_ts_gpts.client))
+		return -EIO;
+
+	if (_IOC_TYPE(cmd) != SMT_IOC_MAGIC)
+		return -ENOTTY;
+	if (_IOC_NR(cmd) > SMT_IOC_MAXNR)
+		return -ENOTTY;
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		err =
+		    !access_ok(VERIFY_WRITE, (void __user *)arg,
+			       _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		err =
+		    !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
+	if (err)
+		return -EFAULT;
 
-		input_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, finger[i].t);
-		input_report_abs(input_dev, ABS_MT_POSITION_X, finger[i].x);
-		input_report_abs(input_dev, ABS_MT_POSITION_Y, finger[i].y);
-		input_mt_sync(input_dev);
-		count++;
+	switch (cmd) {
+	case IOCTL_SMT_GET_DRIVER_REVISION:
+		UpgradeMsg("IOCTL_SMT_GET_DRIVER_REVISION\n");
+		temp[0] = SITRONIX_TOUCH_DRIVER_VERSION;
+		if (copy_to_user((uint8_t __user *) arg, &temp[0], 1)) {
+			UpgradeMsg("fail to get driver version\n");
+			retval = -EFAULT;
+		}
+		break;
+	case IOCTL_SMT_GET_FW_REVISION:
+		UpgradeMsg("IOCTL_SMT_GET_FW_REVISION\n");
+		if (copy_to_user
+		    ((uint8_t __user *) arg, &(sitronix_ts_gpts.fw_revision[0]),
+		     4))
+			retval = -EFAULT;
+		break;
+	case IOCTL_SMT_ENABLE_IRQ:
+		UpgradeMsg("IOCTL_SMT_ENABLE_IRQ\n");
+		if (!atomic_read(&sitronix_ts_in_int)) {
+			if (!atomic_read(&sitronix_ts_irq_on)) {
+				atomic_set(&sitronix_ts_irq_on, 1);
+				enable_irq(sitronix_ts_gpts.client->irq);
+
+#ifdef SITRONIX_MONITOR_THREAD
+/*				if (sitronix_ts_gpts.enable_monitor_thread
+					== 1) {
+					if (!SitronixMonitorThread) {
+					*/
+				if ((sitronix_ts_gpts.enable_monitor_thread
+					== 1) && (!SitronixMonitorThread)) {
+					atomic_set
+						(&iMonitorThreadPostpone, 1);
+					SitronixMonitorThread = kthread_run
+						(sitronix_ts_gpts.
+						sitronix_mt_fp, "Sitronix",
+						"Monitorthread");
+					if (IS_ERR(SitronixMonitorThread))
+						SitronixMonitorThread = NULL;
+				}
+#endif
+			}
+		}
+		break;
+	case IOCTL_SMT_DISABLE_IRQ:
+		UpgradeMsg("IOCTL_SMT_DISABLE_IRQ\n");
+#ifndef SITRONIX_INT_POLLING_MODE
+		schedule_work(&sitronix_ts_gpts.work);
+#else
+		cancel_delayed_work_sync(&sitronix_ts_gpts.work);
+#endif
+		if (atomic_read(&sitronix_ts_irq_on)) {
+			atomic_set(&sitronix_ts_irq_on, 0);
+			disable_irq_nosync(sitronix_ts_gpts.client->irq);
+#ifdef SITRONIX_MONITOR_THREAD
+			if (sitronix_ts_gpts.enable_monitor_thread == 1) {
+				if (SitronixMonitorThread) {
+					kthread_stop(SitronixMonitorThread);
+					SitronixMonitorThread = NULL;
+				}
+			}
+#endif
+		}
+		break;
+	case IOCTL_SMT_RESUME:
+		UpgradeMsg("IOCTL_SMT_RESUME\n");
+		sitronix_ts_resume(sitronix_ts_gpts.client);
+		break;
+	case IOCTL_SMT_SUSPEND:
+		UpgradeMsg("IOCTL_SMT_SUSPEND\n");
+		sitronix_ts_suspend(sitronix_ts_gpts.client, PMSG_SUSPEND);
+		break;
+	case IOCTL_SMT_HW_RESET:
+		UpgradeMsg("IOCTL_SMT_HW_RESET\n");
+		sitronix_ts_reset_ic();
+		break;
+	case IOCTL_SMT_REPROBE:
+		UpgradeMsg("IOCTL_SMT_REPROBE\n");
+		sitronix_ts_reprobe();
+		break;
+	default:
+		retval = -ENOTTY;
 	}
 
-	/* SYN_MT_REPORT only if no contact */
-	if (!count) {
-		input_mt_sync(input_dev);
-		if (ts->low_latency_req.dev) {
-			dev_pm_qos_remove_request(&ts->low_latency_req);
-			ts->low_latency_req.dev = NULL;
+	return retval;
+}
+EXPORT_SYMBOL(sitronix_ioctl);
+#endif
+
+static void sitronix_ts_reset_ic(void)
+{
+	int err;
+	pr_info("%s\n", __func__);
+
+	if (gpio_is_valid(sitronix_ts_gpts.pdata->reset_gpio)) {
+
+		err =
+		    gpio_direction_output(sitronix_ts_gpts.pdata->reset_gpio,
+					  0);
+		if (err) {
+			dev_err(&sitronix_ts_gpts.client->dev,
+				"set_direction for reset gpio failed\n");
+			return;
 		}
-	} else if (!ts->low_latency_req.dev) {
-		/* First contact, request 100 us latency. */
-		dev_pm_qos_add_ancestor_request(&ts->client->dev,
-						&ts->low_latency_req, 100);
+		msleep(sitronix_ts_gpts.pdata->hard_rst_dly);
+		gpio_set_value_cansleep(sitronix_ts_gpts.pdata->reset_gpio, 1);
 	}
 
-	/* SYN_REPORT */
-	input_sync(input_dev);
+	/* make sure CTP already finish startup process */
+	msleep(sitronix_ts_gpts.pdata->soft_rst_dly);
 
-end:
-	return IRQ_HANDLED;
 }
 
-static void st1232_ts_power(struct st1232_ts_data *ts, bool poweron)
+static int sitronix_i2c_read_bytes(struct i2c_client *client, u8 addr,
+				   u8 *rxbuf, int len)
 {
-	if (gpio_is_valid(ts->reset_gpio))
-		gpio_direction_output(ts->reset_gpio, poweron);
+	int ret = 0;
+	u8 txbuf = addr;
+#if defined(SITRONIX_I2C_COMBINED_MESSAGE)
+	struct i2c_msg msg[2] = {
+		{
+		 .addr = client->addr,
+		 .flags = 0,
+		 .len = 1,
+		 .buf = &txbuf,
+		 },
+		{
+		 .addr = client->addr,
+		 .flags = I2C_M_RD,
+		 .len = len,
+		 .buf = rxbuf,
+		 },
+	};
+#endif
+
+	if (rxbuf == NULL)
+		return -EPERM;
+#if defined(SITRONIX_I2C_COMBINED_MESSAGE)
+	ret = i2c_transfer(client->adapter, &msg[0], 2);
+#elif defined(SITRONIX_I2C_SINGLE_MESSAGE)
+	ret = i2c_master_send(client, &txbuf, 1);
+	if (ret < 0) {
+		pr_info("write 0x%x error (%d)\n", addr, ret);
+		return ret;
+	}
+	ret = i2c_master_recv(client, rxbuf, len);
+#endif
+	if (ret < 0) {
+		DbgMsg("read 0x%x error (%d)\n", addr, ret);
+		return ret;
+	}
+	return 0;
 }
 
-static int st1232_ts_probe(struct i2c_client *client,
-					const struct i2c_device_id *id)
+static int sitronix_i2c_write_bytes(struct i2c_client *client, u8 *txbuf,
+				    int len)
 {
-	struct st1232_ts_data *ts;
-	struct st1232_pdata *pdata = client->dev.platform_data;
-	struct input_dev *input_dev;
-	int error;
+	int ret = 0;
+#if defined(SITRONIX_I2C_COMBINED_MESSAGE)
+	struct i2c_msg msg[1] = {
+		{
+		 .addr = client->addr,
+		 .flags = 0,
+		 .len = len,
+		 .buf = txbuf,
+		 },
+	};
+#endif
 
-	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
-		dev_err(&client->dev, "need I2C_FUNC_I2C\n");
-		return -EIO;
+	if (txbuf == NULL)
+		return -EPERM;
+#if defined(SITRONIX_I2C_COMBINED_MESSAGE)
+	ret = i2c_transfer(client->adapter, &msg[0], 1);
+#elif defined(SITRONIX_I2C_SINGLE_MESSAGE)
+	ret = i2c_master_send(client, txbuf, len);
+#endif
+	if (ret < 0) {
+		pr_info("write 0x%x error (%d)\n", *txbuf, ret);
+		return ret;
 	}
+	return 0;
+}
 
-	if (!client->irq) {
-		dev_err(&client->dev, "no IRQ?\n");
-		return -EINVAL;
+static int sitronix_get_fw_revision(struct sitronix_ts_data *ts)
+{
+	int ret = 0;
+	uint8_t buffer[4];
+
+	ret =
+	    sitronix_i2c_read_bytes(ts->client, FIRMWARE_REVISION_3, buffer, 4);
+	if (ret < 0) {
+		pr_info("read fw revision error (%d)\n", ret);
+		return ret;
+	} else {
+		memcpy(ts->fw_revision, buffer, 4);
+		pr_info("fw revision (hex) = %x %x %x %x\n", buffer[0],
+		       buffer[1], buffer[2], buffer[3]);
 	}
+	return 0;
+}
 
-	ts = devm_kzalloc(&client->dev, sizeof(*ts), GFP_KERNEL);
-	if (!ts)
-		return -ENOMEM;
+static int sitronix_get_max_touches(struct sitronix_ts_data *ts)
+{
+	int ret = 0;
+	uint8_t buffer[1];
 
-	input_dev = devm_input_allocate_device(&client->dev);
-	if (!input_dev)
-		return -ENOMEM;
+	ret = sitronix_i2c_read_bytes(ts->client, MAX_NUM_TOUCHES, buffer, 1);
+	if (ret < 0) {
+		pr_info("read max touches error (%d)\n", ret);
+		return ret;
+	} else {
+		ts->max_touches = buffer[0];
+		if (ts->max_touches > SITRONIX_MAX_SUPPORTED_POINT)
+			ts->max_touches = SITRONIX_MAX_SUPPORTED_POINT;
+		pr_info("max touches = %d\n", ts->max_touches);
+	}
+	return 0;
+}
+
+static int sitronix_get_protocol_type(struct sitronix_ts_data *ts)
+{
+	int ret = 0;
+	uint8_t buffer[1];
+
+	if (ts->chip_id <= 3) {
+		ret =
+		    sitronix_i2c_read_bytes(ts->client, I2C_PROTOCOL, buffer,
+					    1);
+		if (ret < 0) {
+			pr_info("read i2c protocol error (%d)\n", ret);
+			return ret;
+		} else {
+			ts->touch_protocol_type = buffer[0] & I2C_PROTOCOL_BMSK;
+			pr_info("i2c protocol = %d\n", ts->touch_protocol_type);
+			ts->sensing_mode =
+			    (buffer[0] &
+			     (ONE_D_SENSING_CONTROL_BMSK <<
+			      ONE_D_SENSING_CONTROL_SHFT)) >>
+			    ONE_D_SENSING_CONTROL_SHFT;
+			pr_info("sensing mode = %d\n", ts->sensing_mode);
+		}
+	} else {
+		ts->touch_protocol_type = SITRONIX_A_TYPE;
+		pr_info("i2c protocol = %d\n", ts->touch_protocol_type);
+		ret = sitronix_i2c_read_bytes(ts->client, 0xf0, buffer, 1);
+		if (ret < 0) {
+			pr_info("read sensing mode error (%d)\n", ret);
+			return ret;
+		} else {
+			ts->sensing_mode =
+			    (buffer[0] & ONE_D_SENSING_CONTROL_BMSK);
+			pr_info("sensing mode = %d\n", ts->sensing_mode);
+		}
+	}
+	return 0;
+}
+
+static int sitronix_get_resolution(struct sitronix_ts_data *ts)
+{
+	int ret = 0;
+	uint8_t buffer[3];
+
+	ret =
+	    sitronix_i2c_read_bytes(ts->client, XY_RESOLUTION_HIGH, buffer, 3);
+	if (ret < 0) {
+		pr_info("read resolution error (%d)\n", ret);
+		return ret;
+	} else {
+		ts->resolution_x =
+		    ((buffer[0] & (X_RES_H_BMSK << X_RES_H_SHFT)) << 4) |
+		    buffer[1];
+		ts->resolution_y =
+		    ((buffer[0] & Y_RES_H_BMSK) << 8) | buffer[2];
+		pr_info("resolution = %d x %d\n", ts->resolution_x,
+		       ts->resolution_y);
+	}
+	return 0;
+}
+
+static int sitronix_ts_get_CHIP_ID(struct sitronix_ts_data *ts)
+{
+	int ret = 0;
+	uint8_t buffer[3];
+
+	DbgMsg("%s\n", __func__);
+
+	ret = sitronix_i2c_read_bytes(ts->client, CHIP_ID, buffer, 3);
+	if (ret < 0) {
+		pr_info("read Chip ID error (%d)\n", ret);
+		return ret;
+	} else {
+		if (buffer[0] == 0) {
+			if (buffer[1] + buffer[2] > 32)
+				ts->chip_id = 2;
+			else
+				ts->chip_id = 0;
+		} else
+			ts->chip_id = buffer[0];
+		ts->Num_X = buffer[1];
+		ts->Num_Y = buffer[2];
+		pr_info("Chip ID = %d\n", ts->chip_id);
+		pr_info("Num_X = %d\n", ts->Num_X);
+		pr_info("Num_Y = %d\n", ts->Num_Y);
+	}
+
+	return 0;
+}
+
+static int sitronix_ts_set_powerdown_bit(struct sitronix_ts_data *ts, int value)
+{
+	int ret = 0;
+	uint8_t buffer[2];
 
-	ts->client = client;
-	ts->input_dev = input_dev;
+	DbgMsg("%s, value = %d\n", __func__, value);
+	ret =
+	    sitronix_i2c_read_bytes(ts->client, DEVICE_CONTROL_REG, buffer, 1);
+	if (ret < 0) {
+		pr_info("read device control status error (%d)\n", ret);
+		return ret;
+	} else {
+		DbgMsg("dev status = %d\n", buffer[0]);
+	}
 
-	if (pdata)
-		ts->reset_gpio = pdata->reset_gpio;
-	else if (client->dev.of_node)
-		ts->reset_gpio = of_get_gpio(client->dev.of_node, 0);
+	if (value == 0)
+		buffer[1] = buffer[0] & 0xfd;
 	else
-		ts->reset_gpio = -ENODEV;
+		buffer[1] = buffer[0] | 0x2;
 
-	if (gpio_is_valid(ts->reset_gpio)) {
-		error = devm_gpio_request(&client->dev, ts->reset_gpio, NULL);
-		if (error) {
-			dev_err(&client->dev,
-				"Unable to request GPIO pin %d.\n",
-				ts->reset_gpio);
-				return error;
+	buffer[0] = DEVICE_CONTROL_REG;
+	ret = sitronix_i2c_write_bytes(ts->client, buffer, 2);
+	if (ret < 0) {
+		pr_info("write power down error (%d)\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sitronix_ts_get_touch_info(struct sitronix_ts_data *ts)
+{
+	int ret = 0;
+	ret = sitronix_get_resolution(ts);
+	if (ret < 0)
+		return ret;
+	ret = sitronix_ts_get_CHIP_ID(ts);
+	if (ret < 0)
+		return ret;
+	ret = sitronix_get_fw_revision(ts);
+	if (ret < 0)
+		return ret;
+	ret = sitronix_get_protocol_type(ts);
+	if (ret < 0)
+		return ret;
+	ret = sitronix_get_max_touches(ts);
+	if (ret < 0)
+		return ret;
+
+	if ((ts->fw_revision[0] == 0) && (ts->fw_revision[1] == 0)) {
+		if (ts->touch_protocol_type == SITRONIX_RESERVED_TYPE_0) {
+			ts->touch_protocol_type = SITRONIX_B_TYPE;
+			pr_info("i2c protocol (revised) = %d\n",
+			       ts->touch_protocol_type);
 		}
 	}
 
-	st1232_ts_power(ts, true);
+	if (ts->touch_protocol_type == SITRONIX_A_TYPE)
+		ts->pixel_length = PIXEL_DATA_LENGTH_A;
+	else if (ts->touch_protocol_type == SITRONIX_B_TYPE) {
+		ts->pixel_length = PIXEL_DATA_LENGTH_B;
+		ts->max_touches = 2;
+		pr_info("max touches (revised) = %d\n", ts->max_touches);
+	}
 
-	input_dev->name = "st1232-touchscreen";
-	input_dev->id.bustype = BUS_I2C;
-	input_dev->dev.parent = &client->dev;
+#ifdef SITRONIX_MONITOR_THREAD
+	ts->RawCRC_enabled = 0;
+	if (ts->chip_id > 3) {
+		ts->enable_monitor_thread = 1;
+		ts->RawCRC_enabled = 1;
+	} else if (ts->chip_id == 3) {
+		ts->enable_monitor_thread = 1;
+		if (((ts->fw_revision[2] << 8) | ts->fw_revision[3]) >=
+		    (6 << 8 | 3))
+			ts->RawCRC_enabled = 1;
+	} else
+		ts->enable_monitor_thread = 0;
+#endif
 
-	__set_bit(EV_SYN, input_dev->evbit);
-	__set_bit(EV_KEY, input_dev->evbit);
-	__set_bit(EV_ABS, input_dev->evbit);
+	return 0;
+}
 
-	input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, MAX_AREA, 0, 0);
-	input_set_abs_params(input_dev, ABS_MT_POSITION_X, MIN_X, MAX_X, 0, 0);
-	input_set_abs_params(input_dev, ABS_MT_POSITION_Y, MIN_Y, MAX_Y, 0, 0);
+static int sitronix_ts_get_device_status(struct i2c_client *client,
+					 uint8_t *err_code,
+					 uint8_t *dev_status)
+{
+	int ret = 0;
+	uint8_t buffer[8];
 
-	error = devm_request_threaded_irq(&client->dev, client->irq,
-					  NULL, st1232_ts_irq_handler,
-					  IRQF_ONESHOT,
-					  client->name, ts);
-	if (error) {
-		dev_err(&client->dev, "Failed to register interrupt\n");
-		return error;
+	DbgMsg("%s\n", __func__);
+	ret = sitronix_i2c_read_bytes(client, STATUS_REG, buffer, 8);
+	if (ret < 0) {
+		pr_info("read status reg error (%d)\n", ret);
+		return ret;
+	} else {
+		pr_info("status reg = %d\n", buffer[0]);
 	}
 
-	error = input_register_device(ts->input_dev);
-	if (error) {
-		dev_err(&client->dev, "Unable to register %s input device\n",
-			input_dev->name);
-		return error;
+	*err_code = (buffer[0] & 0xf0) >> 4;
+	*dev_status = buffer[0] & 0xf;
+
+	return 0;
+}
+
+#ifdef SITRONIX_IDENTIFY_ID
+static int sitronix_ts_Enhance_Function_control(struct sitronix_ts_data *ts,
+						uint8_t *value)
+{
+	int ret = 0;
+	uint8_t buffer[1];
+
+	DbgMsg("%s\n", __func__);
+	ret = sitronix_i2c_read_bytes(ts->client, 0xF0, buffer, 1);
+	if (ret < 0) {
+		pr_info("read Enhance Functions status error (%d)\n", ret);
+		return ret;
+	} else {
+		DbgMsg("Enhance Functions status = %d\n", buffer[0]);
 	}
 
-	i2c_set_clientdata(client, ts);
-	device_init_wakeup(&client->dev, 1);
+	*value = buffer[0] & 0x4;
 
 	return 0;
 }
 
-static int st1232_ts_remove(struct i2c_client *client)
+static int sitronix_ts_FW_Bank_Select(struct sitronix_ts_data *ts,
+				      uint8_t value)
 {
-	struct st1232_ts_data *ts = i2c_get_clientdata(client);
+	int ret = 0;
+	uint8_t buffer[2];
+
+	DbgMsg("%s\n", __func__);
+	ret = sitronix_i2c_read_bytes(ts->client, 0xF1, buffer, 1);
+	if (ret < 0) {
+		pr_info("read FW Bank Select status error (%d)\n", ret);
+		return ret;
+	} else {
+		DbgMsg("FW Bank Select status = %d\n", buffer[0]);
+	}
 
-	device_init_wakeup(&client->dev, 0);
-	st1232_ts_power(ts, false);
+	buffer[1] = ((buffer[0] & 0xfc) | value);
+	buffer[0] = 0xF1;
+	ret = sitronix_i2c_write_bytes(ts->client, buffer, 2);
+	if (ret < 0) {
+		pr_info("send FW Bank Select command error (%d)\n", ret);
+		return ret;
+	}
 
 	return 0;
 }
 
-#ifdef CONFIG_PM_SLEEP
-static int st1232_ts_suspend(struct device *dev)
+static int sitronix_get_id_info(struct sitronix_ts_data *ts, uint8_t *id_info)
 {
-	struct i2c_client *client = to_i2c_client(dev);
-	struct st1232_ts_data *ts = i2c_get_clientdata(client);
+	int ret = 0;
+	uint8_t buffer[4];
 
-	if (device_may_wakeup(&client->dev)) {
-		enable_irq_wake(client->irq);
+	ret = sitronix_i2c_read_bytes(ts->client, 0x0C, buffer, 4);
+	if (ret < 0) {
+		pr_info("read id info error (%d)\n", ret);
+		return ret;
 	} else {
-		disable_irq(client->irq);
-		st1232_ts_power(ts, false);
+		memcpy(id_info, buffer, 4);
 	}
-
 	return 0;
 }
 
-static int st1232_ts_resume(struct device *dev)
+static int sitronix_ts_identify(struct sitronix_ts_data *ts)
 {
-	struct i2c_client *client = to_i2c_client(dev);
-	struct st1232_ts_data *ts = i2c_get_clientdata(client);
+	int ret = 0;
+	uint8_t id[4];
+	uint8_t Enhance_Function = 0;
 
-	if (device_may_wakeup(&client->dev)) {
-		disable_irq_wake(client->irq);
+	ret = sitronix_ts_FW_Bank_Select(ts, 1);
+	if (ret < 0)
+		return ret;
+	ret = sitronix_ts_Enhance_Function_control(ts, &Enhance_Function);
+	if (ret < 0)
+		return ret;
+
+	if (Enhance_Function == 0x4) {
+		ret = sitronix_get_id_info(ts, &id[0]);
+		if (ret < 0)
+			return ret;
+		pr_info("id (hex) = %x %x %x %x\n", id[0], id[1], id[2], id[3]);
+		if ((id[0] == 1) && (id[1] == 2) && (id[2] == 0xb)
+		    && (id[3] == 1)) {
+			return 0;
+		} else {
+			pr_info("Error: It is not Sitronix IC\n");
+			return -EPERM;
+		}
 	} else {
-		st1232_ts_power(ts, true);
-		enable_irq(client->irq);
+		pr_info("Error: Can not get ID of Sitronix IC\n");
+		return -EPERM;
+	}
+}
+#endif
+
+#ifdef SITRONIX_MONITOR_THREAD
+static int sitronix_set_raw_data_type(struct sitronix_ts_data *ts)
+{
+	int ret = 0;
+	uint8_t buffer[2] = { 0 };
+
+	ret =
+	    sitronix_i2c_read_bytes(ts->client, DEVICE_CONTROL_REG, buffer, 1);
+	if (ret < 0) {
+		DbgMsg("read DEVICE_CONTROL_REG error (%d)\n", ret);
+		return ret;
+	} else
+		DbgMsg("read DEVICE_CONTROL_REG status = %d\n", buffer[0]);
+
+	if (ts->sensing_mode == SENSING_BOTH_NOT)
+		buffer[1] = ((buffer[0] & 0xf3) | (0x01 << 2));
+	else
+		buffer[1] = (buffer[0] & 0xf3);
+
+	buffer[0] = DEVICE_CONTROL_REG;
+	ret = sitronix_i2c_write_bytes(ts->client, buffer, 2);
+	if (ret < 0) {
+		DbgMsg("write DEVICE_CONTROL_REG error (%d)\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int sitronix_ts_monitor_thread(void *data)
+{
+	int ret = 0;
+	uint8_t buffer[4] = { 0, 0, 0, 0 };
+	int result = 0;
+	int once = 1;
+	uint8_t raw_data_ofs = 0;
+
+	DbgMsg("%s:\n", __func__);
+
+	pr_info("delay %d ms\n", sitronix_ts_delay_monitor_thread_start);
+	msleep(sitronix_ts_delay_monitor_thread_start);
+
+	while (!kthread_should_stop()) {
+		DbgMsg("%s:\n", "Sitronix_ts_monitoring");
+		if (atomic_read(&iMonitorThreadPostpone)) {
+			atomic_set(&iMonitorThreadPostpone, 0);
+		} else {
+			if (once == 1) {
+				ret =
+				    sitronix_set_raw_data_type
+				    (&sitronix_ts_gpts);
+				if (ret < 0)
+					goto exit_i2c_invalid;
+
+				if ((sitronix_ts_gpts.sensing_mode ==
+				     SENSING_BOTH)
+				    || (sitronix_ts_gpts.sensing_mode ==
+					SENSING_X_ONLY)) {
+					raw_data_ofs = 0x40;
+				} else if (sitronix_ts_gpts.sensing_mode ==
+					   SENSING_Y_ONLY) {
+					raw_data_ofs =
+					    0x40 + sitronix_ts_gpts.Num_X * 2;
+				} else {
+					raw_data_ofs = 0x40;
+				}
+
+				once = 0;
+			}
+			if (raw_data_ofs != 0x40) {
+				ret =
+				    sitronix_i2c_read_bytes(sitronix_ts_gpts.
+							    client, 0x40,
+							    buffer, 1);
+				if (ret < 0) {
+					DbgMsg("read raw data error (%d)\n",
+					       ret);
+					result = 0;
+					goto exit_i2c_invalid;
+				}
+			}
+
+			ret =
+			    sitronix_i2c_read_bytes(sitronix_ts_gpts.client,
+						    raw_data_ofs, buffer, 4);
+			if (ret < 0) {
+				DbgMsg("read raw data error (%d)\n", ret);
+				result = 0;
+				goto exit_i2c_invalid;
+			} else {
+		DbgMsg("%dD data h%x-%x = 0x%02x,0x%02x, 0x%02x, 0x%02x\n",
+				     (sitronix_ts_gpts.sensing_mode ==
+				      SENSING_BOTH_NOT ? 2 : 1), raw_data_ofs,
+				     raw_data_ofs + 3, buffer[0], buffer[1],
+				     buffer[2], buffer[3]);
+				result = 1;
+
+				if ((PreCheckData[0] == buffer[0])
+				    && (PreCheckData[1] == buffer[1])
+				    && (PreCheckData[2] == buffer[2])
+				    && (PreCheckData[3] == buffer[3]))
+					StatusCheckCount++;
+				else
+					StatusCheckCount = 0;
+				PreCheckData[0] = buffer[0];
+				PreCheckData[1] = buffer[1];
+				PreCheckData[2] = buffer[2];
+				PreCheckData[3] = buffer[3];
+				if (3 <= StatusCheckCount) {
+					DbgMsg("IC Status doesn't update!\n");
+					result = -1;
+					StatusCheckCount = 0;
+				}
+			}
+
+			if (-1 == result) {
+				pr_info("Chip abnormal, reset it!\n");
+				sitronix_ts_reset_ic();
+				i2cErrorCount = 0;
+				StatusCheckCount = 0;
+				if (sitronix_ts_gpts.RawCRC_enabled == 0) {
+					ret =
+					    sitronix_set_raw_data_type
+					    (&sitronix_ts_gpts);
+					if (ret < 0)
+						goto exit_i2c_invalid;
+				}
+			}
+
+exit_i2c_invalid:
+			if (0 == result) {
+				i2cErrorCount++;
+				if ((2 <= i2cErrorCount)) {
+					pr_info("I2C abnormal, reset it!\n");
+					sitronix_ts_reset_ic();
+					if (sitronix_ts_gpts.RawCRC_enabled ==
+					    0)
+						sitronix_set_raw_data_type
+						    (&sitronix_ts_gpts);
+					i2cErrorCount = 0;
+					StatusCheckCount = 0;
+				}
+			} else
+				i2cErrorCount = 0;
+		}
+		msleep(gMonitorThreadSleepInterval);
 	}
 
+	DbgMsg("%s exit\n", __func__);
+	return 0;
+}
+
+static int sitronix_ts_monitor_thread_v2(void *data)
+{
+	int ret = 0;
+	uint8_t buffer[1] = { 0 };
+	int result = 0;
+
+	DbgMsg("%s:\n", __func__);
+
+	pr_info("delay %d ms\n", sitronix_ts_delay_monitor_thread_start);
+	msleep(sitronix_ts_delay_monitor_thread_start);
+	while (!kthread_should_stop()) {
+		DbgMsg("%s:\n", "Sitronix_ts_monitoring");
+		if (atomic_read(&iMonitorThreadPostpone)) {
+			atomic_set(&iMonitorThreadPostpone, 0);
+		} else {
+			ret =
+			    sitronix_i2c_read_bytes(sitronix_ts_gpts.client,
+						    0xA, buffer, 1);
+			if (ret < 0) {
+				DbgMsg("read Raw CRC error (%d)\n", ret);
+				result = 0;
+				goto exit_i2c_invalid;
+			} else {
+				DbgMsg("Raw CRC = 0x%02x\n", buffer[0]);
+				result = 1;
+
+				if (PreCheckData[0] == buffer[0])
+					StatusCheckCount++;
+				else
+					StatusCheckCount = 0;
+				PreCheckData[0] = buffer[0];
+				if (3 <= StatusCheckCount) {
+					DbgMsg("IC Status doesn't update!\n");
+					result = -1;
+					StatusCheckCount = 0;
+				}
+			}
+
+			if (-1 == result) {
+				pr_info("Chip abnormal, reset it!\n");
+				sitronix_ts_reset_ic();
+				i2cErrorCount = 0;
+				StatusCheckCount = 0;
+			}
+exit_i2c_invalid:
+			if (0 == result) {
+				i2cErrorCount++;
+				if ((2 <= i2cErrorCount)) {
+					pr_info("I2C abnormal, reset it!\n");
+					sitronix_ts_reset_ic();
+					i2cErrorCount = 0;
+					StatusCheckCount = 0;
+				}
+			} else
+				i2cErrorCount = 0;
+		}
+		msleep(gMonitorThreadSleepInterval);
+	}
+	DbgMsg("%s exit\n", __func__);
 	return 0;
 }
+#endif
 
+static inline void sitronix_ts_pen_down(struct input_dev *input_dev, int id,
+					u16 x, u16 y)
+{
+#ifdef SITRONIX_SUPPORT_MT_SLOT
+	input_mt_slot(input_dev, id);
+	input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, true);
+#ifndef SITRONIX_SWAP_XY
+	input_report_abs(input_dev, ABS_MT_POSITION_X, x);
+	input_report_abs(input_dev, ABS_MT_POSITION_Y, y);
+#else
+	input_report_abs(input_dev, ABS_MT_POSITION_X, y);
+	input_report_abs(input_dev, ABS_MT_POSITION_Y, x);
 #endif
+#else
+	input_report_abs(input_dev, ABS_MT_TRACKING_ID, id);
+#ifndef SITRONIX_SWAP_XY
+	input_report_abs(input_dev, ABS_MT_POSITION_X, x);
+	input_report_abs(input_dev, ABS_MT_POSITION_Y, y);
+#else
+	input_report_abs(input_dev, ABS_MT_POSITION_X, y);
+	input_report_abs(input_dev, ABS_MT_POSITION_Y, x);
+#endif
+	input_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, 10);
+	input_report_abs(input_dev, ABS_MT_WIDTH_MAJOR, 10);
+/*#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)*/
+	input_report_abs(input_dev, ABS_MT_PRESSURE, 10);
+/*#endif*/
+	input_mt_sync(input_dev);
+#endif
+	DbgMsg("[%d](%d, %d)+\n", id, x, y);
+}
 
-static SIMPLE_DEV_PM_OPS(st1232_ts_pm_ops,
-			 st1232_ts_suspend, st1232_ts_resume);
+static inline void sitronix_ts_pen_up(struct input_dev *input_dev, int id)
+{
+#ifdef SITRONIX_SUPPORT_MT_SLOT
+	input_mt_slot(input_dev, id);
+	input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, false);
+#endif
+	DbgMsg("[%d]-\n", id);
+}
 
-static const struct i2c_device_id st1232_ts_id[] = {
-	{ ST1232_TS_NAME, 0 },
-	{ }
-};
-MODULE_DEVICE_TABLE(i2c, st1232_ts_id);
+static inline void sitronix_ts_handle_sensor_key(struct input_dev *input_dev,
+						struct sitronix_sensor_key_t
+						 *key_array,
+						 char *pre_key_status,
+						 char cur_key_status,
+						 int key_count)
+{
+	int i = 0;
+	for (i = 0; i < key_count; i++) {
+		if (cur_key_status & (1 << i)) {
+			DbgMsg("sensor key[%d] down\n", i);
+			input_report_key(input_dev, key_array[i].code, 1);
+			input_sync(input_dev);
+		} else {
+			if (*pre_key_status & (1 << i)) {
+				DbgMsg("sensor key[%d] up\n", i);
+				input_report_key(input_dev, key_array[i].code,
+						 0);
+				input_sync(input_dev);
+			}
+		}
+	}
+	*pre_key_status = cur_key_status;
+}
 
-#ifdef CONFIG_OF
-static const struct of_device_id st1232_ts_dt_ids[] = {
-	{ .compatible = "sitronix,st1232", },
-	{ }
-};
-MODULE_DEVICE_TABLE(of, st1232_ts_dt_ids);
+#ifdef SITRONIX_AA_KEY
+static inline void sitronix_ts_handle_aa_key(struct input_dev *input_dev,
+					     struct sitronix_AA_key *key_array,
+					     char *pre_key_status,
+					     char cur_key_status, int key_count)
+{
+	int i = 0;
+	for (i = 0; i < key_count; i++) {
+		if (cur_key_status & (1 << i)) {
+			DbgMsg("aa key[%d] down\n", i);
+			input_report_key(input_dev, key_array[i].code, 1);
+			input_sync(input_dev);
+		} else {
+			if (*pre_key_status & (1 << i)) {
+				DbgMsg("aa key[%d] up\n", i);
+				input_report_key(input_dev, key_array[i].code,
+						 0);
+				input_sync(input_dev);
+			}
+		}
+	}
+	*pre_key_status = cur_key_status;
+}
 #endif
 
-static struct i2c_driver st1232_ts_driver = {
-	.probe		= st1232_ts_probe,
-	.remove		= st1232_ts_remove,
-	.id_table	= st1232_ts_id,
-	.driver = {
-		.name	= ST1232_TS_NAME,
-		.owner	= THIS_MODULE,
-		.of_match_table = of_match_ptr(st1232_ts_dt_ids),
-		.pm	= &st1232_ts_pm_ops,
-	},
-};
+static void sitronix_ts_work_func(struct work_struct *work)
+{
+	int i;
+#ifdef SITRONIX_AA_KEY
+	int j;
+	char aa_key_status = 0;
+#endif
+	int ret;
+#ifndef SITRONIX_INT_POLLING_MODE
+	struct sitronix_ts_data *ts =
+	    container_of(work, struct sitronix_ts_data, work);
+#else
+	struct sitronix_ts_data *ts =
+	    container_of(to_delayed_work(work), struct sitronix_ts_data, work);
+#endif
+	u16 x, y;
+	uint8_t buffer[1 + SITRONIX_MAX_SUPPORTED_POINT * PIXEL_DATA_LENGTH_A]
+		= { 0 };
+	uint8_t PixelCount = 0;
+
+	DbgMsg("%s\n", __func__);
+	atomic_set(&sitronix_ts_in_int, 1);
+	if (ts->suspend_state)
+		goto exit_invalid_data;
+
+	ret =
+	    sitronix_i2c_read_bytes(ts->client, KEYS_REG, buffer,
+				    1 + ts->max_touches * ts->pixel_length);
+	if (ret < 0) {
+		pr_info("read finger error (%d)\n", ret);
+		i2cErrorCount++;
+		goto exit_invalid_data;
+	}
+
+	for (i = 0; i < ts->max_touches; i++) {
+		if (buffer[1 + i * ts->pixel_length + XY_COORD_H] & 0x80) {
+			x = (u16) (buffer[1 + i * ts->pixel_length + XY_COORD_H]
+				   & 0x70) << 4 | buffer[1 +
+							 i * ts->pixel_length +
+							 X_COORD_L];
+			y = (u16) (buffer[1 + i * ts->pixel_length + XY_COORD_H]
+				   & 0x07) << 8 | buffer[1 +
+							 i * ts->pixel_length +
+							 Y_COORD_L];
+#ifndef SITRONIX_AA_KEY
+			PixelCount++;
+			sitronix_ts_pen_down(ts->input_dev, i, x, y);
+#else
+#ifdef SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY
+			if (y < SITRONIX_TOUCH_RESOLUTION_Y) {
+#else
+			if (y <
+			    (ts->resolution_y -
+			     ts->resolution_y / SCALE_KEY_HIGH_Y)) {
+#endif
+				PixelCount++;
+				sitronix_ts_pen_down(ts->input_dev, i, x, y);
+			} else {
+				for (j = 0;
+				     j <
+				     (sizeof(sitronix_aa_key_array) /
+				      sizeof(struct sitronix_AA_key)); j++) {
+					if ((x >=
+					     sitronix_aa_key_array[j].x_low)
+					    && (x <=
+						sitronix_aa_key_array[j].x_high)
+					    && (y >=
+						sitronix_aa_key_array[j].y_low)
+					    && (y <=
+						sitronix_aa_key_array[j].
+						y_high)) {
+						aa_key_status |= (1 << j);
+						break;
+					}
+				}
+			}
+#endif
+		} else {
+			sitronix_ts_pen_up(ts->input_dev, i);
+		}
+	}
+	input_report_key(ts->input_dev, BTN_TOUCH, PixelCount > 0);
+	input_sync(ts->input_dev);
+
+	sitronix_ts_handle_sensor_key(ts->keyevent_input,
+				      sitronix_sensor_key_array,
+				      &sitronix_sensor_key_status, buffer[0],
+				      (sizeof(sitronix_sensor_key_array) /
+				       sizeof(struct sitronix_sensor_key_t)));
+#ifdef SITRONIX_AA_KEY
+	sitronix_ts_handle_aa_key(ts->keyevent_input, sitronix_aa_key_array,
+				  &sitronix_aa_key_status, aa_key_status,
+				  (sizeof(sitronix_aa_key_array) /
+				   sizeof(struct sitronix_AA_key)));
+#endif
 
-module_i2c_driver(st1232_ts_driver);
+exit_invalid_data:
+#ifdef SITRONIX_INT_POLLING_MODE
+	if (PixelCount > 0) {
+#ifdef SITRONIX_MONITOR_THREAD
+		if (ts->enable_monitor_thread == 1)
+			atomic_set(&iMonitorThreadPostpone, 1);
+#endif
+		schedule_delayed_work(&ts->work,
+				      msecs_to_jiffies
+				      (INT_POLLING_MODE_INTERVAL));
+	} else {
+		if (ts->use_irq) {
+			atomic_set(&sitronix_ts_irq_on, 1);
+			enable_irq(ts->client->irq);
+		}
+	}
+#endif
+#if defined(SITRONIX_LEVEL_TRIGGERED)
+	if (ts->use_irq) {
+		atomic_set(&sitronix_ts_irq_on, 1);
+		enable_irq(ts->client->irq);
+	}
+#endif
+	if ((2 <= i2cErrorCount)) {
+		pr_info("I2C abnormal in work_func(), reset it!\n");
+		sitronix_ts_reset_ic();
+		i2cErrorCount = 0;
+#ifdef SITRONIX_MONITOR_THREAD
+		if (ts->enable_monitor_thread == 1) {
+			StatusCheckCount = 0;
+			if (ts->RawCRC_enabled == 0)
+				sitronix_set_raw_data_type(&sitronix_ts_gpts);
+		}
+#endif
+	}
+	atomic_set(&sitronix_ts_in_int, 0);
+}
+
+static irqreturn_t sitronix_ts_irq_handler(int irq, void *dev_id)
+{
+	struct sitronix_ts_data *ts = dev_id;
+
+	DbgMsg("%s\n", __func__);
+	atomic_set(&sitronix_ts_in_int, 1);
+#if defined(SITRONIX_LEVEL_TRIGGERED) || defined(SITRONIX_INT_POLLING_MODE)
+	atomic_set(&sitronix_ts_irq_on, 0);
+	disable_irq_nosync(ts->client->irq);
+#endif
+#ifdef SITRONIX_MONITOR_THREAD
+	if (ts->enable_monitor_thread == 1)
+		atomic_set(&iMonitorThreadPostpone, 1);
+#endif
+#ifndef SITRONIX_INT_POLLING_MODE
+	schedule_work(&ts->work);
+#else
+	schedule_delayed_work(&ts->work, msecs_to_jiffies(0));
+#endif
+	return IRQ_HANDLED;
+}
+
+static int sitronix_power_on(struct sitronix_ts_data *data, bool on)
+{
+	int rc;
+
+	if (!on)
+		goto power_off;
+
+	rc = regulator_enable(data->vdd);
+	if (rc) {
+		dev_err(&data->client->dev,
+			"Regulator vdd enable failed rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = regulator_enable(data->vcc_i2c);
+	if (rc) {
+		dev_err(&data->client->dev,
+			"Regulator vcc_i2c enable failed rc=%d\n", rc);
+		regulator_disable(data->vdd);
+	}
+
+	return rc;
+
+power_off:
+	rc = regulator_disable(data->vdd);
+	if (rc) {
+		dev_err(&data->client->dev,
+			"Regulator vdd disable failed rc=%d\n", rc);
+		return rc;
+	}
+
+	rc = regulator_disable(data->vcc_i2c);
+	if (rc) {
+		dev_err(&data->client->dev,
+			"Regulator vcc_i2c disable failed rc=%d\n", rc);
+		rc = regulator_enable(data->vdd);
+		if (rc) {
+			dev_err(&data->client->dev,
+				"Regulator vdd enable failed rc=%d\n", rc);
+		}
+	}
+
+	return rc;
+}
+
+static int sitronix_power_init(struct sitronix_ts_data *data, bool on)
+{
+	int rc;
+
+	if (!on)
+		goto pwr_deinit;
+
+	data->vdd = regulator_get(&data->client->dev, "vdd");
+	if (IS_ERR(data->vdd)) {
+		rc = PTR_ERR(data->vdd);
+		dev_err(&data->client->dev, "Regulator get failed vdd rc=%d\n",
+			rc);
+		return rc;
+	}
+
+	if (regulator_count_voltages(data->vdd) > 0) {
+		rc = regulator_set_voltage(data->vdd, SI_VTG_MIN_UV,
+					   SI_VTG_MAX_UV);
+		if (rc) {
+			dev_err(&data->client->dev,
+				"Regulator set_vtg failed vdd rc=%d\n", rc);
+			goto reg_vdd_put;
+		}
+	}
+
+	data->vcc_i2c = regulator_get(&data->client->dev, "vcc_i2c");
+	if (IS_ERR(data->vcc_i2c)) {
+		rc = PTR_ERR(data->vcc_i2c);
+		dev_err(&data->client->dev,
+			"Regulator get failed vcc_i2c rc=%d\n", rc);
+		goto reg_vdd_set_vtg;
+	}
+
+	if (regulator_count_voltages(data->vcc_i2c) > 0) {
+		rc = regulator_set_voltage(data->vcc_i2c, SI_I2C_VTG_MIN_UV,
+					   SI_I2C_VTG_MAX_UV);
+		if (rc) {
+			dev_err(&data->client->dev,
+				"Regulator set_vtg failed vcc_i2c rc=%d\n", rc);
+			goto reg_vcc_i2c_put;
+		}
+	}
+
+	return 0;
+
+reg_vcc_i2c_put:
+	regulator_put(data->vcc_i2c);
+reg_vdd_set_vtg:
+	if (regulator_count_voltages(data->vdd) > 0)
+		regulator_set_voltage(data->vdd, 0, SI_VTG_MAX_UV);
+reg_vdd_put:
+	regulator_put(data->vdd);
+	return rc;
+
+pwr_deinit:
+	if (regulator_count_voltages(data->vdd) > 0)
+		regulator_set_voltage(data->vdd, 0, SI_VTG_MAX_UV);
+
+	regulator_put(data->vdd);
+
+	if (regulator_count_voltages(data->vcc_i2c) > 0)
+		regulator_set_voltage(data->vcc_i2c, 0, SI_I2C_VTG_MAX_UV);
+
+	regulator_put(data->vcc_i2c);
+	return 0;
+}
+
+static ssize_t sitronix_ts_info_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct sitronix_ts_data *data = dev_get_drvdata(dev);
+	return snprintf(buf, SI_INFO_MAX_LEN, "%s\n", data->ts_info);
+}
+
+static DEVICE_ATTR(ts_info, 0444, sitronix_ts_info_show, NULL);
+
+static ssize_t sitronix_mt_protocol_type_show(struct device *dev,
+					      struct device_attribute *attr,
+					      char *buf)
+{
+	return snprintf(buf, 16, "%s\n", "MT Protocal B");
+}
+
+static DEVICE_ATTR(mt_protocol_type, 0444, sitronix_mt_protocol_type_show,
+		   NULL);
+
+static ssize_t sitronix_enable_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t size)
+{
+	struct sitronix_ts_data *data = dev_get_drvdata(dev);
+	unsigned long val;
+	int rc;
+
+	if (size > 2)
+		return -EINVAL;
+
+	if (data->suspend_state) {
+		dev_info(&data->client->dev, "Already in suspend state\n");
+		goto no_operation;
+	}
+
+	rc = kstrtoul(buf, 10, &val);
+	if (rc != 0)
+		return rc;
+
+	if (val) {
+		if (gpio_is_valid(data->pdata->reset_gpio)) {
+			gpio_set_value_cansleep(data->pdata->reset_gpio, 0);
+			msleep(data->pdata->hard_rst_dly);
+			gpio_set_value_cansleep(data->pdata->reset_gpio, 1);
+			msleep(data->pdata->soft_rst_dly);
+		}
+		sitronix_ts_set_powerdown_bit(data, 0);
+		if (data->use_irq) {
+			atomic_set(&sitronix_ts_irq_on, 1);
+			enable_irq(data->client->irq);
+		}
+		data->enable = true;
+	} else {
+		mutex_lock(&data->input_dev->mutex);
+		rc = sitronix_ts_set_powerdown_bit(data, 1);
+		if (rc < 0)
+			dev_err(&data->client->dev, "disable tp ic failed\n");
+		if (data->use_irq) {
+			atomic_set(&sitronix_ts_irq_on, 0);
+			disable_irq_nosync(data->client->irq);
+		}
+		mutex_unlock(&data->input_dev->mutex);
+		data->enable = false;
+	}
+
+no_operation:
+	return size;
+}
+
+static ssize_t sitronix_enable_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct sitronix_ts_data *data = dev_get_drvdata(dev);
+
+	if (data->suspend_state) {
+		dev_info(&data->client->dev, "Already in suspend state\n");
+		return snprintf(buf, 4, "%s\n", "0");
+	}
+
+	return snprintf(buf, 4, "%s\n", data->enable ? "1" : "0");
+}
+
+static DEVICE_ATTR(enable, 0664, sitronix_enable_show, sitronix_enable_store);
+
+static ssize_t sitronix_fw_name_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct sitronix_ts_data *data = dev_get_drvdata(dev);
+	return snprintf(buf, SI_FW_NAME_MAX_LEN - 1, "%s\n", data->fw_name);
+}
+
+static ssize_t sitronix_fw_name_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t size)
+{
+	struct sitronix_ts_data *data = dev_get_drvdata(dev);
+
+	if (size > SI_FW_NAME_MAX_LEN - 1)
+		return -EINVAL;
+
+	strlcpy(data->fw_name, buf, size);
+	if (data->fw_name[size - 1] == '\n')
+		data->fw_name[size - 1] = 0;
+
+	return size;
+}
+
+static DEVICE_ATTR(fw_name, 0664, sitronix_fw_name_show,
+		   sitronix_fw_name_store);
+
+static bool sitronix_debug_addr_is_valid(int addr)
+{
+	if (addr < 0 || addr > 0xFF) {
+		pr_err("FT reg address is invalid: 0x%x\n", addr);
+		return false;
+	}
+
+	return true;
+}
+
+static int sitronix_debug_data_set(void *_data, u64 val)
+{
+	struct sitronix_ts_data *data = _data;
+
+	mutex_lock(&data->input_dev->mutex);
+
+	if (sitronix_debug_addr_is_valid(data->addr))
+		dev_info(&data->client->dev,
+			 "Writing into FT registers not supported\n");
+
+	mutex_unlock(&data->input_dev->mutex);
+
+	return 0;
+}
+
+static int sitronix_debug_data_get(void *_data, u64 *val)
+{
+	struct sitronix_ts_data *data = _data;
+	int rc;
+	u8 reg;
+
+	mutex_lock(&data->input_dev->mutex);
+
+	if (sitronix_debug_addr_is_valid(data->addr)) {
+		rc = sitronix_i2c_read_bytes(data->client, data->addr, &reg, 1);
+		if (rc < 0)
+			dev_err(&data->client->dev,
+				"sitronix read register 0x%x failed (%d)\n",
+				data->addr, rc);
+		else
+			*val = reg;
+	}
+
+	mutex_unlock(&data->input_dev->mutex);
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(debug_data_fops, sitronix_debug_data_get,
+			sitronix_debug_data_set, "0x%02llX\n");
+
+static int sitronix_debug_addr_set(void *_data, u64 val)
+{
+	struct sitronix_ts_data *data = _data;
+
+	if (sitronix_debug_addr_is_valid(val)) {
+		mutex_lock(&data->input_dev->mutex);
+		data->addr = val;
+		mutex_unlock(&data->input_dev->mutex);
+	}
+
+	return 0;
+}
+
+static int sitronix_debug_addr_get(void *_data, u64 *val)
+{
+	struct sitronix_ts_data *data = _data;
+
+	mutex_lock(&data->input_dev->mutex);
+
+	if (sitronix_debug_addr_is_valid(data->addr))
+		*val = data->addr;
+
+	mutex_unlock(&data->input_dev->mutex);
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(debug_addr_fops, sitronix_debug_addr_get,
+			sitronix_debug_addr_set, "0x%02llX\n");
+
+static int sitronix_debug_suspend_set(void *_data, u64 val)
+{
+	struct sitronix_ts_data *data = _data;
+
+	mutex_lock(&data->input_dev->mutex);
+
+	if (val)
+		sitronix_ts_normal_suspend(&data->client->dev);
+	else
+		sitronix_ts_normal_resume(&data->client->dev);
+
+	mutex_unlock(&data->input_dev->mutex);
+
+	return 0;
+}
+
+static int sitronix_debug_suspend_get(void *_data, u64 *val)
+{
+	struct sitronix_ts_data *data = _data;
+
+	mutex_lock(&data->input_dev->mutex);
+	*val = data->suspend_state;
+	mutex_unlock(&data->input_dev->mutex);
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(debug_suspend_fops, sitronix_debug_suspend_get,
+			sitronix_debug_suspend_set, "%lld\n");
+
+static int sitronix_debug_dump_info(struct seq_file *m, void *v)
+{
+	struct sitronix_ts_data *data = m->private;
+
+	seq_printf(m, "%s\n", data->ts_info);
+
+	return 0;
+}
+
+static int debugfs_dump_info_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, sitronix_debug_dump_info, inode->i_private);
+}
+
+static const struct file_operations debug_dump_info_fops = {
+	.owner = THIS_MODULE,
+	.open = debugfs_dump_info_open,
+	.read = seq_read,
+	.release = single_release,
+};
+
+#ifdef CONFIG_OF
+static int sitronix_get_dt_coords(struct device *dev, char *name,
+				  struct sitronix_ts_platform_data *pdata)
+{
+	u32 coords[SI_COORDS_ARR_SIZE];
+	struct property *prop;
+	struct device_node *np = dev->of_node;
+	int coords_size, rc;
+
+	prop = of_find_property(np, name, NULL);
+	if (!prop)
+		return -EINVAL;
+	if (!prop->value)
+		return -ENODATA;
+
+	coords_size = prop->length / sizeof(u32);
+	if (coords_size != SI_COORDS_ARR_SIZE) {
+		dev_err(dev, "invalid %s\n", name);
+		return -EINVAL;
+	}
+
+	rc = of_property_read_u32_array(np, name, coords, coords_size);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read %s\n", name);
+		return rc;
+	}
+
+	if (!strcmp(name, "sitronix,panel-coords")) {
+		pdata->panel_minx = coords[0];
+		pdata->panel_miny = coords[1];
+		pdata->panel_maxx = coords[2];
+		pdata->panel_maxy = coords[3];
+	} else if (!strcmp(name, "sitronix,display-coords")) {
+		pdata->x_min = coords[0];
+		pdata->y_min = coords[1];
+		pdata->x_max = coords[2];
+		pdata->y_max = coords[3];
+	} else {
+		dev_err(dev, "unsupported property %s\n", name);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sitronix_parse_dt(struct device *dev,
+			     struct sitronix_ts_platform_data *pdata)
+{
+	int rc;
+	struct device_node *np = dev->of_node;
+	struct property *prop;
+	u32 temp_val;
+
+	pdata->name = "sitronix";
+	rc = of_property_read_string(np, "sitronix,name", &pdata->name);
+	if (rc && (rc != -EINVAL)) {
+		dev_err(dev, "Unable to read name\n");
+		return rc;
+	}
+
+	rc = sitronix_get_dt_coords(dev, "sitronix,panel-coords", pdata);
+	if (rc && (rc != -EINVAL))
+		dev_err(dev, "Unable to read sitronix,panel-coords\n");
+
+	rc = sitronix_get_dt_coords(dev, "sitronix,display-coords", pdata);
+	if (rc)
+		dev_err(dev, "Unable to read sitronix,display-coords\n");
+
+	pdata->i2c_pull_up = of_property_read_bool(np, "sitronix,i2c-pull-up");
+
+	pdata->no_force_update = of_property_read_bool(np,
+						       "sitronix,no-force-update");
+	/* reset, irq gpio info */
+	pdata->reset_gpio = of_get_named_gpio_flags(np, "sitronix,reset-gpio",
+						    0,
+						    &pdata->reset_gpio_flags);
+	if (pdata->reset_gpio < 0)
+		return pdata->reset_gpio;
+
+	pdata->irq_gpio = of_get_named_gpio_flags(np, "sitronix,irq-gpio",
+						  0, &pdata->irq_gpio_flags);
+	if (pdata->irq_gpio < 0)
+		return pdata->irq_gpio;
+
+	pdata->fw_name = "unknown";
+	rc = of_property_read_string(np, "sitronix,fw-name", &pdata->fw_name);
+	if (rc && (rc != -EINVAL))
+		dev_err(dev, "Unable to read fw name\n");
+
+	rc = of_property_read_u32(np, "sitronix,group-id", &temp_val);
+	if (!rc)
+		pdata->group_id = temp_val;
+	else
+		pdata->group_id = 0;
+
+	rc = of_property_read_u32(np, "sitronix,family-id", &temp_val);
+	if (!rc)
+		pdata->family_id = temp_val;
+	else
+		pdata->family_id = 0;
+
+	rc = of_property_read_u32(np, "sitronix,hard-reset-delay-ms",
+				  &temp_val);
+	if (!rc)
+		pdata->hard_rst_dly = temp_val;
+	else
+		return rc;
+
+	rc = of_property_read_u32(np, "sitronix,soft-reset-delay-ms",
+				  &temp_val);
+	if (!rc)
+		pdata->soft_rst_dly = temp_val;
+	else
+		return rc;
+
+	rc = of_property_read_u32(np, "sitronix,num-max-touches", &temp_val);
+	if (!rc)
+		pdata->num_max_touches = temp_val;
+	else
+		return rc;
+
+	pdata->fw_vkey_support = of_property_read_bool(np,
+						       "sitronix,fw-vkey-support");
+
+	pdata->num_buttons = 0;
+	prop = of_find_property(np, "sitronix,button-map", NULL);
+	if (prop) {
+		pdata->num_buttons = prop->length / sizeof(temp_val);
+		if (pdata->num_buttons > MAX_BUTTONS)
+			return -EINVAL;
+
+		rc = of_property_read_u32_array(np,
+						"sitronix,button-map",
+					pdata->button_map, pdata->num_buttons);
+		if (rc) {
+			dev_err(dev, "Unable to read key codes\n");
+			return rc;
+		}
+	}
+
+	return 0;
+}
+#else
+static int sitronix_parse_dt(struct device *dev,
+			     struct sitronix_ts_platform_data *pdata)
+{
+	return -ENODEV;
+}
+#endif
+
+static int sitronix_ts_probe(struct i2c_client *client,
+			     const struct i2c_device_id *id)
+{
+	int i;
+	int ret = 0;
+	uint16_t max_x = 0, max_y = 0;
+	uint8_t err_code = 0;
+	uint8_t dev_status = 0;
+	struct sitronix_ts_platform_data *pdata;
+	struct sitronix_ts_data *data = &sitronix_ts_gpts;
+	struct dentry *temp;
+	int len;
+#ifdef SITRONIX_AA_KEY
+	int num;
+#endif
+	int err;
+
+	if (client->dev.of_node) {
+		pdata = devm_kzalloc(&client->dev,
+				     sizeof(struct sitronix_ts_platform_data),
+				     GFP_KERNEL);
+		if (!pdata) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			return -ENOMEM;
+		}
+
+		err = sitronix_parse_dt(&client->dev, pdata);
+		if (err) {
+			dev_err(&client->dev, "DT parsing failed\n");
+			return err;
+		}
+	} else
+		pdata = client->dev.platform_data;
+
+	if (!pdata) {
+		dev_err(&client->dev, "Invalid pdata\n");
+		return -EINVAL;
+	}
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		ret = -ENODEV;
+		goto err_check_functionality_failed;
+	}
+
+	sitronix_ts_gpts.enable = true;
+	sitronix_ts_gpts.pdata = pdata;
+	sitronix_ts_gpts.client = client;
+	sitronix_ts_gpts.suspend_state = 0;
+	i2c_set_clientdata(client, &sitronix_ts_gpts);
+
+	if (pdata->fw_name) {
+		len = strlen(pdata->fw_name);
+		if (len > SI_FW_NAME_MAX_LEN - 1) {
+			dev_err(&client->dev, "Invalid firmware name\n");
+			return -EINVAL;
+		}
+
+		strlcpy(sitronix_ts_gpts.fw_name, pdata->fw_name, len + 1);
+	}
+
+#ifdef SITRONIX_AA_KEY
+	if (pdata->num_buttons) {
+		for (num = 0; num < pdata->num_buttons &&
+			num < (sizeof(sitronix_aa_key_array) /
+				sizeof(struct sitronix_AA_key));
+				num++) {
+			sitronix_aa_key_array[num].code =
+				pdata->button_map[num];
+			pr_info("sitronix_aa_key_array[num].code = %d\n",
+					pdata->button_map[num]);
+		}
+	}
+#endif
+
+	if (pdata->power_init) {
+		err = pdata->power_init(true);
+		if (err) {
+			dev_err(&client->dev, "power init failed");
+			return -ENODEV;
+		}
+	} else {
+		err = sitronix_power_init(&sitronix_ts_gpts, true);
+		if (err) {
+			dev_err(&client->dev, "power init failed");
+			return -ENODEV;
+		}
+	}
+
+	if (pdata->power_on) {
+		err = pdata->power_on(true);
+		if (err) {
+			dev_err(&client->dev, "power on failed");
+			goto pwr_deinit;
+		}
+	} else {
+		err = sitronix_power_on(&sitronix_ts_gpts, true);
+		if (err) {
+			dev_err(&client->dev, "power on failed");
+			goto pwr_deinit;
+		}
+	}
+
+	if (gpio_is_valid(pdata->irq_gpio)) {
+		err = gpio_request(pdata->irq_gpio, "sitronix_irq_gpio");
+		if (err) {
+			dev_err(&client->dev, "irq gpio request failed");
+			goto pwr_off;
+		}
+		err = gpio_direction_input(pdata->irq_gpio);
+		if (err) {
+			dev_err(&client->dev,
+				"set_direction for irq gpio failed\n");
+			goto free_irq_gpio;
+		}
+	}
+
+	if (gpio_is_valid(pdata->reset_gpio)) {
+		err = gpio_request(pdata->reset_gpio, "sitronix_reset_gpio");
+		if (err) {
+			dev_err(&client->dev, "reset gpio request failed");
+			goto free_irq_gpio;
+		}
+
+		err = gpio_direction_output(pdata->reset_gpio, 0);
+		if (err) {
+			dev_err(&client->dev,
+				"set_direction for reset gpio failed\n");
+			goto free_reset_gpio;
+		}
+		msleep(sitronix_ts_gpts.pdata->hard_rst_dly);
+		gpio_set_value_cansleep(pdata->reset_gpio, 1);
+	}
+
+	/* make sure CTP already finish startup process */
+	msleep(sitronix_ts_gpts.pdata->soft_rst_dly);
+
+	ret = sitronix_ts_get_device_status(client, &err_code, &dev_status);
+	if ((ret < 0) || (dev_status == 0x6) || ((err_code == 0x8)
+				       && (dev_status == 0x0))) {
+		if ((dev_status == 0x6)
+		    || ((err_code == 0x8) && (dev_status == 0x0))) {
+			sitronix_ts_gpts.client = client;
+		}
+		ret = -EPERM;
+		goto err_device_info_error;
+	}
+
+	ret = sitronix_ts_get_touch_info(&sitronix_ts_gpts);
+	if (ret < 0)
+		goto err_device_info_error;
+
+#ifdef SITRONIX_IDENTIFY_ID
+	ret = sitronix_ts_identify(&sitronix_ts_gpts);
+	if (ret < 0)
+		goto err_device_info_error;
+#endif
+
+#ifndef SITRONIX_INT_POLLING_MODE
+	INIT_WORK(&(sitronix_ts_gpts.work), sitronix_ts_work_func);
+#else
+	INIT_DELAYED_WORK(&(sitronix_ts_gpts.work), sitronix_ts_work_func);
+#endif
+
+#ifdef SITRONIX_MONITOR_THREAD
+	if (sitronix_ts_gpts.enable_monitor_thread == 1) {
+		atomic_set(&iMonitorThreadPostpone, 1);
+		sitronix_ts_gpts.sitronix_mt_fp =
+		    sitronix_ts_gpts.
+		    RawCRC_enabled ? sitronix_ts_monitor_thread_v2 :
+		    sitronix_ts_monitor_thread;
+		SitronixMonitorThread =
+		    kthread_run(sitronix_ts_gpts.sitronix_mt_fp, "Sitronix",
+				"Monitorthread");
+		if (IS_ERR(SitronixMonitorThread))
+			SitronixMonitorThread = NULL;
+	}
+#endif
+
+	sitronix_ts_gpts.input_dev = input_allocate_device();
+	if (sitronix_ts_gpts.input_dev == NULL) {
+		pr_info("Can not allocate memory for input device.\n");
+		ret = -ENOMEM;
+		goto err_input_dev_alloc_failed;
+	}
+
+	sitronix_ts_gpts.input_dev->name = SITRONIX_I2C_TOUCH_MT_INPUT_DEV_NAME;
+	sitronix_ts_gpts.input_dev->dev.parent = &client->dev;
+	sitronix_ts_gpts.input_dev->id.bustype = BUS_I2C;
+
+	set_bit(EV_KEY, sitronix_ts_gpts.input_dev->evbit);
+	set_bit(BTN_TOUCH, sitronix_ts_gpts.input_dev->keybit);
+	set_bit(EV_ABS, sitronix_ts_gpts.input_dev->evbit);
+
+	sitronix_ts_gpts.keyevent_input = input_allocate_device();
+	if (sitronix_ts_gpts.keyevent_input == NULL) {
+		pr_info("Can not allocate memory for key input device.\n");
+		ret = -ENOMEM;
+		goto err_input_dev_alloc_failed;
+	}
+	sitronix_ts_gpts.keyevent_input->name =
+	    SITRONIX_I2C_TOUCH_KEY_INPUT_DEV_NAME;
+	sitronix_ts_gpts.keyevent_input->dev.parent = &client->dev;
+	set_bit(EV_KEY, sitronix_ts_gpts.keyevent_input->evbit);
+	for (i = 0;
+	     i <
+	     (sizeof(sitronix_sensor_key_array) /
+	      sizeof(struct sitronix_sensor_key_t)); i++) {
+		set_bit(sitronix_sensor_key_array[i].code,
+			sitronix_ts_gpts.keyevent_input->keybit);
+	}
+
+#ifndef SITRONIX_AA_KEY
+	max_x = sitronix_ts_gpts.resolution_x;
+	max_y = sitronix_ts_gpts.resolution_y;
+#else
+	sitronix_aa_key_status = 0;
+
+#ifdef SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY
+	for (i = 0;
+	     i <
+	     (sizeof(sitronix_aa_key_array) / sizeof(struct sitronix_AA_key));
+	     i++) {
+		set_bit(sitronix_aa_key_array[i].code,
+			sitronix_ts_gpts.keyevent_input->keybit);
+	}
+	max_x = SITRONIX_TOUCH_RESOLUTION_X;
+	max_y = SITRONIX_TOUCH_RESOLUTION_Y;
+#else
+	for (i = 0;
+	     i <
+	     (sizeof(sitronix_aa_key_array) / sizeof(struct sitronix_AA_key));
+	     i++) {
+		sitronix_aa_key_array[i].x_low =
+		    ((sitronix_ts_gpts.resolution_x /
+		      (sizeof(sitronix_aa_key_array)
+		       / sizeof(struct sitronix_AA_key))) * i) + 15;
+		sitronix_aa_key_array[i].x_high =
+		    ((sitronix_ts_gpts.resolution_x /
+		      (sizeof(sitronix_aa_key_array)
+		       / sizeof(struct sitronix_AA_key))) * (i + 1)) - 15;
+		sitronix_aa_key_array[i].y_low =
+		    sitronix_ts_gpts.resolution_y -
+		    sitronix_ts_gpts.resolution_y / SCALE_KEY_HIGH_Y;
+		sitronix_aa_key_array[i].y_high = sitronix_ts_gpts.resolution_y;
+		DbgMsg("key[%d] %d, %d, %d, %d\n", i,
+		       sitronix_aa_key_array[i].x_low,
+		       sitronix_aa_key_array[i].x_high,
+		       sitronix_aa_key_array[i].y_low,
+		       sitronix_aa_key_array[i].y_high);
+		set_bit(sitronix_aa_key_array[i].code,
+			sitronix_ts_gpts.keyevent_input->keybit);
+	}
+	max_x = sitronix_ts_gpts.resolution_x;
+	max_y =
+	    sitronix_ts_gpts.resolution_y -
+	    sitronix_ts_gpts.resolution_y / SCALE_KEY_HIGH_Y;
+#endif
+#endif
+	ret = input_register_device(sitronix_ts_gpts.keyevent_input);
+	if (ret < 0) {
+		pr_info("Can not register key input device.\n");
+		goto err_input_register_device_failed;
+	}
+#ifdef SITRONIX_SUPPORT_MT_SLOT
+	__set_bit(INPUT_PROP_DIRECT, sitronix_ts_gpts.input_dev->propbit);
+	input_mt_init_slots(sitronix_ts_gpts.input_dev,
+			    sitronix_ts_gpts.max_touches, 0);
+#else
+	__set_bit(ABS_X, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_Y, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_MT_TOUCH_MAJOR, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_MT_WIDTH_MAJOR, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_MT_POSITION_X, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_MT_POSITION_Y, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_MT_TOOL_TYPE, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_MT_BLOB_ID, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(ABS_MT_TRACKING_ID, sitronix_ts_gpts.input_dev->absbit);
+	__set_bit(INPUT_PROP_DIRECT, sitronix_ts_gpts.input_dev->propbit);
+
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_MT_TOUCH_MAJOR, 0,
+			     255, 0, 0);
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_MT_WIDTH_MAJOR, 0,
+			     255, 0, 0);
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_MT_TRACKING_ID, 0,
+			     sitronix_ts_gpts.max_touches, 0, 0);
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_PRESSURE, 0, 255,
+			     0, 0);
+#endif
+#ifndef SITRONIX_SWAP_XY
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_MT_POSITION_X, 0,
+			     max_x - 1, 0, 0);
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_MT_POSITION_Y, 0,
+			     max_y - 1, 0, 0);
+#else
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_MT_POSITION_X, 0,
+			     max_y - 1, 0, 0);
+	input_set_abs_params(sitronix_ts_gpts.input_dev, ABS_MT_POSITION_Y, 0,
+			     max_x - 1, 0, 0);
+#endif
+
+	ret = input_register_device(sitronix_ts_gpts.input_dev);
+	if (ret < 0) {
+		pr_info("Can not register input device.\n");
+		goto err_input_register_device_failed;
+	}
+
+	if (client->irq) {
+		dev_info(&client->dev, "irq = %d\n", client->irq);
+#ifdef SITRONIX_LEVEL_TRIGGERED
+		ret =
+		    request_irq(client->irq, sitronix_ts_irq_handler,
+				IRQF_TRIGGER_LOW | IRQF_ONESHOT, client->name,
+				&sitronix_ts_gpts);
+#else
+		ret =
+		    request_irq(client->irq, sitronix_ts_irq_handler,
+				IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+				client->name, &sitronix_ts_gpts);
+#endif
+		if (ret == 0) {
+			atomic_set(&sitronix_ts_irq_on, 1);
+			sitronix_ts_gpts.use_irq = 1;
+		} else {
+			dev_err(&client->dev, "request_irq failed\n");
+			goto err_request_irq_failed;
+		}
+	}
+
+	err = device_create_file(&client->dev, &dev_attr_ts_info);
+	if (err) {
+		dev_err(&client->dev, "sys file creation failed\n");
+		goto irq_free;
+	}
+
+	err = device_create_file(&client->dev, &dev_attr_mt_protocol_type);
+	if (err) {
+		dev_err(&client->dev, "sys file creation failed\n");
+		goto free_ts_info;
+	}
+
+	err = device_create_file(&client->dev, &dev_attr_enable);
+	if (err) {
+		dev_err(&client->dev, "sys file creation failed\n");
+		goto free_type;
+	}
+
+	err = device_create_file(&client->dev, &dev_attr_fw_name);
+	if (err) {
+		dev_err(&client->dev, "sys file creation failed\n");
+		goto free_enable;
+	}
+
+	data->dir = debugfs_create_dir(SI_DEBUG_DIR_NAME, NULL);
+	if (data->dir == NULL || IS_ERR(data->dir)) {
+		pr_err("debugfs_create_dir failed(%ld)\n", PTR_ERR(data->dir));
+		err = PTR_ERR(data->dir);
+		goto free_fw_name_sys;
+	}
+
+	temp = debugfs_create_file("addr", S_IRUSR | S_IWUSR, data->dir, data,
+				   &debug_addr_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		pr_err("debugfs_create_file failed: rc=%ld\n", PTR_ERR(temp));
+		err = PTR_ERR(temp);
+		goto free_debug_dir;
+	}
+
+	temp = debugfs_create_file("data", S_IRUSR | S_IWUSR, data->dir, data,
+				   &debug_data_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		pr_err("debugfs_create_file failed: rc=%ld\n", PTR_ERR(temp));
+		err = PTR_ERR(temp);
+		goto free_debug_dir;
+	}
+
+	temp = debugfs_create_file("suspend", S_IRUSR | S_IWUSR, data->dir,
+				   data, &debug_suspend_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		pr_err("debugfs_create_file failed: rc=%ld\n", PTR_ERR(temp));
+		err = PTR_ERR(temp);
+		goto free_debug_dir;
+	}
+
+	temp = debugfs_create_file("dump_info", S_IRUSR | S_IWUSR, data->dir,
+				   data, &debug_dump_info_fops);
+	if (temp == NULL || IS_ERR(temp)) {
+		pr_err("debugfs_create_file failed: rc=%ld\n", PTR_ERR(temp));
+		err = PTR_ERR(temp);
+		goto free_debug_dir;
+	}
+
+	data->ts_info = devm_kzalloc(&client->dev, SI_INFO_MAX_LEN, GFP_KERNEL);
+	if (!data->ts_info) {
+		dev_err(&client->dev, "Not enough memory\n");
+		goto free_debug_dir;
+	}
+
+	/*get some register information */
+
+	SI_STORE_TS_INFO(data->ts_info, data->pdata->family_id,
+			 data->pdata->name, data->pdata->num_max_touches,
+			 data->pdata->group_id,
+			 data->pdata->fw_vkey_support ? "yes" : "no",
+			 data->pdata->fw_name, data->fw_revision[0],
+			 data->fw_revision[1], data->fw_revision[2],
+			 data->fw_revision[3]);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	sitronix_ts_gpts.early_suspend.level =
+	    EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	sitronix_ts_gpts.early_suspend.suspend = sitronix_ts_early_suspend;
+	sitronix_ts_gpts.early_suspend.resume = sitronix_ts_late_resume;
+	register_early_suspend(&sitronix_ts_gpts.early_suspend);
+#endif
+
+	return 0;
+
+free_debug_dir:
+	debugfs_remove_recursive(data->dir);
+free_fw_name_sys:
+	device_remove_file(&client->dev, &dev_attr_fw_name);
+free_enable:
+	device_remove_file(&client->dev, &dev_attr_enable);
+free_type:
+	device_remove_file(&client->dev, &dev_attr_mt_protocol_type);
+free_ts_info:
+	device_remove_file(&client->dev, &dev_attr_ts_info);
+irq_free:
+	free_irq(client->irq, &sitronix_ts_gpts);
+err_request_irq_failed:
+	input_unregister_device(sitronix_ts_gpts.input_dev);
+	input_unregister_device(sitronix_ts_gpts.keyevent_input);
+err_input_register_device_failed:
+err_input_dev_alloc_failed:
+	if (sitronix_ts_gpts.input_dev)
+		input_free_device(sitronix_ts_gpts.input_dev);
+	if (sitronix_ts_gpts.keyevent_input)
+		input_free_device(sitronix_ts_gpts.keyevent_input);
+#ifdef SITRONIX_MONITOR_THREAD
+	if (sitronix_ts_gpts.enable_monitor_thread == 1) {
+		if (SitronixMonitorThread) {
+			kthread_stop(SitronixMonitorThread);
+			SitronixMonitorThread = NULL;
+		}
+	}
+#endif
+err_device_info_error:
+
+free_reset_gpio:
+	if (gpio_is_valid(pdata->reset_gpio))
+		gpio_free(pdata->reset_gpio);
+free_irq_gpio:
+	if (gpio_is_valid(pdata->irq_gpio))
+		gpio_free(pdata->irq_gpio);
+pwr_off:
+	if (pdata->power_on)
+		pdata->power_on(false);
+	else
+		sitronix_power_on(&sitronix_ts_gpts, false);
+pwr_deinit:
+	if (pdata->power_init)
+		pdata->power_init(false);
+	else
+		sitronix_power_init(&sitronix_ts_gpts, false);
+err_check_functionality_failed:
+
+	return ret;
+}
+
+static int sitronix_ts_remove(struct i2c_client *client)
+{
+	struct sitronix_ts_data *ts = i2c_get_clientdata(client);
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&ts->early_suspend);
+#endif
+#ifdef SITRONIX_MONITOR_THREAD
+	if (ts->enable_monitor_thread == 1) {
+		if (SitronixMonitorThread) {
+			kthread_stop(SitronixMonitorThread);
+			SitronixMonitorThread = NULL;
+		}
+	}
+#endif
+
+	debugfs_remove_recursive(ts->dir);
+	device_remove_file(&client->dev, &dev_attr_fw_name);
+	device_remove_file(&client->dev, &dev_attr_enable);
+	device_remove_file(&client->dev, &dev_attr_mt_protocol_type);
+	device_remove_file(&client->dev, &dev_attr_ts_info);
+
+	i2c_set_clientdata(client, NULL);
+	if (ts->use_irq)
+		free_irq(client->irq, ts);
+	if (ts->input_dev)
+		input_unregister_device(ts->input_dev);
+	if (ts->keyevent_input)
+		input_unregister_device(ts->keyevent_input);
+	return 0;
+}
+
+static int sitronix_ts_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	int ret;
+	struct sitronix_ts_data *ts = i2c_get_clientdata(client);
+
+	DbgMsg("%s\n", __func__);
+#ifdef SITRONIX_MONITOR_THREAD
+	if (ts->enable_monitor_thread == 1) {
+		if (SitronixMonitorThread) {
+			kthread_stop(SitronixMonitorThread);
+			SitronixMonitorThread = NULL;
+		}
+		sitronix_ts_delay_monitor_thread_start =
+		    DELAY_MONITOR_THREAD_START_RESUME;
+	}
+#endif
+	if (ts->use_irq) {
+		atomic_set(&sitronix_ts_irq_on, 0);
+		disable_irq_nosync(ts->client->irq);
+	}
+
+	ret = sitronix_ts_set_powerdown_bit(ts, 1);
+
+	if (ts->chip_id == 2)
+		pr_info("chip_id %d\n", ts->chip_id);
+
+	if (ts->pdata->power_on) {
+		ret = ts->pdata->power_on(false);
+		if (ret) {
+			dev_err(&client->dev, "power off failed");
+			goto pwr_off_fail;
+		}
+	} else {
+		ret = sitronix_power_on(ts, false);
+		if (ret) {
+			dev_err(&client->dev, "power off failed");
+			goto pwr_off_fail;
+		}
+	}
+
+	ts->suspend_state = 1;
+
+	DbgMsg("%s return\n", __func__);
+
+	return 0;
+pwr_off_fail:
+	if (gpio_is_valid(ts->pdata->reset_gpio)) {
+		gpio_set_value_cansleep(ts->pdata->reset_gpio, 0);
+		msleep(ts->pdata->hard_rst_dly);
+		gpio_set_value_cansleep(ts->pdata->reset_gpio, 1);
+		msleep(ts->pdata->soft_rst_dly);
+	}
+	ret = sitronix_ts_set_powerdown_bit(ts, 0);
+	if (ts->use_irq) {
+		atomic_set(&sitronix_ts_irq_on, 1);
+		enable_irq(ts->client->irq);
+	}
+	return -EPERM;
+}
+
+static int sitronix_ts_resume(struct i2c_client *client)
+{
+	int ret;
+	struct sitronix_ts_data *ts = i2c_get_clientdata(client);
+
+	DbgMsg("%s\n", __func__);
+
+	if (ts->pdata->power_on) {
+		ret = ts->pdata->power_on(true);
+		if (ret) {
+			dev_err(&client->dev, "power on failed");
+			return ret;
+		}
+	} else {
+		ret = sitronix_power_on(ts, true);
+		if (ret) {
+			dev_err(&client->dev, "power on failed");
+			return ret;
+		}
+	}
+
+	if (gpio_is_valid(ts->pdata->reset_gpio)) {
+		gpio_set_value_cansleep(ts->pdata->reset_gpio, 0);
+		msleep(ts->pdata->hard_rst_dly);
+		gpio_set_value_cansleep(ts->pdata->reset_gpio, 1);
+	}
+
+	msleep(ts->pdata->soft_rst_dly);
+
+	if (ts->chip_id == 2)
+		pr_info("chip_id %d\n", ts->chip_id);
+	else
+		ret = sitronix_ts_set_powerdown_bit(ts, 0);
+
+	if (ts->use_irq) {
+		atomic_set(&sitronix_ts_irq_on, 1);
+		enable_irq(ts->client->irq);
+	}
+#ifdef SITRONIX_MONITOR_THREAD
+	if (ts->enable_monitor_thread == 1) {
+		atomic_set(&iMonitorThreadPostpone, 1);
+		SitronixMonitorThread =
+		    kthread_run(sitronix_ts_gpts.sitronix_mt_fp, "Sitronix",
+				"Monitorthread");
+		if (IS_ERR(SitronixMonitorThread))
+			SitronixMonitorThread = NULL;
+	}
+#endif
+
+	ts->suspend_state = 0;
+
+	DbgMsg("%s return\n", __func__);
+
+	return 0;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void sitronix_ts_early_suspend(struct early_suspend *h)
+{
+	struct sitronix_ts_data *ts;
+	DbgMsg("%s\n", __func__);
+	ts = container_of(h, struct sitronix_ts_data, early_suspend);
+	sitronix_ts_suspend(ts->client, PMSG_SUSPEND);
+}
+
+static void sitronix_ts_late_resume(struct early_suspend *h)
+{
+	struct sitronix_ts_data *ts;
+	DbgMsg("%s\n", __func__);
+	ts = container_of(h, struct sitronix_ts_data, early_suspend);
+	sitronix_ts_resume(ts->client);
+}
+#else
+static int sitronix_ts_normal_suspend(struct device *dev)
+{
+	struct sitronix_ts_data *ts;
+	DbgMsg("%s\n", __func__);
+	ts = dev_get_drvdata(dev);
+	return sitronix_ts_suspend(ts->client, PMSG_SUSPEND);
+}
+
+static int sitronix_ts_normal_resume(struct device *dev)
+{
+	struct sitronix_ts_data *ts;
+	DbgMsg("%s\n", __func__);
+	ts = dev_get_drvdata(dev);
+	return sitronix_ts_resume(ts->client);
+}
+
+#endif
+
+static const struct dev_pm_ops sitronix_ts_pm_ops = {
+#if !defined(CONFIG_HAS_EARLYSUSPEND)
+	.suspend = sitronix_ts_normal_suspend,
+	.resume = sitronix_ts_normal_resume,
+#endif
+};
+
+static const struct i2c_device_id sitronix_ts_id[] = {
+	{SITRONIX_I2C_TOUCH_DRV_NAME, 0},
+	{}
+};
+
+#ifdef CONFIG_OF
+static struct of_device_id sitronix_match_table[] = {
+	{.compatible = "sitronix,st1633",},
+	{},
+};
+#else
+#define sitronix_match_table NULL
+#endif
+
+static struct i2c_driver sitronix_ts_driver = {
+	.probe = sitronix_ts_probe,
+	.remove = sitronix_ts_remove,
+
+	.driver = {
+		   .name = SITRONIX_I2C_TOUCH_DRV_NAME,
+		   .owner = THIS_MODULE,
+		   .of_match_table = sitronix_match_table,
+#ifdef CONFIG_PM
+		   .pm = &sitronix_ts_pm_ops,
+#endif
+		   },
+	.id_table = sitronix_ts_id,
+};
+
+#ifdef SITRONIX_FW_UPGRADE_FEATURE
+static const struct file_operations nc_fops = {
+	.owner = THIS_MODULE,
+	.write = sitronix_write,
+	.read = sitronix_read,
+	.open = sitronix_open,
+	.unlocked_ioctl = sitronix_ioctl,
+	.release = sitronix_release,
+};
+#endif
+
+static void sitronix_ts_reprobe(void)
+{
+	int retval = 0;
+	i2c_del_driver(&sitronix_ts_driver);
+	retval = i2c_add_driver(&sitronix_ts_driver);
+	if (retval < 0)
+		pr_info("fail to reprobe driver!\n");
+}
+
+static int __init sitronix_ts_init(void)
+{
+#ifdef SITRONIX_FW_UPGRADE_FEATURE
+	int result;
+	int err = 0;
+	dev_t devno = MKDEV(sitronix_major, 0);
+#endif
+	pr_info("Sitronix touch driver %d.%d.%d\n", DRIVER_MAJOR, DRIVER_MINOR,
+	       DRIVER_PATCHLEVEL);
+	pr_info("Release date: %s\n", DRIVER_DATE);
+#ifdef SITRONIX_FW_UPGRADE_FEATURE
+	result = alloc_chrdev_region(&devno, 0, 1, SITRONIX_I2C_TOUCH_DEV_NAME);
+	if (result < 0) {
+		pr_info("fail to allocate chrdev (%d)\n", result);
+		return 0;
+	}
+
+	sitronix_major = MAJOR(devno);
+	cdev_init(&sitronix_cdev, &nc_fops);
+	sitronix_cdev.owner = THIS_MODULE;
+	sitronix_cdev.ops = &nc_fops;
+
+	err = cdev_add(&sitronix_cdev, devno, 1);
+	if (err) {
+		pr_info("fail to add cdev (%d)\n", err);
+		return 0;
+	}
+
+	sitronix_class = class_create(THIS_MODULE, SITRONIX_I2C_TOUCH_DEV_NAME);
+	if (IS_ERR(sitronix_class)) {
+		result = PTR_ERR(sitronix_class);
+		unregister_chrdev(sitronix_major, SITRONIX_I2C_TOUCH_DEV_NAME);
+
+		pr_info("fail to create class (%d)\n", result);
+		return result;
+	}
+
+	device_create(sitronix_class, NULL, MKDEV(sitronix_major, 0), NULL,
+		      SITRONIX_I2C_TOUCH_DEV_NAME);
+#ifdef SITRONIX_PERMISSION_THREAD
+	SitronixPermissionThread = kthread_run(sitronix_ts_permission_thread,
+					       "Sitronix", "Permissionthread");
+	if (IS_ERR(SitronixPermissionThread))
+		SitronixPermissionThread = NULL;
+#endif
+#endif
+	return i2c_add_driver(&sitronix_ts_driver);
+}
+
+static void __exit sitronix_ts_exit(void)
+{
+#ifdef SITRONIX_FW_UPGRADE_FEATURE
+	dev_t dev_id = MKDEV(sitronix_major, 0);
+#endif
+	i2c_del_driver(&sitronix_ts_driver);
+#ifdef SITRONIX_FW_UPGRADE_FEATURE
+	cdev_del(&sitronix_cdev);
+
+	device_destroy(sitronix_class, dev_id);
+	class_destroy(sitronix_class);
+	unregister_chrdev_region(dev_id, 1);
+#ifdef SITRONIX_PERMISSION_THREAD
+	if (SitronixPermissionThread)
+		SitronixPermissionThread = NULL;
+#endif
+#endif
+}
 
-MODULE_AUTHOR("Tony SIM <chinyeow.sim.xt@renesas.com>");
-MODULE_DESCRIPTION("SITRONIX ST1232 Touchscreen Controller Driver");
-MODULE_LICENSE("GPL");
+module_init(sitronix_ts_init);
+module_exit(sitronix_ts_exit);
+MODULE_DESCRIPTION("Sitronix I2C multitouch panels driver");
+MODULE_LICENSE("GPL v2");
diff --git a/include/linux/platform_data/st1232_pdata.h b/include/linux/platform_data/st1232_pdata.h
index cac3e7b..9ad17b8 100644
--- a/include/linux/platform_data/st1232_pdata.h
+++ b/include/linux/platform_data/st1232_pdata.h
@@ -1,13 +1,233 @@
-#ifndef _LINUX_ST1232_PDATA_H
-#define _LINUX_ST1232_PDATA_H
-
 /*
- * Optional platform data
+ * drivers/input/touchscreen/sitronix_i2c_touch.h
+ *
+ * Touchscreen driver for Sitronix
  *
- * Use this if you want the driver to drive the reset pin.
+ * Copyright (C) 2014-2015 Sitronix Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+#ifndef __SITRONIX_I2C_TOUCH_h
+#define __SITRONIX_I2C_TOUCH_h
+
+/* needed for the _IOW etc stuff used later */
+#include <linux/ioctl.h>
+
+#define SITRONIX_TOUCH_DRIVER_VERSION 0x03
+#define SITRONIX_MAX_SUPPORTED_POINT 10
+#define SITRONIX_I2C_TOUCH_DRV_NAME "sitronix"
+#define SITRONIX_I2C_TOUCH_DEV_NAME "sitronixDev"
+#define SITRONIX_I2C_TOUCH_MT_INPUT_DEV_NAME "sitronix-i2c-touch-mt"
+#define SITRONIX_I2C_TOUCH_KEY_INPUT_DEV_NAME "sitronix-i2c-touch-key"
+
+/*  MT SLOT feature is implmented in linux kernel 2.6.38 and later.
+ *  Make sure that version of your linux kernel before using this
+ *  feature.
+*/
+
+#define SITRONIX_SUPPORT_MT_SLOT
+/* #define SITRONIX_SWAP_XY */
+/* #define SITRONIX_I2C_COMBINED_MESSAGE */
+
+#ifndef SITRONIX_I2C_COMBINED_MESSAGE
+#define SITRONIX_I2C_SINGLE_MESSAGE
+#endif
+#define SITRONIX_MONITOR_THREAD
+#define DELAY_MONITOR_THREAD_START_PROBE 10000
+#define DELAY_MONITOR_THREAD_START_RESUME 3000
+#define SITRONIX_FW_UPGRADE_FEATURE
+#define SITRONIX_PERMISSION_THREAD
+#define SITRONIX_LEVEL_TRIGGERED
+
+/* When enable_irq() is invoked, irq will be sent once while INT is
+ * not triggered if CONFIG_HARDIRQS_SW_RESEND is set.
+ * This behavior is implemented by linux kernel, it is used to
+ * prevent irq from losting when irq is edge-triggered mode.
  */
-struct st1232_pdata {
-	int reset_gpio;
+
+#ifndef SITRONIX_LEVEL_TRIGGERED
+#define SITRONIX_INT_POLLING_MODE
+#define INT_POLLING_MODE_INTERVAL 14
+#endif
+
+/* #define SITRONIX_IDENTIFY_ID */
+/* #define SITRONIX_MULTI_SLAVE_ADDR */
+
+/*
+   #define EnableDbgMsg 1
+   #define EnableUpgradeMsg 1
+*/
+#ifdef EnableDbgMsg
+#define DbgMsg(arg...) printk(arg)
+#else
+#define DbgMsg(arg...)
+#endif
+
+#ifdef EnableUpgradeMsg
+#define UpgradeMsg(arg...) printk(arg)
+#else
+#define UpgradeMsg(arg...)
+#endif
+
+enum {
+	FIRMWARE_VERSION,
+	STATUS_REG,
+	DEVICE_CONTROL_REG,
+	TIMEOUT_TO_IDLE_REG,
+	XY_RESOLUTION_HIGH,
+	X_RESOLUTION_LOW,
+	Y_RESOLUTION_LOW,
+	DEVICE_CONTROL_REG2 = 0x09,
+	FIRMWARE_REVISION_3 = 0x0C,
+	FIRMWARE_REVISION_2,
+	FIRMWARE_REVISION_1,
+	FIRMWARE_REVISION_0,
+	FINGERS,
+	KEYS_REG,
+	XY0_COORD_H,
+	X0_COORD_L,
+	Y0_COORD_L,
+	I2C_PROTOCOL = 0x3E,
+	MAX_NUM_TOUCHES,
+	DATA_0_HIGH,
+	DATA_0_LOW,
+	CHIP_ID = 0xF4,
+
+	PAGE_REG = 0xff,
+};
+
+#define SITRONIX_TS_CHANGE_MODE_DELAY 150
+
+enum {
+	XY_COORD_H,
+	X_COORD_L,
+	Y_COORD_L,
+	PIXEL_DATA_LENGTH_B,
+	PIXEL_DATA_LENGTH_A,
+};
+
+#define X_RES_H_SHFT 4
+#define X_RES_H_BMSK 0xf
+#define Y_RES_H_SHFT 0
+#define Y_RES_H_BMSK 0xf
+#define FINGERS_SHFT 0
+#define FINGERS_BMSK 0xf
+#define X_COORD_VALID_SHFT 7
+#define X_COORD_VALID_BMSK 0x1
+#define X_COORD_H_SHFT 4
+#define X_COORD_H_BMSK 0x7
+#define Y_COORD_H_SHFT 0
+#define Y_COORD_H_BMSK 0x7
+
+enum {
+	SITRONIX_RESERVED_TYPE_0,
+	SITRONIX_A_TYPE,
+	SITRONIX_B_TYPE,
+};
+
+#define I2C_PROTOCOL_SHFT 0x0
+#define I2C_PROTOCOL_BMSK 0x3
+
+enum {
+	SENSING_BOTH,
+	SENSING_X_ONLY,
+	SENSING_Y_ONLY,
+	SENSING_BOTH_NOT,
+};
+
+#define ONE_D_SENSING_CONTROL_SHFT 0x2
+#define ONE_D_SENSING_CONTROL_BMSK 0x3
+
+#define SMT_IOC_MAGIC   0xf1
+
+enum {
+	SMT_GET_DRIVER_REVISION = 1,
+	SMT_GET_FW_REVISION,
+	SMT_ENABLE_IRQ,
+	SMT_DISABLE_IRQ,
+	SMT_RESUME,
+	SMT_SUSPEND,
+	SMT_HW_RESET,
+	SMT_REPROBE,
+	SMT_IOC_MAXNR,
+};
+
+#define IOCTL_SMT_GET_DRIVER_REVISION  \
+		_IOC(_IOC_READ,  SMT_IOC_MAGIC, SMT_GET_DRIVER_REVISION, 1)
+#define IOCTL_SMT_GET_FW_REVISION		\
+		_IOC(_IOC_READ,  SMT_IOC_MAGIC, SMT_GET_FW_REVISION, 4)
+#define IOCTL_SMT_ENABLE_IRQ		\
+		_IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_ENABLE_IRQ, 0)
+#define IOCTL_SMT_DISABLE_IRQ		\
+		_IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_DISABLE_IRQ, 0)
+#define IOCTL_SMT_RESUME			\
+		_IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_RESUME, 0)
+#define IOCTL_SMT_SUSPEND			\
+		_IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_SUSPEND, 0)
+#define IOCTL_SMT_HW_RESET			\
+		_IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_HW_RESET, 0)
+#define IOCTL_SMT_REPROBE			\
+		_IOC(_IOC_NONE, SMT_IOC_MAGIC, SMT_REPROBE, 0)
+
+#define SITRONIX_AA_KEY
+#define SITRONIX_KEY_BOUNDARY_MANUAL_SPECIFY
+
+struct xy_data_t {
+	u8 y_h:3, reserved:1, x_h:3, valid:1;
+	u8 x_l;
+	u8 y_l;
+	u8 z;
+};
+
+struct stx_report_data_t {
+	struct xy_data_t xy_data[SITRONIX_MAX_SUPPORTED_POINT];
+};
+
+struct sitronix_sensor_key_t {
+	unsigned int code;
+};
+
+#ifndef SITRONIX_AA_KEY
+enum {
+	AREA_NONE,
+	AREA_DISPLAY,
+};
+#else
+enum {
+	AREA_NONE,
+	AREA_DISPLAY,
+	AREA_KEY,
+	AREA_INVALID,
+};
+
+struct sitronix_AA_key {
+	int x_low;
+	int x_high;
+	int y_low;
+	int y_high;
+	unsigned int code;
+};
+#endif
+
+struct sitronix_reg_field {
+	uint8_t offset;
+	uint8_t shft;
+	uint8_t bmsk;
+};
+
+struct sitronix_i2c_protocol_map {
+	struct sitronix_reg_field dis_coord_flag;
+};
+
+struct sitronix_i2c_touch_platform_data {
+	uint32_t version;	/* Use this entry for panels with */
+	/* (major << 8 | minor) version or above. */
+	/* If non-zero another array entry follows */
+	void (*reset_ic) (void);
 };
 
 #endif
-- 
1.7.9.5

