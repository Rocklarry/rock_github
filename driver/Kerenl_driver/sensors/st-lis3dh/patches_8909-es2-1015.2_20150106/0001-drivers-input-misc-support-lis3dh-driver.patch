From 764ec4773edac47f173f475528f1d21fd73d884f Mon Sep 17 00:00:00 2001
From: Yukun Wan <wanyk0402@thundersoft.com>
Date: Sun, 4 Jan 2015 15:54:03 +0800
Subject: [PATCH 1/3] drivers:input:misc: support lis3dh driver

Driver support lis3dh

Change-Id: I72a919639a03875ed96d2c6d11755a80dfb72e30
Signed-off-by: Yukun Wan <wanyk0402@thundersoft.com>
---
 .../devicetree/bindings/input/misc/lis3dh_acc.txt  |   12 +-
 drivers/input/misc/lis3dh_acc.c                    | 1013 ++++----------------
 include/linux/input/lis3dh.h                       |   10 +-
 3 files changed, 201 insertions(+), 834 deletions(-)

diff --git a/Documentation/devicetree/bindings/input/misc/lis3dh_acc.txt b/Documentation/devicetree/bindings/input/misc/lis3dh_acc.txt
index 087b335..e80041a 100644
--- a/Documentation/devicetree/bindings/input/misc/lis3dh_acc.txt
+++ b/Documentation/devicetree/bindings/input/misc/lis3dh_acc.txt
@@ -58,23 +58,23 @@ Optional properties:
 
 Example:
 	i2c@f9925000 { /* BLSP-1 QUP-3 */
-		st@18 {
+		st@19 {
 			compatible = "st,lis3dh";
-			reg = <0x18>;
+			reg = <0x19>;
 			pinctrl-names = "lis3dh_default","lis3dh_sleep";
 			pinctrl-0 = <&lis3dh_int1_default>;
 			pinctrl-1 = <&lis3dh_int1_sleep>;
 			interrupt-parent = <&msm_gpio>;
-			interrupts = <115 0x2002>;
-			vdd-supply = <&pm8916_l17>;
-			vddio-supply = <&pm8916_l6>;
+			interrupts = <94 0x2002>;
+			vdd-supply = <&pm8909_l17>;
+			vddio-supply = <&pm8909_l6>;
 			st,min-interval = <5>;
 			st,init-interval = <200>;
 			st,axis-map-x = <1>;
 			st,axis-map-y = <0>;
 			st,axis-map-z = <2>;
 			st,g-range = <2>;
-			st,gpio-int1 = <&msm_gpio 115 0x2002>;
+			st,gpio-int1 = <&msm_gpio 94 0x2002>;
 			st,negate-x;
 			st,negate-y;
 			st,negate-z;
diff --git a/drivers/input/misc/lis3dh_acc.c b/drivers/input/misc/lis3dh_acc.c
index b442107..ddddec8 100644
--- a/drivers/input/misc/lis3dh_acc.c
+++ b/drivers/input/misc/lis3dh_acc.c
@@ -1,6 +1,4 @@
-/******************** (C) COPYRIGHT 2010 STMicroelectronics ********************
- *
- * Copyright (c) 2014, The Linux Foundation. All rights reserved.
+/*************** (C) COPYRIGHT 2010-2014 STMicroelectronics ********************
  *
  * File Name          : lis3dh_acc.c
  * Authors            : MSH - Motion Mems BU - Application Team
@@ -47,7 +45,8 @@
  Revision 1.0.9 07/25/2011
   Romove several unused functions,add 5ms delay in init,change sysfs attributes.
  Revision 1.1.0 07/10/2012
-  To replace some deprecated functions for 3.4 kernel; to pass the checkpatch's formatting requirement;
+  To replace some deprecated functions for 3.4 kernel;
+  To pass the checkpatch's formatting requirement;
   To add regulator request;
 
  ******************************************************************************/
@@ -74,14 +73,16 @@
 #define	DEBUG	1
 
 #define	G_MAX		16000
-#define LIS3DH_FIFO_SIZE	32
-#define LIS3DH_TIME_MS_TO_NS	1000000L
+
 
 #define SENSITIVITY_2G		1	/**	mg/LSB	*/
 #define SENSITIVITY_4G		2	/**	mg/LSB	*/
 #define SENSITIVITY_8G		4	/**	mg/LSB	*/
 #define SENSITIVITY_16G		12	/**	mg/LSB	*/
 
+
+
+
 /* Accelerometer Sensor Operating Mode */
 #define LIS3DH_ACC_ENABLE	0x01
 #define LIS3DH_ACC_DISABLE	0x00
@@ -103,7 +104,6 @@
 #define	CTRL_REG6		0x25	/*	control reg 6		*/
 
 #define	FIFO_CTRL_REG		0x2E	/*	FiFo control reg	*/
-#define	FIFO_SRC_REG		0x2F	/*	FiFo source reg	*/
 
 #define	INT_CFG1		0x30	/*	interrupt 1 config	*/
 #define	INT_SRC1		0x31	/*	interrupt 1 source	*/
@@ -125,30 +125,9 @@
 #define LIS3DH_ACC_PM_OFF		0x00
 #define LIS3DH_ACC_ENABLE_ALL_AXES	0x07
 
-/* FIFO REG BITS*/
-#define PMODE_MASK			0x08
-#define REG1_ODR_MASK			0XF0
-#define REG1_ODR_SHIFT			4
-#define FIFO_MODE_SHIFT			6
-#define FIFO_MODE_MASK			0xC0
-#define FIFO_WM_CFG_MASK		0x1F
-#define FIFO_STATE_WATER_MARK		0x80
-#define FIFO_STATE_FULL			0x40
-#define FIFO_SRC_DATA_CNT_MASK		0x1F
-#define FIFO_MAX_CNT			0x1F
-#define FIFO_SRC_OVRN_MASK		0x40
-#define REG5_FIFO_EN			0x40
-
-/* interrupt configure REG BITS */
-#define INT_GEN_I1_CLICK		0x80
-#define INT_GEN_I1_GEN1			0x40
-#define INT_GEN_I1_DRDY1		0x10
-#define INT_GEN_I1_WTM			0x04
-#define INT_GEN_I1_OVRN			0x02
-
-#define IS_FIFO_FULL(status)		(status & FIFO_STATE_FULL)
-#define IS_WATER_MARK_REACHED(status)	(status & FIFO_STATE_WATER_MARK)
 
+#define PMODE_MASK			0x08
+#define ODR_MASK			0XF0
 
 #define ODR1		0x10  /* 1Hz output data rate */
 #define ODR10		0x20  /* 10Hz output data rate */
@@ -183,9 +162,6 @@
 #define	TAP_TLAT_MASK		NO_MASK
 #define	TAP_TW_MASK		NO_MASK
 
-/*soc irq set*/
-#define CONFIG_IRQ_DRDY1	0x10
-#define CONFIG_BLOCK_READ	0x80
 
 /* TAP_SOURCE_REG BIT */
 #define	DTAP			0x20
@@ -227,25 +203,13 @@
 #define	RESUME_ENTRIES		17
 /* end RESUME STATE INDICES */
 
-#define BATCH_MODE_NORMAL		0
-#define BATCH_MODE_WAKE_UPON_FIFO_FULL	2
-
-enum {
-	LIS3DH_BYPASS_MODE = 0,
-	LIS3DH_FIFO_MODE,
-	LIS3DH_STREAM_MODE,
-	LIS3DH_STREAM2FIFO_MODE,
-	LIS3DH_FIFO_MODE_NUM
-};
 
-struct odr_config_table {
+struct {
 	unsigned int cutoff_ms;
 	unsigned int mask;
-};
-
-struct odr_config_table lis3dh_acc_odr_table[] = {
+} lis3dh_acc_odr_table[] = {
 		{    1, ODR1250 },
-		{    3, ODR400  },  /* round to 3 */
+		{    3, ODR400  },
 		{    5, ODR200  },
 		{   10, ODR100  },
 		{   20, ODR50   },
@@ -270,7 +234,6 @@ struct lis3dh_acc_data {
 	int hw_initialized;
 	/* hw_working=-1 means not tested yet */
 	int hw_working;
-	/* flag sensor is enabled (batch/poll) */
 	atomic_t enabled;
 	int on_before_suspend;
 
@@ -278,14 +241,12 @@ struct lis3dh_acc_data {
 
 	u8 resume_state[RESUME_ENTRIES];
 
-	/* batch mode is configured */
-	bool use_batch;
-	unsigned int delay_ms;
-	unsigned int batch_mode;
-	unsigned int fifo_timeout_ms;
-	unsigned int flush_count;
 	int irq1;
+	struct work_struct irq1_work;
+	struct workqueue_struct *irq1_work_queue;
 	int irq2;
+	struct work_struct irq2_work;
+	struct workqueue_struct *irq2_work_queue;
 
 #ifdef DEBUG
 	u8 reg_addr;
@@ -293,7 +254,8 @@ struct lis3dh_acc_data {
 };
 
 static struct sensors_classdev lis3dh_acc_cdev = {
-	.name = "lis3dh-accel",
+/*	.name = "lis3dh-accel", */
+	.name = "lis3dh",
 	.vendor = "STMicroelectronics",
 	.version = 1,
 	.handle = SENSORS_ACCELERATION_HANDLE,
@@ -301,18 +263,13 @@ static struct sensors_classdev lis3dh_acc_cdev = {
 	.max_range = "156.8",
 	.resolution = "0.01",
 	.sensor_power = "0.01",
-	.min_delay = 10000,
-	.max_delay = 6400,
+	.min_delay = 5000,
 	.delay_msec = 200,
 	.fifo_reserved_event_count = 0,
 	.fifo_max_event_count = 0,
 	.enabled = 0,
-	.max_latency = 0,
-	.flags = 0,
 	.sensors_enable = NULL,
 	.sensors_poll_delay = NULL,
-	.sensors_set_latency = NULL,
-	.sensors_flush = NULL,
 };
 
 struct sensor_regulator {
@@ -327,30 +284,6 @@ struct sensor_regulator lis3dh_acc_vreg[] = {
 	{NULL, "vddio", 1700000, 3600000},
 };
 
-static inline s64 lis3dh_acc_get_time_ns(void)
-{
-	struct timespec ts;
-
-	ktime_get_ts(&ts);
-	return timespec_to_ns(&ts);
-}
-
-static unsigned int lis3dh_acc_odr_to_interval(struct lis3dh_acc_data *acc,
-				unsigned int odr)
-{
-	unsigned int odr_mask;
-	unsigned int i;
-
-	odr_mask = (odr << REG1_ODR_SHIFT) & REG1_ODR_MASK;
-
-	for (i = ARRAY_SIZE(lis3dh_acc_odr_table) - 1; i > 0; i--) {
-		if (lis3dh_acc_odr_table[i].mask == odr_mask)
-			break;
-	}
-
-	return lis3dh_acc_odr_table[i].cutoff_ms;
-}
-
 static int lis3dh_acc_config_regulator(struct lis3dh_acc_data *acc, bool on)
 {
 	int rc = 0, i;
@@ -363,11 +296,10 @@ static int lis3dh_acc_config_regulator(struct lis3dh_acc_data *acc, bool on)
 				lis3dh_acc_vreg[i].name);
 			if (IS_ERR(lis3dh_acc_vreg[i].vreg)) {
 				rc = PTR_ERR(lis3dh_acc_vreg[i].vreg);
-				dev_err(&acc->client->dev,
-					"Regulator(%s) get failed rc=%d\n",
-					lis3dh_acc_vreg[i].name, rc);
+				pr_err("%s:regulator get failed rc=%d\n",
+								__func__, rc);
 				lis3dh_acc_vreg[i].vreg = NULL;
-				goto deinit_vregs;
+				goto error_vdd;
 			}
 
 			if (regulator_count_voltages(
@@ -377,24 +309,44 @@ static int lis3dh_acc_config_regulator(struct lis3dh_acc_data *acc, bool on)
 					lis3dh_acc_vreg[i].min_uV,
 					lis3dh_acc_vreg[i].max_uV);
 				if (rc) {
-					dev_err(&acc->client->dev,
-					"Regulator(%s)Set voltage failed rc=%d\n",
-					lis3dh_acc_vreg[i].name, rc);
+					pr_err("%s: set voltage failed rc=%d\n",
+					__func__, rc);
 					regulator_put(lis3dh_acc_vreg[i].vreg);
 					lis3dh_acc_vreg[i].vreg = NULL;
-					goto deinit_vregs;
+					goto error_vdd;
 				}
 			}
+
+			rc = regulator_enable(lis3dh_acc_vreg[i].vreg);
+			if (rc) {
+				pr_err("%s: regulator_enable failed rc =%d\n",
+					__func__, rc);
+				if (regulator_count_voltages(
+					lis3dh_acc_vreg[i].vreg) > 0) {
+					regulator_set_voltage(
+						lis3dh_acc_vreg[i].vreg, 0,
+						lis3dh_acc_vreg[i].max_uV);
+				}
+				regulator_put(lis3dh_acc_vreg[i].vreg);
+				lis3dh_acc_vreg[i].vreg = NULL;
+				goto error_vdd;
+			}
 		}
 		return rc;
 	} else {
 		i = num_reg;
-		goto deinit_vregs;
 	}
 
-deinit_vregs:
+error_vdd:
 	while (--i >= 0) {
 		if (!IS_ERR_OR_NULL(lis3dh_acc_vreg[i].vreg)) {
+			if (regulator_count_voltages(
+			lis3dh_acc_vreg[i].vreg) > 0) {
+				regulator_set_voltage(lis3dh_acc_vreg[i].vreg,
+						0, lis3dh_acc_vreg[i].max_uV);
+			}
+			regulator_disable(lis3dh_acc_vreg[i].vreg);
+			pr_info("%s:before suspend --wanyk\n", __func__);
 			regulator_put(lis3dh_acc_vreg[i].vreg);
 			lis3dh_acc_vreg[i].vreg = NULL;
 		}
@@ -402,45 +354,6 @@ deinit_vregs:
 	return rc;
 }
 
-static int lis3dh_acc_set_regulator(struct lis3dh_acc_data *acc, bool on)
-{
-	int rc = 0, i;
-	int num_reg = sizeof(lis3dh_acc_vreg) / sizeof(struct sensor_regulator);
-
-	if (on) {
-		for (i = 0; i < num_reg; i++) {
-			if (!IS_ERR_OR_NULL(lis3dh_acc_vreg[i].vreg)) {
-				rc = regulator_enable(lis3dh_acc_vreg[i].vreg);
-				if (rc) {
-					dev_err(&acc->client->dev,
-					"Enable regulator(%s) failed rc=%d\n",
-					lis3dh_acc_vreg[i].name, rc);
-					goto disable_regulator;
-				}
-			}
-		}
-		return rc;
-	} else {
-		for (i = (num_reg - 1); i >= 0; i--) {
-			if (!IS_ERR_OR_NULL(lis3dh_acc_vreg[i].vreg)) {
-				rc = regulator_disable(lis3dh_acc_vreg[i].vreg);
-				if (rc)
-					dev_err(&acc->client->dev,
-					"Disable regulator(%s) failed rc=%d\n",
-					lis3dh_acc_vreg[i].name, rc);
-			}
-		}
-		return 0;
-	}
-
-disable_regulator:
-	while (--i >= 0) {
-		if (!IS_ERR_OR_NULL(lis3dh_acc_vreg[i].vreg))
-			regulator_disable(lis3dh_acc_vreg[i].vreg);
-	}
-	return rc;
-}
-
 static int lis3dh_acc_i2c_read(struct lis3dh_acc_data *acc,
 				u8 *buf, int len)
 {
@@ -606,17 +519,13 @@ static void lis3dh_acc_device_power_off(struct lis3dh_acc_data *acc)
 	if (err < 0)
 		dev_err(&acc->client->dev, "soft power off failed: %d\n", err);
 
-	lis3dh_acc_set_regulator(acc, false);
+	lis3dh_acc_config_regulator(acc, false);
 
 	if (acc->hw_initialized) {
-		if (gpio_is_valid(acc->pdata->gpio_int1)
-				&& acc->pdata->enable_int)
+		if (gpio_is_valid(acc->pdata->gpio_int1))
 			disable_irq_nosync(acc->irq1);
-
-		if (gpio_is_valid(acc->pdata->gpio_int2)
-				&& acc->pdata->enable_int)
+		if (gpio_is_valid(acc->pdata->gpio_int2))
 			disable_irq_nosync(acc->irq2);
-
 		acc->hw_initialized = 0;
 	}
 }
@@ -625,7 +534,7 @@ static int lis3dh_acc_device_power_on(struct lis3dh_acc_data *acc)
 {
 	int err = -1;
 
-	err = lis3dh_acc_set_regulator(acc, true);
+	err = lis3dh_acc_config_regulator(acc, true);
 	if (err < 0) {
 		dev_err(&acc->client->dev,
 				"power_on failed: %d\n", err);
@@ -637,22 +546,62 @@ static int lis3dh_acc_device_power_on(struct lis3dh_acc_data *acc)
 	if (!acc->hw_initialized) {
 		err = lis3dh_acc_hw_init(acc);
 		if (acc->hw_working == 1 && err < 0) {
-			lis3dh_acc_set_regulator(acc, false);
+			lis3dh_acc_device_power_off(acc);
 			return err;
 		}
 	}
 
 	if (acc->hw_initialized) {
-		if (gpio_is_valid(acc->pdata->gpio_int1)
-			&& acc->pdata->enable_int)
+		if (gpio_is_valid(acc->pdata->gpio_int1))
 			enable_irq(acc->irq1);
-		if (gpio_is_valid(acc->pdata->gpio_int2)
-			&& acc->pdata->enable_int)
+		if (gpio_is_valid(acc->pdata->gpio_int2))
 			enable_irq(acc->irq2);
 	}
 	return 0;
 }
 
+static irqreturn_t lis3dh_acc_isr1(int irq, void *dev)
+{
+	struct lis3dh_acc_data *acc = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(acc->irq1_work_queue, &acc->irq1_work);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t lis3dh_acc_isr2(int irq, void *dev)
+{
+	struct lis3dh_acc_data *acc = dev;
+
+	disable_irq_nosync(irq);
+	queue_work(acc->irq2_work_queue, &acc->irq2_work);
+
+	return IRQ_HANDLED;
+}
+
+static void lis3dh_acc_irq1_work_func(struct work_struct *work)
+{
+
+	struct lis3dh_acc_data *acc =
+	container_of(work, struct lis3dh_acc_data, irq1_work);
+
+	goto exit;
+exit:
+	enable_irq(acc->irq1);
+}
+
+static void lis3dh_acc_irq2_work_func(struct work_struct *work)
+{
+
+	struct lis3dh_acc_data *acc =
+	container_of(work, struct lis3dh_acc_data, irq2_work);
+
+	goto exit;
+exit:
+	enable_irq(acc->irq2);
+}
+
 int lis3dh_acc_update_g_range(struct lis3dh_acc_data *acc, u8 new_g_range)
 {
 	int err = -1;
@@ -716,43 +665,35 @@ error:
 	return err;
 }
 
-static unsigned int lis3dh_acc_delay_to_odr(struct lis3dh_acc_data *acc,
-				unsigned int delay_ms)
+int lis3dh_acc_update_odr(struct lis3dh_acc_data *acc, int poll_interval_ms)
 {
-	unsigned int i;
-	/*
-	 * Following, looks for the longest possible odr interval scrolling the
-	 * odr_table vector from the end (shortest interval) backward (longest
-	 * interval), to support the polling interval requested by the system.
-	 * It must be the longest interval lower then the poll interval.
-	 * polling interval should not less then 1.
-	 */
+	int err = -1;
+	int i;
+	u8 config[2];
 
-	for (i = ARRAY_SIZE(lis3dh_acc_odr_table) - 1; i > 0; i--) {
-		if (lis3dh_acc_odr_table[i].cutoff_ms <= delay_ms)
+	/* Following, looks for the longest possible odr interval scrolling the
+	 * odr_table vector from the end (shortest interval) backward (longest
+	 * interval), to support the poll_interval requested by the system.
+	 * It must be the longest interval lower then the poll interval.*/
+	for (i = ARRAY_SIZE(lis3dh_acc_odr_table) - 1; i >= 0; i--) {
+		if (lis3dh_acc_odr_table[i].cutoff_ms <= poll_interval_ms)
 			break;
 	}
-	return lis3dh_acc_odr_table[i].mask;
-}
+	config[1] = lis3dh_acc_odr_table[i].mask;
 
-static int lis3dh_acc_update_odr(struct lis3dh_acc_data *acc,
-			unsigned int delay_ms)
-{
-	int err = -1;
-	u8 config[2];
-
-	config[1] = lis3dh_acc_delay_to_odr(acc, delay_ms);
 	config[1] |= LIS3DH_ACC_ENABLE_ALL_AXES;
 
-	config[0] = CTRL_REG1;
-	err = lis3dh_acc_i2c_write(acc, config, 1);
-	if (err < 0)
-		goto error;
-	acc->resume_state[RES_CTRL_REG1] = config[1];
+	/* If device is currently enabled, we need to write new
+	 *  configuration out to it */
+	if (atomic_read(&acc->enabled)) {
+		config[0] = CTRL_REG1;
+		err = lis3dh_acc_i2c_write(acc, config, 1);
+		if (err < 0)
+			goto error;
+		acc->resume_state[RES_CTRL_REG1] = config[1];
+	}
 
-	dev_dbg(&acc->client->dev,
-		"update odr success delay=%u code=%#x\n", delay_ms, config[1]);
-	return 0;
+	return err;
 
 error:
 	dev_err(&acc->client->dev, "update odr failed 0x%x,0x%x: %d\n",
@@ -761,298 +702,7 @@ error:
 	return err;
 }
 
-static int lis3dh_acc_calc_watermark(struct lis3dh_acc_data *acc,
-				unsigned int timeout_ms)
-{
-	unsigned int num;
-	unsigned int odr, delay_ms;
-
-	/* Get actual odr and calculate watermark */
-	odr = acc->resume_state[RES_CTRL_REG1] >> 4;
-	delay_ms = lis3dh_acc_odr_to_interval(acc, odr);
-	/* Ensure watermark number always > 1 and not divide by zero */
-	if ((timeout_ms < delay_ms) || (delay_ms == 0)) {
-		dev_err(&acc->client->dev,
-			"Timeout(%u) is less than polling interval(%u)\n",
-			timeout_ms, delay_ms);
-		return -EINVAL;
-	}
-
-	num = timeout_ms / delay_ms;
-	dev_dbg(&acc->client->dev,
-		"timeout_ms=%d, delay=%d sample_num =%d\n",
-		timeout_ms, delay_ms, num);
-	return num;
-}
-
-static int lis3dh_acc_get_fifo_lvl(struct lis3dh_acc_data *acc)
-{
-	int error = 0;
-	unsigned char buf[2];
-	unsigned int fifo_lvl;
-
-	buf[0] = FIFO_SRC_REG;
-	error = lis3dh_acc_i2c_read(acc, buf, 1);
-	if (error < 0) {
-		dev_err(&acc->client->dev, "read fifo level error\n");
-		return error;
-	}
-	fifo_lvl = buf[0] & FIFO_SRC_DATA_CNT_MASK;
-	if ((fifo_lvl == FIFO_MAX_CNT)
-		&& (buf[0] | FIFO_SRC_OVRN_MASK))
-		fifo_lvl = FIFO_MAX_CNT + 1;
-
-	return fifo_lvl;
-}
-
-static int lis3dh_acc_set_wtm_int(struct lis3dh_acc_data *acc, bool enable)
-{
-	unsigned char buf[2];
-	int error = 0;
-
-	buf[0] = CTRL_REG3;
-	error = lis3dh_acc_i2c_read(acc, buf, 1);
-	if (error < 0) {
-		dev_err(&acc->client->dev, "read fifo control reg error\n");
-		return error;
-	}
-	if (enable)
-		buf[1] = buf[0] | INT_GEN_I1_WTM;
-	else
-		buf[1] = buf[0] & (~INT_GEN_I1_WTM);
-
-	buf[0] = CTRL_REG3;
-	error = lis3dh_acc_i2c_write(acc, buf, 1);
-	if (error < 0) {
-		dev_err(&acc->client->dev, "write fifo control reg error\n");
-		return error;
-	}
-	acc->resume_state[RES_CTRL_REG3] = buf[1];
-	return 0;
-}
-
-/*
- * Turn ON/OFF FIFO by setting the FIFO_En bit,
- * FIFO must be enabled before activate FIFO mode.
- */
-static int lis3dh_enable_fifo(struct i2c_client *client, bool enable)
-{
-	unsigned char buf[2];
-	int error;
-	struct lis3dh_acc_data *acc = i2c_get_clientdata(client);
-
-	buf[0] = CTRL_REG5;
-	error = lis3dh_acc_i2c_read(acc, buf, 1);
-	if (error < 0) {
-		dev_err(&client->dev, "read fifo enable reg error\n");
-		return error;
-	}
-	if (enable)
-		buf[1] = buf[0] | REG5_FIFO_EN;
-	else
-		buf[1] = buf[0] & (~REG5_FIFO_EN);
-	buf[0] = CTRL_REG5;
-	error = lis3dh_acc_i2c_write(acc, buf, 1);
-	if (error < 0) {
-		dev_err(&client->dev, "write fifo enable reg error\n");
-		return error;
-	}
-	acc->resume_state[RES_CTRL_REG5] = buf[1];
-	dev_dbg(&client->dev, "lis3dh REG5 = %#x\n", buf[1]);
-	buf[0] = CTRL_REG3;
-	error = lis3dh_acc_i2c_read(acc, buf, 1);
-	if (error < 0) {
-		dev_err(&client->dev, "read fifo control reg error\n");
-		return error;
-	}
-	if (enable) {
-		buf[0] = buf[0] & (~INT_GEN_I1_DRDY1);
-		buf[1] = buf[0] | INT_GEN_I1_OVRN;
-	} else {
-		/* disable I1_WTM and I1_OVERRUN */
-		buf[1] = buf[0] & ~(INT_GEN_I1_OVRN | INT_GEN_I1_WTM);
-		/* REenable I1_DRDY1 */
-		if (acc->pdata->enable_int)
-			buf[1] = buf[1] | INT_GEN_I1_DRDY1;
-	}
-	buf[0] = CTRL_REG3;
-	error = lis3dh_acc_i2c_write(acc, buf, 1);
-	if (error < 0) {
-		dev_err(&client->dev, "write enable fifo reg error\n");
-		return error;
-	}
-	acc->resume_state[RES_CTRL_REG3] = buf[1];
-	dev_dbg(&client->dev,
-		"EN FIFO; lis3dh REG3=%#x, err=%d\n", buf[1], error);
-	return error;
-}
-
-/*
- * Activate FIFO mode by setting FIFO mode bits.
- */
-static int lis3dh_set_fifo_mode(struct i2c_client *client,
-				unsigned char fifo_mode)
-{
-	unsigned char buf[2];
-	int error;
-	struct lis3dh_acc_data *acc = i2c_get_clientdata(client);
-
-	buf[0] = FIFO_CTRL_REG;
-	error = lis3dh_acc_i2c_read(acc, buf, 1);
-	if (error < 0) {
-		dev_err(&client->dev, "read fifo reg error\n");
-		return error;
-	}
-	buf[1] = buf[0] & (~FIFO_MODE_MASK);
-	buf[1] |= (unsigned char)(fifo_mode << FIFO_MODE_SHIFT);
-
-	buf[0] = FIFO_CTRL_REG;
-	error = lis3dh_acc_i2c_write(acc, buf, 1);
-	if (error < 0) {
-		dev_err(&client->dev, "write fifo mode error\n");
-		return error;
-	}
-	acc->resume_state[RES_FIFO_CTRL_REG] = buf[1];
-	dev_dbg(&client->dev,
-		"lis3dh_set_fifo_mode: lis3dh fifo_reg = %#x\n", buf[1]);
-	return error;
-}
-
-static int lis3dh_interrupt_status(struct lis3dh_acc_data *acc, char *status)
-{
-	int error;
-	char buf;
-
-	buf = FIFO_SRC_REG;
-	error =  lis3dh_acc_i2c_read(acc, &buf, 1);
-	if (error < 0) {
-		dev_err(&acc->client->dev, "read interrupt status error\n");
-		return error;
-	} else {
-		*status = buf;
-		dev_dbg(&acc->client->dev, "FIFO_SRC = %#x\n", (int) buf);
-	}
-	return 0;
-}
-
-static int lis3dh_enable_DRDY_int(struct lis3dh_acc_data *acc)
-{
-	int error;
-	char buf[2];
-
-	if (acc->pdata->enable_int) {
-		buf[0] = CTRL_REG3;
-		error = lis3dh_acc_i2c_read(acc, buf, 1);
-		if (error < 0) {
-			dev_err(&acc->client->dev,
-				"read fifo control reg error\n");
-			return error;
-		}
-
-		buf[1] = buf[0] | INT_GEN_I1_DRDY1;
-		buf[0] = CTRL_REG3;
-		error = lis3dh_acc_i2c_write(acc, buf, 1);
-		if (error < 0) {
-			dev_err(&acc->client->dev,
-				"write enable fifo reg error\n");
-			return error;
-		}
-		acc->resume_state[RES_CTRL_REG3] = buf[1];
-	} else {
-		dev_info(&acc->client->dev, "Interrupt not enabled\n");
-	}
-	return 0;
-}
-
-static int lis3dh_acc_set_waterwark(struct lis3dh_acc_data *acc,
-				int watermark)
-{
-	unsigned char buf[2];
-	int error = 0;
-
-	if (watermark < LIS3DH_FIFO_SIZE - 1) {
-		buf[0] = FIFO_CTRL_REG;
-		error = lis3dh_acc_i2c_read(acc, buf, 1);
-		if (error < 0) {
-			dev_err(&acc->client->dev, "read fifo reg error\n");
-			return error;
-		}
-		buf[1] = buf[0] & (~FIFO_WM_CFG_MASK);
-		buf[1] = buf[1] | (watermark & FIFO_WM_CFG_MASK);
-		buf[0] = FIFO_CTRL_REG;
-		error = lis3dh_acc_i2c_write(acc, buf, 1);
-		if (error < 0) {
-			dev_err(&acc->client->dev, "write fifo mode error\n");
-			return error;
-		}
-		acc->resume_state[RES_FIFO_CTRL_REG] = buf[1];
-		error = lis3dh_acc_set_wtm_int(acc, true);
-	} else {
-		error = lis3dh_acc_set_wtm_int(acc, false);
-
-		dev_dbg(&acc->client->dev,
-			"Watermark (%d) >= FIFO level (%d), disable WTM int!\n",
-			watermark, LIS3DH_FIFO_SIZE - 1);
-	}
-	return error;
-}
-
-static int lis3dh_acc_enable_batch(struct lis3dh_acc_data *acc, bool en)
-{
-	struct i2c_client *client = acc->client;
-	int watermark;
-	int err;
 
-	mutex_lock(&acc->lock);
-	if (en) {
-		watermark = lis3dh_acc_calc_watermark(acc,
-					acc->fifo_timeout_ms);
-		if (watermark <= 0) {
-			dev_err(&acc->client->dev,
-				"enable batch: cannot calculate watermark, ret=%d\n",
-				watermark);
-			err = -EINVAL;
-			goto exit;
-		}
-		err = lis3dh_acc_set_waterwark(acc, watermark);
-		if (err < 0) {
-			dev_err(&acc->client->dev,
-				"enable batch: cannot set watermark, ret=%d\n",
-				err);
-			goto exit;
-		}
-
-		err = lis3dh_enable_fifo(client, true);
-		if (err < 0) {
-			dev_err(&acc->client->dev,
-				"enable batch: cannot enable FIFO\n");
-			goto exit;
-		}
-		err = lis3dh_set_fifo_mode(client, LIS3DH_FIFO_MODE);
-		if (err < 0) {
-			dev_err(&acc->client->dev,
-				"enable batch: cannot set FIFO mode\n");
-			goto exit;
-		}
-	} else {
-		err = lis3dh_set_fifo_mode(client, LIS3DH_BYPASS_MODE);
-		if (err < 0) {
-			dev_err(&acc->client->dev,
-				"enable batch: cannot set FIFO mode\n");
-			goto exit;
-		}
-		err = lis3dh_enable_fifo(client, false);
-		if (err < 0) {
-			dev_err(&acc->client->dev,
-				"enable batch: cannot enable FIFO\n");
-			goto exit;
-		}
-	}
-
-exit:
-	mutex_unlock(&acc->lock);
-	return err;
-}
 
 static int lis3dh_acc_register_write(struct lis3dh_acc_data *acc, u8 *buf,
 		u8 reg_address, u8 new_value)
@@ -1099,8 +749,10 @@ static int lis3dh_acc_get_acceleration_data(struct lis3dh_acc_data *acc,
 	xyz[2] = ((acc->pdata->negate_z) ? (-hw_d[acc->pdata->axis_map_z])
 		   : (hw_d[acc->pdata->axis_map_z]));
 
+	#ifdef DEBUG
 	dev_dbg(&acc->client->dev, "%s read x=%d, y=%d, z=%d\n",
-				LIS3DH_ACC_DEV_NAME, xyz[0], xyz[1], xyz[2]);
+			LIS3DH_ACC_DEV_NAME, xyz[0], xyz[1], xyz[2]);
+	#endif
 	return err;
 }
 
@@ -1117,46 +769,18 @@ static int lis3dh_acc_enable(struct lis3dh_acc_data *acc)
 {
 	int err;
 
-	dev_dbg(&acc->client->dev, "enable acc: state =%d\n",
-			atomic_read(&acc->enabled));
 	if (!atomic_cmpxchg(&acc->enabled, 0, 1)) {
 		if (pinctrl_select_state(acc->pinctrl, acc->pin_default))
 			dev_err(&acc->client->dev,
-				"can't select pinctrl default state\n");
+				"Can't select pinctrl default state\n");
 
 		err = lis3dh_acc_device_power_on(acc);
 		if (err < 0) {
 			atomic_set(&acc->enabled, 0);
 			return err;
 		}
-		err = lis3dh_acc_update_odr(acc, acc->delay_ms);
-		if (err) {
-			atomic_set(&acc->enabled, 0);
-			dev_err(&acc->client->dev, "update_odr err=%d\n", err);
-			return err;
-		}
-		if (!acc->pdata->enable_int && !acc->use_batch) {
-			schedule_delayed_work(&acc->input_work,
-				msecs_to_jiffies(acc->delay_ms));
-			return 0;
-		}
-		if (acc->use_batch) {
-			err = lis3dh_acc_enable_batch(acc, true);
-			if (err < 0) {
-				atomic_set(&acc->enabled, 0);
-				dev_err(&acc->client->dev,
-					"enable batch err=%d\n", err);
-				return err;
-			}
-		} else {
-			err = lis3dh_enable_DRDY_int(acc);
-			if (err) {
-				atomic_set(&acc->enabled, 0);
-				dev_err(&acc->client->dev,
-					"enable interrupt err=%d\n", err);
-				return err;
-			}
-		}
+		schedule_delayed_work(&acc->input_work,
+			msecs_to_jiffies(acc->pdata->poll_interval));
 	}
 
 	return 0;
@@ -1164,115 +788,17 @@ static int lis3dh_acc_enable(struct lis3dh_acc_data *acc)
 
 static int lis3dh_acc_disable(struct lis3dh_acc_data *acc)
 {
-	int err = 0;
-
-	dev_dbg(&acc->client->dev, "disable state=%d\n",
-		atomic_read(&acc->enabled));
 	if (atomic_cmpxchg(&acc->enabled, 1, 0)) {
-		if (acc->use_batch) {
-			err = lis3dh_acc_enable_batch(acc, false);
-			if (err < 0) {
-				atomic_set(&acc->enabled, 1);
-				return err;
-			}
-		}
-		if (!acc->pdata->enable_int && !acc->use_batch)
-			cancel_delayed_work_sync(&acc->input_work);
+		cancel_delayed_work_sync(&acc->input_work);
 		lis3dh_acc_device_power_off(acc);
 		if (pinctrl_select_state(acc->pinctrl, acc->pin_sleep))
 			dev_err(&acc->client->dev,
-				"can't select pinctrl sleep state\n");
+				"Can't select pinctrl sleep state\n");
 	}
 
 	return 0;
 }
 
-static irqreturn_t lis3dh_acc_isr1(int irq, void *dev)
-{
-	int err;
-	char status;
-	int i;
-	int fifo_cnt;
-	int xyz[3] = { 0 };
-	u64 timestamp = 0;
-	u32 time_h, time_l, time_ms;
-	struct lis3dh_acc_data *acc = dev;
-
-	err = lis3dh_interrupt_status(acc, &status);
-	if (err) {
-		dev_err(&acc->client->dev, "read status error\n");
-		goto exit;
-	}
-	if (IS_FIFO_FULL(status) || IS_WATER_MARK_REACHED(status)) {
-		timestamp = lis3dh_acc_get_time_ns();
-		time_ms = lis3dh_acc_odr_to_interval(acc,
-			(acc->resume_state[RES_CTRL_REG1] >> 4));
-		fifo_cnt = lis3dh_acc_get_fifo_lvl(acc);
-		dev_dbg(&acc->client->dev, "TS: base=%lld, interval=%d fifo_cnt=%d\n",
-			timestamp, time_ms, fifo_cnt);
-		timestamp = timestamp -
-			((u64)time_ms * LIS3DH_TIME_MS_TO_NS * fifo_cnt);
-
-		for (i = 0; i < fifo_cnt; i++) {
-			err = lis3dh_acc_get_acceleration_data(acc, xyz);
-			if (err < 0) {
-				dev_err(&acc->client->dev,
-					"get_acceleration_data failed\n");
-				goto exit;
-			} else {
-				timestamp = timestamp +
-				((u64)time_ms * LIS3DH_TIME_MS_TO_NS);
-				time_h = (u32)((timestamp >> 32) & 0xFFFFFFFF);
-				time_l = (u32)(timestamp & 0xFFFFFFFF);
-
-				input_report_abs(acc->input_dev, ABS_RX,
-						time_h);
-				input_report_abs(acc->input_dev, ABS_RY,
-						time_l);
-				lis3dh_acc_report_values(acc, xyz);
-			}
-		}
-
-		err = lis3dh_set_fifo_mode(acc->client, LIS3DH_BYPASS_MODE);
-		if (err < 0) {
-			dev_err(&acc->client->dev,
-					"set fifo mode to bypass failed\n");
-			goto exit;
-		}
-
-		err = lis3dh_set_fifo_mode(acc->client, LIS3DH_FIFO_MODE);
-		if (err < 0) {
-			dev_err(&acc->client->dev,
-					"set fifo mode to bypass failed\n");
-			goto exit;
-		}
-	} else {
-		err = lis3dh_acc_get_acceleration_data(acc, xyz);
-		if (err < 0) {
-			dev_err(&acc->client->dev,
-					"get_acceleration_data failed\n");
-			goto exit;
-		} else {
-			lis3dh_acc_report_values(acc, xyz);
-		}
-	}
-exit:
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t lis3dh_acc_isr2(int irq, void *dev)
-{
-	struct lis3dh_acc_data *acc = dev;
-	int err;
-	int xyz[3] = { 0 };
-	err = lis3dh_acc_get_acceleration_data(acc, xyz);
-	if (err < 0)
-		dev_err(&acc->client->dev, "get_acceleration_data failed\n");
-	else
-		lis3dh_acc_report_values(acc, xyz);
-
-	return IRQ_HANDLED;
-}
 
 static ssize_t read_single_reg(struct device *dev, char *buf, u8 reg)
 {
@@ -1318,7 +844,7 @@ static ssize_t attr_get_polling_rate(struct device *dev,
 	int val;
 	struct lis3dh_acc_data *acc = dev_get_drvdata(dev);
 	mutex_lock(&acc->lock);
-	val = acc->delay_ms;
+	val = acc->pdata->poll_interval;
 	mutex_unlock(&acc->lock);
 	return snprintf(buf, 8, "%d\n", val);
 }
@@ -1335,7 +861,7 @@ static ssize_t attr_set_polling_rate(struct device *dev,
 	if (!interval_ms)
 		return -EINVAL;
 	mutex_lock(&acc->lock);
-	acc->delay_ms = interval_ms;
+	acc->pdata->poll_interval = interval_ms;
 	lis3dh_acc_update_odr(acc, interval_ms);
 	mutex_unlock(&acc->lock);
 	return size;
@@ -1622,91 +1148,16 @@ static int remove_sysfs_interfaces(struct device *dev)
 	return 0;
 }
 
-static int lis3dh_acc_flush(struct sensors_classdev *sensors_cdev)
-{
-	struct lis3dh_acc_data *acc = container_of(sensors_cdev,
-			struct lis3dh_acc_data, cdev);
-	s64 timestamp;
-	int err;
-	int fifo_cnt;
-	int i;
-	u32 time_h, time_l, time_ms;
-	int xyz[3] = {0};
-
-	timestamp = lis3dh_acc_get_time_ns();
-	time_ms = lis3dh_acc_odr_to_interval(acc,
-			(acc->resume_state[RES_CTRL_REG1] >> 4));
-	fifo_cnt = lis3dh_acc_get_fifo_lvl(acc);
-	dev_dbg(&acc->client->dev, "TS: base=%lld, interval=%d fifo_cnt=%d\n",
-			timestamp, time_ms, fifo_cnt);
-	timestamp = timestamp -
-		((s64)time_ms * LIS3DH_TIME_MS_TO_NS * fifo_cnt);
-
-	for (i = 0; i < fifo_cnt; i++) {
-		err = lis3dh_acc_get_acceleration_data(acc, xyz);
-		if (err < 0) {
-			dev_err(&acc->client->dev,
-					"get_acceleration_data failed\n");
-			goto exit;
-		} else {
-			timestamp = timestamp +
-				(time_ms * LIS3DH_TIME_MS_TO_NS);
-			time_h = (u32)(((u64)timestamp >> 32) & 0xFFFFFFFF);
-			time_l = (u32)(timestamp & 0xFFFFFFFF);
-
-			input_report_abs(acc->input_dev, ABS_RX,
-					time_h);
-			input_report_abs(acc->input_dev, ABS_RY,
-					time_l);
-			lis3dh_acc_report_values(acc, xyz);
-		}
-	}
-
-	input_event(acc->input_dev, EV_SYN, SYN_CONFIG, acc->flush_count++);
-	input_sync(acc->input_dev);
-
-	return 0;
-exit:
-	return err;
-}
-
 static int lis3dh_acc_poll_delay_set(struct sensors_classdev *sensors_cdev,
 	unsigned int delay_msec)
 {
 	struct lis3dh_acc_data *acc = container_of(sensors_cdev,
 		struct lis3dh_acc_data, cdev);
 	int err;
-	int watermark;
 
-	dev_dbg(&acc->client->dev, "set poll delay =%d\n", delay_msec);
 	mutex_lock(&acc->lock);
-	acc->delay_ms = delay_msec;
-	/*
-	 * Device may not power on,
-	 * only set register when device is enabled.
-	 */
-	if (atomic_read(&acc->enabled)) {
-		err = lis3dh_acc_update_odr(acc, delay_msec);
-		if (err < 0) {
-			dev_err(&acc->client->dev, "Cannot update ODR\n");
-			err = -EBUSY;
-			goto exit;
-		}
-		if (acc->use_batch) {
-			watermark = lis3dh_acc_calc_watermark(acc,
-					acc->fifo_timeout_ms);
-			if (watermark <= 0) {
-				dev_err(&acc->client->dev,
-					"Cannot calculate watermark, ret=%d\n",
-					watermark);
-				err = -EINVAL;
-				goto exit;
-			} else {
-				err = lis3dh_acc_set_waterwark(acc, watermark);
-			}
-		}
-	}
-exit:
+	acc->pdata->poll_interval = delay_msec;
+	err = lis3dh_acc_update_odr(acc, delay_msec);
 	mutex_unlock(&acc->lock);
 	return err;
 }
@@ -1718,40 +1169,13 @@ static int lis3dh_acc_enable_set(struct sensors_classdev *sensors_cdev,
 		struct lis3dh_acc_data, cdev);
 	int err;
 
-	if (enable) {
+	if (enable)
 		err = lis3dh_acc_enable(acc);
-		if (err < 0) {
-			dev_err(&acc->client->dev, "enable error\n");
-			return err;
-		}
-	} else {
+	else
 		err = lis3dh_acc_disable(acc);
-		if (err < 0) {
-			dev_err(&acc->client->dev, "enable error\n");
-			return err;
-		}
-	}
 	return err;
 }
-static int lis3dh_latency_set(struct sensors_classdev *cdev,
-					unsigned int max_latency)
-{
-	struct lis3dh_acc_data *acc = container_of(cdev,
-		struct lis3dh_acc_data, cdev);
-	struct i2c_client *client = acc->client;
-
-	/* Does not support batch in while interrupt is not enabled */
-	if (!acc->pdata->enable_int) {
-		dev_err(&client->dev,
-			"Cannot set batch mode, interrupt is not enabled!\n");
-		return -EPERM;
-	}
-	acc->use_batch = max_latency ? true : false;
-	acc->fifo_timeout_ms = max_latency;
-	return 0;
-}
 
-/* Work function for polling mode */
 static void lis3dh_acc_input_work_func(struct work_struct *work)
 {
 	struct lis3dh_acc_data *acc;
@@ -1770,7 +1194,7 @@ static void lis3dh_acc_input_work_func(struct work_struct *work)
 		lis3dh_acc_report_values(acc, xyz);
 
 	schedule_delayed_work(&acc->input_work, msecs_to_jiffies(
-			acc->delay_ms));
+			acc->pdata->poll_interval));
 	mutex_unlock(&acc->lock);
 }
 
@@ -1790,7 +1214,7 @@ void lis3dh_acc_input_close(struct input_dev *dev)
 
 static int lis3dh_acc_validate_pdata(struct lis3dh_acc_data *acc)
 {
-	acc->pdata->init_interval = max(acc->pdata->init_interval,
+	acc->pdata->poll_interval = max(acc->pdata->poll_interval,
 			acc->pdata->min_interval);
 
 	if (acc->pdata->axis_map_x > 2 ||
@@ -1814,7 +1238,7 @@ static int lis3dh_acc_validate_pdata(struct lis3dh_acc_data *acc)
 	}
 
 	/* Enforce minimum polling interval */
-	if (acc->pdata->init_interval < acc->pdata->min_interval) {
+	if (acc->pdata->poll_interval < acc->pdata->min_interval) {
 		dev_err(&acc->client->dev, "minimum poll interval violated\n");
 		return -EINVAL;
 	}
@@ -1826,8 +1250,7 @@ static int lis3dh_acc_input_init(struct lis3dh_acc_data *acc)
 {
 	int err;
 
-	if (!acc->pdata->enable_int)
-		INIT_DELAYED_WORK(&acc->input_work, lis3dh_acc_input_work_func);
+	INIT_DELAYED_WORK(&acc->input_work, lis3dh_acc_input_work_func);
 	acc->input_dev = input_allocate_device();
 	if (!acc->input_dev) {
 		err = -ENOMEM;
@@ -1849,10 +1272,6 @@ static int lis3dh_acc_input_init(struct lis3dh_acc_data *acc)
 	/*	next is used for interruptB sources data if the case */
 	set_bit(ABS_WHEEL, acc->input_dev->absbit);
 
-	input_set_abs_params(acc->input_dev, ABS_RX, 0, (1UL << 31) - 1,
-						FUZZ, FLAT);
-	input_set_abs_params(acc->input_dev, ABS_RY, 0, (1UL << 31) - 1,
-						FUZZ, FLAT);
 	input_set_abs_params(acc->input_dev, ABS_X, -G_MAX, G_MAX, FUZZ, FLAT);
 	input_set_abs_params(acc->input_dev, ABS_Y, -G_MAX, G_MAX, FUZZ, FLAT);
 	input_set_abs_params(acc->input_dev, ABS_Z, -G_MAX, G_MAX, FUZZ, FLAT);
@@ -1932,7 +1351,7 @@ static int lis3dh_parse_dt(struct device *dev,
 		dev_err(dev, "Unable to read init-interval\n");
 		return rc;
 	} else {
-		pdata->init_interval = temp_val;
+		pdata->poll_interval = temp_val;
 	}
 
 	rc = of_property_read_u32(np, "st,axis-map-x", &temp_val);
@@ -1989,8 +1408,6 @@ static int lis3dh_parse_dt(struct device *dev,
 
 	pdata->negate_z = of_property_read_bool(np, "st,negate-z");
 
-	pdata->enable_int = of_property_read_bool(np, "st,enable-int");
-
 	pdata->gpio_int1 = of_get_named_gpio_flags(dev->of_node,
 				"st,gpio-int1", 0, NULL);
 
@@ -2023,8 +1440,8 @@ static int lis3dh_acc_probe(struct i2c_client *client,
 	if (acc == NULL) {
 		err = -ENOMEM;
 		dev_err(&client->dev,
-				"failed to allocate memory for module data: "
-					"%d\n", err);
+				"failed to allocate memory for module data: %d\n",
+				err);
 		goto exit_check_functionality_failed;
 	}
 
@@ -2088,12 +1505,10 @@ static int lis3dh_acc_probe(struct i2c_client *client,
 		}
 	}
 
-	if (gpio_is_valid(acc->pdata->gpio_int1)
-			&& acc->pdata->enable_int)
+	if (gpio_is_valid(acc->pdata->gpio_int1))
 		acc->irq1 = gpio_to_irq(acc->pdata->gpio_int1);
 
-	if (gpio_is_valid(acc->pdata->gpio_int2)
-			&& acc->pdata->enable_int)
+	if (gpio_is_valid(acc->pdata->gpio_int2))
 		acc->irq2 = gpio_to_irq(acc->pdata->gpio_int2);
 
 	memset(acc->resume_state, 0, ARRAY_SIZE(acc->resume_state));
@@ -2117,22 +1532,10 @@ static int lis3dh_acc_probe(struct i2c_client *client,
 	acc->resume_state[RES_TT_TLAT] = 0x00;
 	acc->resume_state[RES_TT_TW] = 0x00;
 
-	if (acc->pdata->enable_int) {
-		if (gpio_is_valid(acc->pdata->gpio_int1))
-			acc->resume_state[RES_CTRL_REG3] = CONFIG_IRQ_DRDY1;
-		acc->resume_state[RES_CTRL_REG4] = CONFIG_BLOCK_READ;
-	}
-
-	err = lis3dh_acc_config_regulator(acc, true);
-	if (err < 0) {
-		dev_err(&client->dev, "Configure power failed: %d\n", err);
-		goto err_pdata_init;
-	}
-
 	err = lis3dh_acc_device_power_on(acc);
 	if (err < 0) {
 		dev_err(&client->dev, "power on failed: %d\n", err);
-		goto err_regulator_init;
+		goto err_pdata_init;
 	}
 
 	atomic_set(&acc->enabled, 1);
@@ -2143,11 +1546,7 @@ static int lis3dh_acc_probe(struct i2c_client *client,
 		goto  err_power_off;
 	}
 
-	acc->use_batch = false;
-	acc->batch_mode = BATCH_MODE_NORMAL;
-	acc->fifo_timeout_ms = 0;
-	acc->delay_ms = acc->pdata->init_interval;
-	err = lis3dh_acc_update_odr(acc, acc->delay_ms);
+	err = lis3dh_acc_update_odr(acc, acc->pdata->poll_interval);
 	if (err < 0) {
 		dev_err(&client->dev, "update_odr failed\n");
 		goto  err_power_off;
@@ -2170,13 +1569,6 @@ static int lis3dh_acc_probe(struct i2c_client *client,
 	acc->cdev = lis3dh_acc_cdev;
 	acc->cdev.sensors_enable = lis3dh_acc_enable_set;
 	acc->cdev.sensors_poll_delay = lis3dh_acc_poll_delay_set;
-	/* batch is possiable only when interrupt is enabled */
-	if (gpio_is_valid(acc->pdata->gpio_int1) && acc->pdata->enable_int) {
-		acc->cdev.sensors_set_latency = lis3dh_latency_set;
-		acc->cdev.sensors_flush = lis3dh_acc_flush;
-		acc->cdev.fifo_reserved_event_count = LIS3DH_FIFO_SIZE;
-		acc->cdev.fifo_max_event_count = LIS3DH_FIFO_SIZE;
-	}
 	err = sensors_classdev_register(&client->dev, &acc->cdev);
 	if (err) {
 		dev_err(&client->dev,
@@ -2189,35 +1581,46 @@ static int lis3dh_acc_probe(struct i2c_client *client,
 	/* As default, do not report information */
 	atomic_set(&acc->enabled, 0);
 
-	if (gpio_is_valid(acc->pdata->gpio_int1) && acc->pdata->enable_int) {
-		err = request_threaded_irq(acc->irq1, NULL,
-				lis3dh_acc_isr1,
+	if (gpio_is_valid(acc->pdata->gpio_int1)) {
+		INIT_WORK(&acc->irq1_work, lis3dh_acc_irq1_work_func);
+		acc->irq1_work_queue =
+			create_singlethread_workqueue("lis3dh_acc_wq1");
+		if (!acc->irq1_work_queue) {
+			err = -ENOMEM;
+			dev_err(&client->dev,
+					"cannot create work queue1: %d\n", err);
+			goto err_unreg_sensor_class;
+		}
+		err = request_irq(acc->irq1, lis3dh_acc_isr1,
 				IRQF_TRIGGER_RISING | IRQF_ONESHOT,
 				"lis3dh_acc_irq1", acc);
 		if (err < 0) {
-			dev_err(&client->dev,
-					"request irq1 failed: %d\n", err);
-			goto err_unreg_sensor_class;
+			dev_err(&client->dev, "request irq1 failed: %d\n", err);
+			goto err_destoyworkqueue1;
 		}
 		disable_irq_nosync(acc->irq1);
 	}
 
-	if (gpio_is_valid(acc->pdata->gpio_int2) && acc->pdata->enable_int) {
-		err = request_threaded_irq(acc->irq2, NULL,
-				lis3dh_acc_isr2,
+	if (gpio_is_valid(acc->pdata->gpio_int2)) {
+		INIT_WORK(&acc->irq2_work, lis3dh_acc_irq2_work_func);
+		acc->irq2_work_queue =
+			create_singlethread_workqueue("lis3dh_acc_wq2");
+		if (!acc->irq2_work_queue) {
+			err = -ENOMEM;
+			dev_err(&client->dev,
+					"cannot create work queue2: %d\n", err);
+			goto err_free_irq1;
+		}
+		err = request_irq(acc->irq2, lis3dh_acc_isr2,
 				IRQF_TRIGGER_RISING | IRQF_ONESHOT,
 				"lis3dh_acc_irq2", acc);
 		if (err < 0) {
-			dev_err(&client->dev,
-					"request irq2 failed: %d\n", err);
-			goto err_free_irq1;
+			dev_err(&client->dev, "request irq2 failed: %d\n", err);
+			goto err_destoyworkqueue2;
 		}
 		disable_irq_nosync(acc->irq2);
 	}
 
-	if (acc->pdata->enable_int)
-		device_init_wakeup(&client->dev, 1);
-
 	if (pinctrl_select_state(acc->pinctrl, acc->pin_sleep))
 		dev_err(&client->dev,
 			"Can't select pinctrl sleep state\n");
@@ -2228,9 +1631,14 @@ static int lis3dh_acc_probe(struct i2c_client *client,
 
 	return 0;
 
+err_destoyworkqueue2:
+	if (gpio_is_valid(acc->pdata->gpio_int2))
+		destroy_workqueue(acc->irq2_work_queue);
 err_free_irq1:
-if (gpio_is_valid(acc->pdata->gpio_int1) && acc->pdata->enable_int)
 	free_irq(acc->irq1, acc);
+err_destoyworkqueue1:
+	if (gpio_is_valid(acc->pdata->gpio_int1))
+		destroy_workqueue(acc->irq1_work_queue);
 err_unreg_sensor_class:
 	sensors_classdev_unregister(&acc->cdev);
 err_remove_sysfs_int:
@@ -2239,8 +1647,6 @@ err_input_cleanup:
 	lis3dh_acc_input_cleanup(acc);
 err_power_off:
 	lis3dh_acc_device_power_off(acc);
-err_regulator_init:
-	lis3dh_acc_config_regulator(acc, false);
 err_pdata_init:
 	if (acc->pdata->exit)
 		acc->pdata->exit();
@@ -2258,16 +1664,21 @@ static int lis3dh_acc_remove(struct i2c_client *client)
 {
 	struct lis3dh_acc_data *acc = i2c_get_clientdata(client);
 
-	lis3dh_acc_device_power_off(acc);
-	if (gpio_is_valid(acc->pdata->gpio_int1) && acc->pdata->enable_int)
+	if (gpio_is_valid(acc->pdata->gpio_int1)) {
 		free_irq(acc->irq1, acc);
+		gpio_free(acc->pdata->gpio_int1);
+		destroy_workqueue(acc->irq1_work_queue);
+	}
 
-	if (gpio_is_valid(acc->pdata->gpio_int2) && acc->pdata->enable_int)
+	if (gpio_is_valid(acc->pdata->gpio_int2)) {
 		free_irq(acc->irq2, acc);
+		gpio_free(acc->pdata->gpio_int2);
+		destroy_workqueue(acc->irq2_work_queue);
+	}
 
 	sensors_classdev_unregister(&acc->cdev);
 	lis3dh_acc_input_cleanup(acc);
-	lis3dh_acc_config_regulator(acc, false);
+	lis3dh_acc_device_power_off(acc);
 	remove_sysfs_interfaces(&client->dev);
 
 	if (acc->pdata->exit)
@@ -2282,66 +1693,22 @@ static int lis3dh_acc_remove(struct i2c_client *client)
 static int lis3dh_acc_resume(struct i2c_client *client)
 {
 	struct lis3dh_acc_data *acc = i2c_get_clientdata(client);
-	int err;
 
-	if (!acc->on_before_suspend)
-		return 0;
+	pr_info("%s:lis3dh resuming.\n", __func__);
 
-	if (!acc->use_batch) {
-		err = lis3dh_acc_enable(acc);
-		if (err < 0)
-			dev_err(&client->dev,
-				"Resume: fail to enable sensor\n");
-		return 0;
-	}
-	/* resume to FIFO mode */
-	if (acc->batch_mode == BATCH_MODE_WAKE_UPON_FIFO_FULL) {
-		irq_set_irq_wake(acc->irq1, 0);
-		dev_dbg(&client->dev, "Resume: cancel irq wakeup\n");
-	} else {
-		err = lis3dh_set_fifo_mode(client, LIS3DH_FIFO_MODE);
-		dev_dbg(&client->dev, "Resume: swich back to FIFO mode\n");
-		if (err < 0)
-			dev_err(&client->dev,
-				"Resume: set fifo mode error\n");
-	}
+	if (acc->on_before_suspend)
+		return lis3dh_acc_enable(acc);
 	return 0;
 }
 
 static int lis3dh_acc_suspend(struct i2c_client *client, pm_message_t mesg)
 {
 	struct lis3dh_acc_data *acc = i2c_get_clientdata(client);
-	int err;
-
-	acc->on_before_suspend = atomic_read(&acc->enabled);
-	if (!acc->on_before_suspend)
-		return 0;
 
-	/* Power off the sensor if not in batch */
-	if (!acc->use_batch) {
-		err = lis3dh_acc_disable(acc);
-		if (err < 0)
-			dev_err(&client->dev,
-				"Suspend: fail to disable sensor\n");
-		return 0;
-	}
+	pr_info("%s:lis3dh suspending.\n", __func__);
 
-	/*
-	 * set IRQ wakeup if FIFO full wakeup is required,
-	 * otherwise switch to steam mode and drop data.
-	 */
-	if (acc->batch_mode == BATCH_MODE_WAKE_UPON_FIFO_FULL) {
-		irq_set_irq_wake(acc->irq1, 1);
-		dev_dbg(&client->dev, "Suspend: Wakeup upon FIFO full\n");
-	} else {
-		err = lis3dh_set_fifo_mode(client, LIS3DH_STREAM_MODE);
-		dev_dbg(&client->dev, "Suspend: swich to STREAM mode\n");
-		if (err < 0)
-			dev_err(&client->dev,
-				"Suspend: set fifo mode error\n");
-	}
-
-	return 0;
+	acc->on_before_suspend = atomic_read(&acc->enabled);
+	return lis3dh_acc_disable(acc);
 }
 #else
 #define lis3dh_acc_suspend	NULL
diff --git a/include/linux/input/lis3dh.h b/include/linux/input/lis3dh.h
index 3da0f96..5a8d2db 100644
--- a/include/linux/input/lis3dh.h
+++ b/include/linux/input/lis3dh.h
@@ -1,5 +1,5 @@
 
-/******************** (C) COPYRIGHT 2010 STMicroelectronics ********************
+/****************** (C) COPYRIGHT 2010-2014 STMicroelectronics ****************
 *
 * File Name          : lis3dh_misc.h
 * Authors            : MH - C&I BU - Application Team
@@ -36,8 +36,9 @@
 #define LIS3DH_ACC_I2C_SADROOT	0x0C
 #define LIS3DH_ACC_I2C_SAD_L	((LIS3DH_ACC_I2C_SADROOT<<1)|SAD0L)
 #define LIS3DH_ACC_I2C_SAD_H	((LIS3DH_ACC_I2C_SADROOT<<1)|SAD0H)
-#define	LIS3DH_ACC_DEV_NAME	"lis3dh_acc"
-#define ACCEL_INPUT_DEV_NAME	"lis3dh-accel"
+/* #define	LIS3DH_ACC_DEV_NAME	"lis3dh_acc" */
+#define	LIS3DH_ACC_DEV_NAME	"lis3dh"
+#define ACCEL_INPUT_DEV_NAME	"accelerometer"
 
 /************************************************/
 /*	Accelerometer defines section		*/
@@ -53,7 +54,7 @@
 
 #ifdef	__KERNEL__
 struct lis3dh_acc_platform_data {
-	int init_interval;
+	int poll_interval;
 	int min_interval;
 
 	u8 g_range;
@@ -65,7 +66,6 @@ struct lis3dh_acc_platform_data {
 	u8 negate_x;
 	u8 negate_y;
 	u8 negate_z;
-	bool enable_int;
 
 	int (*init)(void);
 	void (*exit)(void);
-- 
2.2.1

