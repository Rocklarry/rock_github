From 64f4eb8a23a6e6845c30dc75eb0632e873bf2372 Mon Sep 17 00:00:00 2001
From: wanyk0402 <wanyk0402@thundersoft.com>
Date: Wed, 18 Jun 2014 14:51:11 +0800
Subject: [PATCH 1/3] drivers:misc: support apds9900 driver

Driver support apds9900

Change-Id: I5e39c1886c75c607338c34f5ab8b03649d966056
Signed-off-by: Yukun Wan <wanyk0402@thundersoft.com>
---
 .../devicetree/bindings/input/misc/apds990x.txt    |   50 +
 drivers/misc/Kconfig                               |    7 +
 drivers/misc/Makefile                              |    2 +-
 drivers/misc/apds990x.c                            | 3273 ++++++++++++++------
 include/linux/i2c/apds990x.h                       |   53 +-
 5 files changed, 2405 insertions(+), 980 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/input/misc/apds990x.txt

diff --git a/Documentation/devicetree/bindings/input/misc/apds990x.txt b/Documentation/devicetree/bindings/input/misc/apds990x.txt
new file mode 100644
index 0000000..36abf75
--- /dev/null
+++ b/Documentation/devicetree/bindings/input/misc/apds990x.txt
@@ -0,0 +1,50 @@
+Avago apds990x ambient light + proximity combo driver.
+
+Required properties:
+
+ - compatible					: Should be "avago,apds990x".
+ - reg							: i2c slave address of the device.
+ - pinctrl-names				: The pinctrl configration names of this sensor driver. Should be
+					"default" and "sleep".
+ - pinctrl-0					: Should specify pin control groups used for this controller.
+ - pinctrl-1					: Should specify pin control groups used for this controller.
+ - interrupt-parent				: Parent of interrupt.
+ - interupts					: L/P sample interrupt to indicate new data ready.
+ - vdd-supply					: Power supply needed to power up the device.
+ - vio-supply					: IO power supply needed for IO and I2C.
+ - avago,irq-gpio				: The gpio pin for the interrupt.
+ - avago,ps-threshold			: The threshold adc value for proximity sensor
+				to trigger away interrupt.
+ - avago,ps-hysteresis-threshold: The hysteresis threshold adc value for
+				proximity sensor to trigger  close interrupt.
+ - avago,ps-pulse				: The proximity pulse that the LDR will generate.
+ - avago,ps-gain				: The proximity gain of the sensor.
+ - avago,als-B					: Tuning value of COE_B parameter.
+ - avago,als-C					: Tuning value of COE_C parameter.
+ - avago,als-D					: Tuning value of COE_D parameter.
+ - avago,ga-value				: Tuning value of the gain for light sensor.
+
+ Example:
+
+&i2c_0 { /* BLSP1 QUP2 */
+	 avago@39 {
+		 compatible = "avago,apds990x";
+		 reg = <0x39>;
+		 pinctrl-names = "default","sleep";
+		 pinctrl-0 = <&apds99xx_default>;
+		 pinctrl-1 = <&apds99xx_sleep>;
+		 interrupt-parent = <&msmgpio>;
+		 interrupts = <80 0x2>;
+		 vdd-supply = <&pm8110_l19>;
+		 vio-supply = <&pm8110_l14>;
+		 avago,irq-gpio = <&msmgpio 80 0x2>;
+		 avago,ps_threshold = <800>;
+		 avago,ps_hysteresis_threshold = <300>;
+		 avago,ps_pulse = <8>;
+		 avago,ps_pgain = <0>;
+		 avago,als_B = <223>;
+		 avago,als_C = <70>;
+		 avago,als_D = <142>;
+		 avago,ga_value = <48>;
+	 };
+};
\ No newline at end of file
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index c316a69..105a224 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -619,6 +619,13 @@ config APQ8084_DOCKING_STATION
 	  This option enables support for the USB and Ethernet ports found on
 	  the QTI APQ8084 Docking Station.
 
+config AVAGO_APDS990X
+        tristate "Avago apds990x light/proximity sensor support"
+        depends on I2C=y
+        help
+          If you say yes here you get support for Avago
+          light/proximity sensors apds990x.
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 7c13a34..3b34a56 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -21,7 +21,7 @@ obj-$(CONFIG_TIFM_7XX1)       	+= tifm_7xx1.o
 obj-$(CONFIG_PHANTOM)		+= phantom.o
 obj-$(CONFIG_SENSORS_BH1780)	+= bh1780gli.o
 obj-$(CONFIG_SENSORS_BH1770)	+= bh1770glc.o
-obj-$(CONFIG_SENSORS_APDS990X)	+= apds990x.o
+obj-$(CONFIG_AVAGO_APDS990X)	+= apds990x.o
 obj-$(CONFIG_SGI_IOC4)		+= ioc4.o
 obj-$(CONFIG_ENCLOSURE_SERVICES) += enclosure.o
 obj-$(CONFIG_KGDB_TESTS)	+= kgdbts.o
diff --git a/drivers/misc/apds990x.c b/drivers/misc/apds990x.c
index 98f9bb2..3afdaff 100644
--- a/drivers/misc/apds990x.c
+++ b/drivers/misc/apds990x.c
@@ -2,7 +2,7 @@
  * This file is part of the APDS990x sensor driver.
  * Chip is combined proximity and ambient light sensor.
  *
- * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ * Copyright (C) 2010-2014 Nokia Corporation and/or its subsidiary(-ies).
  *
  * Contact: Samu Onkalo <samu.p.onkalo@nokia.com>
  *
@@ -22,1258 +22,2581 @@
  *
  */
 
-#include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
 #include <linux/i2c.h>
-#include <linux/interrupt.h>
 #include <linux/mutex.h>
-#include <linux/regulator/consumer.h>
-#include <linux/pm_runtime.h>
 #include <linux/delay.h>
-#include <linux/wait.h>
-#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/input.h>
+#include <linux/ioctl.h>
+#include <linux/miscdevice.h>
+#include <linux/uaccess.h>
 #include <linux/i2c/apds990x.h>
+#include <linux/regulator/consumer.h>
+#include <linux/of_gpio.h>
+#include <linux/sensors.h>
 
-/* Register map */
-#define APDS990X_ENABLE	 0x00 /* Enable of states and interrupts */
-#define APDS990X_ATIME	 0x01 /* ALS ADC time  */
-#define APDS990X_PTIME	 0x02 /* Proximity ADC time  */
-#define APDS990X_WTIME	 0x03 /* Wait time  */
-#define APDS990X_AILTL	 0x04 /* ALS interrupt low threshold low byte */
-#define APDS990X_AILTH	 0x05 /* ALS interrupt low threshold hi byte */
-#define APDS990X_AIHTL	 0x06 /* ALS interrupt hi threshold low byte */
-#define APDS990X_AIHTH	 0x07 /* ALS interrupt hi threshold hi byte */
-#define APDS990X_PILTL	 0x08 /* Proximity interrupt low threshold low byte */
-#define APDS990X_PILTH	 0x09 /* Proximity interrupt low threshold hi byte */
-#define APDS990X_PIHTL	 0x0a /* Proximity interrupt hi threshold low byte */
-#define APDS990X_PIHTH	 0x0b /* Proximity interrupt hi threshold hi byte */
-#define APDS990X_PERS	 0x0c /* Interrupt persistence filters */
-#define APDS990X_CONFIG	 0x0d /* Configuration */
-#define APDS990X_PPCOUNT 0x0e /* Proximity pulse count */
-#define APDS990X_CONTROL 0x0f /* Gain control register */
-#define APDS990X_REV	 0x11 /* Revision Number */
-#define APDS990X_ID	 0x12 /* Device ID */
-#define APDS990X_STATUS	 0x13 /* Device status */
-#define APDS990X_CDATAL	 0x14 /* Clear ADC low data register */
-#define APDS990X_CDATAH	 0x15 /* Clear ADC high data register */
-#define APDS990X_IRDATAL 0x16 /* IR ADC low data register */
-#define APDS990X_IRDATAH 0x17 /* IR ADC high data register */
-#define APDS990X_PDATAL	 0x18 /* Proximity ADC low data register */
-#define APDS990X_PDATAH	 0x19 /* Proximity ADC high data register */
-
-/* Control */
-#define APDS990X_MAX_AGAIN	3
-
-/* Enable register */
-#define APDS990X_EN_PIEN	(0x1 << 5)
-#define APDS990X_EN_AIEN	(0x1 << 4)
-#define APDS990X_EN_WEN		(0x1 << 3)
-#define APDS990X_EN_PEN		(0x1 << 2)
-#define APDS990X_EN_AEN		(0x1 << 1)
-#define APDS990X_EN_PON		(0x1 << 0)
-#define APDS990X_EN_DISABLE_ALL 0
-
-/* Status register */
-#define APDS990X_ST_PINT	(0x1 << 5)
-#define APDS990X_ST_AINT	(0x1 << 4)
-
-/* I2C access types */
-#define APDS990x_CMD_TYPE_MASK	(0x03 << 5)
-#define APDS990x_CMD_TYPE_RB	(0x00 << 5) /* Repeated byte */
-#define APDS990x_CMD_TYPE_INC	(0x01 << 5) /* Auto increment */
-#define APDS990x_CMD_TYPE_SPE	(0x03 << 5) /* Special function */
-
-#define APDS990x_ADDR_SHIFT	0
-#define APDS990x_CMD		0x80
-
-/* Interrupt ack commands */
-#define APDS990X_INT_ACK_ALS	0x6
-#define APDS990X_INT_ACK_PS	0x5
-#define APDS990X_INT_ACK_BOTH	0x7
-
-/* ptime */
-#define APDS990X_PTIME_DEFAULT	0xff /* Recommended conversion time 2.7ms*/
-
-/* wtime */
-#define APDS990X_WTIME_DEFAULT	0xee /* ~50ms wait time */
-
-#define APDS990X_TIME_TO_ADC	1024 /* One timetick as ADC count value */
-
-/* Persistence */
-#define APDS990X_APERS_SHIFT	0
-#define APDS990X_PPERS_SHIFT	4
-
-/* Supported ID:s */
-#define APDS990X_ID_0		0x0
-#define APDS990X_ID_4		0x4
-#define APDS990X_ID_29		0x29
-
-/* pgain and pdiode settings */
-#define APDS_PGAIN_1X	       0x0
-#define APDS_PDIODE_IR	       0x2
-
-#define APDS990X_LUX_OUTPUT_SCALE 10
-
-/* Reverse chip factors for threshold calculation */
-struct reverse_factors {
-	u32 afactor;
-	int cf1;
-	int irf1;
-	int cf2;
-	int irf2;
-};
+#define APDS990X_HAL_USE_SYS_ENABLE
 
-struct apds990x_chip {
-	struct apds990x_platform_data	*pdata;
-	struct i2c_client		*client;
-	struct mutex			mutex; /* avoid parallel access */
-	struct regulator_bulk_data	regs[2];
-	wait_queue_head_t		wait;
-
-	int	prox_en;
-	bool	prox_continuous_mode;
-	bool	lux_wait_fresh_res;
-
-	/* Chip parameters */
-	struct	apds990x_chip_factors	cf;
-	struct	reverse_factors		rcf;
-	u16	atime;		/* als integration time */
-	u16	arate;		/* als reporting rate */
-	u16	a_max_result;	/* Max possible ADC value with current atime */
-	u8	again_meas;	/* Gain used in last measurement */
-	u8	again_next;	/* Next calculated gain */
-	u8	pgain;
-	u8	pdiode;
-	u8	pdrive;
-	u8	lux_persistence;
-	u8	prox_persistence;
-
-	u32	lux_raw;
-	u32	lux;
-	u16	lux_clear;
-	u16	lux_ir;
-	u16	lux_calib;
-	u32	lux_thres_hi;
-	u32	lux_thres_lo;
-
-	u32	prox_thres;
-	u16	prox_data;
-	u16	prox_calib;
-
-	char	chipname[10];
-	u8	revision;
-};
+#define APDS990X_DRV_NAME	"apds990x"
+#define DRIVER_VERSION		"1.0.0"
 
-#define APDS_CALIB_SCALER		8192
-#define APDS_LUX_NEUTRAL_CALIB_VALUE	(1 * APDS_CALIB_SCALER)
-#define APDS_PROX_NEUTRAL_CALIB_VALUE	(1 * APDS_CALIB_SCALER)
+#define ALS_POLLING_ENABLED
 
-#define APDS_PROX_DEF_THRES		600
-#define APDS_PROX_HYSTERESIS		50
-#define APDS_LUX_DEF_THRES_HI		101
-#define APDS_LUX_DEF_THRES_LO		100
-#define APDS_DEFAULT_PROX_PERS		1
+#define APDS990X_PS_DETECTION_THRESHOLD		800
+#define APDS990X_PS_HSYTERESIS_THRESHOLD	700
+#define APDS990X_PS_PULSE_NUMBER		8
 
-#define APDS_TIMEOUT			2000
-#define APDS_STARTUP_DELAY		25000 /* us */
-#define APDS_RANGE			65535
-#define APDS_PROX_RANGE			1023
-#define APDS_LUX_GAIN_LO_LIMIT		100
-#define APDS_LUX_GAIN_LO_LIMIT_STRICT	25
+#define APDS990X_ALS_THRESHOLD_HSYTERESIS	20	/* % */
 
-#define TIMESTEP			87 /* 2.7ms is about 87 / 32 */
-#define TIME_STEP_SCALER		32
+#define APDS990X_GA	48	/* 0.48 without glass window */
+#define APDS990X_COE_B	223	/* 2.23 without glass window */
+#define APDS990X_COE_C	70	/* 0.70 without glass window */
+#define APDS990X_COE_D	142	/* 1.42 without glass window */
+#define APDS990X_DF	52
+#define ALS_MAX_RANGE	60000
+
+/* Change History
+ *
+ * 1.0.0	Fundamental Functions of APDS-993x
+ *
+ */
+#define APDS990X_IOCTL_PS_ENABLE	1
+#define APDS990X_IOCTL_PS_GET_ENABLE	2
+#define APDS990X_IOCTL_PS_GET_PDATA	3	/* pdata */
+#define APDS990X_IOCTL_ALS_ENABLE	4
+#define APDS990X_IOCTL_ALS_GET_ENABLE	5
+#define APDS990X_IOCTL_ALS_GET_CH0DATA	6	/* ch0data */
+#define APDS990X_IOCTL_ALS_GET_CH1DATA	7	/* ch1data */
+#define APDS990X_IOCTL_ALS_DELAY	8
+
+/*
+ * Defines
+ */
+#define	APDS9930_ID	0x30
+#define	APDS9931_ID	0x39
+#define	APDS9900_ID	0x29
+#define	APDS9901_ID	0x20
+
+#define APDS990X_ENABLE_REG	0x00
+#define APDS990X_ATIME_REG	0x01
+#define APDS990X_PTIME_REG	0x02
+#define APDS990X_WTIME_REG	0x03
+#define APDS990X_AILTL_REG	0x04
+#define APDS990X_AILTH_REG	0x05
+#define APDS990X_AIHTL_REG	0x06
+#define APDS990X_AIHTH_REG	0x07
+#define APDS990X_PILTL_REG	0x08
+#define APDS990X_PILTH_REG	0x09
+#define APDS990X_PIHTL_REG	0x0A
+#define APDS990X_PIHTH_REG	0x0B
+#define APDS990X_PERS_REG	0x0C
+#define APDS990X_CONFIG_REG	0x0D
+#define APDS990X_PPCOUNT_REG	0x0E
+#define APDS990X_CONTROL_REG	0x0F
+#define APDS990X_REV_REG	0x11
+#define APDS990X_ID_REG		0x12
+#define APDS990X_STATUS_REG	0x13
+#define APDS990X_CH0DATAL_REG	0x14
+#define APDS990X_CH0DATAH_REG	0x15
+#define APDS990X_CH1DATAL_REG	0x16
+#define APDS990X_CH1DATAH_REG	0x17
+#define APDS990X_PDATAL_REG	0x18
+#define APDS990X_PDATAH_REG	0x19
+
+#define CMD_BYTE		0x80
+#define CMD_WORD		0xA0
+#define CMD_SPECIAL		0xE0
+
+#define CMD_CLR_PS_INT		0xE5
+#define CMD_CLR_ALS_INT		0xE6
+#define CMD_CLR_PS_ALS_INT	0xE7
+
+
+/* Register Value define : ATIME */
+#define APDS990X_100MS_ADC_TIME	0xDB  /* 100.64ms integration time */
+#define APDS990X_50MS_ADC_TIME	0xED  /* 51.68ms integration time */
+#define APDS990X_27MS_ADC_TIME	0xF6  /* 27.2ms integration time */
+
+/* Register Value define : PRXCNFG */
+#define APDS990X_ALS_REDUCE	0x04  /* ALSREDUCE - ALS Gain reduced by 4x */
+
+/* Register Value define : PERS */
+#define APDS990X_PPERS_0	0x00  /* Every proximity ADC cycle */
+#define APDS990X_PPERS_1	0x10
+#define APDS990X_PPERS_2	0x20
+#define APDS990X_PPERS_3	0x30
+#define APDS990X_PPERS_4	0x40
+#define APDS990X_PPERS_5	0x50
+#define APDS990X_PPERS_6	0x60
+#define APDS990X_PPERS_7	0x70
+#define APDS990X_PPERS_8	0x80
+#define APDS990X_PPERS_9	0x90
+#define APDS990X_PPERS_10	0xA0
+#define APDS990X_PPERS_11	0xB0
+#define APDS990X_PPERS_12	0xC0
+#define APDS990X_PPERS_13	0xD0
+#define APDS990X_PPERS_14	0xE0
+#define APDS990X_PPERS_15	0xF0
+
+#define APDS990X_APERS_0	0x00  /* Every ADC cycle */
+#define APDS990X_APERS_1	0x01
+#define APDS990X_APERS_2	0x02
+#define APDS990X_APERS_3	0x03
+#define APDS990X_APERS_5	0x04
+#define APDS990X_APERS_10	0x05
+#define APDS990X_APERS_15	0x06
+#define APDS990X_APERS_20	0x07
+#define APDS990X_APERS_25	0x08
+#define APDS990X_APERS_30	0x09
+#define APDS990X_APERS_35	0x0A
+#define APDS990X_APERS_40	0x0B
+#define APDS990X_APERS_45	0x0C
+#define APDS990X_APERS_50	0x0D
+#define APDS990X_APERS_55	0x0E
+#define APDS990X_APERS_60	0x0F
+
+/* Register Value define : CONTROL */
+#define APDS990X_AGAIN_1X	0x00  /* 1X ALS GAIN */
+#define APDS990X_AGAIN_8X	0x01  /* 8X ALS GAIN */
+#define APDS990X_AGAIN_16X	0x02  /* 16X ALS GAIN */
+#define APDS990X_AGAIN_120X	0x03  /* 120X ALS GAIN */
+
+#define APDS990X_PRX_IR_DIOD	0x20  /* Proximity uses CH1 diode */
+
+#define APDS990X_PGAIN_1X	0x00  /* PS GAIN 1X */
+#define APDS990X_PGAIN_2X	0x04  /* PS GAIN 2X */
+#define APDS990X_PGAIN_4X	0x08  /* PS GAIN 4X */
+#define APDS990X_PGAIN_8X	0x0C  /* PS GAIN 8X */
+
+#define APDS990X_PDRVIE_100MA	0x00  /* PS 100mA LED drive */
+#define APDS990X_PDRVIE_50MA	0x40  /* PS 50mA LED drive */
+#define APDS990X_PDRVIE_25MA	0x80  /* PS 25mA LED drive */
+#define APDS990X_PDRVIE_12_5MA	0xC0  /* PS 12.5mA LED drive */
+
+/*calibration*/
+#define DEFAULT_CROSS_TALK	400
+#define ADD_TO_CROSS_TALK	300
+#define SUB_FROM_PS_THRESHOLD	100
+
+/*PS tuning value*/
+static int apds990x_ps_detection_threshold;
+static int apds990x_ps_hsyteresis_threshold;
+static int apds990x_ps_pulse_number;
+static int apds990x_ps_pgain;
+
+static int low;
+static int high;
+
+enum {
+	APDS990X_ALS_RES_10240 = 0,    /* 27.2ms integration time */
+	APDS990X_ALS_RES_19456 = 1,    /* 51.68ms integration time */
+	APDS990X_ALS_RES_37888 = 2     /* 100.64ms integration time */
+} apds990x_als_res_e;
+
+enum {
+	APDS990X_ALS_GAIN_1X    = 0,    /* 1x AGAIN */
+	APDS990X_ALS_GAIN_8X    = 1,    /* 8x AGAIN */
+	APDS990X_ALS_GAIN_16X   = 2,    /* 16x AGAIN */
+	APDS990X_ALS_GAIN_120X  = 3     /* 120x AGAIN */
+} apds990x_als_gain_e;
+
+struct apds990x_data {
+	struct i2c_client *client;
+	struct mutex update_lock;
+	struct delayed_work	dwork;		/* for PS interrupt */
+	struct delayed_work	als_dwork;	/* for ALS polling */
+	struct input_dev *input_dev_als;
+	struct input_dev *input_dev_ps;
+	struct regulator *vdd;
+	struct regulator *vio;
+	struct sensors_classdev als_cdev;
+	struct sensors_classdev ps_cdev;
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pin_default;
+	struct pinctrl_state *pin_sleep;
+
+	struct apds990x_platform_data *platform_data;
+	int irq;
+
+	unsigned int enable;
+	unsigned int atime;
+	unsigned int ptime;
+	unsigned int wtime;
+	unsigned int ailt;
+	unsigned int aiht;
+	unsigned int pilt;
+	unsigned int piht;
+	unsigned int pers;
+	unsigned int config;
+	unsigned int ppcount;
+	unsigned int control;
+
+	/* control flag from HAL */
+	unsigned int enable_ps_sensor;
+	unsigned int enable_als_sensor;
+
+	/* PS parameters */
+	unsigned int ps_threshold;
+	unsigned int ps_hysteresis_threshold;
+	unsigned int ps_detection;/* 5 = near-to-far; 0 = far-to-near */
+	unsigned int ps_data;			/* to store PS data */
+
+	/*calibration*/
+	unsigned int cross_talk;		/* cross_talk value */
+	unsigned int avg_cross_talk;		/* average cross_talk  */
+	unsigned int ps_cal_result;		/* result of calibration*/
+
+	/* ALS parameters */
+	unsigned int als_threshold_l;	/* low threshold */
+	unsigned int als_threshold_h;	/* high threshold */
+	unsigned int als_data;		/* to store ALS data */
+	int als_prev_lux;		/* to store previous lux value */
+
+	unsigned int als_gain;		/* needed for Lux calculation */
+	unsigned int als_poll_delay;
+	unsigned int als_atime_index;	/* storage for als integratiion time */
+	unsigned int als_again_index;	/* storage for als GAIN */
+	unsigned int als_reduce;	/* flag indicate ALS 6x reduction */
+};
 
-#define APDS_LUX_AVERAGING_TIME		50 /* tolerates 50/60Hz ripple */
-#define APDS_LUX_DEFAULT_RATE		200
+static struct sensors_classdev sensors_light_cdev = {
+	.name = "apds9900-light",
+	.vendor = "avago",
+	.version = 1,
+	.handle = SENSORS_LIGHT_HANDLE,
+	.type = SENSOR_TYPE_LIGHT,
+	.max_range = "60000",
+	.resolution = "0.0125",
+	.sensor_power = "0.20",
+	.min_delay = 0, /* in microseconds */
+	.fifo_reserved_event_count = 0,
+	.fifo_max_event_count = 0,
+	.enabled = 0,
+	.delay_msec = 100,
+	.sensors_enable = NULL,
+	.sensors_poll_delay = NULL,
+};
 
-static const u8 again[]	= {1, 8, 16, 120}; /* ALS gain steps */
-static const u8 ir_currents[]	= {100, 50, 25, 12}; /* IRled currents in mA */
+static struct sensors_classdev sensors_proximity_cdev = {
+	.name = "apds9900-proximity",
+	.vendor = "avago",
+	.version = 1,
+	.handle = SENSORS_PROXIMITY_HANDLE,
+	.type = SENSOR_TYPE_PROXIMITY,
+	.max_range = "5",
+	.resolution = "5.0",
+	.sensor_power = "3",
+	.min_delay = 0, /* in microseconds */
+	.fifo_reserved_event_count = 0,
+	.fifo_max_event_count = 0,
+	.enabled = 0,
+	.delay_msec = 100,
+	.sensors_enable = NULL,
+	.sensors_poll_delay = NULL,
+};
 
-/* Following two tables must match i.e 10Hz rate means 1 as persistence value */
-static const u16 arates_hz[] = {10, 5, 2, 1};
-static const u8 apersis[] = {1, 2, 4, 5};
+/*
+ * Global data
+ */
+static struct apds990x_data *pdev_data;
+
+/* global i2c_client to support ioctl */
+static struct i2c_client *apds990x_i2c_client;
+static struct workqueue_struct *apds990x_workqueue;
+
+static unsigned char apds990x_als_atime_tb[] = { 0xF6, 0xED, 0xDB };
+static unsigned short apds990x_als_integration_tb[] = {2720, 5168, 10064};
+static unsigned short apds990x_als_res_tb[] = { 10240, 19456, 37888 };
+static unsigned char apds990x_als_again_tb[] = { 1, 8, 16, 120 };
+static unsigned char apds990x_als_again_bit_tb[] = { 0x00, 0x01, 0x02, 0x03 };
+
+/*calibration*/
+static int apds990x_cross_talk_val;
+
+/* ALS tuning */
+static int apds990x_ga;
+static int apds990x_coe_b;
+static int apds990x_coe_c;
+static int apds990x_coe_d;
+
+#ifdef ALS_POLLING_ENABLED
+static int apds990x_set_als_poll_delay(struct i2c_client *client,
+unsigned int val);
+#endif
 
-/* Regulators */
-static const char reg_vcc[] = "Vdd";
-static const char reg_vled[] = "Vled";
+static int sensor_regulator_power_on(struct apds990x_data *data, bool on);
 
-static int apds990x_read_byte(struct apds990x_chip *chip, u8 reg, u8 *data)
+/*
+ * Management functions
+ */
+static int apds990x_set_command(struct i2c_client *client, int command)
 {
-	struct i2c_client *client = chip->client;
-	s32 ret;
+	struct apds990x_data *data = i2c_get_clientdata(client);
+	int ret;
+	int clearInt;
 
-	reg &= ~APDS990x_CMD_TYPE_MASK;
-	reg |= APDS990x_CMD | APDS990x_CMD_TYPE_RB;
+	if (command == 0)
+		clearInt = CMD_CLR_PS_INT;
+	else if (command == 1)
+		clearInt = CMD_CLR_ALS_INT;
+	else
+		clearInt = CMD_CLR_PS_ALS_INT;
+
+	mutex_lock(&data->update_lock);
+	ret = i2c_smbus_write_byte(client, clearInt);
+	mutex_unlock(&data->update_lock);
 
-	ret = i2c_smbus_read_byte_data(client, reg);
-	*data = ret;
-	return (int)ret;
+	return ret;
 }
 
-static int apds990x_read_word(struct apds990x_chip *chip, u8 reg, u16 *data)
+static int apds990x_set_enable(struct i2c_client *client, int enable)
 {
-	struct i2c_client *client = chip->client;
-	s32 ret;
+	struct apds990x_data *data = i2c_get_clientdata(client);
+	int ret;
 
-	reg &= ~APDS990x_CMD_TYPE_MASK;
-	reg |= APDS990x_CMD | APDS990x_CMD_TYPE_INC;
+	mutex_lock(&data->update_lock);
+	ret = i2c_smbus_write_byte_data(client,
+			CMD_BYTE|APDS990X_ENABLE_REG, enable);
+	mutex_unlock(&data->update_lock);
 
-	ret = i2c_smbus_read_word_data(client, reg);
-	*data = ret;
-	return (int)ret;
+	data->enable = enable;
+
+	return ret;
 }
 
-static int apds990x_write_byte(struct apds990x_chip *chip, u8 reg, u8 data)
+static int apds990x_set_atime(struct i2c_client *client, int atime)
 {
-	struct i2c_client *client = chip->client;
-	s32 ret;
+	struct apds990x_data *data = i2c_get_clientdata(client);
+	int ret;
+
+	mutex_lock(&data->update_lock);
+	ret = i2c_smbus_write_byte_data(client,
+			CMD_BYTE|APDS990X_ATIME_REG, atime);
+	mutex_unlock(&data->update_lock);
 
-	reg &= ~APDS990x_CMD_TYPE_MASK;
-	reg |= APDS990x_CMD | APDS990x_CMD_TYPE_RB;
+	data->atime = atime;
 
-	ret = i2c_smbus_write_byte_data(client, reg, data);
-	return (int)ret;
+	return ret;
 }
 
-static int apds990x_write_word(struct apds990x_chip *chip, u8 reg, u16 data)
+static int apds990x_set_ptime(struct i2c_client *client, int ptime)
 {
-	struct i2c_client *client = chip->client;
-	s32 ret;
+	struct apds990x_data *data = i2c_get_clientdata(client);
+	int ret;
 
-	reg &= ~APDS990x_CMD_TYPE_MASK;
-	reg |= APDS990x_CMD | APDS990x_CMD_TYPE_INC;
+	mutex_lock(&data->update_lock);
+	ret = i2c_smbus_write_byte_data(client,
+			CMD_BYTE|APDS990X_PTIME_REG, ptime);
+	mutex_unlock(&data->update_lock);
 
-	ret = i2c_smbus_write_word_data(client, reg, data);
-	return (int)ret;
+	data->ptime = ptime;
+
+	return ret;
 }
 
-static int apds990x_mode_on(struct apds990x_chip *chip)
+static int apds990x_set_wtime(struct i2c_client *client, int wtime)
 {
-	/* ALS is mandatory, proximity optional */
-	u8 reg = APDS990X_EN_AIEN | APDS990X_EN_PON | APDS990X_EN_AEN |
-		APDS990X_EN_WEN;
+	struct apds990x_data *data = i2c_get_clientdata(client);
+	int ret;
+
+	mutex_lock(&data->update_lock);
+	ret = i2c_smbus_write_byte_data(client,
+			CMD_BYTE|APDS990X_WTIME_REG, wtime);
+	mutex_unlock(&data->update_lock);
 
-	if (chip->prox_en)
-		reg |= APDS990X_EN_PIEN | APDS990X_EN_PEN;
+	data->wtime = wtime;
 
-	return apds990x_write_byte(chip, APDS990X_ENABLE, reg);
+	return ret;
 }
 
-static u16 apds990x_lux_to_threshold(struct apds990x_chip *chip, u32 lux)
+static int apds990x_set_ailt(struct i2c_client *client, int threshold)
 {
-	u32 thres;
-	u32 cpl;
-	u32 ir;
+	struct apds990x_data *data = i2c_get_clientdata(client);
+	int ret;
 
-	if (lux == 0)
-		return 0;
-	else if (lux == APDS_RANGE)
-		return APDS_RANGE;
+	mutex_lock(&data->update_lock);
+	ret = i2c_smbus_write_word_data(client,
+			CMD_WORD|APDS990X_AILTL_REG, threshold);
+	mutex_unlock(&data->update_lock);
 
-	/*
-	 * Reported LUX value is a combination of the IR and CLEAR channel
-	 * values. However, interrupt threshold is only for clear channel.
-	 * This function approximates needed HW threshold value for a given
-	 * LUX value in the current lightning type.
-	 * IR level compared to visible light varies heavily depending on the
-	 * source of the light
-	 *
-	 * Calculate threshold value for the next measurement period.
-	 * Math: threshold = lux * cpl where
-	 * cpl = atime * again / (glass_attenuation * device_factor)
-	 * (count-per-lux)
-	 *
-	 * First remove calibration. Division by four is to avoid overflow
-	 */
-	lux = lux * (APDS_CALIB_SCALER / 4) / (chip->lux_calib / 4);
+	data->ailt = threshold;
 
-	/* Multiplication by 64 is to increase accuracy */
-	cpl = ((u32)chip->atime * (u32)again[chip->again_next] *
-		APDS_PARAM_SCALE * 64) / (chip->cf.ga * chip->cf.df);
+	return ret;
+}
 
-	thres = lux * cpl / 64;
-	/*
-	 * Convert IR light from the latest result to match with
-	 * new gain step. This helps to adapt with the current
-	 * source of light.
-	 */
-	ir = (u32)chip->lux_ir * (u32)again[chip->again_next] /
-		(u32)again[chip->again_meas];
+static int apds990x_set_aiht(struct i2c_client *client, int threshold)
+{
+	struct apds990x_data *data = i2c_get_clientdata(client);
+	int ret;
 
-	/*
-	 * Compensate count with IR light impact
-	 * IAC1 > IAC2 (see apds990x_get_lux for formulas)
-	 */
-	if (chip->lux_clear * APDS_PARAM_SCALE >=
-		chip->rcf.afactor * chip->lux_ir)
-		thres = (chip->rcf.cf1 * thres + chip->rcf.irf1 * ir) /
-			APDS_PARAM_SCALE;
-	else
-		thres = (chip->rcf.cf2 * thres + chip->rcf.irf2 * ir) /
-			APDS_PARAM_SCALE;
+	mutex_lock(&data->update_lock);
+	ret = i2c_smbus_write_word_data(client,
+			CMD_WORD|APDS990X_AIHTL_REG, threshold);
+	mutex_unlock(&data->update_lock);
+
+	data->aiht = threshold;
 
-	if (thres >= chip->a_max_result)
-		thres = chip->a_max_result - 1;
-	return thres;
+	return ret;
 }
 
-static inline int apds990x_set_atime(struct apds990x_chip *chip, u32 time_ms)
+static int apds990x_set_pilt(struct i2c_client *client, int threshold)
 {
-	u8 reg_value;
+	struct apds990x_data *data = i2c_get_clientdata(client);
+	int ret;
+
+	mutex_lock(&data->update_lock);
+	ret = i2c_smbus_write_word_data(client,
+			CMD_WORD|APDS990X_PILTL_REG, threshold);
+	mutex_unlock(&data->update_lock);
+
+	data->pilt = threshold;
 
-	chip->atime = time_ms;
-	/* Formula is specified in the data sheet */
-	reg_value = 256 - ((time_ms * TIME_STEP_SCALER) / TIMESTEP);
-	/* Calculate max ADC value for given integration time */
-	chip->a_max_result = (u16)(256 - reg_value) * APDS990X_TIME_TO_ADC;
-	return apds990x_write_byte(chip, APDS990X_ATIME, reg_value);
+	return ret;
 }
 
-/* Called always with mutex locked */
-static int apds990x_refresh_pthres(struct apds990x_chip *chip, int data)
+static int apds990x_set_piht(struct i2c_client *client, int threshold)
 {
-	int ret, lo, hi;
+	struct apds990x_data *data = i2c_get_clientdata(client);
+	int ret;
 
-	/* If the chip is not in use, don't try to access it */
-	if (pm_runtime_suspended(&chip->client->dev))
-		return 0;
+	mutex_lock(&data->update_lock);
+	ret = i2c_smbus_write_word_data(client,
+			CMD_WORD|APDS990X_PIHTL_REG, threshold);
+	mutex_unlock(&data->update_lock);
 
-	if (data < chip->prox_thres) {
-		lo = 0;
-		hi = chip->prox_thres;
-	} else {
-		lo = chip->prox_thres - APDS_PROX_HYSTERESIS;
-		if (chip->prox_continuous_mode)
-			hi = chip->prox_thres;
-		else
-			hi = APDS_RANGE;
-	}
+	data->piht = threshold;
 
-	ret = apds990x_write_word(chip, APDS990X_PILTL, lo);
-	ret |= apds990x_write_word(chip, APDS990X_PIHTL, hi);
 	return ret;
 }
 
-/* Called always with mutex locked */
-static int apds990x_refresh_athres(struct apds990x_chip *chip)
+static int apds990x_set_pers(struct i2c_client *client, int pers)
 {
+	struct apds990x_data *data = i2c_get_clientdata(client);
 	int ret;
-	/* If the chip is not in use, don't try to access it */
-	if (pm_runtime_suspended(&chip->client->dev))
-		return 0;
 
-	ret = apds990x_write_word(chip, APDS990X_AILTL,
-			apds990x_lux_to_threshold(chip, chip->lux_thres_lo));
-	ret |= apds990x_write_word(chip, APDS990X_AIHTL,
-			apds990x_lux_to_threshold(chip, chip->lux_thres_hi));
+	mutex_lock(&data->update_lock);
+	ret = i2c_smbus_write_byte_data(client,
+			CMD_BYTE|APDS990X_PERS_REG, pers);
+	mutex_unlock(&data->update_lock);
+
+	data->pers = pers;
 
 	return ret;
 }
 
-/* Called always with mutex locked */
-static void apds990x_force_a_refresh(struct apds990x_chip *chip)
+static int apds990x_set_config(struct i2c_client *client, int config)
 {
-	/* This will force ALS interrupt after the next measurement. */
-	apds990x_write_word(chip, APDS990X_AILTL, APDS_LUX_DEF_THRES_LO);
-	apds990x_write_word(chip, APDS990X_AIHTL, APDS_LUX_DEF_THRES_HI);
-}
+	struct apds990x_data *data = i2c_get_clientdata(client);
+	int ret;
 
-/* Called always with mutex locked */
-static void apds990x_force_p_refresh(struct apds990x_chip *chip)
-{
-	/* This will force proximity interrupt after the next measurement. */
-	apds990x_write_word(chip, APDS990X_PILTL, APDS_PROX_DEF_THRES - 1);
-	apds990x_write_word(chip, APDS990X_PIHTL, APDS_PROX_DEF_THRES);
+	mutex_lock(&data->update_lock);
+	ret = i2c_smbus_write_byte_data(client,
+			CMD_BYTE|APDS990X_CONFIG_REG, config);
+	mutex_unlock(&data->update_lock);
+
+	data->config = config;
+
+	return ret;
 }
 
-/* Called always with mutex locked */
-static int apds990x_calc_again(struct apds990x_chip *chip)
+static int apds990x_set_ppcount(struct i2c_client *client, int ppcount)
 {
-	int curr_again = chip->again_meas;
-	int next_again = chip->again_meas;
-	int ret = 0;
-
-	/* Calculate suitable als gain */
-	if (chip->lux_clear == chip->a_max_result)
-		next_again -= 2; /* ALS saturated. Decrease gain by 2 steps */
-	else if (chip->lux_clear > chip->a_max_result / 2)
-		next_again--;
-	else if (chip->lux_clear < APDS_LUX_GAIN_LO_LIMIT_STRICT)
-		next_again += 2; /* Too dark. Increase gain by 2 steps */
-	else if (chip->lux_clear < APDS_LUX_GAIN_LO_LIMIT)
-		next_again++;
-
-	/* Limit gain to available range */
-	if (next_again < 0)
-		next_again = 0;
-	else if (next_again > APDS990X_MAX_AGAIN)
-		next_again = APDS990X_MAX_AGAIN;
-
-	/* Let's check can we trust the measured result */
-	if (chip->lux_clear == chip->a_max_result)
-		/* Result can be totally garbage due to saturation */
-		ret = -ERANGE;
-	else if (next_again != curr_again &&
-		chip->lux_clear < APDS_LUX_GAIN_LO_LIMIT_STRICT)
-		/*
-		 * Gain is changed and measurement result is very small.
-		 * Result can be totally garbage due to underflow
-		 */
-		ret = -ERANGE;
+	struct apds990x_data *data = i2c_get_clientdata(client);
+	int ret;
 
-	chip->again_next = next_again;
-	apds990x_write_byte(chip, APDS990X_CONTROL,
-			(chip->pdrive << 6) |
-			(chip->pdiode << 4) |
-			(chip->pgain << 2) |
-			(chip->again_next << 0));
+	mutex_lock(&data->update_lock);
+	ret = i2c_smbus_write_byte_data(client,
+			CMD_BYTE|APDS990X_PPCOUNT_REG, ppcount);
+	mutex_unlock(&data->update_lock);
 
-	/*
-	 * Error means bad result -> re-measurement is needed. The forced
-	 * refresh uses fastest possible persistence setting to get result
-	 * as soon as possible.
-	 */
-	if (ret < 0)
-		apds990x_force_a_refresh(chip);
-	else
-		apds990x_refresh_athres(chip);
+	data->ppcount = ppcount;
 
 	return ret;
 }
 
-/* Called always with mutex locked */
-static int apds990x_get_lux(struct apds990x_chip *chip, int clear, int ir)
+static int apds990x_set_control(struct i2c_client *client, int control)
 {
-	int iac, iac1, iac2; /* IR adjusted counts */
-	u32 lpc; /* Lux per count */
-
-	/* Formulas:
-	 * iac1 = CF1 * CLEAR_CH - IRF1 * IR_CH
-	 * iac2 = CF2 * CLEAR_CH - IRF2 * IR_CH
-	 */
-	iac1 = (chip->cf.cf1 * clear - chip->cf.irf1 * ir) / APDS_PARAM_SCALE;
-	iac2 = (chip->cf.cf2 * clear - chip->cf.irf2 * ir) / APDS_PARAM_SCALE;
+	struct apds990x_data *data = i2c_get_clientdata(client);
+	int ret;
 
-	iac = max(iac1, iac2);
-	iac = max(iac, 0);
+	mutex_lock(&data->update_lock);
+	ret = i2c_smbus_write_byte_data(client,
+			CMD_BYTE|APDS990X_CONTROL_REG, control);
+	mutex_unlock(&data->update_lock);
 
-	lpc = APDS990X_LUX_OUTPUT_SCALE * (chip->cf.df * chip->cf.ga) /
-		(u32)(again[chip->again_meas] * (u32)chip->atime);
+	data->control = control;
 
-	return (iac * lpc) / APDS_PARAM_SCALE;
+	return ret;
 }
 
-static int apds990x_ack_int(struct apds990x_chip *chip, u8 mode)
+/*calibration*/
+void apds990x_swap(int *x, int *y)
 {
-	struct i2c_client *client = chip->client;
-	s32 ret;
-	u8 reg = APDS990x_CMD | APDS990x_CMD_TYPE_SPE;
-
-	switch (mode & (APDS990X_ST_AINT | APDS990X_ST_PINT)) {
-	case APDS990X_ST_AINT:
-		reg |= APDS990X_INT_ACK_ALS;
-		break;
-	case APDS990X_ST_PINT:
-		reg |= APDS990X_INT_ACK_PS;
-		break;
-	default:
-		reg |= APDS990X_INT_ACK_BOTH;
-		break;
-	}
-
-	ret = i2c_smbus_read_byte_data(client, reg);
-	return (int)ret;
+	int temp = *x;
+	*x = *y;
+	*y = temp;
 }
 
-static irqreturn_t apds990x_irq(int irq, void *data)
+static int apds990x_run_cross_talk_calibration(struct i2c_client *client)
 {
-	struct apds990x_chip *chip = data;
-	u8 status;
+	struct apds990x_data *data = i2c_get_clientdata(client);
+	unsigned int sum_of_pdata = 0;
+	unsigned int temp_pdata[20];
+	unsigned int ArySize = 20;
+	unsigned int cal_check_flag = 0;
+	int i, j;
+#if defined(APDS993x_SENSOR_DEBUG)
+	int status;
+	int rdata;
+#endif
+	pr_info("%s: START proximity sensor calibration\n", __func__);
 
-	apds990x_read_byte(chip, APDS990X_STATUS, &status);
-	apds990x_ack_int(chip, status);
+RECALIBRATION:
+	apds990x_set_enable(client, 0x0D);/* Enable PS and Wait */
 
-	mutex_lock(&chip->mutex);
-	if (!pm_runtime_suspended(&chip->client->dev)) {
-		if (status & APDS990X_ST_AINT) {
-			apds990x_read_word(chip, APDS990X_CDATAL,
-					&chip->lux_clear);
-			apds990x_read_word(chip, APDS990X_IRDATAL,
-					&chip->lux_ir);
-			/* Store used gain for calculations */
-			chip->again_meas = chip->again_next;
+#if defined(APDS993x_SENSOR_DEBUG)
+	mutex_lock(&data->update_lock);
+	status = i2c_smbus_read_byte_data(client, CMD_BYTE|APDS990X_STATUS_REG);
+	rdata = i2c_smbus_read_byte_data(client, CMD_BYTE|APDS990X_ENABLE_REG);
+	mutex_unlock(&data->update_lock);
 
-			chip->lux_raw = apds990x_get_lux(chip,
-							chip->lux_clear,
-							chip->lux_ir);
+	pr_info("%s: APDS993x_ENABLE_REG=%2d APDS993x_STATUS_REG=%2d\n",
+			__func__, rdata, status);
+#endif
 
-			if (apds990x_calc_again(chip) == 0) {
-				/* Result is valid */
-				chip->lux = chip->lux_raw;
-				chip->lux_wait_fresh_res = false;
-				wake_up(&chip->wait);
-				sysfs_notify(&chip->client->dev.kobj,
-					NULL, "lux0_input");
-			}
-		}
+	for (i = 0; i < 20; i++) {
+		msleep(20);/* mdelay(6); */
+		mutex_lock(&data->update_lock);
+		temp_pdata[i] = i2c_smbus_read_word_data(client,
+				CMD_WORD|APDS990X_PDATAL_REG);
+		mutex_unlock(&data->update_lock);
+	}
 
-		if ((status & APDS990X_ST_PINT) && chip->prox_en) {
-			u16 clr_ch;
+	/* pdata sorting */
+	for (i = 0; i < ArySize - 1; i++)
+		for (j = i+1; j < ArySize; j++)
+			if (temp_pdata[i] > temp_pdata[j])
+				apds990x_swap(temp_pdata + i, temp_pdata + j);
 
-			apds990x_read_word(chip, APDS990X_CDATAL, &clr_ch);
-			/*
-			 * If ALS channel is saturated at min gain,
-			 * proximity gives false posivite values.
-			 * Just ignore them.
-			 */
-			if (chip->again_meas == 0 &&
-				clr_ch == chip->a_max_result)
-				chip->prox_data = 0;
-			else
-				apds990x_read_word(chip,
-						APDS990X_PDATAL,
-						&chip->prox_data);
-
-			apds990x_refresh_pthres(chip, chip->prox_data);
-			if (chip->prox_data < chip->prox_thres)
-				chip->prox_data = 0;
-			else if (!chip->prox_continuous_mode)
-				chip->prox_data = APDS_PROX_RANGE;
-			sysfs_notify(&chip->client->dev.kobj,
-				NULL, "prox0_raw");
-		}
+	/* calculate the cross-talk using central 10 data */
+	for (i = 5; i < 15; i++) {
+		pr_info("%s: temp_pdata = %d\n", __func__, temp_pdata[i]);
+		sum_of_pdata = sum_of_pdata + temp_pdata[i];
 	}
-	mutex_unlock(&chip->mutex);
-	return IRQ_HANDLED;
-}
 
-static int apds990x_configure(struct apds990x_chip *chip)
-{
-	/* It is recommended to use disabled mode during these operations */
-	apds990x_write_byte(chip, APDS990X_ENABLE, APDS990X_EN_DISABLE_ALL);
+	data->cross_talk = sum_of_pdata/10;
+	pr_info("%s: sum_of_pdata = %d   cross_talk = %d\n",
+			__func__, sum_of_pdata, data->cross_talk);
 
-	/* conversion and wait times for different state machince states */
-	apds990x_write_byte(chip, APDS990X_PTIME, APDS990X_PTIME_DEFAULT);
-	apds990x_write_byte(chip, APDS990X_WTIME, APDS990X_WTIME_DEFAULT);
-	apds990x_set_atime(chip, APDS_LUX_AVERAGING_TIME);
+	/*
+	 * this value is used at Hidden Menu to check
+	 * if the calibration is pass or fail
+	 */
+	data->avg_cross_talk = data->cross_talk;
+
+	if (data->cross_talk > 720) {
+		pr_warn("%s: invalid calibrated data\n", __func__);
+
+		if (cal_check_flag == 0) {
+			pr_info("%s: RECALIBRATION start\n", __func__);
+			cal_check_flag = 1;
+			goto RECALIBRATION;
+		} else {
+			pr_err("%s: CALIBRATION FAIL -> cross_talk is set to DEFAULT\n",
+				__func__);
+			data->cross_talk = DEFAULT_CROSS_TALK;
+			apds990x_set_enable(client, 0x00); /* Power Off */
+			data->ps_cal_result = 0; /* 0:Fail, 1:Pass */
+			return -EINVAL;
+		}
+	}
 
-	apds990x_write_byte(chip, APDS990X_CONFIG, 0);
+	data->ps_threshold = ADD_TO_CROSS_TALK + data->cross_talk;
+	data->ps_hysteresis_threshold =
+		data->ps_threshold - SUB_FROM_PS_THRESHOLD;
 
-	/* Persistence levels */
-	apds990x_write_byte(chip, APDS990X_PERS,
-			(chip->lux_persistence << APDS990X_APERS_SHIFT) |
-			(chip->prox_persistence << APDS990X_PPERS_SHIFT));
+	apds990x_set_enable(client, 0x00); /* Power Off */
+	data->ps_cal_result = 1;
 
-	apds990x_write_byte(chip, APDS990X_PPCOUNT, chip->pdata->ppcount);
+	pr_info("%s: total_pdata = %d & cross_talk = %d\n",
+			__func__, sum_of_pdata, data->cross_talk);
+	pr_info("%s: FINISH proximity sensor calibration\n", __func__);
 
-	/* Start with relatively small gain */
-	chip->again_meas = 1;
-	chip->again_next = 1;
-	apds990x_write_byte(chip, APDS990X_CONTROL,
-			(chip->pdrive << 6) |
-			(chip->pdiode << 4) |
-			(chip->pgain << 2) |
-			(chip->again_next << 0));
-	return 0;
+	/* Save the cross-talk to the non-volitile memory in the phone  */
+	return data->cross_talk;
 }
 
-static int apds990x_detect(struct apds990x_chip *chip)
+/* apply the Cross-talk value to threshold */
+static void apds990x_set_ps_threshold_adding_cross_talk(
+		struct i2c_client *client, int cal_data)
 {
-	struct i2c_client *client = chip->client;
-	int ret;
-	u8 id;
-
-	ret = apds990x_read_byte(chip, APDS990X_ID, &id);
-	if (ret < 0) {
-		dev_err(&client->dev, "ID read failed\n");
-		return ret;
-	}
+	struct apds990x_data *data = i2c_get_clientdata(client);
 
-	ret = apds990x_read_byte(chip, APDS990X_REV, &chip->revision);
-	if (ret < 0) {
-		dev_err(&client->dev, "REV read failed\n");
-		return ret;
-	}
+	if (cal_data > 770)
+		cal_data = 770;
+	if (cal_data < 0)
+		cal_data = 0;
 
-	switch (id) {
-	case APDS990X_ID_0:
-	case APDS990X_ID_4:
-	case APDS990X_ID_29:
-		snprintf(chip->chipname, sizeof(chip->chipname), "APDS-990x");
-		break;
-	default:
-		ret = -ENODEV;
-		break;
+	if (cal_data == 0) {
+		data->ps_threshold = apds990x_ps_detection_threshold;
+		data->ps_hysteresis_threshold =
+			data->ps_threshold - SUB_FROM_PS_THRESHOLD;
+	} else {
+		data->cross_talk = cal_data;
+		data->ps_threshold = ADD_TO_CROSS_TALK + data->cross_talk;
+		data->ps_hysteresis_threshold =
+			data->ps_threshold - SUB_FROM_PS_THRESHOLD;
 	}
-	return ret;
+	pr_info("%s: configurations are set\n", __func__);
 }
 
-#if defined(CONFIG_PM) || defined(CONFIG_PM_RUNTIME)
-static int apds990x_chip_on(struct apds990x_chip *chip)
+static int LuxCalculation(struct i2c_client *client, int ch0data, int ch1data)
 {
-	int err	 = regulator_bulk_enable(ARRAY_SIZE(chip->regs),
-					chip->regs);
-	if (err < 0)
-		return err;
+	struct apds990x_data *data = i2c_get_clientdata(client);
+	int luxValue = 0;
+	int IAC1 = 0;
+	int IAC2 = 0;
+	int IAC = 0;
+
+	if (ch0data >= apds990x_als_res_tb[data->als_atime_index] ||
+	    ch1data >= apds990x_als_res_tb[data->als_atime_index]) {
+		luxValue = data->als_prev_lux;
+		return luxValue;
+	}
 
-	usleep_range(APDS_STARTUP_DELAY, 2 * APDS_STARTUP_DELAY);
+	/* re-adjust COE_B to avoid 2 decimal point */
+	IAC1 = (ch0data - (apds990x_coe_b * ch1data) / 100);
+	/* re-adjust COE_C and COE_D to void 2 decimal point */
+	IAC2 = ((apds990x_coe_c * ch0data) / 100 -
+			(apds990x_coe_d * ch1data) / 100);
 
-	/* Refresh all configs in case of regulators were off */
-	chip->prox_data = 0;
-	apds990x_configure(chip);
-	apds990x_mode_on(chip);
-	return 0;
+	if (IAC1 > IAC2)
+		IAC = IAC1;
+	else if (IAC1 <= IAC2)
+		IAC = IAC2;
+	else
+		IAC = 0;
+
+	if (IAC1 < 0 && IAC2 < 0) {
+		IAC = 0;/* cdata and irdata saturated */
+		return 0;/* don't report first, change gain may help */
+	}
+
+	if (data->als_reduce) {
+		luxValue = ((IAC * apds990x_ga * APDS990X_DF) / 100) * 65 / 10 /
+			((apds990x_als_integration_tb[data->als_atime_index] /
+			  100) * apds990x_als_again_tb[data->als_again_index]);
+	} else {
+		luxValue = ((IAC * apds990x_ga * APDS990X_DF) / 100) /
+			((apds990x_als_integration_tb[data->als_atime_index] /
+			  100) * apds990x_als_again_tb[data->als_again_index]);
+	}
+
+	return luxValue;
 }
-#endif
 
-static int apds990x_chip_off(struct apds990x_chip *chip)
+static void apds990x_change_ps_threshold(struct i2c_client *client)
 {
-	apds990x_write_byte(chip, APDS990X_ENABLE, APDS990X_EN_DISABLE_ALL);
-	regulator_bulk_disable(ARRAY_SIZE(chip->regs), chip->regs);
-	return 0;
+	struct apds990x_data *data = i2c_get_clientdata(client);
+
+	data->ps_data =	i2c_smbus_read_word_data(
+			client, CMD_WORD|APDS990X_PDATAL_REG);
+	if (data->ps_data > high) {
+		/* far-to-near detected */
+		data->ps_detection = 1;
+
+		/* FAR-to-NEAR detection */
+		input_report_abs(data->input_dev_ps, ABS_DISTANCE, 0);
+		input_sync(data->input_dev_ps);
+		pr_info("------kaishi ps_high_ADC = %d", data->ps_data);
+		i2c_smbus_write_word_data(client,
+				CMD_WORD|APDS990X_PILTL_REG,
+				data->ps_hysteresis_threshold);
+		i2c_smbus_write_word_data(client,
+				CMD_WORD|APDS990X_PIHTL_REG, 1023);
+
+		pr_info("=====%s: far-to-near\n", __func__);
+	} else if (data->ps_data < low) {
+		/* near-to-far detected */
+		data->ps_detection = 0;
+
+		/* NEAR-to-FAR detection */
+		input_report_abs(data->input_dev_ps, ABS_DISTANCE, 1);
+		input_sync(data->input_dev_ps);
+		pr_info("kaishi ps_low_ADC = %d", data->ps_data);
+		i2c_smbus_write_word_data(client,
+				CMD_WORD|APDS990X_PILTL_REG, 0);
+		i2c_smbus_write_word_data(client,
+				CMD_WORD|APDS990X_PIHTL_REG,
+				data->ps_threshold);
+
+		pr_info("%s: near-to-far\n", __func__);
+	}
 }
 
-static ssize_t apds990x_lux_show(struct device *dev,
-				 struct device_attribute *attr, char *buf)
+static void apds990x_change_als_threshold(struct i2c_client *client)
 {
-	struct apds990x_chip *chip = dev_get_drvdata(dev);
-	ssize_t ret;
-	u32 result;
-	long timeout;
+	struct apds990x_data *data = i2c_get_clientdata(client);
+	int ch0data, ch1data, v;
+	int luxValue = 0;
+	int err;
+	unsigned char change_again = 0;
+	unsigned char control_data = 0;
+	unsigned char lux_is_valid = 1;
 
-	if (pm_runtime_suspended(dev))
-		return -EIO;
+	ch0data = i2c_smbus_read_word_data(client,
+			CMD_WORD|APDS990X_CH0DATAL_REG);
+	ch1data = i2c_smbus_read_word_data(client,
+			CMD_WORD|APDS990X_CH1DATAL_REG);
 
-	timeout = wait_event_interruptible_timeout(chip->wait,
-						!chip->lux_wait_fresh_res,
-						msecs_to_jiffies(APDS_TIMEOUT));
-	if (!timeout)
-		return -EIO;
+	luxValue = LuxCalculation(client, ch0data, ch1data);
 
-	mutex_lock(&chip->mutex);
-	result = (chip->lux * chip->lux_calib) / APDS_CALIB_SCALER;
-	if (result > (APDS_RANGE * APDS990X_LUX_OUTPUT_SCALE))
-		result = APDS_RANGE * APDS990X_LUX_OUTPUT_SCALE;
+	if (luxValue >= 0) {
+		luxValue = (luxValue < ALS_MAX_RANGE)
+					? luxValue : ALS_MAX_RANGE;
+		data->als_prev_lux = luxValue;
+	} else {
+		/* don't report, the lux is invalid value */
+		lux_is_valid = 0;
+		luxValue = data->als_prev_lux;
+		if (data->als_reduce)
+			lux_is_valid = 1;
+			/* report anyway since this is the lowest gain */
+	}
 
-	ret = sprintf(buf, "%d.%d\n",
-		result / APDS990X_LUX_OUTPUT_SCALE,
-		result % APDS990X_LUX_OUTPUT_SCALE);
-	mutex_unlock(&chip->mutex);
-	return ret;
-}
+	/*
+	pr_info("%s: lux=%d ch0data=%d ch1data=%d again=%d als_reduce=%d\n",
+			__func__,
+			luxValue, ch0data, ch1data,
+			apds990x_als_again_tb[data->als_again_index],
+			data->als_reduce);
+	*/
 
-static DEVICE_ATTR(lux0_input, S_IRUGO, apds990x_lux_show, NULL);
+	/*
+	 *  check PS under sunlight
+	 * PS was previously in far-to-near condition
+	 */
+	v = 1024 * (256 - apds990x_als_atime_tb[data->als_atime_index]);
+	v = (v * 75) / 100;
+	if ((data->ps_detection == 1) && (ch0data > v)) {
+		/*
+		 * need to inform input event as there will be no interrupt
+		 * from the PS
+		 */
+		/* NEAR-to-FAR detection */
+		input_report_abs(data->input_dev_ps, ABS_DISTANCE, 1);
+		input_sync(data->input_dev_ps);
 
-static ssize_t apds990x_lux_range_show(struct device *dev,
-				 struct device_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%u\n", APDS_RANGE);
-}
+		i2c_smbus_write_word_data(client,
+				CMD_WORD|APDS990X_PILTL_REG, 0);
+		i2c_smbus_write_word_data(client,
+				CMD_WORD|APDS990X_PIHTL_REG,
+				data->ps_threshold);
 
-static DEVICE_ATTR(lux0_sensor_range, S_IRUGO, apds990x_lux_range_show, NULL);
+		data->pilt = 0;
+		data->piht = data->ps_threshold;
 
-static ssize_t apds990x_lux_calib_format_show(struct device *dev,
-				 struct device_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%u\n", APDS_CALIB_SCALER);
-}
+		/* near-to-far detected */
+		data->ps_detection = 0;
 
-static DEVICE_ATTR(lux0_calibscale_default, S_IRUGO,
-		apds990x_lux_calib_format_show, NULL);
+		pr_info("%s: FAR\n", __func__);
+	}
 
-static ssize_t apds990x_lux_calib_show(struct device *dev,
-				 struct device_attribute *attr, char *buf)
-{
-	struct apds990x_chip *chip = dev_get_drvdata(dev);
+	if (lux_is_valid) {
+		/* report the lux level */
+		input_report_abs(data->input_dev_als, ABS_MISC, luxValue);
+		input_sync(data->input_dev_als);
+	}
 
-	return sprintf(buf, "%u\n", chip->lux_calib);
-}
+	data->als_data = ch0data;
 
-static ssize_t apds990x_lux_calib_store(struct device *dev,
-				  struct device_attribute *attr,
-				  const char *buf, size_t len)
-{
-	struct apds990x_chip *chip = dev_get_drvdata(dev);
-	unsigned long value;
+	data->als_threshold_l = (data->als_data *
+			(100 - APDS990X_ALS_THRESHOLD_HSYTERESIS)) / 100;
+	data->als_threshold_h = (data->als_data *
+			(100 + APDS990X_ALS_THRESHOLD_HSYTERESIS)) / 100;
 
-	if (strict_strtoul(buf, 0, &value))
-		return -EINVAL;
+	if (data->als_threshold_h >=
+			apds990x_als_res_tb[data->als_atime_index]) {
+		data->als_threshold_h =
+			apds990x_als_res_tb[data->als_atime_index];
+	}
 
-	chip->lux_calib = value;
+	if (data->als_data >=
+		((apds990x_als_res_tb[data->als_atime_index] * 90) / 100)) {
+		/* lower AGAIN if possible */
+		if (data->als_again_index != APDS990X_ALS_GAIN_1X) {
+			data->als_again_index--;
+			change_again = 1;
+		} else {
+			err = i2c_smbus_write_byte_data(client,
+					CMD_BYTE|APDS990X_CONFIG_REG,
+					APDS990X_ALS_REDUCE);
+			if (err >= 0)
+				data->als_reduce = 1;
+		}
+	} else if (data->als_data <=
+		   ((apds990x_als_res_tb[data->als_atime_index] * 10) / 100)) {
+		/* increase AGAIN if possible */
+		if (data->als_reduce) {
+			err = i2c_smbus_write_byte_data(client,
+					CMD_BYTE|APDS990X_CONFIG_REG, 0);
+			if (err >= 0)
+				data->als_reduce = 0;
+		} else if (data->als_again_index != APDS990X_ALS_GAIN_120X) {
+			data->als_again_index++;
+			change_again = 1;
+		}
+	}
 
-	return len;
-}
+	if (change_again) {
+		control_data = i2c_smbus_read_byte_data(client,
+				CMD_BYTE|APDS990X_CONTROL_REG);
+		control_data = control_data & 0xFC;
+		control_data = control_data |
+			apds990x_als_again_bit_tb[data->als_again_index];
+		i2c_smbus_write_byte_data(client,
+				CMD_BYTE|APDS990X_CONTROL_REG, control_data);
+	}
 
-static DEVICE_ATTR(lux0_calibscale, S_IRUGO | S_IWUSR, apds990x_lux_calib_show,
-		apds990x_lux_calib_store);
+	i2c_smbus_write_word_data(client,
+			CMD_WORD|APDS990X_AILTL_REG, data->als_threshold_l);
+	i2c_smbus_write_word_data(client,
+			CMD_WORD|APDS990X_AIHTL_REG, data->als_threshold_h);
 
-static ssize_t apds990x_rate_avail(struct device *dev,
-				   struct device_attribute *attr, char *buf)
-{
-	int i;
-	int pos = 0;
-	for (i = 0; i < ARRAY_SIZE(arates_hz); i++)
-		pos += sprintf(buf + pos, "%d ", arates_hz[i]);
-	sprintf(buf + pos - 1, "\n");
-	return pos;
 }
 
-static ssize_t apds990x_rate_show(struct device *dev,
-				   struct device_attribute *attr, char *buf)
+static void apds990x_reschedule_work(struct apds990x_data *data,
+				unsigned long delay)
 {
-	struct apds990x_chip *chip =  dev_get_drvdata(dev);
-	return sprintf(buf, "%d\n", chip->arate);
+	/*
+	 * If work is already scheduled then subsequent schedules will not
+	 * change the scheduled time that's why we have to cancel it first.
+	 */
+	cancel_delayed_work(&data->dwork);
+	queue_delayed_work(apds990x_workqueue, &data->dwork, delay);
 }
 
-static int apds990x_set_arate(struct apds990x_chip *chip, int rate)
+
+#ifdef ALS_POLLING_ENABLED
+/* ALS polling routine */
+static void apds990x_als_polling_work_handler(struct work_struct *work)
 {
-	int i;
+	struct apds990x_data *data = container_of(work,
+			struct apds990x_data, als_dwork.work);
+	struct i2c_client *client = data->client;
+	int ch0data, ch1data, pdata, v;
+	int luxValue = 0;
+	int err;
+	unsigned char change_again = 0;
+	unsigned char control_data = 0;
+	unsigned char lux_is_valid = 1;
+
+	ch0data = i2c_smbus_read_word_data(client,
+			CMD_WORD|APDS990X_CH0DATAL_REG);
+	ch1data = i2c_smbus_read_word_data(client,
+			CMD_WORD|APDS990X_CH1DATAL_REG);
+	pdata = i2c_smbus_read_word_data(client,
+			CMD_WORD|APDS990X_PDATAL_REG);
+
+	luxValue = LuxCalculation(client, ch0data, ch1data);
+
+	if (luxValue >= 0) {
+		luxValue = (luxValue < ALS_MAX_RANGE)
+					? luxValue : ALS_MAX_RANGE;
+		data->als_prev_lux = luxValue;
+	} else {
+		/* don't report, this is invalid lux value */
+		lux_is_valid = 0;
+		luxValue = data->als_prev_lux;
+		if (data->als_reduce)
+			lux_is_valid = 1;
+			/* report anyway since this is the lowest gain */
+	}
+	/*
+	pr_info("%s: lux=%d ch0data=%d ch1data=%d pdata=%d delay=%d again=%d "
+		"als_reduce=%d)\n",
+			__func__,
+			luxValue, ch0data, ch1data, pdata,
+			data->als_poll_delay,
+			apds990x_als_again_tb[data->als_again_index],
+			data->als_reduce);
+	*/
 
-	for (i = 0; i < ARRAY_SIZE(arates_hz); i++)
-		if (rate >= arates_hz[i])
-			break;
+	/*
+	 * check PS under sunlight
+	 * PS was previously in far-to-near condition
+	 */
+	v = (75 * (1024 * (256 - data->atime))) / 100;
+	if ((data->ps_detection == 1) && (ch0data > v)) {
+		/*
+		 * need to inform input event as there will be no interrupt
+		 * from the PS
+		 */
+		/* NEAR-to-FAR detection */
+		input_report_abs(data->input_dev_ps, ABS_DISTANCE, 1);
+		input_sync(data->input_dev_ps);
 
-	if (i == ARRAY_SIZE(arates_hz))
-		return -EINVAL;
+		i2c_smbus_write_word_data(client,
+				CMD_WORD|APDS990X_PILTL_REG, 0);
+		i2c_smbus_write_word_data(client,
+				CMD_WORD|APDS990X_PIHTL_REG,
+				data->ps_threshold);
 
-	/* Pick up corresponding persistence value */
-	chip->lux_persistence = apersis[i];
-	chip->arate = arates_hz[i];
+		data->pilt = 0;
+		data->piht = data->ps_threshold;
 
-	/* If the chip is not in use, don't try to access it */
-	if (pm_runtime_suspended(&chip->client->dev))
-		return 0;
+		data->ps_detection = 0;	/* near-to-far detected */
 
-	/* Persistence levels */
-	return apds990x_write_byte(chip, APDS990X_PERS,
-			(chip->lux_persistence << APDS990X_APERS_SHIFT) |
-			(chip->prox_persistence << APDS990X_PPERS_SHIFT));
-}
+		pr_info("%s: FAR\n", __func__);
+	}
 
-static ssize_t apds990x_rate_store(struct device *dev,
-				  struct device_attribute *attr,
-				  const char *buf, size_t len)
-{
-	struct apds990x_chip *chip =  dev_get_drvdata(dev);
-	unsigned long value;
-	int ret;
+	if (lux_is_valid) {
+		/* report the lux level */
+		input_report_abs(data->input_dev_als, ABS_MISC, luxValue);
+		input_sync(data->input_dev_als);
+	}
 
-	if (strict_strtoul(buf, 0, &value))
-		return -EINVAL;
+	data->als_data = ch0data;
+
+	if (data->als_data >=
+	    (apds990x_als_res_tb[data->als_atime_index] * 90) / 100) {
+		/* lower AGAIN if possible */
+		if (data->als_again_index != APDS990X_ALS_GAIN_1X) {
+			data->als_again_index--;
+			change_again = 1;
+		} else {
+			err = i2c_smbus_write_byte_data(client,
+					CMD_BYTE|APDS990X_CONFIG_REG,
+					APDS990X_ALS_REDUCE);
+			if (err >= 0)
+				data->als_reduce = 1;
+		}
+	} else if (data->als_data <=
+		   (apds990x_als_res_tb[data->als_atime_index] * 10) / 100) {
+		/* increase AGAIN if possible */
+		if (data->als_reduce) {
+			err = i2c_smbus_write_byte_data(client,
+					CMD_BYTE|APDS990X_CONFIG_REG, 0);
+			if (err >= 0)
+				data->als_reduce = 0;
+		} else if (data->als_again_index != APDS990X_ALS_GAIN_120X) {
+			data->als_again_index++;
+			change_again = 1;
+		}
+	}
 
-	mutex_lock(&chip->mutex);
-	ret = apds990x_set_arate(chip, value);
-	mutex_unlock(&chip->mutex);
+	if (change_again) {
+		control_data = i2c_smbus_read_byte_data(client,
+				CMD_BYTE|APDS990X_CONTROL_REG);
+		control_data = control_data & 0xFC;
+		control_data = control_data |
+			apds990x_als_again_bit_tb[data->als_again_index];
+		i2c_smbus_write_byte_data(client,
+				CMD_BYTE|APDS990X_CONTROL_REG, control_data);
+	}
 
-	if (ret < 0)
-		return ret;
-	return len;
+	/* restart timer */
+	queue_delayed_work(apds990x_workqueue, &data->als_dwork,
+	msecs_to_jiffies(data->als_poll_delay));
 }
+#endif /* ALS_POLLING_ENABLED */
 
-static DEVICE_ATTR(lux0_rate_avail, S_IRUGO, apds990x_rate_avail, NULL);
-
-static DEVICE_ATTR(lux0_rate, S_IRUGO | S_IWUSR, apds990x_rate_show,
-						 apds990x_rate_store);
-
-static ssize_t apds990x_prox_show(struct device *dev,
-				 struct device_attribute *attr, char *buf)
+/* PS interrupt routine */
+static void apds990x_work_handler(struct work_struct *work)
 {
-	ssize_t ret;
-	struct apds990x_chip *chip =  dev_get_drvdata(dev);
-	if (pm_runtime_suspended(dev) || !chip->prox_en)
-		return -EIO;
-
-	mutex_lock(&chip->mutex);
-	ret = sprintf(buf, "%d\n", chip->prox_data);
-	mutex_unlock(&chip->mutex);
-	return ret;
-}
+	struct apds990x_data *data =
+		container_of(work, struct apds990x_data, dwork.work);
+	struct i2c_client *client = data->client;
+	int status;
+	int ch0data;
+	int enable;
+
+	status = i2c_smbus_read_byte_data(client, CMD_BYTE|APDS990X_STATUS_REG);
+	enable = i2c_smbus_read_byte_data(client, CMD_BYTE|APDS990X_ENABLE_REG);
+
+	/* disable 993x's ADC first */
+	i2c_smbus_write_byte_data(client, CMD_BYTE|APDS990X_ENABLE_REG, 1);
+
+	pr_debug("%s: status = %x\n", __func__, status);
+
+	if ((status & enable & 0x30) == 0x30) {
+		/* both PS and ALS are interrupted */
+		apds990x_change_als_threshold(client);
+
+		ch0data = i2c_smbus_read_word_data(client,
+				CMD_WORD|APDS990X_CH0DATAL_REG);
+		if (ch0data < (75 * (1024 * (256 - data->atime))) / 100) {
+			apds990x_change_ps_threshold(client);
+		} else {
+			if (data->ps_detection == 1)
+				apds990x_change_ps_threshold(client);
+			else
+				pr_info("%s: background ambient noise\n",
+						__func__);
+		}
 
-static DEVICE_ATTR(prox0_raw, S_IRUGO, apds990x_prox_show, NULL);
+		/* 2 = CMD_CLR_PS_ALS_INT */
+		apds990x_set_command(client, 2);
+	} else if ((status & enable & 0x20) == 0x20) {
+		/* only PS is interrupted */
+		/* check if this is triggered by background ambient noise */
+		ch0data = i2c_smbus_read_word_data(client,
+				CMD_WORD|APDS990X_CH0DATAL_REG);
+		if (ch0data <
+		    (75 * (apds990x_als_res_tb[data->als_atime_index])) / 100) {
+			apds990x_change_ps_threshold(client);
+		} else {
+			if (data->ps_detection == 1)
+				apds990x_change_ps_threshold(client);
+			else
+				pr_info("%s: background ambient noise\n",
+						__func__);
+		}
 
-static ssize_t apds990x_prox_range_show(struct device *dev,
-				 struct device_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%u\n", APDS_PROX_RANGE);
-}
+		/* 0 = CMD_CLR_PS_INT */
+		apds990x_set_command(client, 0);
+	} else if ((status & enable & 0x10) == 0x10) {
+		/* only ALS is interrupted */
+		apds990x_change_als_threshold(client);
 
-static DEVICE_ATTR(prox0_sensor_range, S_IRUGO, apds990x_prox_range_show, NULL);
+		/* 1 = CMD_CLR_ALS_INT */
+		apds990x_set_command(client, 1);
+	}
 
-static ssize_t apds990x_prox_enable_show(struct device *dev,
-				   struct device_attribute *attr, char *buf)
-{
-	struct apds990x_chip *chip =  dev_get_drvdata(dev);
-	return sprintf(buf, "%d\n", chip->prox_en);
+	i2c_smbus_write_byte_data(client,
+			CMD_BYTE|APDS990X_ENABLE_REG, data->enable);
 }
 
-static ssize_t apds990x_prox_enable_store(struct device *dev,
-				  struct device_attribute *attr,
-				  const char *buf, size_t len)
+/* assume this is ISR */
+static irqreturn_t apds990x_interrupt(int vec, void *info)
 {
-	struct apds990x_chip *chip =  dev_get_drvdata(dev);
-	unsigned long value;
-
-	if (strict_strtoul(buf, 0, &value))
-		return -EINVAL;
-
-	mutex_lock(&chip->mutex);
+	struct i2c_client *client = (struct i2c_client *)info;
+	struct apds990x_data *data = i2c_get_clientdata(client);
 
-	if (!chip->prox_en)
-		chip->prox_data = 0;
+	apds990x_reschedule_work(data, 0);
 
-	if (value)
-		chip->prox_en++;
-	else if (chip->prox_en > 0)
-		chip->prox_en--;
-
-	if (!pm_runtime_suspended(dev))
-		apds990x_mode_on(chip);
-	mutex_unlock(&chip->mutex);
-	return len;
+	return IRQ_HANDLED;
 }
 
-static DEVICE_ATTR(prox0_raw_en, S_IRUGO | S_IWUSR, apds990x_prox_enable_show,
-						   apds990x_prox_enable_store);
-
-static const char reporting_modes[][9] = {"trigger", "periodic"};
-
-static ssize_t apds990x_prox_reporting_mode_show(struct device *dev,
-				   struct device_attribute *attr, char *buf)
+/*
+ * IOCTL support
+ */
+static int apds990x_enable_als_sensor(struct i2c_client *client, int val)
 {
-	struct apds990x_chip *chip =  dev_get_drvdata(dev);
-	return sprintf(buf, "%s\n",
-		reporting_modes[!!chip->prox_continuous_mode]);
-}
+	struct apds990x_data *data = i2c_get_clientdata(client);
 
-static ssize_t apds990x_prox_reporting_mode_store(struct device *dev,
-				  struct device_attribute *attr,
-				  const char *buf, size_t len)
-{
-	struct apds990x_chip *chip =  dev_get_drvdata(dev);
+	pr_debug("%s: val=%d\n", __func__, val);
 
-	if (sysfs_streq(buf, reporting_modes[0]))
-		chip->prox_continuous_mode = 0;
-	else if (sysfs_streq(buf, reporting_modes[1]))
-		chip->prox_continuous_mode = 1;
-	else
+	if ((val != 0) && (val != 1)) {
+		pr_err("%s: invalid value (val = %d)\n", __func__, val);
 		return -EINVAL;
-	return len;
-}
+	}
 
-static DEVICE_ATTR(prox0_reporting_mode, S_IRUGO | S_IWUSR,
-		apds990x_prox_reporting_mode_show,
-		apds990x_prox_reporting_mode_store);
+	if (val == 1) {
+		/* turn on light  sensor */
+		if (data->enable_als_sensor == 0) {
+			data->enable_als_sensor = 1;
+			/* Power Off */
+			apds990x_set_enable(client, 0);
+
+#ifdef ALS_POLLING_ENABLED
+			if (data->enable_ps_sensor) {
+				/* Enable PS with interrupt */
+				apds990x_set_enable(client, 0x27);
+			} else {
+				/* no interrupt*/
+				apds990x_set_enable(client, 0x03);
+			}
+#else
+			/*
+			 *  force first ALS interrupt in order to
+			 * get environment reading
+			 */
+			apds990x_set_ailt(client, 0xFFFF);
+			apds990x_set_aiht(client, 0);
+
+			if (data->enable_ps_sensor) {
+				/* Enable both ALS and PS with interrupt */
+				apds990x_set_enable(client, 0x37);
+			} else {
+				/* only enable light sensor with interrupt*/
+				apds990x_set_enable(client, 0x13);
+			}
+#endif
 
-static ssize_t apds990x_prox_reporting_avail_show(struct device *dev,
-				   struct device_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%s %s\n", reporting_modes[0], reporting_modes[1]);
-}
+#ifdef ALS_POLLING_ENABLED
+			/*
+			 * If work is already scheduled then subsequent
+			 * schedules will not change the scheduled time
+			 * that's why we have to cancel it first.
+			 */
+			cancel_delayed_work(&data->als_dwork);
+			flush_delayed_work(&data->als_dwork);
+			queue_delayed_work(apds990x_workqueue,
+				&data->als_dwork,
+				msecs_to_jiffies(data->als_poll_delay));
+#endif
+		}
+	} else {
+		/*
+		 * turn off light sensor
+		 * what if the p sensor is active?
+		 */
+		data->enable_als_sensor = 0;
 
-static DEVICE_ATTR(prox0_reporting_mode_avail, S_IRUGO | S_IWUSR,
-		apds990x_prox_reporting_avail_show, NULL);
+		if (data->enable_ps_sensor) {
+			/* Power Off */
+			apds990x_set_enable(client, 0);
 
+			apds990x_set_piht(client, 0);
+			apds990x_set_piht(client,
+					apds990x_ps_detection_threshold);
 
-static ssize_t apds990x_lux_thresh_above_show(struct device *dev,
-				   struct device_attribute *attr, char *buf)
-{
-	struct apds990x_chip *chip =  dev_get_drvdata(dev);
-	return sprintf(buf, "%d\n", chip->lux_thres_hi);
-}
+			/* only enable prox sensor with interrupt */
+			apds990x_set_enable(client, 0x27);
+		} else {
+			apds990x_set_enable(client, 0);
+		}
 
-static ssize_t apds990x_lux_thresh_below_show(struct device *dev,
-				   struct device_attribute *attr, char *buf)
-{
-	struct apds990x_chip *chip =  dev_get_drvdata(dev);
-	return sprintf(buf, "%d\n", chip->lux_thres_lo);
+#ifdef ALS_POLLING_ENABLED
+		/*
+		 * If work is already scheduled then subsequent schedules
+		 * will not change the scheduled time that's why we have
+		 * to cancel it first.
+		 */
+		cancel_delayed_work(&data->als_dwork);
+		flush_delayed_work(&data->als_dwork);
+#endif
+	}
+	return 0;
 }
 
-static ssize_t apds990x_set_lux_thresh(struct apds990x_chip *chip, u32 *target,
-				const char *buf)
+#ifdef ALS_POLLING_ENABLED
+static int apds990x_set_als_poll_delay(struct i2c_client *client,
+		unsigned int val)
 {
-	int ret = 0;
-	unsigned long thresh;
+	struct apds990x_data *data = i2c_get_clientdata(client);
+	int ret;
+	int atime_index = 0;
 
-	if (strict_strtoul(buf, 0, &thresh))
-		return -EINVAL;
+	pr_debug("%s: val=%d\n", __func__, val);
 
-	if (thresh > APDS_RANGE)
-		return -EINVAL;
+	/* minimum 3ms */
+	if (val < 3)
+		val = 3;
+	data->als_poll_delay = val;
+
+	if (data->als_poll_delay >= 100)
+		atime_index = APDS990X_ALS_RES_37888;
+	else if (data->als_poll_delay >= 50)
+		atime_index = APDS990X_ALS_RES_19456;
+	else
+		atime_index = APDS990X_ALS_RES_10240;
+
+	ret = apds990x_set_atime(client, apds990x_als_atime_tb[atime_index]);
+	if (ret >= 0) {
+		data->als_atime_index = atime_index;
+		pr_debug("poll delay %d, atime_index %d\n",
+				data->als_poll_delay, data->als_atime_index);
+	} else {
+		return ret;
+	}
 
-	mutex_lock(&chip->mutex);
-	*target = thresh;
 	/*
-	 * Don't update values in HW if we are still waiting for
-	 * first interrupt to come after device handle open call.
+	 * If work is already scheduled then subsequent schedules will not
+	 * change the scheduled time that's why we have to cancel it first.
 	 */
-	if (!chip->lux_wait_fresh_res)
-		apds990x_refresh_athres(chip);
-	mutex_unlock(&chip->mutex);
-	return ret;
-
-}
+	cancel_delayed_work(&data->als_dwork);
+	flush_delayed_work(&data->als_dwork);
+	queue_delayed_work(apds990x_workqueue,
+			&data->als_dwork,
+			msecs_to_jiffies(data->als_poll_delay));
 
-static ssize_t apds990x_lux_thresh_above_store(struct device *dev,
-				  struct device_attribute *attr,
-				  const char *buf, size_t len)
-{
-	struct apds990x_chip *chip =  dev_get_drvdata(dev);
-	int ret = apds990x_set_lux_thresh(chip, &chip->lux_thres_hi, buf);
-	if (ret < 0)
-		return ret;
-	return len;
+	return 0;
 }
+#endif
 
-static ssize_t apds990x_lux_thresh_below_store(struct device *dev,
-				  struct device_attribute *attr,
-				  const char *buf, size_t len)
+static int apds990x_enable_ps_sensor(struct i2c_client *client, int val)
 {
-	struct apds990x_chip *chip =  dev_get_drvdata(dev);
-	int ret = apds990x_set_lux_thresh(chip, &chip->lux_thres_lo, buf);
-	if (ret < 0)
-		return ret;
-	return len;
-}
+	struct apds990x_data *data = i2c_get_clientdata(client);
 
-static DEVICE_ATTR(lux0_thresh_above_value, S_IRUGO | S_IWUSR,
-		apds990x_lux_thresh_above_show,
-		apds990x_lux_thresh_above_store);
+	pr_debug("%s: val=%d\n", __func__, val);
 
-static DEVICE_ATTR(lux0_thresh_below_value, S_IRUGO | S_IWUSR,
-		apds990x_lux_thresh_below_show,
-		apds990x_lux_thresh_below_store);
+	if ((val != 0) && (val != 1)) {
+		pr_err("%s: invalid value=%d\n", __func__, val);
+		return -EINVAL;
+	}
 
-static ssize_t apds990x_prox_threshold_show(struct device *dev,
-				   struct device_attribute *attr, char *buf)
-{
-	struct apds990x_chip *chip =  dev_get_drvdata(dev);
-	return sprintf(buf, "%d\n", chip->prox_thres);
+	if (val == 1) {
+		/* turn on p sensor */
+		if (data->enable_ps_sensor == 0) {
+			data->enable_ps_sensor = 1;
+
+			/* Power Off */
+			apds990x_set_enable(client, 0);
+
+			/* init threshold for proximity */
+			apds990x_set_pilt(client,
+					apds990x_ps_detection_threshold);
+			apds990x_set_piht(client,
+					apds990x_ps_detection_threshold);
+			/*calirbation*/
+			apds990x_set_ps_threshold_adding_cross_talk(client,
+			data->cross_talk);
+
+			if (data->enable_als_sensor == 0) {
+				/* only enable PS interrupt */
+				apds990x_set_enable(client, 0x27);
+			} else {
+#ifdef ALS_POLLING_ENABLED
+				/* enable PS interrupt */
+				apds990x_set_enable(client, 0x27);
+#else
+				/* enable ALS and PS interrupt */
+				apds990x_set_enable(client, 0x37);
+#endif
+			}
+		}
+	} else {
+		/*
+		 * turn off p sensor - kk 25 Apr 2011
+		 * we can't turn off the entire sensor,
+		 * the light sensor may be needed by HAL
+		 */
+		data->enable_ps_sensor = 0;
+		if (data->enable_als_sensor) {
+#ifdef ALS_POLLING_ENABLED
+			/* no ALS interrupt */
+			apds990x_set_enable(client, 0x03);
+
+			/*
+			 * If work is already scheduled then subsequent
+			 * schedules will not change the scheduled time
+			 * that's why we have to cancel it first.
+			 */
+			cancel_delayed_work(&data->als_dwork);
+			flush_delayed_work(&data->als_dwork);
+			/* 100ms */
+			queue_delayed_work(apds990x_workqueue,
+					&data->als_dwork,
+					msecs_to_jiffies(data->als_poll_delay));
+
+#else
+			/* reconfigute light sensor setting */
+			/* Power Off */
+			apds990x_set_enable(client, 0);
+			/* Force ALS interrupt */
+			apds990x_set_ailt(client, 0xFFFF);
+			apds990x_set_aiht(client, 0);
+
+			/* enable ALS interrupt */
+			apds990x_set_enable(client, 0x13);
+#endif
+		} else {
+			apds990x_set_enable(client, 0);
+#ifdef ALS_POLLING_ENABLED
+			/*
+			 * If work is already scheduled then subsequent
+			 * schedules will not change the scheduled time
+			 * that's why we have to cancel it first.
+			 */
+			cancel_delayed_work(&data->als_dwork);
+			flush_delayed_work(&data->als_dwork);
+#endif
+		}
+	}
+	return 0;
 }
 
-static ssize_t apds990x_prox_threshold_store(struct device *dev,
-				  struct device_attribute *attr,
-				  const char *buf, size_t len)
+static int apds990x_ps_open(struct inode *inode, struct file *file)
 {
-	struct apds990x_chip *chip =  dev_get_drvdata(dev);
-	unsigned long value;
+	return 0;
+}
 
-	if (strict_strtoul(buf, 0, &value))
-		return -EINVAL;
+static int apds990x_ps_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static long apds990x_ps_ioctl(struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	struct apds990x_data *data;
+	struct i2c_client *client;
+	int enable;
+	int ret = -1;
 
-	if ((value > APDS_RANGE) || (value == 0) ||
-		(value < APDS_PROX_HYSTERESIS))
+	if (arg == 0)
 		return -EINVAL;
 
-	mutex_lock(&chip->mutex);
-	chip->prox_thres = value;
+	if (apds990x_i2c_client == NULL) {
+		pr_err("%s: i2c driver not installed\n", __func__);
+		return -ENODEV;
+	}
+
+	client = apds990x_i2c_client;
+	data = i2c_get_clientdata(apds990x_i2c_client);
+
+	switch (cmd) {
+	case APDS990X_IOCTL_PS_ENABLE:
+		ret = copy_from_user(&enable,
+				(void __user *)arg, sizeof(enable));
+		if (ret) {
+			pr_err("%s: PS_ENABLE: copy_from_user failed\n",
+					__func__);
+			return -EFAULT;
+		}
+
+		ret = apds990x_enable_ps_sensor(client, enable);
+		if (ret < 0)
+			return ret;
+		break;
+
+	case APDS990X_IOCTL_PS_GET_ENABLE:
+		ret = copy_to_user((void __user *)arg,
+				&data->enable_ps_sensor,
+				sizeof(data->enable_ps_sensor));
+		if (ret) {
+			pr_err("%s: PS_GET_ENABLE: copy_to_user failed\n",
+					__func__);
+			return -EFAULT;
+		}
+
+		break;
+
+	case APDS990X_IOCTL_PS_GET_PDATA:
+		data->ps_data =	i2c_smbus_read_word_data(client,
+				CMD_WORD|APDS990X_PDATAL_REG);
+
+		ret = copy_to_user((void __user *)arg,
+				&data->ps_data, sizeof(data->ps_data));
+		if (ret) {
+			pr_err("%s: PS_GET_PDATA: copy_to_user failed\n",
+					__func__);
+			return -EFAULT;
+		}
+		break;
 
-	apds990x_force_p_refresh(chip);
-	mutex_unlock(&chip->mutex);
-	return len;
+	default:
+		pr_warn("%s: unknown ioctl (%d)\n", __func__, cmd);
+		break;
+	}
+
+	return 0;
 }
 
-static DEVICE_ATTR(prox0_thresh_above_value, S_IRUGO | S_IWUSR,
-		apds990x_prox_threshold_show,
-		apds990x_prox_threshold_store);
+static int apds990x_als_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
 
-static ssize_t apds990x_power_state_show(struct device *dev,
-				   struct device_attribute *attr, char *buf)
+static int apds990x_als_release(struct inode *inode, struct file *file)
 {
-	return sprintf(buf, "%d\n", !pm_runtime_suspended(dev));
 	return 0;
 }
 
-static ssize_t apds990x_power_state_store(struct device *dev,
-				  struct device_attribute *attr,
-				  const char *buf, size_t len)
+static long apds990x_als_ioctl(struct file *file,
+		unsigned int cmd, unsigned long arg)
 {
-	struct apds990x_chip *chip =  dev_get_drvdata(dev);
-	unsigned long value;
+	struct apds990x_data *data;
+	struct i2c_client *client;
+	int enable;
+	int ret = -1;
 
-	if (strict_strtoul(buf, 0, &value))
+#ifdef ALS_POLLING_ENABLED
+	unsigned int delay;
+#endif
+
+	if (arg == 0)
 		return -EINVAL;
-	if (value) {
-		pm_runtime_get_sync(dev);
-		mutex_lock(&chip->mutex);
-		chip->lux_wait_fresh_res = true;
-		apds990x_force_a_refresh(chip);
-		apds990x_force_p_refresh(chip);
-		mutex_unlock(&chip->mutex);
-	} else {
-		if (!pm_runtime_suspended(dev))
-			pm_runtime_put(dev);
-	}
-	return len;
-}
-
-static DEVICE_ATTR(power_state, S_IRUGO | S_IWUSR,
-		apds990x_power_state_show,
-		apds990x_power_state_store);
-
-static ssize_t apds990x_chip_id_show(struct device *dev,
-				   struct device_attribute *attr, char *buf)
-{
-	struct apds990x_chip *chip =  dev_get_drvdata(dev);
-	return sprintf(buf, "%s %d\n", chip->chipname, chip->revision);
-}
-
-static DEVICE_ATTR(chip_id, S_IRUGO, apds990x_chip_id_show, NULL);
-
-static struct attribute *sysfs_attrs_ctrl[] = {
-	&dev_attr_lux0_calibscale.attr,
-	&dev_attr_lux0_calibscale_default.attr,
-	&dev_attr_lux0_input.attr,
-	&dev_attr_lux0_sensor_range.attr,
-	&dev_attr_lux0_rate.attr,
-	&dev_attr_lux0_rate_avail.attr,
-	&dev_attr_lux0_thresh_above_value.attr,
-	&dev_attr_lux0_thresh_below_value.attr,
-	&dev_attr_prox0_raw_en.attr,
-	&dev_attr_prox0_raw.attr,
-	&dev_attr_prox0_sensor_range.attr,
-	&dev_attr_prox0_thresh_above_value.attr,
-	&dev_attr_prox0_reporting_mode.attr,
-	&dev_attr_prox0_reporting_mode_avail.attr,
-	&dev_attr_chip_id.attr,
-	&dev_attr_power_state.attr,
+
+	if (apds990x_i2c_client == NULL) {
+		pr_err("%s: i2c driver not installed\n", __func__);
+		return -ENODEV;
+	}
+
+	client = apds990x_i2c_client;
+	data = i2c_get_clientdata(apds990x_i2c_client);
+
+	switch (cmd) {
+	case APDS990X_IOCTL_ALS_ENABLE:
+		ret = copy_from_user(&enable,
+				(void __user *)arg, sizeof(enable));
+		if (ret) {
+			pr_err("%s: ALS_ENABLE: copy_from_user failed\n",
+					__func__);
+			return -EFAULT;
+		}
+
+		ret = apds990x_enable_als_sensor(client, enable);
+		if (ret < 0)
+			return ret;
+		break;
+
+#ifdef ALS_POLLING_ENABLED
+	case APDS990X_IOCTL_ALS_DELAY:
+		ret = copy_from_user(&delay, (void __user *)arg, sizeof(delay));
+		if (ret) {
+			pr_err("%s: ALS_DELAY: copy_to_user failed\n",
+					__func__);
+			return -EFAULT;
+		}
+
+		ret = apds990x_set_als_poll_delay(client, delay);
+		if (ret < 0)
+			return ret;
+		break;
+#endif
+
+	case APDS990X_IOCTL_ALS_GET_ENABLE:
+		ret = copy_to_user((void __user *)arg,
+				&data->enable_als_sensor,
+				sizeof(data->enable_als_sensor));
+		if (ret) {
+			pr_err("%s: ALS_GET_ENABLE: copy_to_user failed\n",
+					__func__);
+			return -EFAULT;
+		}
+		break;
+
+	case APDS990X_IOCTL_ALS_GET_CH0DATA:
+		data->als_data = i2c_smbus_read_word_data(client,
+					CMD_WORD|APDS990X_CH0DATAL_REG);
+
+		ret = copy_to_user((void __user *)arg,
+				&data->als_data, sizeof(data->als_data));
+		if (ret) {
+			pr_err("%s: ALS_GET_CH0DATA: copy_to_user failed\n",
+					__func__);
+			return -EFAULT;
+		}
+		break;
+
+	case APDS990X_IOCTL_ALS_GET_CH1DATA:
+		data->als_data = i2c_smbus_read_word_data(client,
+				CMD_WORD|APDS990X_CH1DATAL_REG);
+
+		ret = copy_to_user((void __user *)arg,
+				&data->als_data, sizeof(data->als_data));
+		if (ret) {
+			pr_err("%s: ALS_GET_CH1DATA: copy_to_user failed\n",
+					__func__);
+			return -EFAULT;
+		}
+		break;
+
+	default:
+		pr_warn("%s: unknown ioctl (%d)\n", __func__, cmd);
+		break;
+	}
+
+	return 0;
+}
+
+/*
+ * SysFS support
+ */
+static ssize_t apds990x_show_ch0data(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct apds990x_data *data = i2c_get_clientdata(client);
+	int ch0data;
+
+	mutex_lock(&data->update_lock);
+	ch0data = i2c_smbus_read_word_data(client,
+			CMD_WORD|APDS990X_CH0DATAL_REG);
+	mutex_unlock(&data->update_lock);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", ch0data);
+}
+
+static DEVICE_ATTR(ch0data, S_IRUGO, apds990x_show_ch0data, NULL);
+
+static ssize_t apds990x_show_ch1data(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct apds990x_data *data = i2c_get_clientdata(client);
+	int ch1data;
+
+	mutex_lock(&data->update_lock);
+	ch1data = i2c_smbus_read_word_data(client,
+			CMD_WORD|APDS990X_CH1DATAL_REG);
+	mutex_unlock(&data->update_lock);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", ch1data);
+}
+
+static DEVICE_ATTR(ch1data, S_IRUGO, apds990x_show_ch1data, NULL);
+
+static ssize_t apds990x_show_pdata(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct apds990x_data *data = i2c_get_clientdata(client);
+	int pdata;
+
+	mutex_lock(&data->update_lock);
+	pdata = i2c_smbus_read_word_data(client, CMD_WORD|APDS990X_PDATAL_REG);
+	mutex_unlock(&data->update_lock);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", pdata);
+}
+
+static DEVICE_ATTR(pdata, S_IRUGO, apds990x_show_pdata, NULL);
+
+/*calibration sysfs*/
+static ssize_t apds990x_show_status(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct apds990x_data *data = i2c_get_clientdata(client);
+	int status;
+	int rdata;
+
+	mutex_lock(&data->update_lock);
+	status = i2c_smbus_read_byte_data(client, CMD_BYTE|APDS990X_STATUS_REG);
+	rdata = i2c_smbus_read_byte_data(client, CMD_BYTE|APDS990X_ENABLE_REG);
+	mutex_unlock(&data->update_lock);
+
+	pr_info("%s: APDS993x_ENABLE_REG=%2d APDS993x_STATUS_REG=%2d\n",
+			__func__, rdata, status);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", status);
+}
+
+static DEVICE_ATTR(status, S_IRUSR | S_IRGRP, apds990x_show_status, NULL);
+
+static ssize_t apds990x_show_ps_run_calibration(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct apds990x_data *data = i2c_get_clientdata(client);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", data->avg_cross_talk);
+}
+
+static ssize_t apds990x_store_ps_run_calibration(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct apds990x_data *data = i2c_get_clientdata(client);
+	int ret = 0;
+
+	/* start calibration */
+	ret = apds990x_run_cross_talk_calibration(client);
+
+	/* set threshold for near/far status */
+	data->ps_threshold = data->cross_talk + ADD_TO_CROSS_TALK;
+	data->ps_hysteresis_threshold =
+		data->ps_threshold - SUB_FROM_PS_THRESHOLD;
+
+	pr_info("%s: [piht][pilt][c_t] = [%d][%d][%d]\n", __func__,
+			data->ps_threshold,
+			data->ps_hysteresis_threshold,
+			data->cross_talk);
+
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static DEVICE_ATTR(ps_run_calibration,  S_IWUSR | S_IWGRP | S_IRUGO,
+		apds990x_show_ps_run_calibration,
+		apds990x_store_ps_run_calibration);
+
+static ssize_t apds990x_show_ps_default_crosstalk(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", DEFAULT_CROSS_TALK);
+}
+
+static ssize_t apds990x_store_ps_default_crosstalk(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct apds990x_data *data = i2c_get_clientdata(client);
+
+	data->ps_threshold = DEFAULT_CROSS_TALK + ADD_TO_CROSS_TALK;
+	data->ps_hysteresis_threshold =
+		data->ps_threshold - SUB_FROM_PS_THRESHOLD;
+
+	pr_info("%s: [piht][pilt][c_t] = [%d][%d][%d]\n", __func__,
+			data->ps_threshold,
+			data->ps_hysteresis_threshold,
+			data->cross_talk);
+
+	return count;
+}
+
+static DEVICE_ATTR(ps_default_crosstalk, S_IRUGO | S_IWUSR | S_IWGRP,
+		apds990x_show_ps_default_crosstalk,
+		apds990x_store_ps_default_crosstalk);
+
+/* for Calibration result */
+static ssize_t apds990x_show_ps_cal_result(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct apds990x_data *data = i2c_get_clientdata(client);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", data->ps_cal_result);
+}
+
+static DEVICE_ATTR(ps_cal_result, S_IRUGO, apds990x_show_ps_cal_result, NULL);
+/*calibration sysfs end*/
+
+#ifdef APDS990X_HAL_USE_SYS_ENABLE
+static ssize_t apds990x_show_enable_ps_sensor(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct apds990x_data *data = i2c_get_clientdata(client);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", data->enable_ps_sensor);
+}
+
+static ssize_t apds990x_store_enable_ps_sensor(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	unsigned long val = (unsigned long)kstrtoul(buf, 10, NULL);
+
+	pr_debug("%s: val=%ld\n", __func__, val);
+
+	if (val != 0 && val != 1) {
+		pr_err("%s: invalid value(%ld)\n", __func__, val);
+		return -EINVAL;
+	}
+
+	apds990x_enable_ps_sensor(client, val);
+
+	return count;
+}
+
+static DEVICE_ATTR(enable_ps_sensor, S_IWUSR | S_IWGRP | S_IRUGO,
+		apds990x_show_enable_ps_sensor,
+		apds990x_store_enable_ps_sensor);
+
+static ssize_t apds990x_show_enable_als_sensor(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct apds990x_data *data = i2c_get_clientdata(client);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", data->enable_als_sensor);
+}
+
+static ssize_t apds990x_store_enable_als_sensor(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	unsigned long val = (unsigned long)kstrtoul(buf, 10, NULL);
+
+	pr_debug("%s: val=%ld\n", __func__, val);
+
+	if (val != 0 && val != 1) {
+		pr_err("%s: invalid value(%ld)\n", __func__, val);
+		return -EINVAL;
+	}
+
+	apds990x_enable_als_sensor(client, val);
+
+	return count;
+}
+
+static int apds990x_als_set_enable(struct sensors_classdev *sensors_cdev,
+		unsigned int enable)
+{
+	struct apds990x_data *data = container_of(sensors_cdev,
+			struct apds990x_data, als_cdev);
+
+	if ((enable != 0) && (enable != 1)) {
+		pr_err("%s: invalid value(%d)\n", __func__, enable);
+		return -EINVAL;
+	}
+
+	return apds990x_enable_als_sensor(data->client, enable);
+}
+
+static int apds990x_ps_set_enable(struct sensors_classdev *sensors_cdev,
+		unsigned int enable)
+{
+	struct apds990x_data *data = container_of(sensors_cdev,
+			struct apds990x_data, ps_cdev);
+
+	if ((enable != 0) && (enable != 1)) {
+		pr_err("%s: invalid value(%d)\n", __func__, enable);
+		return -EINVAL;
+	}
+
+	return apds990x_enable_ps_sensor(data->client, enable);
+}
+
+static DEVICE_ATTR(enable_als_sensor, S_IWUSR | S_IWGRP | S_IRUGO,
+		apds990x_show_enable_als_sensor,
+		apds990x_store_enable_als_sensor);
+
+static ssize_t apds990x_show_als_poll_delay(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct apds990x_data *data = i2c_get_clientdata(client);
+
+	/* return in micro-second */
+	return snprintf(buf, PAGE_SIZE, "%d\n", data->als_poll_delay);
+}
+
+static ssize_t apds990x_store_als_poll_delay(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+#ifdef ALS_POLLING_ENABLED
+	struct i2c_client *client = to_i2c_client(dev);
+	unsigned long val = (unsigned long)kstrtoul(buf, 10, NULL);
+
+	apds990x_set_als_poll_delay(client, val);
+#endif
+
+	return count;
+}
+
+#ifdef ALS_POLLING_ENABLED
+static int apds990x_als_poll_delay(struct sensors_classdev *sensors_cdev,
+		unsigned int delay_msec)
+{
+	struct apds990x_data *data = container_of(sensors_cdev,
+			struct apds990x_data, als_cdev);
+	apds990x_set_als_poll_delay(data->client, delay_msec);
+	return 0;
+}
+#else
+static int apds990x_als_poll_delay(struct sensors_classdev *sensors_cdev,
+		unsigned int delay_msec)
+{
+	return 0;
+}
+#endif
+
+static DEVICE_ATTR(als_poll_delay, S_IWUSR | S_IRUGO,
+		apds990x_show_als_poll_delay, apds990x_store_als_poll_delay);
+
+#endif
+
+static struct attribute *apds990x_attributes[] = {
+	&dev_attr_ch0data.attr,
+	&dev_attr_ch1data.attr,
+	&dev_attr_pdata.attr,
+#ifdef APDS990X_HAL_USE_SYS_ENABLE
+	&dev_attr_enable_ps_sensor.attr,
+	&dev_attr_enable_als_sensor.attr,
+	&dev_attr_als_poll_delay.attr,
+#endif
+	/*calibration*/
+	&dev_attr_status.attr,
+	&dev_attr_ps_run_calibration.attr,
+	&dev_attr_ps_default_crosstalk.attr,
+	&dev_attr_ps_cal_result.attr,
 	NULL
 };
 
-static struct attribute_group apds990x_attribute_group[] = {
-	{.attrs = sysfs_attrs_ctrl },
+static const struct attribute_group apds990x_attr_group = {
+	.attrs = apds990x_attributes,
 };
 
-static int apds990x_probe(struct i2c_client *client,
-				const struct i2c_device_id *id)
+static const struct file_operations apds990x_ps_fops = {
+	.owner = THIS_MODULE,
+	.open = apds990x_ps_open,
+	.release = apds990x_ps_release,
+	.unlocked_ioctl = apds990x_ps_ioctl,
+};
+
+static struct miscdevice apds990x_ps_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "apds990x_ps_dev",
+	.fops = &apds990x_ps_fops,
+};
+
+static const struct file_operations apds990x_als_fops = {
+	.owner = THIS_MODULE,
+	.open = apds990x_als_open,
+	.release = apds990x_als_release,
+	.unlocked_ioctl = apds990x_als_ioctl,
+};
+
+static struct miscdevice apds990x_als_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "apds990x_als_dev",
+	.fops = &apds990x_als_fops,
+};
+
+/*
+ * Initialization function
+ */
+
+static int apds990x_init_client(struct i2c_client *client)
 {
-	struct apds990x_chip *chip;
+	struct apds990x_data *data = i2c_get_clientdata(client);
 	int err;
+	int id;
 
-	chip = kzalloc(sizeof *chip, GFP_KERNEL);
-	if (!chip)
-		return -ENOMEM;
+	err = apds990x_set_enable(client, 0);
+	if (err < 0)
+		return err;
 
-	i2c_set_clientdata(client, chip);
-	chip->client  = client;
+	id = i2c_smbus_read_byte_data(client, CMD_BYTE|APDS990X_ID_REG);
+	switch (id) {
+	case APDS9931_ID:
+		dev_dbg(&client->dev, "APDS9931\n");
+		break;
 
-	init_waitqueue_head(&chip->wait);
-	mutex_init(&chip->mutex);
-	chip->pdata	= client->dev.platform_data;
+	case APDS9930_ID:
+		dev_dbg(&client->dev, "APDS9930\n");
+		break;
 
-	if (chip->pdata == NULL) {
-		dev_err(&client->dev, "platform data is mandatory\n");
-		err = -EINVAL;
-		goto fail1;
-	}
+	case APDS9900_ID:
+		dev_dbg(&client->dev, "APDS9900\n");
+		break;
 
-	if (chip->pdata->cf.ga == 0) {
-		/* set uncovered sensor default parameters */
-		chip->cf.ga = 1966; /* 0.48 * APDS_PARAM_SCALE */
-		chip->cf.cf1 = 4096; /* 1.00 * APDS_PARAM_SCALE */
-		chip->cf.irf1 = 9134; /* 2.23 * APDS_PARAM_SCALE */
-		chip->cf.cf2 = 2867; /* 0.70 * APDS_PARAM_SCALE */
-		chip->cf.irf2 = 5816; /* 1.42 * APDS_PARAM_SCALE */
-		chip->cf.df = 52;
-	} else {
-		chip->cf = chip->pdata->cf;
-	}
-
-	/* precalculate inverse chip factors for threshold control */
-	chip->rcf.afactor =
-		(chip->cf.irf1 - chip->cf.irf2) * APDS_PARAM_SCALE /
-		(chip->cf.cf1 - chip->cf.cf2);
-	chip->rcf.cf1 = APDS_PARAM_SCALE * APDS_PARAM_SCALE /
-		chip->cf.cf1;
-	chip->rcf.irf1 = chip->cf.irf1 * APDS_PARAM_SCALE /
-		chip->cf.cf1;
-	chip->rcf.cf2 = APDS_PARAM_SCALE * APDS_PARAM_SCALE /
-		chip->cf.cf2;
-	chip->rcf.irf2 = chip->cf.irf2 * APDS_PARAM_SCALE /
-		chip->cf.cf2;
-
-	/* Set something to start with */
-	chip->lux_thres_hi = APDS_LUX_DEF_THRES_HI;
-	chip->lux_thres_lo = APDS_LUX_DEF_THRES_LO;
-	chip->lux_calib = APDS_LUX_NEUTRAL_CALIB_VALUE;
-
-	chip->prox_thres = APDS_PROX_DEF_THRES;
-	chip->pdrive = chip->pdata->pdrive;
-	chip->pdiode = APDS_PDIODE_IR;
-	chip->pgain = APDS_PGAIN_1X;
-	chip->prox_calib = APDS_PROX_NEUTRAL_CALIB_VALUE;
-	chip->prox_persistence = APDS_DEFAULT_PROX_PERS;
-	chip->prox_continuous_mode = false;
-
-	chip->regs[0].supply = reg_vcc;
-	chip->regs[1].supply = reg_vled;
-
-	err = regulator_bulk_get(&client->dev,
-				 ARRAY_SIZE(chip->regs), chip->regs);
-	if (err < 0) {
-		dev_err(&client->dev, "Cannot get regulators\n");
-		goto fail1;
+	case APDS9901_ID:
+		dev_dbg(&client->dev, "APDS9931\n");
+		break;
+	default:
+		dev_err(&client->dev, "Neither APDS993x nor APDS990x\n");
+		return -ENODEV;
 	}
 
-	err = regulator_bulk_enable(ARRAY_SIZE(chip->regs), chip->regs);
-	if (err < 0) {
-		dev_err(&client->dev, "Cannot enable regulators\n");
-		goto fail2;
+	/* 100.64ms ALS integration time */
+	err = apds990x_set_atime(client,
+			apds990x_als_atime_tb[data->als_atime_index]);
+	if (err < 0)
+		return err;
+
+	/* 2.72ms Prox integration time */
+	err = apds990x_set_ptime(client, 0xFF);
+	if (err < 0)
+		return err;
+
+	/* 2.72ms Wait time */
+	err = apds990x_set_wtime(client, 0xFF);
+	if (err < 0)
+		return err;
+
+	err = apds990x_set_ppcount(client, apds990x_ps_pulse_number);
+	if (err < 0)
+		return err;
+
+	/* no long wait */
+	err = apds990x_set_config(client, 0);
+	if (err < 0)
+		return err;
+
+	err = apds990x_set_control(client,
+			APDS990X_PDRVIE_100MA |
+			APDS990X_PRX_IR_DIOD |
+			apds990x_ps_pgain |
+			apds990x_als_again_bit_tb[data->als_again_index]);
+	if (err < 0)
+		return err;
+
+	/* init threshold for proximity */
+	err = apds990x_set_pilt(client, 0);
+	if (err < 0)
+		return err;
+
+	err = apds990x_set_piht(client, apds990x_ps_detection_threshold);
+	if (err < 0)
+		return err;
+
+	/*calirbation*/
+	apds990x_set_ps_threshold_adding_cross_talk(client, data->cross_talk);
+	data->ps_detection = 0; /* initial value = far*/
+
+	/* force first ALS interrupt to get the environment reading */
+	err = apds990x_set_ailt(client, 0xFFFF);
+	if (err < 0)
+		return err;
+
+	err = apds990x_set_aiht(client, 0);
+	if (err < 0)
+		return err;
+
+	/* 2 consecutive Interrupt persistence */
+	err = apds990x_set_pers(client, APDS990X_PPERS_2|APDS990X_APERS_2);
+	if (err < 0)
+		return err;
+
+	/* sensor is in disabled mode but all the configurations are preset */
+	return 0;
+}
+
+static int apds990x_suspend(struct device *dev)
+{
+	struct apds990x_data *data;
+	struct apds990x_platform_data *pdata;
+
+	data = dev_get_drvdata(dev);
+	pdata = data->platform_data;
+
+	if (data->irq) {
+		irq_set_irq_wake(data->irq, 0);
+		disable_irq(data->irq);
 	}
 
-	usleep_range(APDS_STARTUP_DELAY, 2 * APDS_STARTUP_DELAY);
+	cancel_delayed_work_sync(&data->dwork);
+#ifdef ALS_POLLING_ENABLED
+	cancel_delayed_work_sync(&data->als_dwork);
+#endif
 
-	err = apds990x_detect(chip);
-	if (err < 0) {
-		dev_err(&client->dev, "APDS990X not found\n");
-		goto fail3;
+	if (pdata->power_on)
+		pdata->power_on(false);
+
+	return 0;
+}
+
+static int apds990x_resume(struct device *dev)
+{
+	struct apds990x_data *data;
+	struct apds990x_platform_data *pdata;
+
+	data = dev_get_drvdata(dev);
+	pdata = data->platform_data;
+
+	if (pdata->power_on)
+		pdata->power_on(true);
+
+	if (data->enable_ps_sensor)
+		apds990x_ps_set_enable(&data->ps_cdev, 1);
+
+	if (data->enable_als_sensor)
+		apds990x_als_set_enable(&data->als_cdev, 1);
+
+	if (data->irq) {
+		enable_irq(data->irq);
+		irq_set_irq_wake(data->irq, 1);
 	}
 
-	pm_runtime_set_active(&client->dev);
+	return 0;
+}
+
+static int sensor_regulator_configure(struct apds990x_data *data, bool on)
+{
+	int rc;
 
-	apds990x_configure(chip);
-	apds990x_set_arate(chip, APDS_LUX_DEFAULT_RATE);
-	apds990x_mode_on(chip);
+	if (!on) {
 
-	pm_runtime_enable(&client->dev);
+		if (regulator_count_voltages(data->vdd) > 0)
+			regulator_set_voltage(data->vdd, 0,
+				APDS990X_VDD_MAX_UV);
 
-	if (chip->pdata->setup_resources) {
-		err = chip->pdata->setup_resources();
-		if (err) {
-			err = -EINVAL;
-			goto fail3;
+		regulator_put(data->vdd);
+
+		if (regulator_count_voltages(data->vio) > 0)
+			regulator_set_voltage(data->vio, 0,
+				APDS990X_VIO_MAX_UV);
+
+		regulator_put(data->vio);
+	} else {
+		data->vdd = regulator_get(&data->client->dev, "vdd");
+		if (IS_ERR(data->vdd)) {
+			rc = PTR_ERR(data->vdd);
+			dev_err(&data->client->dev,
+				"Regulator get failed vdd rc=%d\n", rc);
+			return rc;
 		}
-	}
 
-	err = sysfs_create_group(&chip->client->dev.kobj,
-				apds990x_attribute_group);
-	if (err < 0) {
-		dev_err(&chip->client->dev, "Sysfs registration failed\n");
-		goto fail4;
-	}
+		if (regulator_count_voltages(data->vdd) > 0) {
+			rc = regulator_set_voltage(data->vdd,
+				APDS990X_VDD_MIN_UV, APDS990X_VDD_MAX_UV);
+			if (rc) {
+				dev_err(&data->client->dev,
+					"Regulator set failed vdd rc=%d\n",
+					rc);
+				goto reg_vdd_put;
+			}
+		}
 
-	err = request_threaded_irq(client->irq, NULL,
-				apds990x_irq,
-				IRQF_TRIGGER_FALLING | IRQF_TRIGGER_LOW |
-				IRQF_ONESHOT,
-				"apds990x", chip);
-	if (err) {
-		dev_err(&client->dev, "could not get IRQ %d\n",
-			client->irq);
-		goto fail5;
+		data->vio = regulator_get(&data->client->dev, "vio");
+		if (IS_ERR(data->vio)) {
+			rc = PTR_ERR(data->vio);
+			dev_err(&data->client->dev,
+				"Regulator get failed vio rc=%d\n", rc);
+			goto reg_vdd_set;
+		}
+
+		if (regulator_count_voltages(data->vio) > 0) {
+			rc = regulator_set_voltage(data->vio,
+				APDS990X_VIO_MIN_UV, APDS990X_VIO_MAX_UV);
+			if (rc) {
+				dev_err(&data->client->dev,
+				"Regulator set failed vio rc=%d\n", rc);
+				goto reg_vio_put;
+			}
+		}
 	}
-	return err;
-fail5:
-	sysfs_remove_group(&chip->client->dev.kobj,
-			&apds990x_attribute_group[0]);
-fail4:
-	if (chip->pdata && chip->pdata->release_resources)
-		chip->pdata->release_resources();
-fail3:
-	regulator_bulk_disable(ARRAY_SIZE(chip->regs), chip->regs);
-fail2:
-	regulator_bulk_free(ARRAY_SIZE(chip->regs), chip->regs);
-fail1:
-	kfree(chip);
-	return err;
+
+	return 0;
+reg_vio_put:
+	regulator_put(data->vio);
+
+reg_vdd_set:
+	if (regulator_count_voltages(data->vdd) > 0)
+		regulator_set_voltage(data->vdd, 0, APDS990X_VDD_MAX_UV);
+reg_vdd_put:
+	regulator_put(data->vdd);
+	return rc;
 }
 
-static int apds990x_remove(struct i2c_client *client)
+static int sensor_regulator_power_on(struct apds990x_data *data, bool on)
 {
-	struct apds990x_chip *chip = i2c_get_clientdata(client);
+	int rc = 0;
+
+	if (!on) {
+		rc = regulator_disable(data->vdd);
+		if (rc) {
+			dev_err(&data->client->dev,
+				"Regulator vdd disable failed rc=%d\n", rc);
+			return rc;
+		}
+
+		rc = regulator_disable(data->vio);
+		if (rc) {
+			dev_err(&data->client->dev,
+				"Regulator vio disable failed rc=%d\n", rc);
+			rc = regulator_enable(data->vdd);
+		}
+	} else {
+		rc = regulator_enable(data->vdd);
+		if (rc) {
+			dev_err(&data->client->dev,
+				"Regulator vdd enable failed rc=%d\n", rc);
+			return rc;
+		}
+
+		rc = regulator_enable(data->vio);
+		if (rc) {
+			dev_err(&data->client->dev,
+				"Regulator vio enable failed rc=%d\n", rc);
+			rc = regulator_disable(data->vdd);
+		}
+	}
 
-	free_irq(client->irq, chip);
-	sysfs_remove_group(&chip->client->dev.kobj,
-			apds990x_attribute_group);
+	msleep(130);
 
-	if (chip->pdata && chip->pdata->release_resources)
-		chip->pdata->release_resources();
+	return rc;
+}
 
-	if (!pm_runtime_suspended(&client->dev))
-		apds990x_chip_off(chip);
+static int sensor_platform_hw_power_on(bool on)
+{
+	int err;
 
-	pm_runtime_disable(&client->dev);
-	pm_runtime_set_suspended(&client->dev);
+	if (pdev_data == NULL)
+		return -ENODEV;
 
-	regulator_bulk_free(ARRAY_SIZE(chip->regs), chip->regs);
+	if (!IS_ERR_OR_NULL(pdev_data->pinctrl)) {
+		if (on)
+			err = pinctrl_select_state(pdev_data->pinctrl,
+				pdev_data->pin_default);
+		else
+			err = pinctrl_select_state(pdev_data->pinctrl,
+				pdev_data->pin_sleep);
+		if (err)
+			dev_err(&pdev_data->client->dev,
+				"Can't select pinctrl state\n");
+	}
+	sensor_regulator_power_on(pdev_data, on);
 
-	kfree(chip);
 	return 0;
 }
 
-#ifdef CONFIG_PM_SLEEP
-static int apds990x_suspend(struct device *dev)
+static int sensor_platform_hw_init(void)
 {
-	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
-	struct apds990x_chip *chip = i2c_get_clientdata(client);
+	struct i2c_client *client;
+	struct apds990x_data *data;
+	int error;
+
+	if (pdev_data == NULL)
+		return -ENODEV;
 
-	apds990x_chip_off(chip);
+	data = pdev_data;
+	client = data->client;
+
+	error = sensor_regulator_configure(data, true);
+	if (error < 0) {
+		dev_err(&client->dev, "unable to configure regulator\n");
+		return error;
+	}
+
+	if (gpio_is_valid(data->platform_data->irq_gpio)) {
+		/* configure apds990x irq gpio */
+		error = gpio_request_one(data->platform_data->irq_gpio,
+				GPIOF_DIR_IN,
+				"apds990x_irq_gpio");
+		if (error) {
+			dev_err(&client->dev, "unable to request gpio %d\n",
+				data->platform_data->irq_gpio);
+		}
+		data->irq = client->irq =
+			gpio_to_irq(data->platform_data->irq_gpio);
+	} else {
+		dev_err(&client->dev, "irq gpio not provided\n");
+	}
 	return 0;
 }
 
-static int apds990x_resume(struct device *dev)
+static void sensor_platform_hw_exit(void)
 {
-	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
-	struct apds990x_chip *chip = i2c_get_clientdata(client);
+	struct apds990x_data *data = pdev_data;
 
-	/*
-	 * If we were enabled at suspend time, it is expected
-	 * everything works nice and smoothly. Chip_on is enough
-	 */
-	apds990x_chip_on(chip);
+	if (data == NULL)
+		return;
 
-	return 0;
+	sensor_regulator_configure(data, false);
+
+	if (gpio_is_valid(data->platform_data->irq_gpio))
+		gpio_free(data->platform_data->irq_gpio);
 }
-#endif
 
-#ifdef CONFIG_PM_RUNTIME
-static int apds990x_runtime_suspend(struct device *dev)
+static int apds990x_pinctrl_init(struct apds990x_data *data)
 {
-	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
-	struct apds990x_chip *chip = i2c_get_clientdata(client);
+	struct i2c_client *client = data->client;
+
+	data->pinctrl = devm_pinctrl_get(&client->dev);
+	if (IS_ERR_OR_NULL(data->pinctrl)) {
+		dev_err(&client->dev, "Failed to get pinctrl\n");
+		return PTR_ERR(data->pinctrl);
+	}
+
+	data->pin_default =
+		pinctrl_lookup_state(data->pinctrl, "default");
+	if (IS_ERR_OR_NULL(data->pin_default)) {
+		dev_err(&client->dev, "Failed to look up default state\n");
+		return PTR_ERR(data->pin_default);
+	}
+
+	data->pin_sleep =
+		pinctrl_lookup_state(data->pinctrl, "sleep");
+	if (IS_ERR_OR_NULL(data->pin_sleep)) {
+		dev_err(&client->dev, "Failed to look up sleep state\n");
+		return PTR_ERR(data->pin_sleep);
+	}
 
-	apds990x_chip_off(chip);
 	return 0;
 }
 
-static int apds990x_runtime_resume(struct device *dev)
+static int sensor_parse_dt(struct device *dev,
+		struct apds990x_platform_data *pdata)
 {
-	struct i2c_client *client = container_of(dev, struct i2c_client, dev);
-	struct apds990x_chip *chip = i2c_get_clientdata(client);
+	struct device_node *np = dev->of_node;
+	unsigned int tmp;
+	int rc = 0;
+
+	/* set functions of platform data */
+	pdata->init = sensor_platform_hw_init;
+	pdata->exit = sensor_platform_hw_exit;
+	pdata->power_on = sensor_platform_hw_power_on;
+
+	/* irq gpio */
+	rc = of_get_named_gpio_flags(dev->of_node,
+			"avago,irq-gpio", 0, NULL);
+	if (rc < 0) {
+		dev_err(dev, "Unable to read irq gpio\n");
+		return rc;
+	}
+	pdata->irq_gpio = rc;
+
+	/* ps tuning data*/
+	rc = of_property_read_u32(np, "avago,ps-threshold", &tmp);
+	if (rc) {
+		dev_err(dev, "Unable to read ps threshold\n");
+		return rc;
+	}
+	pdata->prox_threshold = tmp;
+
+	rc = of_property_read_u32(np, "avago,ps-hysteresis-threshold", &tmp);
+	 if (rc) {
+		dev_err(dev, "Unable to read ps hysteresis threshold\n");
+		return rc;
+	}
+	pdata->prox_hsyteresis_threshold = tmp;
+
+	rc = of_property_read_u32(np, "avago,ps-pulse", &tmp);
+	if (rc) {
+		dev_err(dev, "Unable to read ps pulse\n");
+		return rc;
+	}
+	pdata->prox_pulse = tmp;
+
+	rc = of_property_read_u32(np, "avago,ps-pgain", &tmp);
+	if (rc) {
+		dev_err(dev, "Unable to read ps pgain\n");
+		return rc;
+	}
+	pdata->prox_gain = tmp;
+
+	/* ALS tuning value */
+	rc = of_property_read_u32(np, "avago,als-B", &tmp);
+	if (rc) {
+		dev_err(dev, "Unable to read apds990x coefficient b\n");
+		return rc;
+	}
+	pdata->als_B = tmp;
+
+	rc = of_property_read_u32(np, "avago,als-C", &tmp);
+	if (rc) {
+		dev_err(dev, "Unable to read apds990x coefficient c\n");
+		return rc;
+	}
+	pdata->als_C = tmp;
+
+	rc = of_property_read_u32(np, "avago,als-D", &tmp);
+	if (rc) {
+		dev_err(dev, "Unable to read apds990x coefficient d\n");
+		return rc;
+	}
+	pdata->als_D = tmp;
+
+	rc = of_property_read_u32(np, "avago,ga-value", &tmp);
+	if (rc) {
+		dev_err(dev, "Unable to read gain value\n");
+		return rc;
+	}
+	pdata->ga_value = tmp;
 
-	apds990x_chip_on(chip);
 	return 0;
 }
 
+/*
+ * I2C init/probing/exit functions
+ */
+static struct i2c_driver apds990x_driver;
+static int apds990x_probe(struct i2c_client *client,
+				   const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+	struct apds990x_data *data;
+	struct apds990x_platform_data *pdata;
+	int err = 0;
+
+	pr_debug("%s\n", __func__);
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE)) {
+		err = -EIO;
+		goto exit;
+	}
+
+	if (client->dev.of_node) {
+		pdata = devm_kzalloc(&client->dev,
+				sizeof(struct apds990x_platform_data),
+				GFP_KERNEL);
+		if (!pdata) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			return -ENOMEM;
+		}
+
+		client->dev.platform_data = pdata;
+		err = sensor_parse_dt(&client->dev, pdata);
+		if (err) {
+			pr_err("%s: sensor_parse_dt() err\n", __func__);
+			return err;
+		}
+	} else {
+		pdata = client->dev.platform_data;
+		if (!pdata) {
+			dev_err(&client->dev, "No platform data\n");
+			return -ENODEV;
+		}
+	}
+
+	/* Set the default parameters */
+	apds990x_ps_detection_threshold = pdata->prox_threshold;
+	apds990x_ps_hsyteresis_threshold = pdata->prox_hsyteresis_threshold;
+	apds990x_ps_pulse_number = pdata->prox_pulse;
+	apds990x_ps_pgain = pdata->prox_gain;
+
+	apds990x_coe_b = pdata->als_B;
+	apds990x_coe_c = pdata->als_C;
+	apds990x_coe_d = pdata->als_D;
+	apds990x_ga = pdata->ga_value;
+
+	data = kzalloc(sizeof(struct apds990x_data), GFP_KERNEL);
+	if (!data) {
+		dev_err(&client->dev, "Failed to allocate memory\n");
+		err = -ENOMEM;
+		goto exit;
+	}
+	pdev_data = data;
+
+	data->platform_data = pdata;
+	data->client = client;
+	apds990x_i2c_client = client;
+
+	/* initialize pinctrl */
+	err = apds990x_pinctrl_init(data);
+	if (err) {
+		dev_err(&client->dev, "Can't initialize pinctrl\n");
+			goto exit_kfree;
+	}
+	err = pinctrl_select_state(data->pinctrl, data->pin_default);
+	if (err) {
+		dev_err(&client->dev,
+			"Can't select pinctrl default state\n");
+		goto exit_kfree;
+	}
+
+	/* h/w initialization */
+	if (pdata->init)
+		err = pdata->init();
+
+	if (pdata->power_on)
+		err = pdata->power_on(true);
+
+	/*i2c_set_clientdata(client, data);*/
+
+	data->enable = 0;	/* default mode is standard */
+	data->ps_detection = 0;	/* default to no detection */
+	data->enable_als_sensor = 0;
+	data->enable_ps_sensor = 0;
+	data->als_poll_delay = 100;
+	data->als_atime_index = APDS990X_ALS_RES_37888;
+	data->als_again_index = APDS990X_ALS_GAIN_8X;
+	data->als_reduce = 0;
+	data->als_prev_lux = 0;
+	data->piht = apds990x_ps_detection_threshold;
+	data->pilt = apds990x_ps_hsyteresis_threshold;
+	i2c_set_clientdata(client, data);
+	/* calibration */
+	if (apds990x_cross_talk_val > 0 && apds990x_cross_talk_val < 1000) {
+		data->cross_talk = apds990x_cross_talk_val;
+	} else {
+		/*
+		 * default value: Get the cross-talk value from the memory.
+		 * This value is saved during the cross-talk calibration
+		 */
+		data->cross_talk = DEFAULT_CROSS_TALK;
+	}
+
+	mutex_init(&data->update_lock);
+
+	INIT_DELAYED_WORK(&data->dwork, apds990x_work_handler);
+
+#ifdef ALS_POLLING_ENABLED
+	INIT_DELAYED_WORK(&data->als_dwork, apds990x_als_polling_work_handler);
 #endif
 
+	/* Initialize the APDS990X chip */
+	err = apds990x_init_client(client);
+	if (err) {
+		pr_err("%s: Failed to init apds990x\n", __func__);
+		goto exit_uninit;
+	}
+	high = apds990x_ps_detection_threshold;
+	low = apds990x_ps_hsyteresis_threshold;
+	err = request_irq(data->irq, apds990x_interrupt, IRQF_TRIGGER_FALLING,
+				APDS990X_DRV_NAME, (void *)client);
+	if (err < 0) {
+		pr_err("%s: Could not allocate APDS990X_INT !\n", __func__);
+		goto exit_uninit;
+	}
+
+	irq_set_irq_wake(client->irq, 1);
+
+	/* Register to Input Device */
+	data->input_dev_als = input_allocate_device();
+	if (!data->input_dev_als) {
+		err = -ENOMEM;
+		pr_err("%s: Failed to allocate input device als\n", __func__);
+		goto exit_free_irq;
+	}
+
+	data->input_dev_ps = input_allocate_device();
+	if (!data->input_dev_ps) {
+		err = -ENOMEM;
+		pr_err("%s: Failed to allocate input device ps\n", __func__);
+		goto exit_free_dev_als;
+	}
+
+	set_bit(EV_ABS, data->input_dev_als->evbit);
+	set_bit(EV_ABS, data->input_dev_ps->evbit);
+
+	input_set_abs_params(data->input_dev_als, ABS_MISC, 0, 60000, 0, 0);
+	input_set_abs_params(data->input_dev_ps, ABS_DISTANCE, 0, 1, 0, 0);
+
+	data->input_dev_als->name = "light";
+	data->input_dev_ps->name = "proximity";
+
+	err = input_register_device(data->input_dev_als);
+	if (err) {
+		err = -ENOMEM;
+		pr_err("%s: Unable to register input device als: %s\n",
+				__func__, data->input_dev_als->name);
+		goto exit_free_dev_ps;
+	}
+
+	err = input_register_device(data->input_dev_ps);
+	if (err) {
+		err = -ENOMEM;
+		pr_err("%s: Unable to register input device ps: %s\n",
+				__func__, data->input_dev_ps->name);
+		goto exit_unregister_dev_als;
+	}
+
+	/* Register sysfs hooks */
+	err = sysfs_create_group(&client->dev.kobj, &apds990x_attr_group);
+	if (err)
+		goto exit_unregister_dev_ps;
+
+	/* Register for sensor ioctl */
+	err = misc_register(&apds990x_ps_device);
+	if (err) {
+		pr_err("%s: Unable to register ps ioctl: %d", __func__, err);
+		goto exit_remove_sysfs_group;
+	}
+
+	err = misc_register(&apds990x_als_device);
+	if (err) {
+		pr_err("%s: Unable to register als ioctl: %d", __func__,  err);
+		goto exit_unregister_ps_ioctl;
+	}
+
+	/* Register to sensors class */
+	data->als_cdev = sensors_light_cdev;
+	data->als_cdev.sensors_enable = apds990x_als_set_enable;
+	data->als_cdev.sensors_poll_delay = apds990x_als_poll_delay;
+	data->ps_cdev = sensors_proximity_cdev;
+	data->ps_cdev.sensors_enable = apds990x_ps_set_enable;
+	data->ps_cdev.sensors_poll_delay = NULL;
+
+	err = sensors_classdev_register(&client->dev, &data->als_cdev);
+	if (err) {
+		pr_err("%s: Unable to register to sensors class: %d\n",
+				__func__, err);
+		goto exit_unregister_als_ioctl;
+	}
+
+	err = sensors_classdev_register(&client->dev, &data->ps_cdev);
+	if (err) {
+		pr_err("%s: Unable to register to sensors class: %d\n",
+			       __func__, err);
+		goto exit_unregister_als_class;
+	}
+
+	pr_info("%s: Support ver. %s enabled\n", __func__, DRIVER_VERSION);
+
+	return 0;
+
+exit_unregister_als_class:
+	sensors_classdev_unregister(&data->als_cdev);
+exit_unregister_als_ioctl:
+	misc_deregister(&apds990x_als_device);
+exit_unregister_ps_ioctl:
+	misc_deregister(&apds990x_ps_device);
+exit_remove_sysfs_group:
+	sysfs_remove_group(&client->dev.kobj, &apds990x_attr_group);
+exit_unregister_dev_ps:
+	input_unregister_device(data->input_dev_ps);
+exit_unregister_dev_als:
+	input_unregister_device(data->input_dev_als);
+exit_free_dev_ps:
+exit_free_dev_als:
+exit_free_irq:
+	free_irq(data->irq, client);
+exit_uninit:
+	if (pdata->power_on)
+		pdata->power_on(false);
+	if (pdata->exit)
+		pdata->exit();
+exit_kfree:
+	kfree(data);
+	pdev_data = NULL;
+exit:
+	return err;
+}
+
+static int apds990x_remove(struct i2c_client *client)
+{
+	struct apds990x_data *data = i2c_get_clientdata(client);
+	struct apds990x_platform_data *pdata = data->platform_data;
+
+	/* Power down the device */
+	apds990x_set_enable(client, 0);
+
+	misc_deregister(&apds990x_als_device);
+	misc_deregister(&apds990x_ps_device);
+
+	sysfs_remove_group(&client->dev.kobj, &apds990x_attr_group);
+
+	input_unregister_device(data->input_dev_ps);
+	input_unregister_device(data->input_dev_als);
+
+	free_irq(client->irq, data);
+
+	if (pdata->power_on)
+		pdata->power_on(false);
+
+	if (pdata->exit)
+		pdata->exit();
+
+	kfree(data);
+	pdev_data = NULL;
+
+	return 0;
+}
+
 static const struct i2c_device_id apds990x_id[] = {
-	{"apds990x", 0 },
-	{}
+	{ "apds990x", 0 },
+	{ }
 };
-
 MODULE_DEVICE_TABLE(i2c, apds990x_id);
 
+static struct of_device_id apds990x_match_table[] = {
+	{ .compatible = "avago,apds990x",},
+};
+
 static const struct dev_pm_ops apds990x_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(apds990x_suspend, apds990x_resume)
-	SET_RUNTIME_PM_OPS(apds990x_runtime_suspend,
-			apds990x_runtime_resume,
-			NULL)
+	.suspend	= apds990x_suspend,
+	.resume	= apds990x_resume,
 };
 
 static struct i2c_driver apds990x_driver = {
-	.driver	 = {
-		.name	= "apds990x",
-		.owner	= THIS_MODULE,
-		.pm	= &apds990x_pm_ops,
+	.driver = {
+		.name   = APDS990X_DRV_NAME,
+		.owner  = THIS_MODULE,
+		.of_match_table = apds990x_match_table,
+		.pm = &apds990x_pm_ops,
 	},
-	.probe	  = apds990x_probe,
-	.remove	  = apds990x_remove,
+	.probe  = apds990x_probe,
+	.remove = apds990x_remove,
 	.id_table = apds990x_id,
 };
 
-module_i2c_driver(apds990x_driver);
+static int __init apds990x_init(void)
+{
+	apds990x_workqueue = create_workqueue("proximity_als");
+	if (!apds990x_workqueue) {
+		pr_err("%s: out of memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	return i2c_add_driver(&apds990x_driver);
+}
+
+static void __exit apds990x_exit(void)
+{
+	if (apds990x_workqueue)
+		destroy_workqueue(apds990x_workqueue);
+	i2c_del_driver(&apds990x_driver);
+}
+
+MODULE_AUTHOR("Lee Kai Koon <kai-koon.lee@avagotech.com>");
+MODULE_DESCRIPTION("APDS990X ambient light + proximity sensor driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRIVER_VERSION);
 
-MODULE_DESCRIPTION("APDS990X combined ALS and proximity sensor");
-MODULE_AUTHOR("Samu Onkalo, Nokia Corporation");
-MODULE_LICENSE("GPL v2");
+module_init(apds990x_init);
+module_exit(apds990x_exit);
diff --git a/include/linux/i2c/apds990x.h b/include/linux/i2c/apds990x.h
index d186fcc..7d2e636 100644
--- a/include/linux/i2c/apds990x.h
+++ b/include/linux/i2c/apds990x.h
@@ -2,7 +2,7 @@
  * This file is part of the APDS990x sensor driver.
  * Chip is combined proximity and ambient light sensor.
  *
- * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies).
+ * Copyright (C) 2010-2014 Nokia Corporation and/or its subsidiary(-ies).
  *
  * Contact: Samu Onkalo <samu.p.onkalo@nokia.com>
  *
@@ -25,7 +25,6 @@
 #ifndef __APDS990X_H__
 #define __APDS990X_H__
 
-
 #define APDS_IRLED_CURR_12mA	0x3
 #define APDS_IRLED_CURR_25mA	0x2
 #define APDS_IRLED_CURR_50mA	0x1
@@ -68,12 +67,58 @@ struct apds990x_chip_factors {
  *
  */
 
+/* POWER SUPPLY VOLTAGE RANGE */
+#define APDS990X_VDD_MIN_UV  2000000
+#define APDS990X_VDD_MAX_UV  3300000
+#define APDS990X_VIO_MIN_UV  1750000
+#define APDS990X_VIO_MAX_UV  1950000
+
+/* Analog voltage @2.7 V */
+#define AVDD_VTG_MIN_UV		3000000
+#define AVDD_VTG_MAX_UV		3000000
+#define AVDD_ACTIVE_LOAD_UA	15000
+
+/* Digital voltage @1.8 V */
+#define VDDIO_VTG_DIG_MIN_UV	1800000
+#define VDDIO_VTG_DIG_MAX_UV	1800000
+#define VDDIO_ACTIVE_LOAD_DIG_UA	10000
+
+#define VDDIO_I2C_VTG_MIN_UV	1800000
+#define VDDIO_I2C_VTG_MAX_UV	1800000
+#define VDDIO_I2C_LOAD_UA		10000
+
+
 struct apds990x_platform_data {
 	struct apds990x_chip_factors cf;
-	u8     pdrive;
-	u8     ppcount;
+	u8	   pdrive;
+	unsigned int  ppcount;
 	int    (*setup_resources)(void);
 	int    (*release_resources)(void);
+
+	int irq_num;
+	int (*power)(unsigned char onoff);
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(bool);
+
+	unsigned int prox_threshold;
+	unsigned int prox_hsyteresis_threshold;
+	unsigned int prox_pulse;
+	unsigned int prox_gain;
+	unsigned int als_threshold_hsyteresis;
+	unsigned int als_B;
+	unsigned int als_C;
+	unsigned int als_D;
+	unsigned int alsit;
+	unsigned int ga_value;
+	unsigned int df_value;
+	unsigned int atime;
+
+	bool i2c_pull_up;
+	bool digital_pwr_regulator;
+
+	unsigned int irq_gpio;
+	u32 irq_gpio_flags;
 };
 
 #endif
-- 
1.7.9.5

