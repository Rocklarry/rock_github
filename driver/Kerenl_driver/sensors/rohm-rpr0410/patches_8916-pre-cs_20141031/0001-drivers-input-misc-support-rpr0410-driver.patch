From ad502f324bbb1b36f4e925491142804fb7837b6c Mon Sep 17 00:00:00 2001
From: Yukun Wan <wanyk0402@thundersoft.com>
Date: Fri, 31 Oct 2014 15:51:44 +0800
Subject: [PATCH 1/3] drivers:input:misc: support rpr0410 driver

Driver support rpr0410

Change-Id: Icb0b66e8f2d1a2af118a21a650e774c47515ed51
Signed-off-by: Yukun Wan <wanyk0402@thundersoft.com>
---
 .../devicetree/bindings/input/misc/rpr0410.txt     |   31 +
 drivers/input/misc/Kconfig                         |    5 +
 drivers/input/misc/Makefile                        |    1 +
 drivers/input/misc/rpr0410_driver.c                | 2069 ++++++++++++++++++++
 include/linux/input/rpr0410_driver.h               |  251 +++
 5 files changed, 2357 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/input/misc/rpr0410.txt
 create mode 100644 drivers/input/misc/rpr0410_driver.c
 create mode 100644 include/linux/input/rpr0410_driver.h

diff --git a/Documentation/devicetree/bindings/input/misc/rpr0410.txt b/Documentation/devicetree/bindings/input/misc/rpr0410.txt
new file mode 100644
index 0000000..b7f9d15
--- /dev/null
+++ b/Documentation/devicetree/bindings/input/misc/rpr0410.txt
@@ -0,0 +1,31 @@
+Rohm rpr0410 L/P sensor
+
+Required properties:
+
+ - compatible		: Should be "rohm,rpr0410".
+ - reg			: i2c slave address of the device.
+ - vdd-supply		: Analog power supply needed to power device.
+ - vio-supply		: Digital IO power supply needed for IO and I2C.
+ - interrupt-parent	: Parent of interrupt.
+ - interrupts		: L/P sample interrupt to indicate new data ready.
+ - rohm,irq-gpio	: The gpio pin for the interrupt.
+ - rohm,highthr	: The threshold adc value for proximity sensor to trigger close  interrupt.
+ - rohm,lowthr		: The threshold adc value for proximity sensor to trigger.
+away interrupt.
+
+
+Example:
+
+		rohm@39 { /* Ambient light and proximity sensor */
+			compatible = "rohm,rpr0410";
+			reg = <0x39>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&rpr0410_default>;
+			interrupt-parent = <&msm_gpio>;
+			interrupts = <113 0x2002>;
+			vdd-supply = <&pm8916_l17>;
+			vio-supply = <&pm8916_l6>;
+			rohm,irq-gpio = <&msm_gpio 113 0x2002>;
+			rohm,prox_th_min = <46>;
+			rohm,prox_th_max = <80>;
+		};
diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index b358471..78810aa 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -818,6 +818,11 @@ config SENSORS_BMI058
 	help
 	 If you say yes here, you get support for Bosch Sensortec's
 	 sensor driver of BMI058.
+config ROHM_RPR0410
+	tristate "rpr0410 light/proximity sensor support"
+	depends on I2C=y
+	help
+	  If you say yes here you get support for ROHM's light/proximity sensors rpr0410.
 
 endif
 
diff --git a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
index 139a4fb..77fa9a1 100644
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -73,6 +73,7 @@ obj-$(CONFIG_SENSORS_AKM8963)		+= akm8963.o
 obj-$(CONFIG_SENSORS_AKM09911)		+= akm09911.o
 obj-$(CONFIG_SENSORS_LIS3DH)		+= lis3dh_acc.o
 obj-$(CONFIG_SENSORS_BMA2X2)	+= bstclass.o
+obj-$(CONFIG_ROHM_RPR0410)		+= rpr0410_driver.o
 
 obj-$(CONFIG_SENSORS_BMA2X2)	+= bma2x2.o
 
diff --git a/drivers/input/misc/rpr0410_driver.c b/drivers/input/misc/rpr0410_driver.c
new file mode 100644
index 0000000..a370a81
--- /dev/null
+++ b/drivers/input/misc/rpr0410_driver.c
@@ -0,0 +1,2069 @@
+/* drivers/input/misc/rpr0400_driver.c - ROHM RPR0400 Linux kernel driver
+ *
+ * Copyright (C) 2012-2014
+ * Written by Andy Mi <andy-mi@rohm.com.cn>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+/*
+ *  This is Linux kernel modules for ambient light + proximity sensor
+ *  Revision History
+ *  2012-7-19:	Ver. 1.0	New release together with a porting guide.
+ *  2012-8-14:	Ver. 1.1	Added calibration and set thresholds methods.
+ *Besides, the thresholds are automatically changed if a
+ *ps int is triggered to avoid constant interrupts.
+ */
+#define DEBUG
+#define VERBOSE_DEBUG
+#include <linux/debugfs.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/input.h>
+#include <linux/wakelock.h>
+#include <linux/input/rpr0410_driver.h>
+#include <linux/of_gpio.h>
+#include <linux/workqueue.h>
+#include <linux/regulator/consumer.h>
+
+/*************** Global Data ******************/
+/* parameter for als calculation */
+#define COEFFICIENT               (4)
+#define FUNCTION_1 1
+const unsigned long data0_coefficient[COEFFICIENT] = {1458, 2174, 1620, 517};
+const unsigned long data1_coefficient[COEFFICIENT] = {51649, 2949,  1507,  138};
+const unsigned long judge_coefficient[COEFFICIENT] = {
+	131,  3841,  8056, 37307};
+/*
+const unsigned long data0_coefficient[COEFFICIENT] = {192, 141, 127, 117};
+const unsigned long data1_coefficient[COEFFICIENT] = {316, 108,  86,  74};
+const unsigned long judge_coefficient[COEFFICIENT] = { 29,  65,  85, 158};
+*/
+
+#define _AUTO_THRESHOLD_CHANGE_
+/* #define _INIT_CALIB_ */
+
+/* mode control table */
+#define MODE_CTL_FACTOR (16)
+static const struct MCTL_TABLE {
+	short ALS;
+	short PS;
+} mode_table[MODE_CTL_FACTOR] = {
+	{  0,   0},   /*  0 */
+	{  0,  10},   /*  1 */
+	{  0,  40},   /*  2 */
+	{  0, 100},   /*  3 */
+	{  0, 400},   /*  4 */
+	{100,   0},   /*  5 */
+	{100, 100},   /*  6 */
+	{100, 400},   /*  7 */
+	{400,   0},   /*  8 */
+	{400, 100},   /*  9 */
+	{400,   0},   /* 10 */
+	{400, 400},   /* 11 */
+	{  0,   0},   /* 12 */
+	{  0,   0},   /* 13 */
+	{  0,   0},   /* 14 */
+	{  0,   0}    /* 15 */
+};
+
+/*
+ * Global data
+ */
+struct ALS_PS_DATA *sensor_info;
+
+/* gain table */
+#define GAIN_FACTOR (16)
+static const struct GAIN_TABLE {
+	char DATA0;
+	char DATA1;
+} gain_table[GAIN_FACTOR] = {
+	{  1,   1},   /*  0 */
+	{  0,   0},   /*  1 */
+	{  0,   0},   /*  2 */
+	{  0,   0},   /*  3 */
+	{  2,   1},   /*  1 */
+	{  2,   2},   /*  5 */
+	{  0,   0},   /*  6 */
+	{  0,   0},   /*  7 */
+	{  0,   0},   /*  8 */
+	{  0,   0},   /*  9 */
+	{ 64,  64},   /* 10 */
+	{  0,   0},   /* 11 */
+	{  0,   0},   /* 12 */
+	{  0,   0},   /* 13 */
+	{128,  64},   /* 14 */
+	{128, 128}    /* 15 */
+};
+
+static int rpr400_init_client(struct i2c_client *client);
+
+/*************** Functions ******************/
+/******************************************************************************
+ * NAME       : rpr400_set_enable
+ * FUNCTION   : set measurement time according to enable
+ * REMARKS    : this function will overwrite the work mode.
+ *				if it is called improperly,
+ *				you may shutdown some part unexpectedly.
+ *				please check als_ps->enable first.
+ *				I assume it is run in normal mode.
+ *				If you want low noise mode,
+ *				the code should be modified.
+ *****************************************************************************/
+static int rpr400_set_enable(struct i2c_client *client, int enable)
+{
+	struct ALS_PS_DATA *als_ps = i2c_get_clientdata(client);
+	int ret;
+
+	if (enable > 0x0B) {
+		pr_info("%s: invalid measurement time setting.\n", __func__);
+		return -EINVAL;
+	} else {
+		mutex_lock(&als_ps->update_lock);
+		ret = i2c_smbus_write_byte_data(client,
+			REG_MODECONTROL, enable);
+		mutex_unlock(&als_ps->update_lock);
+
+		als_ps->enable = enable;
+		als_ps->als_time = mode_table[(enable & 0xF)].ALS;
+		als_ps->ps_time = mode_table[(enable & 0xF)].PS;
+
+		return ret;
+	}
+}
+
+static int rpr400_set_ps_threshold_low(struct i2c_client *client, int threshold)
+{
+	struct ALS_PS_DATA *als_ps = i2c_get_clientdata(client);
+	int ret;
+	unsigned short write_data;
+
+    /* check whether the parameter is valid */
+	if (threshold > REG_PSTL_MAX) {
+		pr_info("%s: exceed maximum possible value.\n", __func__);
+		return -EINVAL;
+	}
+	if (threshold > als_ps->ps_th_h) {
+		pr_info("%s: higher than threshold high.\n", __func__);
+		return -EINVAL;
+	}
+
+    /* write register to RPR400 via i2c */
+	write_data = CONVERT_TO_BE(threshold);
+	mutex_lock(&als_ps->update_lock);
+	ret = i2c_smbus_write_i2c_block_data(client,
+		REG_PSTL, sizeof(write_data), (unsigned char *)&write_data);
+	mutex_unlock(&als_ps->update_lock);
+	if (ret < 0) {
+		pr_info("%s: write i2c fail.\n", __func__);
+		return ret;
+	}
+	als_ps->ps_th_l = threshold;
+
+	return 0;
+}
+
+static int rpr400_set_ps_threshold_high
+	(struct i2c_client *client, int threshold)
+{
+	struct ALS_PS_DATA *als_ps = i2c_get_clientdata(client);
+	int ret;
+	unsigned short write_data;
+
+    /* check whether the parameter is valid */
+	if (threshold > REG_PSTH_MAX) {
+		pr_info("%s: exceed maximum possible value.\n", __func__);
+		return -EINVAL;
+	}
+	if (threshold < als_ps->ps_th_l) {
+		pr_info("%s: lower than threshold low.\n", __func__);
+		return -EINVAL;
+	}
+
+    /* write register to RPR400 via i2c */
+	write_data = CONVERT_TO_BE(threshold);
+	mutex_lock(&als_ps->update_lock);
+	ret = i2c_smbus_write_i2c_block_data(client, REG_PSTH,
+		sizeof(write_data), (unsigned char *)&write_data);
+	mutex_unlock(&als_ps->update_lock);
+	if (ret < 0) {
+		pr_info("%s: write i2c fail.\n", __func__);
+		return ret;
+	}
+	als_ps->ps_th_h = threshold;
+
+	return 0;
+}
+
+static int rpr400_calibrate(struct i2c_client *client)
+{
+	struct ALS_PS_DATA *als_ps = i2c_get_clientdata(client);
+	int average;
+	unsigned int i, tmp, ps_th_h, ps_th_l;
+
+	average = 0;
+
+	rpr400_set_enable(client, 0x01);
+
+	for (i = 0; i < 20; i++) {
+		tmp = i2c_smbus_read_word_data(client, REG_PSDATA);
+		if (tmp < 0) {
+			pr_info("%s: i2c read ps data fail.\n", __func__);
+			goto err_exit;
+		}
+		average += tmp & 0xFFF;
+	}
+	average /= 20;
+/*
+	ps_th_h = average + PS_ALS_SET_PS_TH;
+	ps_th_l = average + PS_ALS_SET_PS_TL;
+*/
+	ps_th_h = average + THRES_TOLERANCE + THRES_DEFAULT_DIFF;
+	ps_th_l = average + THRES_TOLERANCE;
+
+	if (ps_th_h < 0) {
+		pr_info("%s: high threshold is less than 0.\n", __func__);
+		goto err_exit;
+	}
+	if (ps_th_h > REG_PSTH_MAX) {
+		pr_info("%s: high threshold is greater than maximum allowed value.\n",
+			__func__);
+		goto err_exit;
+	}
+	if (ps_th_l < 0) {
+		pr_info("%s: low threshold is less than 0.\n", __func__);
+		goto err_exit;
+	}
+	if (ps_th_l > REG_PSTL_MAX) {
+		pr_info("%s: low threshold is greater than maximum allowed value.\n",
+			__func__);
+		goto err_exit;
+	}
+
+	if (!(rpr400_set_ps_threshold_high(client, ps_th_h)))
+		als_ps->ps_th_h_back = ps_th_h;
+	else
+		goto err_exit;
+	if (!(rpr400_set_ps_threshold_low(client, ps_th_l)))
+		als_ps->ps_th_l_back = ps_th_l;
+	else
+		goto err_exit;
+
+	rpr400_set_enable(client, 0);
+	return 0;
+
+err_exit:
+	rpr400_set_enable(client, 0);
+	return -EINVAL;
+}
+
+#if _FUNCTION_USED_
+static int rpr400_set_persist(struct i2c_client *client, int persist)
+{
+	struct ALS_PS_DATA *als_ps = i2c_get_clientdata(client);
+	int ret;
+
+    /* check whether the parameter is valid */
+	if (persist > PERSISTENCE_MAX) {
+		pr_info("%s: exceed maximum possible value.\n", __func__);
+		return -EINVAL;
+	}
+
+    /* write register to RPR400 via i2c */
+	mutex_lock(&als_ps->update_lock);
+	ret = i2c_smbus_write_byte_data(client, REG_PERSISTENCE, persist);
+	mutex_unlock(&als_ps->update_lock);
+	if (ret < 0) {
+		pr_info("%s: write i2c fail.\n", __func__);
+		return ret;
+	}
+	als_ps->persistence = persist;
+
+	return 0;
+}
+
+static int rpr400_set_control(struct i2c_client *client, int control)
+{
+	struct ALS_PS_DATA *als_ps = i2c_get_clientdata(client);
+	int ret;
+	unsigned char gain, led_current;
+
+	if (control > REG_ALSPSCTL_MAX) {
+		pr_info("%s: exceed maximum possible value.\n", __func__);
+		return -EINVAL;
+	}
+
+	gain = (control & 0x3C) >> 2;
+	led_current = control & 0x03;
+
+	if (!((gain == ALSGAIN_X1X1) || (gain == ALSGAIN_X1X2) ||
+		(gain == ALSGAIN_X2X2) || (gain == ALSGAIN_X64X64)
+		|| (gain == ALSGAIN_X128X64) || (gain == ALSGAIN_X128X128))) {
+		pr_info("%s: invalid gain setting.\n", __func__);
+		return -EINVAL;
+	}
+
+	mutex_lock(&als_ps->update_lock);
+	ret = i2c_smbus_write_byte_data(client, REG_ALSPSCONTROL, control);
+	mutex_unlock(&als_ps->update_lock);
+	if (ret < 0) {
+		pr_info("%s: write i2c fail.\n", __func__);
+		return ret;
+	}
+	als_ps->control = control;
+	als_ps->gain0 = gain_table[gain].DATA0;
+	als_ps->gain1 = gain_table[gain].DATA1;
+	als_ps->ledcurrent = led_current;
+
+	return ret;
+}
+#endif
+
+
+#if FUNCTION_1
+/******************************************************************************
+ * NAME       : long_long_divider
+ * FUNCTION   : calc divider of unsigned long long int or unsgined long
+ * REMARKS    :
+ *****************************************************************************/
+static void long_long_divider(unsigned long long data,
+unsigned long base_divier, unsigned long *answer,
+unsigned long long *overplus)
+{
+	unsigned long long divier;
+	unsigned long      unit_sft;
+
+	if ((long long)data < 0) {
+		data /= 2;
+		base_divier /= 2;
+	}
+	divier = base_divier;
+	if (data > MASK_LONG) {
+		unit_sft = 0;
+
+		while (data > divier) {
+			unit_sft++;
+			divier = divier << 1;
+		}
+
+		while (data > base_divier) {
+			if (data > divier) {
+				*answer += 1 << unit_sft;
+				data    -= divier;
+			}
+			unit_sft--;
+			divier = divier >> 1;
+		}
+
+		*overplus = data;
+	} else {
+		*answer = (unsigned long)(data & MASK_LONG) / base_divier;
+		/* calculate over plus and shift 16bit */
+		*overplus = (unsigned long long)
+		(data - (*answer * base_divier));
+	}
+}
+
+/******************************************************************************
+ * NAME       : calc_rohm_als_data
+ * FUNCTION   : calculate illuminance data for RPR400
+ * REMARKS    : final_data is 1000 times, which is defined as CUT_UNIT,
+ *			of the actual lux value
+ *****************************************************************************/
+
+static int calc_rohm_als_data(unsigned short data0,
+unsigned short data1, unsigned char gain0, unsigned char gain1,
+unsigned char time)
+{
+#define DECIMAL_BIT      (15)
+/*#define JUDGE_FIXED_COEF (100)*/
+#define JUDGE_FIXED_COEF (10000)
+#define MAX_OUTRANGE     (11357)
+#define MAXRANGE_NMODE   (0xFFFF)
+#define MAXSET_CASE      (4)
+
+	int                final_data;
+	struct CALC_DATA calc_data;
+	struct CALC_ANS calc_ans;
+	unsigned long      calc_judge;
+	unsigned char      set_case;
+	unsigned long      div_answer;
+	unsigned long long div_overplus;
+	unsigned long long overplus;
+	unsigned long      max_range;
+
+	calc_data.als_data0  = data0;
+	calc_data.als_data1  = data1;
+	calc_data.gain_data0 = gain0;
+
+	if (calc_data.gain_data0 == 0)
+		return CALC_ERROR;
+	else
+		max_range = MAX_OUTRANGE / calc_data.gain_data0;
+
+	if (calc_data.als_data0 == MAXRANGE_NMODE) {
+		calc_ans.positive = max_range;
+		calc_ans.decimal  = 0;
+	} else {
+		calc_data.als_time = time;
+		if (calc_data.als_time == 0)
+			return CALC_ERROR;
+
+		calc_judge = calc_data.als_data1 * JUDGE_FIXED_COEF;
+		if (calc_judge <
+			(calc_data.als_data0 * judge_coefficient[0]))
+			set_case = 0;
+		else if (calc_judge <
+			(calc_data.als_data0 * judge_coefficient[1]))
+			set_case = 1;
+		else if (calc_judge <
+			(calc_data.als_data0 * judge_coefficient[2]))
+			set_case = 2;
+		else if (calc_judge <
+			(calc_data.als_data0 * judge_coefficient[3]))
+			set_case = 3;
+		else
+			set_case = MAXSET_CASE;
+		calc_ans.positive = 0;
+		if (set_case >= MAXSET_CASE)
+			calc_ans.decimal = 0;
+		else {
+			calc_data.gain_data1 = gain1;
+			if (calc_data.gain_data1 == 0)
+				return CALC_ERROR;
+			calc_data.data0 = (unsigned long long)
+				(data0_coefficient[set_case]
+				* calc_data.als_data0) * calc_data.gain_data1;
+			calc_data.data1 = (unsigned long long)
+				(data1_coefficient[set_case]
+				* calc_data.als_data1) * calc_data.gain_data0;
+			if (set_case == 0)
+				calc_data.data =
+				(calc_data.data0 + calc_data.data1);
+			else {
+			/* In this case, data will be less than 0.
+			 * As data is unsigned long long,
+			 * it will become extremely big.
+			 */
+				if (calc_data.data0 < calc_data.data1)
+					return CALC_ERROR;
+				else
+					calc_data.data = (calc_data.data0 -
+						calc_data.data1);
+			}
+			calc_data.dev_unit   = calc_data.gain_data0 *
+				calc_data.gain_data1 * calc_data.als_time * 100;
+			if (calc_data.dev_unit == 0)
+				return CALC_ERROR;
+
+			div_answer   = 0;
+			div_overplus = 0;
+			long_long_divider(calc_data.data, calc_data.dev_unit,
+				&div_answer, &div_overplus);
+
+			calc_ans.positive = div_answer;
+			calc_ans.decimal = 0;
+			overplus         = div_overplus;
+			if (calc_ans.positive < max_range) {
+				if (overplus != 0) {
+					overplus = overplus << DECIMAL_BIT;
+					div_answer = 0;
+					div_overplus = 0;
+					long_long_divider(overplus,
+						calc_data.dev_unit,
+						&div_answer, &div_overplus);
+					calc_ans.decimal = div_answer;
+				}
+			} else
+				calc_ans.positive = max_range;
+		}
+	}
+
+	final_data = calc_ans.positive * CUT_UNIT +
+		((calc_ans.decimal * CUT_UNIT) >> DECIMAL_BIT);
+
+	return final_data;
+
+#undef DECIMAL_BIT
+#undef JUDGE_FIXED_COEF
+#undef MAX_OUTRANGE
+#undef MAXRANGE_NMODE
+#undef MAXSET_CASE
+}
+
+#else
+/******************************************************************************
+ * NAME       : long_long_divider
+ * FUNCTION   : calc divider of unsigned long long int or unsgined long
+ * REMARKS    :
+ *****************************************************************************/
+static int long_long_divider(long long data, unsigned long base_divier,
+unsigned long *answer, unsigned long long *overplus)
+{
+	long long divier;
+	long unit_sft;
+
+	if ((data < 0) || (base_divier == 0)) {
+		*answer   = 0;
+		*overplus = 0;
+		return CALC_ERROR;
+	}
+
+	divier = base_divier;
+	if (data > MASK_LONG) {
+		unit_sft = 0;
+		while ((data > divier) && (divier > 0)) {
+			unit_sft++;
+			divier = divier << 1;
+		}
+		while ((data > base_divier) && (unit_sft > 0)) {
+			if (data > divier) {
+				*answer += 1 << unit_sft;
+				data    -= divier;
+		}
+		unit_sft--;
+		divier = divier >> 1;
+	}
+	*overplus = data;
+	} else {
+		*answer = (unsigned long)(data & MASK_LONG) / base_divier;
+		/* calculate over plus and shift 16bit */
+		*overplus = (unsigned long long)(data -
+		(*answer * base_divier));
+	}
+
+	return 0;
+}
+
+/******************************************************************************
+ * NAME       : calculate_als_data
+ * FUNCTION   : calculate illuminance data for RPR400
+ * REMARKS    : final_data format
+ *            :+-------------------------+------------------------+
+ *            :| positive values : 17bit | decimal values : 15bit |
+ *            :+-------------------------+------------------------+
+ *****************************************************************************/
+static int calc_rohm_als_data(unsigned short data0, unsigned short data1,
+unsigned char gain0, unsigned char gain1, unsigned char time)
+{
+#define DECIMAL_BIT      (15)
+/*#define JUDGE_FIXED_COEF (100)*/
+#define JUDGE_FIXED_COEF (10000)
+#define MAX_OUTRANGE     (11357)
+#define MAXRANGE_NMODE   (0xFFFF)
+#define MAXRANGE_50MODE  (0x7FFF)
+#define MAXSET_CASE      (4)
+
+	int                result;
+	int                final_data;
+	CALC_DATA          calc_data;
+	CALC_ANS           calc_ans;
+	unsigned long      calc_judge;
+	unsigned char      set_case;
+	unsigned long      div_answer;
+	unsigned long long div_overplus;
+	unsigned long long overplus;
+	unsigned long      max_range;
+
+	/* set the value of measured als data */
+	calc_data.als_data0  = data0;
+	calc_data.als_data1  = data1;
+	calc_data.gain_data0 = gain0;
+
+	/* set max range */
+	if (calc_data.gain_data0 == 0)
+		/* issue error value when gain is 0 */
+		return CALC_ERROR;
+	else {
+		max_range = MAX_OUTRANGE / calc_data.gain_data0;
+	}
+	/* calculate data */
+	if (calc_data.als_data0 == MAXRANGE_NMODE) {
+		calc_ans.positive = max_range;
+		calc_ans.decimal  = 0;
+	} else {
+		/* get the value which is measured from power table */
+		calc_data.als_time = time;
+
+		calc_judge = calc_data.als_data1 * JUDGE_FIXED_COEF;
+		if (calc_judge < (calc_data.als_data0 * judge_coefficient[0]))
+			set_case = 0;
+		else if (calc_judge < (calc_data.als_data0 *
+			judge_coefficient[1]))
+			set_case = 1;
+		else if (calc_judge < (calc_data.als_data0 *
+			judge_coefficient[2]))
+			set_case = 2;
+		else if (calc_judge < (calc_data.als_data0 *
+			judge_coefficient[3]))
+			set_case = 3;
+		else
+			set_case = MAXSET_CASE;
+
+		calc_ans.positive = 0;
+		if (set_case >= MAXSET_CASE)
+			calc_ans.decimal = 0;
+		else {
+			calc_data.gain_data1 = gain1;
+			calc_data.data0 = (long long)
+				(data0_coefficient[set_case] *
+				calc_data.als_data0) * calc_data.gain_data1;
+			calc_data.data1 = (long long)
+				(data1_coefficient[set_case] *
+				calc_data.als_data1) * calc_data.gain_data0;
+			calc_data.data = (calc_data.data0 - calc_data.data1);
+			calc_data.dev_unit = calc_data.gain_data0 *
+				calc_data.gain_data1 * calc_data.als_time * 10;
+			/* calculate a positive number */
+			div_answer   = 0;
+			div_overplus = 0;
+			result = long_long_divider(calc_data.data,
+				calc_data.dev_unit, &div_answer, &div_overplus);
+
+			if (result == CALC_ERROR)
+				return result;
+			calc_ans.positive = div_answer;
+			/* calculate a decimal number */
+			calc_ans.decimal = 0;
+			overplus         = div_overplus;
+			if (calc_ans.positive < max_range) {
+				if (overplus != 0) {
+					overplus     = overplus << DECIMAL_BIT;
+					div_answer   = 0;
+					div_overplus = 0;
+					result = long_long_divider(overplus,
+						calc_data.dev_unit, &div_answer,
+						&div_overplus);
+					if (result == CALC_ERROR)
+						return result;
+					calc_ans.decimal = div_answer;
+				}
+			} else
+			calc_ans.positive = max_range;
+	}
+	final_data = calc_ans.positive * CUT_UNIT +
+		((calc_ans.decimal * CUT_UNIT) >> DECIMAL_BIT);
+
+	return final_data;
+
+#undef DECIMAL_BIT
+#undef JUDGE_FIXED_COEF
+#undef MAX_OUTRANGE
+#undef MAXRANGE_NMODE
+#undef MAXRANGE_50MODE
+#undef MAXSET_CASE
+}
+
+#endif
+/******************************************************************************
+ * NAME       : calculate_ps_data
+ * FUNCTION   : calculate proximity data for RPR400
+ * REMARKS    : 12 bit output
+ *****************************************************************************/
+static int calc_rohm_ps_data(unsigned short ps_reg_data)
+{
+	return ps_reg_data & 0xFFF;
+}
+
+static unsigned int rpr400_als_data_to_level(unsigned int als_data)
+{
+	return als_data;
+}
+
+static void rpr400_reschedule_work(struct ALS_PS_DATA *als_ps,
+					  unsigned long delay)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&als_ps->update_lock.wait_lock, flags);
+	/*
+	 * If work is already scheduled then subsequent schedules will not
+	 * change the scheduled time that's why we have to cancel it first.
+	 */
+	cancel_delayed_work(&als_ps->dwork);
+	schedule_delayed_work(&als_ps->dwork, delay);
+	spin_unlock_irqrestore(&als_ps->update_lock.wait_lock, flags);
+}
+
+/* ALS polling routine */
+static void rpr400_als_polling_work_handler(struct work_struct *work)
+{
+	struct ALS_PS_DATA *als_ps =
+		container_of(work, struct ALS_PS_DATA, als_dwork.work);
+	struct i2c_client *client = als_ps->client;
+	int tmp = 0;
+
+	schedule_delayed_work(&als_ps->als_dwork,
+		msecs_to_jiffies(atomic_read(&als_ps->delay)));
+
+	tmp = i2c_smbus_read_word_data(client, REG_ALSDATA0);
+	if (tmp < 0)
+		pr_info("%s: i2c read data0 fail.\n", __func__);
+	als_ps->als_data0_raw = (unsigned short)tmp;
+
+	tmp = i2c_smbus_read_word_data(client, REG_ALSDATA1);
+	if (tmp < 0)
+		pr_info("%s: i2c read data1 fail.\n", __func__);
+	als_ps->als_data1_raw = (unsigned short)tmp;
+
+
+	tmp = i2c_smbus_read_byte_data(client, REG_ALSPSCONTROL);
+	if (tmp < 0)
+		pr_info("%s: i2c read gain fail.\n", __func__);
+	tmp = (tmp & 0x3C) >> 2;
+	als_ps->gain0 = gain_table[tmp].DATA0;
+	als_ps->gain1 = gain_table[tmp].DATA1;
+
+	tmp = i2c_smbus_read_byte_data(client, REG_MODECONTROL);
+	if (tmp < 0)
+		pr_info("%s: i2c read time fail.\n", __func__);
+	tmp = tmp & 0xF;
+
+	als_ps->als_time = mode_table[tmp].ALS;
+
+	als_ps->als_data = calc_rohm_als_data(als_ps->als_data0_raw,
+		als_ps->als_data1_raw, als_ps->gain0,
+		als_ps->gain1, als_ps->als_time);
+
+	if (als_ps->als_data == 0)
+		als_ps->als_data++;
+
+	als_ps->als_level = rpr400_als_data_to_level(als_ps->als_data);
+/*
+	pr_info("RPR400 als report: data0 = %d, data1 = %d, gain0 = %d,
+	gain1 = %d, time = %d, lux = %d, level = %d.\n",
+	als_ps->als_data0_raw, als_ps->als_data1_raw, als_ps->gain0,
+	als_ps->gain1,als_ps->als_time, als_ps->als_data, als_ps->als_level);
+*/
+	if (als_ps->als_data != CALC_ERROR) {
+		input_report_abs(als_ps->input_dev_als,
+			ABS_MISC, als_ps->als_level);
+		input_sync(als_ps->input_dev_als);
+	}
+}
+
+
+/* PS interrupt routine */
+static void rpr400_ps_int_work_handler(struct work_struct *work)
+{
+	struct ALS_PS_DATA *als_ps = container_of((struct delayed_work *)work,
+		struct ALS_PS_DATA, dwork);
+	struct i2c_client *client = als_ps->client;
+	int tmp;
+
+	tmp =  i2c_smbus_read_byte_data(client, REG_INTERRUPT);
+
+	if (tmp < 0) {
+		pr_info("%s: i2c read interrupt status fail.\n", __func__);
+		goto exit;
+	}
+
+	if (1)	 {
+		tmp = i2c_smbus_read_byte_data(client, REG_ALSPSCONTROL);
+
+		if (tmp < 0) {
+			pr_info("%s: i2c read led current fail.\n", __func__);
+			goto exit;
+		}
+		als_ps->ledcurrent = tmp & 0x3;
+
+		tmp = i2c_smbus_read_word_data(client, REG_PSDATA);
+
+		if (tmp < 0) {
+			pr_info("%s: i2c read ps data fail.\n", __func__);
+			goto exit;
+		}
+
+		als_ps->ps_data_raw = (unsigned short)tmp;
+		als_ps->ps_data = calc_rohm_ps_data(als_ps->ps_data_raw);
+
+		if (als_ps->ps_data > als_ps->ps_th_h) {
+			als_ps->ps_direction = 0;
+#ifdef _AUTO_THRESHOLD_CHANGE_
+			rpr400_set_ps_threshold_high(client, REG_PSTH_MAX);
+			rpr400_set_ps_threshold_low(client,
+				als_ps->ps_th_l_back);
+#endif
+		} else if (als_ps->ps_data < als_ps->ps_th_l) {
+			als_ps->ps_direction = 1;
+#ifdef _AUTO_THRESHOLD_CHANGE_
+			rpr400_set_ps_threshold_high(client,
+			als_ps->ps_th_h_back);
+			rpr400_set_ps_threshold_low(client, 0);
+#endif
+		}
+
+		pr_info("RPR400 ps report: raw_data = %d, data = %d, direction = %d.\n",
+		als_ps->ps_data_raw, als_ps->ps_data, als_ps->ps_direction);
+
+		input_report_abs(als_ps->input_dev_ps, ABS_DISTANCE,
+			als_ps->ps_direction);
+		input_sync(als_ps->input_dev_ps);
+	} else
+		pr_info("%s: unknown interrupt source.\n", __func__);
+
+exit:
+	enable_irq(client->irq);
+
+}
+
+/* assume this is ISR */
+static irqreturn_t rpr400_interrupt(int vec, void *info)
+{
+	struct i2c_client *client = (struct i2c_client *)info;
+	struct ALS_PS_DATA *als_ps = i2c_get_clientdata(client);
+
+	disable_irq_nosync(client->irq);
+
+
+	rpr400_reschedule_work(als_ps, 0);
+
+	return IRQ_HANDLED;
+}
+
+/*************** SysFS Support ******************/
+static ssize_t rpr400_show_enable_ps_sensor(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ALS_PS_DATA *als_ps = i2c_get_clientdata(client);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", als_ps->enable_ps_sensor);
+}
+
+static ssize_t rpr400_store_enable_ps_sensor(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ALS_PS_DATA *als_ps = i2c_get_clientdata(client);
+	unsigned long val = kstrtoul(buf, 10, NULL);
+
+	pr_info("RPR400 enable PS sensor -> %ld\n", val);
+
+	if ((val != 0) && (val != 1)) {
+		pr_info("%s:store unvalid value=%ld\n", __func__, val);
+		return count;
+	}
+
+	if (val == 1) {
+		if (als_ps->enable_ps_sensor == 0) {
+			als_ps->enable_ps_sensor = 1;
+
+			if (als_ps->enable_als_sensor == 0)
+				rpr400_set_enable(client, PS100MS);
+			else
+				rpr400_set_enable(client, BOTH100MS);
+		}
+	} else {
+		if (als_ps->enable_ps_sensor == 1) {
+			als_ps->enable_ps_sensor = 0;
+			if (als_ps->enable_als_sensor == 0)
+				rpr400_set_enable(client, BOTH_STANDBY);
+			else
+				rpr400_set_enable(client, ALS100MS);
+		}
+	}
+
+	return count;
+}
+
+static ssize_t rpr400_show_enable_als_sensor(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ALS_PS_DATA *als_ps = i2c_get_clientdata(client);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", als_ps->enable_als_sensor);
+}
+
+static ssize_t rpr400_store_enable_als_sensor(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ALS_PS_DATA *als_ps = i2c_get_clientdata(client);
+	unsigned long val = kstrtoul(buf, 10, NULL);
+	unsigned long flags;
+
+	pr_info("RPR400 enable ALS sensor -> %ld\n", val);
+
+	if ((val != 0) && (val != 1)) {
+		pr_info("%s: enable als sensor=%ld\n", __func__, val);
+		return count;
+	}
+
+	if (val == 1) {
+		if (als_ps->enable_als_sensor == 0) {
+			als_ps->enable_als_sensor = 1;
+
+			if (als_ps->enable_ps_sensor == 1)
+				rpr400_set_enable(client, BOTH100MS);
+			else
+				rpr400_set_enable(client, ALS100MS);
+		}
+
+		spin_lock_irqsave(&als_ps->update_lock.wait_lock, flags);
+		cancel_delayed_work(&als_ps->als_dwork);
+		schedule_delayed_work(&als_ps->als_dwork,
+			msecs_to_jiffies(als_ps->als_poll_delay));
+		spin_unlock_irqrestore(&als_ps->update_lock.wait_lock, flags);
+	} else {
+		if (als_ps->enable_als_sensor == 1) {
+			als_ps->enable_als_sensor = 0;
+
+			if (als_ps->enable_ps_sensor == 1)
+
+				rpr400_set_enable(client, PS100MS);
+			else
+				rpr400_set_enable(client, BOTH_STANDBY);
+		}
+
+		spin_lock_irqsave(&als_ps->update_lock.wait_lock, flags);
+		cancel_delayed_work(&als_ps->als_dwork);
+		spin_unlock_irqrestore(&als_ps->update_lock.wait_lock, flags);
+	}
+
+	return count;
+}
+
+static ssize_t rpr400_show_als_poll_delay(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ALS_PS_DATA *als_ps = i2c_get_clientdata(client);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", als_ps->als_poll_delay*1000);
+}
+
+static ssize_t rpr400_store_als_poll_delay(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ALS_PS_DATA *als_ps = i2c_get_clientdata(client);
+	unsigned long val = kstrtoul(buf, 10, NULL);
+	unsigned long flags;
+
+	if (val < PS_ALS_SET_MIN_DELAY_TIME * 1000)
+		val = PS_ALS_SET_MIN_DELAY_TIME * 1000;
+	als_ps->als_poll_delay = val / 1000;
+
+	if (als_ps->enable_als_sensor == 1) {
+		spin_lock_irqsave(&als_ps->update_lock.wait_lock, flags);
+
+		cancel_delayed_work(&als_ps->als_dwork);
+		schedule_delayed_work(&als_ps->als_dwork,
+		msecs_to_jiffies(als_ps->als_poll_delay));
+
+		spin_unlock_irqrestore(&als_ps->update_lock.wait_lock, flags);
+	}
+
+	return count;
+}
+
+static ssize_t rpr400_show_als_data(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	int tmp;
+	int tmp1;
+	tmp = i2c_smbus_read_word_data(client, REG_ALSDATA0);
+	tmp1 = i2c_smbus_read_word_data(client, REG_ALSDATA1);
+	tmp = tmp << 8;
+	tmp = tmp | tmp1;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", tmp);
+}
+
+static ssize_t rpr400_show_ps_data(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	int tmp = 0;
+	tmp = i2c_smbus_read_word_data(client, REG_PSDATA);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", tmp);
+}
+
+static ssize_t rpr400_show_ps_thres_high(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	int ps_data = 0, ps_high = 0, ps_low = 0;
+	ps_data = i2c_smbus_read_word_data(client, REG_PSDATA);
+
+	if (ps_data < 0) {
+			pr_info("%s: i2c read led current fail.\n", __func__);
+			return 0;
+	}
+
+	ps_high = i2c_smbus_read_word_data(client, REG_PSTH);
+	if (ps_high < 0) {
+			pr_info("%s: i2c read led current fail.\n", __func__);
+			return 0;
+	}
+
+	ps_low = i2c_smbus_read_word_data(client, REG_PSTL);
+	if (ps_low < 0) {
+			pr_info("%s: i2c read led current fail.\n", __func__);
+			return 0;
+	}
+
+	return snprintf(buf, PAGE_SIZE, "%d %d %d\n", ps_data, ps_high, ps_low);
+
+}
+
+static ssize_t rpr400_store_ps_thres_high(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ALS_PS_DATA *als_ps = i2c_get_clientdata(client);
+	unsigned long val = kstrtoul(buf, 10, NULL);
+
+	if (!(rpr400_set_ps_threshold_high(client, val)))
+		als_ps->ps_th_h_back = als_ps->ps_th_h;
+
+	return count;
+}
+
+static ssize_t rpr400_show_ps_thres_low(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ALS_PS_DATA *als_ps = i2c_get_clientdata(client);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", als_ps->ps_th_l);
+}
+
+static ssize_t rpr400_store_ps_thres_low(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ALS_PS_DATA *als_ps = i2c_get_clientdata(client);
+	unsigned long val = kstrtoul(buf, 10, NULL);
+
+	if (!(rpr400_set_ps_threshold_low(client, val)))
+		als_ps->ps_th_l_back = als_ps->ps_th_l;
+
+	return count;
+}
+
+static ssize_t rpr400_show_ps_calib(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ALS_PS_DATA *als_ps = i2c_get_clientdata(client);
+
+	return snprintf(buf, PAGE_SIZE, "%d\t%d\n",
+		als_ps->ps_th_h, als_ps->ps_th_l);
+}
+
+static ssize_t rpr400_store_ps_calib(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+#define SET_LOW_THRES	1
+#define SET_HIGH_THRES	2
+#define SET_BOTH_THRES	3
+
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ALS_PS_DATA *als_ps = i2c_get_clientdata(client);
+	unsigned long val = kstrtoul(buf, 10, NULL);
+	unsigned int i, tmp, ps_th_h, ps_th_l;
+	int average;
+
+	switch (val) {
+	case SET_LOW_THRES:
+			average = 0;
+			ps_th_h = als_ps->ps_th_h_back;
+			ps_th_l = als_ps->ps_th_l_back;
+			for (i = 0; i < 20; i++) {
+				tmp = i2c_smbus_read_word_data(client,
+					REG_PSDATA);
+				if (tmp < 0) {
+					pr_info("%s: i2c read ps data fail.\n",
+						__func__);
+					return -EINVAL;
+				}
+				average += tmp & 0xFFF;
+			}
+			average /= 20;
+			ps_th_l = average + THRES_TOLERANCE;
+			if (ps_th_l > REG_PSTL_MAX) {
+				pr_info("%d in %s: low threshold is too high.\n",
+					__LINE__, __func__);
+				return -EINVAL;
+			}
+			if (ps_th_l < 0) {
+				pr_info("%d in %s: low threshold is too low.\n",
+					__LINE__, __func__);
+				return -EINVAL;
+			}
+			if (ps_th_h < ps_th_l + THRES_DIFF) {
+				ps_th_h = ps_th_l + THRES_DIFF;
+				if (ps_th_h > REG_PSTH_MAX) {
+					pr_info("%d in %s: high threshold is too high.\n",
+						__LINE__, __func__);
+					return -EINVAL;
+				}
+				if (!rpr400_set_ps_threshold_high(client,
+					ps_th_h))
+					als_ps->ps_th_h_back = ps_th_h;
+				else
+					return -EINVAL;
+			}
+			if (!rpr400_set_ps_threshold_low(client, ps_th_l))
+				als_ps->ps_th_l_back = ps_th_l;
+			else
+				return -EINVAL;
+			break;
+
+	case SET_HIGH_THRES:
+			average = 0;
+			ps_th_h = als_ps->ps_th_h_back;
+			ps_th_l = als_ps->ps_th_l_back;
+			for (i = 0; i < 20; i++) {
+				tmp = i2c_smbus_read_word_data(client,
+					REG_PSDATA);
+				if (tmp < 0) {
+					pr_info("%s: i2c read ps data fail.\n",
+						__func__);
+					return -EINVAL;
+				}
+				average += tmp & 0xFFF;
+			}
+			average /= 20;
+			ps_th_h = average - THRES_TOLERANCE;
+			if (ps_th_h > REG_PSTH_MAX) {
+				pr_info("%d in %s: high threshold is too high.\n",
+					__LINE__, __func__);
+				return -EINVAL;
+			}
+			if (ps_th_h < 0) {
+				pr_info("%d in %s: high threshold is too low.\n",
+					__LINE__, __func__);
+				return -EINVAL;
+			}
+			if (ps_th_l > ps_th_h - THRES_DIFF) {
+				ps_th_l = ps_th_h - THRES_DIFF;
+				if (ps_th_l < 0) {
+					pr_info("%d in %s: low threshold is too low.\n",
+						__LINE__, __func__);
+					return -EINVAL;
+				}
+				if (!rpr400_set_ps_threshold_low(client,
+					ps_th_l))
+					als_ps->ps_th_l_back = ps_th_l;
+				else
+					return -EINVAL;
+			}
+			if (!rpr400_set_ps_threshold_high(client, ps_th_h))
+				als_ps->ps_th_h_back = ps_th_h;
+			else
+				return -EINVAL;
+			break;
+
+	case SET_BOTH_THRES:
+			rpr400_calibrate(client);
+			break;
+
+	default:
+			return -EINVAL;
+	}
+
+	return count;
+
+#undef SET_BOTH_THRES
+#undef SET_HIGH_THRES
+#undef SET_LOW_THRES
+}
+
+static DEVICE_ATTR(als_poll_delay,  S_IRUGO |
+	S_IWUGO, rpr400_show_als_poll_delay, rpr400_store_als_poll_delay);
+
+static DEVICE_ATTR(enable_als_sensor,  S_IRUGO |
+	S_IWUGO , rpr400_show_enable_als_sensor,
+	rpr400_store_enable_als_sensor);
+
+static DEVICE_ATTR(enable_ps_sensor,  S_IRUGO |
+	S_IWUGO , rpr400_show_enable_ps_sensor, rpr400_store_enable_ps_sensor);
+
+static DEVICE_ATTR(ps_thres_high,  S_IRUGO |
+	S_IWUGO , rpr400_show_ps_thres_high, rpr400_store_ps_thres_high);
+
+static DEVICE_ATTR(ps_thres_low,  S_IRUGO |
+	S_IWUGO , rpr400_show_ps_thres_low, rpr400_store_ps_thres_low);
+
+static DEVICE_ATTR(ps_calib,  0666,
+				   rpr400_show_ps_calib, rpr400_store_ps_calib);
+static DEVICE_ATTR(als_data, S_IRUGO |
+	S_IWUGO, rpr400_show_als_data, NULL);
+static DEVICE_ATTR(ps_data, S_IRUGO |
+	S_IWUGO, rpr400_show_ps_data, NULL);
+
+static struct attribute *rpr400_attributes[] = {
+	&dev_attr_enable_ps_sensor.attr,
+	&dev_attr_enable_als_sensor.attr,
+	&dev_attr_als_poll_delay.attr,
+	&dev_attr_ps_thres_high.attr,
+	&dev_attr_ps_thres_low.attr,
+	&dev_attr_ps_calib.attr,
+	&dev_attr_als_data.attr,
+	&dev_attr_ps_data.attr,
+	NULL
+};
+
+static const struct attribute_group rpr400_attr_group = {
+	.attrs = rpr400_attributes,
+};
+
+/*************** Initialze Functions ******************/
+static int rpr400_init_client(struct i2c_client *client)
+{
+	struct init_func_write_data {
+		unsigned char mode_ctl;
+		unsigned char psals_ctl;
+		unsigned char persist;
+		unsigned char reserved0;
+		unsigned char reserved1;
+		unsigned char reserved2;
+		unsigned char reserved3;
+		unsigned char reserved4;
+		unsigned char reserved5;
+		unsigned char intr;
+		unsigned char psth_hl;
+		unsigned char psth_hh;
+		unsigned char psth_ll;
+		unsigned char psth_lh;
+		unsigned char alsth_hl;
+		unsigned char alsth_hh;
+		unsigned char alsth_ll;
+		unsigned char alsth_lh;
+	} write_data;
+	int result;
+	unsigned char gain;
+
+	unsigned char mode_ctl    = PS_ALS_SET_MODE_CONTROL;
+	unsigned char psals_ctl   = PS_ALS_SET_ALSPS_CONTROL;
+	unsigned char persist     = PS_ALS_SET_INTR_PERSIST;
+	unsigned char intr        = PS_ALS_SET_INTR;
+	unsigned short psth_upper  = PS_ALS_SET_PS_TH;
+	unsigned short psth_low    = PS_ALS_SET_PS_TL;
+	unsigned short alsth_upper = PS_ALS_SET_ALS_TH;
+	unsigned short alsth_low   = PS_ALS_SET_ALS_TL;
+
+	struct ALS_PS_DATA *als_ps = i2c_get_clientdata(client);
+
+	/* execute software reset */
+	result =  i2c_smbus_write_byte_data(client, REG_SYSTEMCONTROL, 0xC0);
+	if (result != 0)
+		return result;
+
+	/* check the PS orerating mode */
+	if ((NORMAL_MODE != mode_ctl) && (LOW_NOISE_MODE != mode_ctl)) {
+		pr_info("%s: invalid parameter.\n", __func__);
+		return -EINVAL;
+	}
+	/* check the parameter of ps and als control */
+	if (psals_ctl > REG_ALSPSCTL_MAX) {
+		pr_info("%s: invalid parameter.\n", __func__);
+		return -EINVAL;
+	}
+	/* check the parameter of ps interrupt persistence */
+	if (persist > PERSISTENCE_MAX) {
+		pr_info("%s: invalid parameter.\n", __func__);
+		return -EINVAL;
+	}
+	/* check the parameter of interrupt */
+	if (intr > REG_INTERRUPT_MAX) {
+		pr_info("%s: invalid parameter.\n", __func__);
+		return -EINVAL;
+	}
+	/* check the parameter of proximity sensor threshold high */
+	if (psth_upper > REG_PSTH_MAX) {
+		pr_info("%s: invalid parameter.\n", __func__);
+		return -EINVAL;
+	}
+	/* check the parameter of proximity sensor threshold low */
+	if (psth_low > REG_PSTL_MAX) {
+		pr_info("%s: invalid parameter.\n", __func__);
+		return -EINVAL;
+	}
+	write_data.mode_ctl  = mode_ctl;
+	write_data.psals_ctl = psals_ctl;
+	write_data.persist   = persist;
+	write_data.reserved0 = 0;
+	write_data.reserved1 = 0;
+	write_data.reserved2 = 0;
+	write_data.reserved3 = 0;
+	write_data.reserved4 = 0;
+	write_data.reserved5 = 0;
+	write_data.intr      = intr;
+	write_data.psth_hl   = CONVERT_TO_BE(psth_upper) & MASK_CHAR;
+	write_data.psth_hh   = CONVERT_TO_BE(psth_upper) >> 8;
+	write_data.psth_ll   = CONVERT_TO_BE(psth_low) & MASK_CHAR;
+	write_data.psth_lh   = CONVERT_TO_BE(psth_low) >> 8;
+	write_data.alsth_hl  = CONVERT_TO_BE(alsth_upper) & MASK_CHAR;
+	write_data.alsth_hh  = CONVERT_TO_BE(alsth_upper) >> 8;
+	write_data.alsth_ll  = CONVERT_TO_BE(alsth_low) & MASK_CHAR;
+	write_data.alsth_lh  = CONVERT_TO_BE(alsth_low) >> 8;
+	result = i2c_smbus_write_i2c_block_data(client, REG_MODECONTROL,
+		sizeof(write_data), (unsigned char *)&write_data);
+
+	if (result < 0) {
+		pr_info("%s: i2c write fail.\n", __func__);
+		return result;
+	}
+
+	gain = (psals_ctl & 0x3C) >> 2;
+
+	als_ps->enable = mode_ctl;
+	als_ps->als_time = mode_table[(mode_ctl & 0xF)].ALS;
+	als_ps->ps_time = mode_table[(mode_ctl & 0xF)].PS;
+	als_ps->persistence = persist;
+	als_ps->ps_th_l = psth_low;
+	als_ps->ps_th_h = psth_upper;
+	als_ps->als_th_l = alsth_low;
+	als_ps->als_th_h = alsth_upper;
+	als_ps->control = psals_ctl;
+	als_ps->gain0 = gain_table[gain].DATA0;
+	als_ps->gain1 = gain_table[gain].DATA1;
+	als_ps->ledcurrent = psals_ctl & 0x03;
+	als_ps->enable_als_sensor = 0;
+	als_ps->enable_ps_sensor = 0;
+
+#ifdef _INIT_CALIB_
+	rpr400_calibrate(client);
+#else
+	als_ps->ps_th_h_back = als_ps->ps_th_h;
+	als_ps->ps_th_l_back = als_ps->ps_th_l;
+#endif
+
+	return result;
+}
+
+static int rpr0410_enable_als_sensor(struct i2c_client *client, int val)
+{
+
+	struct ALS_PS_DATA *als_ps = i2c_get_clientdata(client);
+	struct rpr0410_platform_data *pdata = als_ps->platform_data;
+	unsigned long flags;
+
+	pr_info("RPR400 enable ALS sensor -> %d\n", val);
+	if ((val != 0) && (val != 1)) {
+		pr_info("%s: enable als sensor=%d\n", __func__, val);
+		return val;
+	}
+
+	if (val == 1) {
+		if ((als_ps->enable_als_sensor == 0)
+			&& (als_ps->enable_ps_sensor == 0)) {
+
+			/* power on reinit the device */
+			if (pdata->power_on)
+				pdata->power_on(true);
+		}
+		if (als_ps->enable_als_sensor == 0) {
+			als_ps->enable_als_sensor = 1;
+
+			if (als_ps->enable_ps_sensor == 1)
+				rpr400_set_enable(client, BOTH100MS);
+			else
+				rpr400_set_enable(client, ALS100MS);
+		}
+
+		spin_lock_irqsave(&als_ps->update_lock.wait_lock, flags);
+		cancel_delayed_work(&als_ps->als_dwork);
+		schedule_delayed_work(&als_ps->als_dwork,
+			msecs_to_jiffies(atomic_read(&als_ps->delay)));
+			/* msecs_to_jiffies(als_ps->als_poll_delay)); */
+		spin_unlock_irqrestore(&als_ps->update_lock.wait_lock, flags);
+	} else {
+		if (als_ps->enable_als_sensor == 1) {
+			als_ps->enable_als_sensor = 0;
+
+			if (als_ps->enable_ps_sensor == 1)
+				rpr400_set_enable(client, PS100MS);
+			else
+				rpr400_set_enable(client, BOTH_STANDBY);
+		}
+
+		spin_lock_irqsave(&als_ps->update_lock.wait_lock, flags);
+		cancel_delayed_work(&als_ps->als_dwork);
+		spin_unlock_irqrestore(&als_ps->update_lock.wait_lock, flags);
+	}
+
+	/* Vote off  regulators if both light and prox sensor are off */
+	if ((als_ps->enable_als_sensor == 0) &&
+		(als_ps->enable_ps_sensor == 0) &&
+		(pdata->power_on))
+		pdata->power_on(false);
+
+	return 0;
+}
+
+static int rpr0410_enable_ps_sensor(struct i2c_client *client, int val)
+{
+	struct ALS_PS_DATA *als_ps = i2c_get_clientdata(client);
+	struct rpr0410_platform_data *pdata = als_ps->platform_data;
+
+	if ((val != 0) && (val != 1)) {
+		pr_info("%s:store unvalid value=%d\n", __func__, val);
+		return val;
+	}
+
+	if (val == 1) {
+		if ((als_ps->enable_als_sensor == 0) &&
+			(als_ps->enable_ps_sensor == 0)) {
+			/**** Power on and initalize the device ****/
+			if (pdata->power_on)
+				pdata->power_on(true);
+		}
+
+		rpr400_init_client(client);
+
+		if (als_ps->enable_ps_sensor == 0) {
+			als_ps->enable_ps_sensor = 1;
+
+			if (als_ps->enable_als_sensor == 0)
+				rpr400_set_enable(client, PS100MS);
+			else
+				rpr400_set_enable(client, BOTH100MS);
+		}
+	} else {
+		if (als_ps->enable_ps_sensor == 1) {
+			als_ps->enable_ps_sensor = 0;
+			if (als_ps->enable_als_sensor == 0)
+				rpr400_set_enable(client, BOTH_STANDBY);
+			else
+				rpr400_set_enable(client, ALS100MS);
+		}
+	}
+
+	/* when enable auto change backlight,
+	* als_enable should be reinit when ps
+	* disabled after use
+	*/
+	if (val == 0)
+		rpr400_set_enable(client, ALS100MS);
+
+	/* Vote off  regulators if both light and prox sensor are off */
+	if ((als_ps->enable_ps_sensor == 0) &&
+		(als_ps->enable_als_sensor == 0) &&
+		(pdata->power_on))
+		pdata->power_on(false);
+
+	return 0;
+}
+
+static int rpr0410_als_set_enable(struct sensors_classdev *sensors_cdev,
+		unsigned int enable)
+{
+	struct ALS_PS_DATA *als_ps = container_of(sensors_cdev,
+			struct ALS_PS_DATA, als_cdev);
+
+	if ((enable != 0) && (enable != 1)) {
+		pr_err("%s: invalid value(%d)\n", __func__, enable);
+		return -EINVAL;
+	}
+
+	return rpr0410_enable_als_sensor(als_ps->client, enable);
+}
+
+static int rpr0410_ps_set_enable(struct sensors_classdev *sensors_cdev,
+		unsigned int enable)
+{
+	struct ALS_PS_DATA *als_ps = container_of(sensors_cdev,
+			struct ALS_PS_DATA, ps_cdev);
+
+	if ((enable != 0) && (enable != 1)) {
+		pr_err("%s: invalid value(%d)\n", __func__, enable);
+		return -EINVAL;
+	}
+
+	return rpr0410_enable_ps_sensor(als_ps->client, enable);
+
+}
+
+static int rpr0410_als_poll_delay(struct sensors_classdev *sensors_cdev,
+				unsigned int delay_ms)
+{
+	struct  ALS_PS_DATA *data = container_of(sensors_cdev,
+					struct  ALS_PS_DATA, als_cdev);
+
+	if (delay_ms < RPR0410_MIN_DELAY)
+		delay_ms = RPR0410_MIN_DELAY;
+	if (delay_ms > RPR0410_MAX_DELAY)
+		delay_ms = RPR0410_MAX_DELAY;
+	atomic_set(&data->delay, (unsigned int) delay_ms);
+
+	return 0;
+}
+
+/*****************regulator configuration start**************/
+static int sensor_regulator_configure(struct ALS_PS_DATA *data, bool on)
+{
+	int rc;
+
+	if (!on) {
+
+		if (regulator_count_voltages(data->vdd) > 0)
+			regulator_set_voltage(data->vdd, 0,
+				RPR0410_VDD_MAX_UV);
+
+		regulator_put(data->vdd);
+
+		if (regulator_count_voltages(data->vio) > 0)
+			regulator_set_voltage(data->vio, 0,
+				RPR0410_VIO_MAX_UV);
+
+		regulator_put(data->vio);
+	} else {
+		data->vdd = regulator_get(&data->client->dev, "vdd");
+		if (IS_ERR(data->vdd)) {
+			rc = PTR_ERR(data->vdd);
+			dev_err(&data->client->dev,
+				"Regulator get failed vdd rc=%d\n", rc);
+			return rc;
+		}
+
+		if (regulator_count_voltages(data->vdd) > 0) {
+			rc = regulator_set_voltage(data->vdd,
+				RPR0410_VDD_MIN_UV, RPR0410_VDD_MAX_UV);
+			if (rc) {
+				dev_err(&data->client->dev,
+					"Regulator set failed vdd rc=%d\n",
+					rc);
+				goto reg_vdd_put;
+			}
+		}
+
+		data->vio = regulator_get(&data->client->dev, "vio");
+		if (IS_ERR(data->vio)) {
+			rc = PTR_ERR(data->vio);
+			dev_err(&data->client->dev,
+				"Regulator get failed vio rc=%d\n", rc);
+			goto reg_vdd_set;
+		}
+
+		if (regulator_count_voltages(data->vio) > 0) {
+			rc = regulator_set_voltage(data->vio,
+				RPR0410_VIO_MIN_UV, RPR0410_VIO_MAX_UV);
+			if (rc) {
+				dev_err(&data->client->dev,
+				"Regulator set failed vio rc=%d\n", rc);
+				goto reg_vio_put;
+			}
+		}
+	}
+
+	return 0;
+reg_vio_put:
+	regulator_put(data->vio);
+
+reg_vdd_set:
+	if (regulator_count_voltages(data->vdd) > 0)
+		regulator_set_voltage(data->vdd, 0, RPR0410_VDD_MAX_UV);
+reg_vdd_put:
+	regulator_put(data->vdd);
+	return rc;
+}
+
+static int sensor_regulator_power_on(struct ALS_PS_DATA *data, bool on)
+{
+	int rc = 0;
+
+	if (!on) {
+		rc = regulator_disable(data->vdd);
+		if (rc) {
+			dev_err(&data->client->dev,
+				"Regulator vdd disable failed rc=%d\n", rc);
+			return rc;
+		}
+
+		rc = regulator_disable(data->vio);
+		if (rc) {
+			dev_err(&data->client->dev,
+				"Regulator vio disable failed rc=%d\n", rc);
+			rc = regulator_enable(data->vdd);
+			dev_err(&data->client->dev,
+					"Regulator vio re-enabled rc=%d\n", rc);
+			/*
+			 * Successfully re-enable regulator.
+			 * Enter poweron delay and returns error.
+			 */
+			if (!rc) {
+				rc = -EBUSY;
+				goto enable_delay;
+			}
+		}
+		return rc;
+	} else {
+		rc = regulator_enable(data->vdd);
+		if (rc) {
+			dev_err(&data->client->dev,
+				"Regulator vdd enable failed rc=%d\n", rc);
+			return rc;
+		}
+
+		rc = regulator_enable(data->vio);
+		if (rc) {
+			dev_err(&data->client->dev,
+				"Regulator vio enable failed rc=%d\n", rc);
+			regulator_disable(data->vdd);
+			return rc;
+		}
+	}
+
+enable_delay:
+	msleep(130);
+	dev_dbg(&data->client->dev,
+		"Sensor regulator power on =%d\n", on);
+	return rc;
+}
+
+static int sensor_platform_hw_power_on(bool on)
+{
+	struct ALS_PS_DATA *data;
+	int err = 0;
+
+	/* sensor_info is global pointer to struct ltr553_data */
+	if (sensor_info == NULL)
+		return -ENODEV;
+
+	data = sensor_info;
+
+	if (data->power_on != on) {
+
+		err = sensor_regulator_power_on(data, on);
+		if (err)
+			dev_err(&data->client->dev,
+					"Can't configure regulator!\n");
+		else
+			data->power_on = on;
+	}
+
+	return err;
+}
+
+static int sensor_platform_hw_init(void)
+{
+	struct i2c_client *client;
+	struct ALS_PS_DATA *data;
+	int error;
+
+	if (sensor_info == NULL)
+		return -ENODEV;
+
+	data = sensor_info;
+	client = data->client;
+
+	error = sensor_regulator_configure(data, true);
+	if (error < 0) {
+		dev_err(&client->dev, "unable to configure regulator\n");
+		return error;
+	}
+
+	return 0;
+}
+
+static void sensor_platform_hw_exit(void)
+{
+	struct ALS_PS_DATA *data = sensor_info;
+
+	if (data == NULL)
+		return;
+
+	sensor_regulator_configure(data, false);
+}
+
+static int sensor_parse_dt(struct device *dev,
+		struct rpr0410_platform_data *rpr_pdata)
+{
+	struct device_node *np = dev->of_node;
+	struct i2c_client *client;
+	struct ALS_PS_DATA *data = sensor_info;
+
+	unsigned int tmp;
+	int rc = 0;
+	client = data->client;
+
+	/* set functions of platform data */
+	rpr_pdata->init = sensor_platform_hw_init;
+	rpr_pdata->exit = sensor_platform_hw_exit;
+	rpr_pdata->power_on = sensor_platform_hw_power_on;
+
+	data->irq = of_get_named_gpio_flags(np, "rohm,irq-gpio", 0, NULL);
+	if (data->irq < 0)
+		return data->irq;
+
+	if (gpio_is_valid(data->irq)) {
+		rc = gpio_request(data->irq, "rpr_irq_gpio");
+		if (rc)
+			dev_err(&client->dev, "irq request failed");
+
+		rc = gpio_direction_input(data->irq);
+		if (rc) {
+			dev_err(&client->dev,
+				"set_direction for irq gpio failed\n");
+		}
+	}
+
+	rc = of_property_read_u32(np, "rohm,prox_th_min", &tmp);
+	if (rc) {
+		dev_err(dev, "Unable to read prox_th_min\n");
+		return rc;
+	}
+	data->ps_th_l = tmp;
+
+	rc = of_property_read_u32(np, "rohm,prox_th_max", &tmp);
+	 if (rc) {
+		dev_err(dev, "Unable to read prox_th_max\n");
+		return rc;
+	}
+
+	data->ps_th_h = tmp;
+
+	return 0;
+}
+
+
+/*********** I2C init/probing/exit functions ****************/
+
+static struct i2c_driver rpr400_driver;
+
+static int rpr400_probe(struct i2c_client *client,
+				   const struct i2c_device_id *id)
+{
+	#define ROHM_PSALS_ALSMAX (65535)
+	#define ROHM_PSALS_PSMAX  (4095)
+
+	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
+	struct ALS_PS_DATA *als_ps;
+	struct rpr0410_platform_data *pdata;
+	int err = 0;
+	int ret;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE)) {
+		err = -EIO;
+		goto exit;
+	}
+
+	als_ps = kzalloc(sizeof(struct ALS_PS_DATA), GFP_KERNEL);
+	if (!als_ps) {
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	/* Set initial defaults */
+	als_ps->enable_ps_sensor = 0;
+	als_ps->enable_als_sensor = 0;
+
+	/* Global pointer for this device */
+	sensor_info = als_ps;
+	als_ps->client = client;
+
+	if (client->dev.of_node) {
+		pdata = devm_kzalloc(&client->dev,
+			sizeof(struct rpr0410_platform_data), GFP_KERNEL);
+
+		if (!pdata) {
+				dev_err(&client->dev,
+				"failed to allocate memory for platform data\n");
+				return -ENOMEM;
+		}
+		als_ps->platform_data = pdata;
+
+		client->dev.platform_data = pdata;
+
+		ret = sensor_parse_dt(&client->dev, pdata);
+		if (ret) {
+				dev_err(&client->dev,
+		"Unable to parse platfrom data err=%d\n", ret);
+				return ret;
+		}
+	} else {
+		pdata = client->dev.platform_data;
+		if (!pdata) {
+			dev_err(&client->dev, "No platform data\n");
+			return -ENODEV;
+		}
+	}
+	/* h/w initialization */
+	if (pdata->init)
+		ret = pdata->init();
+
+	if (pdata->power_on)
+		ret = pdata->power_on(true);
+	i2c_set_clientdata(client, als_ps);
+
+	pr_debug("enable = %x\n", als_ps->enable);
+	if (err < 0) {
+		pr_err("%s: sensor_parse_dt() err\n", __func__);
+		return err;
+	}
+/*
+	err = rpr_power_init(als_ps, true);
+	if (err)
+		dev_err(&client->dev, "power init failed");
+	err = rpr_power_on(als_ps, true);
+	if (err)
+		dev_err(&client->dev, "power on failed");
+*/
+	mutex_init(&als_ps->update_lock);
+	INIT_DELAYED_WORK(&als_ps->dwork, rpr400_ps_int_work_handler);
+	INIT_DELAYED_WORK(&als_ps->als_dwork, rpr400_als_polling_work_handler);
+
+	/* Initialize the RPR400 chip */
+	err = rpr400_init_client(client);
+	if (err)
+		goto exit_kfree;
+
+	atomic_set(&als_ps->delay, RPR0410_MAX_DELAY);
+
+	/* Register to Input Device */
+	als_ps->input_dev_als = input_allocate_device();
+	if (!als_ps->input_dev_als) {
+		err = -ENOMEM;
+		pr_info("%s: Failed to allocate input device als\n", __func__);
+		goto exit_kfree;
+	}
+
+	als_ps->input_dev_ps = input_allocate_device();
+	if (!als_ps->input_dev_ps) {
+		err = -ENOMEM;
+		pr_info("%s: Failed to allocate input device ps\n", __func__);
+		goto exit_free_dev_als;
+	}
+
+	input_set_drvdata(als_ps->input_dev_ps, als_ps);
+	input_set_drvdata(als_ps->input_dev_als, als_ps);
+
+	set_bit(EV_ABS, als_ps->input_dev_als->evbit);
+	set_bit(EV_ABS, als_ps->input_dev_ps->evbit);
+	input_set_abs_params(als_ps->input_dev_als, ABS_MISC,
+		0, ROHM_PSALS_ALSMAX, 0, 0);
+	input_set_abs_params(als_ps->input_dev_ps, ABS_DISTANCE,
+		0, ROHM_PSALS_PSMAX, 0, 0);
+
+	als_ps->input_dev_als->name = "light";
+	als_ps->input_dev_ps->name = "proximity";
+	als_ps->input_dev_als->id.bustype = BUS_I2C;
+	als_ps->input_dev_als->dev.parent = &als_ps->client->dev;
+	als_ps->input_dev_ps->id.bustype = BUS_I2C;
+	als_ps->input_dev_ps->dev.parent = &als_ps->client->dev;
+
+	err = input_register_device(als_ps->input_dev_als);
+	if (err) {
+		err = -ENOMEM;
+		pr_info("%s: Unable to register input device als: %s\n",
+			__func__, als_ps->input_dev_als->name);
+		goto exit_free_dev_ps;
+	}
+
+	err = input_register_device(als_ps->input_dev_ps);
+	if (err) {
+		err = -ENOMEM;
+		pr_info("%s: Unable to register input device ps: %s\n",
+			__func__, als_ps->input_dev_ps->name);
+		goto exit_unregister_dev_als;
+	}
+
+	/* Register sysfs hooks */
+	err = sysfs_create_group(&client->dev.kobj, &rpr400_attr_group);
+	if (err) {
+		pr_info("%s sysfs_create_groupX\n", __func__);
+		goto exit_unregister_dev_ps;
+	}
+
+	if (request_irq(client->irq, rpr400_interrupt, IRQ_TYPE_EDGE_FALLING,
+	RPR400_DRV_NAME, (void *)client)) {
+		pr_info("%s Could not allocate RPR400_INT !\n", __func__);
+		goto exit_remove_sysfs_group;
+	}
+	pr_info("%s: INT No. %d", __func__, client->irq);
+
+	/* Register to sensors class */
+	als_ps->als_cdev = sensors_light_cdev;
+	als_ps->als_cdev.sensors_enable = rpr0410_als_set_enable;
+	als_ps->als_cdev.sensors_poll_delay = rpr0410_als_poll_delay;
+	als_ps->ps_cdev = sensors_proximity_cdev;
+	als_ps->ps_cdev.sensors_enable = rpr0410_ps_set_enable;
+	als_ps->ps_cdev.sensors_poll_delay = NULL;
+
+	err = sensors_classdev_register(&client->dev, &als_ps->als_cdev);
+	if (err) {
+		pr_err("%s: Unable to register to sensors class: %d\n",
+				__func__, err);
+		goto exit_free_irq;
+	}
+
+	err = sensors_classdev_register(&client->dev, &als_ps->ps_cdev);
+	if (err) {
+		pr_err("%s: Unable to register to sensors class: %d\n",
+			       __func__, err);
+		goto exit_create_class_sysfs;
+	}
+
+	return 0;
+exit_create_class_sysfs:
+	sensors_classdev_unregister(&als_ps->als_cdev);
+exit_free_irq:
+	free_irq(client->irq, client);
+exit_remove_sysfs_group:
+	sysfs_remove_group(&client->dev.kobj, &rpr400_attr_group);
+exit_unregister_dev_ps:
+	input_unregister_device(als_ps->input_dev_ps);
+exit_unregister_dev_als:
+	input_unregister_device(als_ps->input_dev_als);
+exit_free_dev_ps:
+	input_free_device(als_ps->input_dev_ps);
+exit_free_dev_als:
+	input_free_device(als_ps->input_dev_als);
+exit_kfree:
+	if (pdata->power_on)
+		pdata->power_on(false);
+	if (pdata->exit)
+		pdata->exit();
+	kfree(als_ps);
+exit:
+	return err;
+
+#undef ROHM_PSALS_ALSMAX
+#undef ROHM_PSALS_PSMAX
+}
+
+static int  rpr400_remove(struct i2c_client *client)
+{
+	struct ALS_PS_DATA *als_ps = i2c_get_clientdata(client);
+
+	input_unregister_device(als_ps->input_dev_als);
+	input_unregister_device(als_ps->input_dev_ps);
+
+	input_free_device(als_ps->input_dev_als);
+	input_free_device(als_ps->input_dev_ps);
+
+	free_irq(client->irq, client);
+
+	sysfs_remove_group(&client->dev.kobj, &rpr400_attr_group);
+
+	/* Power down the device */
+	rpr400_set_enable(client, 0);
+
+	sensor_info = NULL;
+	kfree(als_ps);
+
+	return 0;
+}
+
+static int rpr400_suspend(struct device *dev)
+{
+	int err;
+	struct ALS_PS_DATA *als_ps;
+	als_ps = dev_get_drvdata(dev);
+	pr_info("%s\n", __func__);
+
+	/*
+	  * Save sensor state and disable them,
+	  * this is to ensure internal state flags are set correctly.
+	  * device will power off after both sensors are disabled.
+	  * P sensor will not be disabled because it  is a wakeup sensor.
+	*/
+	als_ps->enable_als_state = als_ps->enable_als_sensor;
+	als_ps->enable_ps_state = als_ps->enable_ps_sensor;
+
+	if (als_ps->enable_ps_state) {
+		err = enable_irq_wake(als_ps->client->irq);
+		if (err)
+			pr_info("%s: enable_irq_wake(%d) failed,err=(%d)\n",
+				__func__, als_ps->client->irq, err);
+	}
+
+	if (als_ps->enable_als_sensor == 1)
+		rpr0410_enable_als_sensor(als_ps->client, 0);
+
+	return 0;
+}
+
+static int rpr400_resume(struct device *dev)
+{
+	int err;
+	struct ALS_PS_DATA *als_ps;
+	als_ps = dev_get_drvdata(dev);
+	pr_info("%s\n", __func__);
+
+	if (als_ps->enable_ps_state) {
+		err = disable_irq_wake(als_ps->client->irq);
+		if (err)
+			pr_info("%s: disable_irq_wake(%d) failed,err=(%d)\n",
+				__func__, als_ps->client->irq, err);
+	}
+
+	if (als_ps->enable_als_sensor == 1)
+		rpr0410_enable_als_sensor(als_ps->client, 1);
+
+	return 0;
+}
+
+MODULE_DEVICE_TABLE(i2c, rpr400_id);
+
+static struct of_device_id rpr_match_table[] = {
+	{ .compatible = "rohm,rpr0410",},
+	{ },
+};
+
+static const struct i2c_device_id rpr400_id[] = {
+	{ "rpr400", 0 },
+	{ }
+};
+
+static const struct dev_pm_ops rpr400_pm_ops = {
+	.suspend	= rpr400_suspend,
+	.resume		= rpr400_resume,
+};
+
+static struct i2c_driver rpr400_driver = {
+	.driver = {
+		.name	= RPR400_DRV_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table = rpr_match_table,
+		.pm = &rpr400_pm_ops,
+	},
+	.probe	= rpr400_probe,
+	.remove	= rpr400_remove,
+	.id_table	= rpr400_id,
+};
+
+static int __init rpr400_init(void)
+{
+	return i2c_add_driver(&rpr400_driver);
+}
+
+static void __exit rpr400_exit(void)
+{
+	i2c_del_driver(&rpr400_driver);
+}
+
+MODULE_AUTHOR("Andy Mi @ ROHM");
+MODULE_DESCRIPTION("RPR400 ambient light + proximity sensor driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRIVER_VERSION);
+
+module_init(rpr400_init);
+module_exit(rpr400_exit);
diff --git a/include/linux/input/rpr0410_driver.h b/include/linux/input/rpr0410_driver.h
new file mode 100644
index 0000000..4b070f1
--- /dev/null
+++ b/include/linux/input/rpr0410_driver.h
@@ -0,0 +1,251 @@
+/* include/linux/input/rpr0400_driver.h - ROHM RPR0400 Linux kernel driver
+ *
+ * Copyright (C) 2012-2014
+ * Written by Andy Mi <andy-mi@rohm.com.cn>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <linux/sensors.h>
+ /*************** Definitions ******************/
+/* GENERAL */
+#define RPR400_DRV_NAME	"rpr0410"
+#define DRIVER_VERSION		"1.1"
+#define THRES_TOLERANCE		15
+#define THRES_DIFF	20
+#define THRES_DEFAULT_DIFF	30
+
+/* RPR400 REGSTER */
+#define REG_SYSTEMCONTROL	0x40
+#define REG_MODECONTROL	0x41
+#define REG_ALSPSCONTROL	0x42
+#define REG_PERSISTENCE	0x43
+	#define REG_PSDATA		0x44
+	#define REG_PSDATA_LSB	0x44
+	#define REG_PSDATA_MBS	0x45
+#define REG_ALSDATA0		0x46
+#define REG_ALSDATA0_LSB	0x46
+#define REG_ALSDATA0_MBS	0x47
+#define REG_ALSDATA1		0x48
+	#define REG_ALSDATA1_LSB	0x48
+	#define REG_ALSDATA1_MBS	0x49
+#define REG_INTERRUPT	0x4A
+#define REG_PSTH			0x4B
+	#define REG_PSTH_LSB	0x4B
+	#define REG_PSTH_MBS	0x4C
+#define REG_PSTL			0x4D
+	#define REG_PSTL_LSB		0x4D
+	#define REG_PSTL_MBS	0x4E
+#define REG_ALSDATA0TH		0x4F
+	#define REG_ALSDATA0TH_LSB	0x4F
+	#define REG_ALSDATA0TH_MBS	0x50
+#define REG_ALSDATA0TL	0x51
+	#define REG_ALSDATA0TL_LSB	0x51
+	#define REG_ALSDATA0TL_MBS	0x52
+#define MANUFACT_ID 0x92
+
+/* SETTINGS */
+#define CUT_UNIT		1
+#define CALC_ERROR	0x80000000
+#define MASK_LONG	0xFFFFFFFF
+#define MASK_CHAR	0xFF
+#define BOTH_STANDBY	0
+#define ALS100MS	0x5
+#define PS100MS	0x3
+#define BOTH100MS	0x6
+#define LEDCURRENT_025MA	0
+#define LEDCURRENT_050MA	1
+#define LEDCURRENT_100MA	2
+#define LEDCURRENT_200MA	3
+#define ALSGAIN_X1X1	(0x0 << 2)
+#define ALSGAIN_X1X2	(0x1 << 2)
+#define ALSGAIN_X2X2	(0x5 << 2)
+#define ALSGAIN_X64X64	(0xA << 2)
+#define ALSGAIN_X128X64	(0xE << 2)
+#define ALSGAIN_X128X128	(0xF << 2)
+#define NORMAL_MODE	(0 << 4)
+#define LOW_NOISE_MODE	(1 << 4)
+#define PS_INT_MASK		(1 << 7)
+#define ALS_INT_MASK	(1 << 6)
+#define PS_THH_ONLY	(0 << 4)
+#define PS_THH_BOTH_HYS			(1 << 4)
+#define PS_THH_BOTH_OUTSIDE	(2 << 4)
+#define POLA_ACTIVEL	(0 << 3)
+#define POLA_INACTIVEL	(1 << 3)
+#define OUTPUT_ANYTIME	(0 << 2)
+#define OUTPUT_LATCH	(1 << 2)
+#define MODE_NONUSE			0
+#define MODE_PROXIMITY		1
+#define MODE_ILLUMINANCE	2
+#define MODE_BOTH			3
+
+/* RANGE */
+#define REG_PSTH_MAX	0xFFF
+#define REG_PSTL_MAX	0xFFF
+#define PERSISTENCE_MAX	0x0F
+#define GEN_READ_MAX	19
+#define REG_ALSPSCTL_MAX	0x3F
+#define REG_INTERRUPT_MAX	0x2F
+
+/* POWER SUPPLY VOLTAGE RANGE */
+#define RPR0410_VDD_MIN_UV	2000000
+#define RPR0410_VDD_MAX_UV	3300000
+#define RPR0410_VIO_MIN_UV	1750000
+#define RPR0410_VIO_MAX_UV	1950000
+
+/* INIT PARAM */
+#define PS_ALS_SET_MODE_CONTROL	(NORMAL_MODE)
+#define PS_ALS_SET_ALSPS_CONTROL	(LEDCURRENT_100MA | ALSGAIN_X1X1)
+#define PS_ALS_SET_INTR_PERSIST	 1
+#define PS_ALS_SET_INTR \
+	(PS_THH_BOTH_OUTSIDE | POLA_ACTIVEL | OUTPUT_LATCH | MODE_PROXIMITY)
+#define PS_ALS_SET_PS_TH	80
+#define PS_ALS_SET_PS_TL	10
+#define PS_ALS_SET_ALS_TH	2000
+#define PS_ALS_SET_ALS_TL	0x0000
+#define PS_ALS_SET_MIN_DELAY_TIME	1000
+#define RPR0410_MAX_DELAY	1000
+#define RPR0410_MIN_DELAY	1
+
+/* OTHER */
+#ifdef _ALS_BIG_ENDIAN_
+#define CONVERT_TO_BE(value)
+((((value) >> 8) & 0xFF) | (((value) << 8) & 0xFF00))
+#else
+#define CONVERT_TO_BE(value) (value)
+#endif
+
+#define _FUNCTION_USED_ 0
+
+/*************** Structs ******************/
+struct rpr0410_platform_data {
+	/* power contrl */
+	int (*power)(unsigned char onoff);
+	int (*init)(void);
+	void (*exit)(void);
+	int (*power_on)(bool);
+};
+
+struct  wake_lock ps_lock;
+struct ALS_PS_DATA {
+	struct i2c_client *client;
+	struct sensors_classdev als_cdev;
+	struct sensors_classdev ps_cdev;
+	/* regulator data */
+	bool power_on;
+	struct regulator *vdd;
+	struct regulator *vio;
+
+	struct rpr0410_platform_data *platform_data;
+
+	struct mutex update_lock;
+	struct delayed_work	dwork;/* for PS interrupt */
+	struct delayed_work    als_dwork;/* for ALS polling */
+	struct input_dev *input_dev_als;
+	struct input_dev *input_dev_ps;
+
+	atomic_t delay;
+	unsigned int enable;
+	unsigned int als_time;
+	unsigned int ps_time;
+	unsigned int ps_th_l;
+	unsigned int ps_th_h;
+	unsigned int ps_th_l_back;
+	unsigned int ps_th_h_back;
+	unsigned int als_th_l;
+	unsigned int als_th_h;
+	unsigned int persistence;
+	unsigned int control;
+	unsigned int irq_gpio;
+	unsigned int irq_gpio_flags;
+	int irq;
+
+	/* register value */
+	unsigned short als_data0_raw;
+	unsigned short als_data1_raw;
+	unsigned short ps_data_raw;
+
+	/* control flag from HAL */
+	unsigned int enable_ps_sensor;
+	unsigned int enable_als_sensor;
+
+	unsigned int enable_ps_state;
+	unsigned int enable_als_state;
+
+	/* PS parameters */
+	unsigned int ps_direction;/* 0 = near-to-far; 1 = far-to-near */
+	unsigned int ps_data;/* to store PS data */
+	float ps_distance;
+	unsigned int ledcurrent;
+
+	/* ALS parameters */
+	unsigned int als_data;/* to store ALS data */
+	unsigned int als_level;
+	unsigned int gain0;
+	unsigned int gain1;
+	unsigned int als_poll_delay;
+};
+
+static struct sensors_classdev sensors_light_cdev = {
+	.name = "rpr0410-light",
+	.vendor = "rohm",
+	.version = 1,
+	.handle = SENSORS_LIGHT_HANDLE,
+	.type = SENSOR_TYPE_LIGHT,
+	.max_range = "60000",
+	.resolution = "0.0125",
+	.sensor_power = "0.20",
+	.min_delay = 0, /* in microseconds */
+	.fifo_reserved_event_count = 0,
+	.fifo_max_event_count = 0,
+	.enabled = 0,
+	.delay_msec = 100,
+	.sensors_enable = NULL,
+	.sensors_poll_delay = NULL,
+};
+
+static struct sensors_classdev sensors_proximity_cdev = {
+	.name = "rpr0410-proximity",
+	.vendor = "rohm",
+	.version = 1,
+	.handle = SENSORS_PROXIMITY_HANDLE,
+	.type = SENSOR_TYPE_PROXIMITY,
+	.max_range = "5",
+	.resolution = "5.0",
+	.sensor_power = "3",
+	.min_delay = 0, /* in microseconds */
+	.fifo_reserved_event_count = 0,
+	.fifo_max_event_count = 0,
+	.enabled = 0,
+	.delay_msec = 100,
+	.sensors_enable = NULL,
+	.sensors_poll_delay = NULL,
+};
+
+struct CALC_DATA {
+	unsigned long long	data;
+	unsigned long long	data0;
+	unsigned long long	data1;
+	unsigned char	gain_data0;
+	unsigned char	gain_data1;
+	unsigned long	dev_unit;
+	unsigned short	als_time;
+	unsigned short	als_data0;
+	unsigned short	als_data1;
+};
+
+struct CALC_ANS {
+	unsigned long	positive;
+	unsigned long	decimal;
+};
-- 
1.7.9.5

