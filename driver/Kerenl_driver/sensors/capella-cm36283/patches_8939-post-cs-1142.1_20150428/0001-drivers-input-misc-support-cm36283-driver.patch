From 4985254aae04ebe7915ad3983ec6fcf09426517a Mon Sep 17 00:00:00 2001
From: Yukun Wan <wanyk0402@thundersoft.com>
Date: Tue, 28 Apr 2015 17:33:46 +0800
Subject: [PATCH 1/3] drivers:input:misc: support cm36283 driver

Driver support cm36283

Change-Id: Ic06538b70fade47bdb99ad543de24cce3e9d9947
Signed-off-by: Yukun Wan <wanyk0402@thundersoft.com>
---
 drivers/input/misc/Kconfig   |  10 +
 drivers/input/misc/Makefile  |   1 +
 drivers/input/misc/cm36283.c | 809 +++++++++++++++++++++++++++----------------
 include/linux/cm36283.h      | 145 ++++----
 4 files changed, 596 insertions(+), 369 deletions(-)

diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index b358471..fcbb6de 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -217,6 +217,16 @@ config SENSORS_LIS3DH
 	  To compile this driver as a module, choose M here: the
 	  module will be called lis3dh_acc.
 
+config SENSORS_CM36283
+	tristate "CAPELLA CM36283 Ambient light and proximity sensor"
+	depends on I2C
+	help
+	  Say Y here if you want to support Capella CM36283
+	  combined ambient light and proximity sensor chip.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called cm36283. If unsure, say N here.
+
 config INPUT_APANEL
 	tristate "Fujitsu Lifebook Application Panel buttons"
 	depends on X86 && I2C && LEDS_CLASS
diff --git a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
index 139a4fb..0ce9517 100644
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -72,6 +72,7 @@ obj-$(CONFIG_SENSORS_MPU6050)		+= mpu6050.o
 obj-$(CONFIG_SENSORS_AKM8963)		+= akm8963.o
 obj-$(CONFIG_SENSORS_AKM09911)		+= akm09911.o
 obj-$(CONFIG_SENSORS_LIS3DH)		+= lis3dh_acc.o
+obj-$(CONFIG_SENSORS_CM36283)	+= cm36283.o
 obj-$(CONFIG_SENSORS_BMA2X2)	+= bstclass.o
 
 obj-$(CONFIG_SENSORS_BMA2X2)	+= bma2x2.o
diff --git a/drivers/input/misc/cm36283.c b/drivers/input/misc/cm36283.c
index d2359f1..b224a04 100644
--- a/drivers/input/misc/cm36283.c
+++ b/drivers/input/misc/cm36283.c
@@ -1,9 +1,9 @@
 /* drivers/input/misc/cm36283.c - cm36283 optical sensors driver
  *
- * Copyright (C) 2012 Capella Microsystems Inc.
+ * Copyright (C) 2012-2015 Capella Microsystems Inc.
  * Author: Frank Hsieh <pengyueh@gmail.com>
  *
- * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2013-2015, The Linux Foundation. All rights reserved.
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -35,8 +35,8 @@
 #include <linux/jiffies.h>
 #include <linux/cm36283.h>
 #include <linux/of_gpio.h>
-
-#include <asm/uaccess.h>
+/*#include <asm/uaccess.h>*/
+#include <linux/uaccess.h>
 #include <asm/setup.h>
 
 #define I2C_RETRY_COUNT 10
@@ -44,8 +44,8 @@
 #define NEAR_DELAY_TIME ((100 * HZ) / 1000)
 
 #define CONTROL_INT_ISR_REPORT        0x00
-#define CONTROL_ALS                   0x01
-#define CONTROL_PS                    0x02
+#define CONTROL_ALS		0x01
+#define CONTROL_PS		0x02
 
 /* POWER SUPPLY VOLTAGE RANGE */
 #define CM36283_VDD_MIN_UV	2700000
@@ -62,6 +62,14 @@
 #define CM36283_PS_MAX_POLL_DELAY	1000
 #define CM36283_PS_DEFAULT_POLL_DELAY	100
 
+#define ALS_MAX			3277
+
+/* whether disable light or not at phone
+  * calling while the automatic backlight is on.
+  * the default value is 1.
+  */
+#define UNSUPPORT_AUTO_BACKLIGHT 0
+
 static struct sensors_classdev sensors_light_cdev = {
 	.name = "cm36283-light",
 	.vendor = "Capella",
@@ -121,6 +129,11 @@ struct cm36283_info {
 	struct device *ls_dev;
 	struct device *ps_dev;
 
+	unsigned int enable_als_sensor;
+	unsigned int enable_ps_sensor;
+	unsigned int enable_als_state;
+	unsigned int enable_ps_state;
+
 	struct input_dev *ls_input_dev;
 	struct input_dev *ps_input_dev;
 
@@ -137,7 +150,7 @@ struct cm36283_info {
 	int irq;
 
 	int ls_calibrate;
-	
+
 	int (*power)(int, uint8_t); /* power to the chip */
 
 	uint32_t als_kadc;
@@ -150,7 +163,8 @@ struct cm36283_info {
 	uint8_t slave_addr;
 
 	uint8_t ps_close_thd_set;
-	uint8_t ps_away_thd_set;	
+	uint8_t ps_away_thd_set;
+	uint8_t ps_away_cali_param;
 	int current_level;
 	uint16_t current_adc;
 
@@ -170,23 +184,28 @@ struct cm36283_info {
 	struct sensors_classdev ps_cdev;
 };
 struct cm36283_info *lp_info;
-int fLevel=-1;
-static struct mutex als_enable_mutex, als_disable_mutex, als_get_adc_mutex;
-static struct mutex ps_enable_mutex, ps_disable_mutex, ps_get_adc_mutex;
+int fLevel = -1;
+static struct mutex als_enable_mutex;
+static struct mutex als_disable_mutex;
+static struct mutex als_get_adc_mutex;
+static struct mutex ps_enable_mutex;
+static struct mutex ps_disable_mutex;
+static struct mutex ps_get_adc_mutex;
 static struct mutex CM36283_control_mutex;
 static struct mutex wq_lock;
 static int lightsensor_enable(struct cm36283_info *lpi);
 static int lightsensor_disable(struct cm36283_info *lpi);
-static int initial_cm36283(struct cm36283_info *lpi);
 static void psensor_initial_cmd(struct cm36283_info *lpi);
 static int cm36283_power_set(struct cm36283_info *info, bool on);
+static int cm36283_enable_als_sensor(struct i2c_client *client, int enable);
 
 int32_t als_kadc;
 
 static int control_and_report(struct cm36283_info *lpi, uint8_t mode,
 		uint16_t param, int report);
 
-static int I2C_RxData(uint16_t slaveAddr, uint8_t cmd, uint8_t *rxData, int length)
+static int I2C_RxData(uint16_t slaveAddr,
+	uint8_t cmd, uint8_t *rxData, int length)
 {
 	uint8_t loop_i;
 	struct cm36283_info *lpi = lp_info;
@@ -204,7 +223,7 @@ static int I2C_RxData(uint16_t slaveAddr, uint8_t cmd, uint8_t *rxData, int leng
 		 .flags = I2C_M_RD,
 		 .len = length,
 		 .buf = rxData,
-		 },		 
+		 },
 	};
 
 	subaddr[0] = cmd;
@@ -216,7 +235,7 @@ static int I2C_RxData(uint16_t slaveAddr, uint8_t cmd, uint8_t *rxData, int leng
 
 		dev_err(&lpi->i2c_client->dev, "%s: I2C error(%d). Retrying.\n",
 				__func__, cmd);
-		msleep(10);
+		/*msleep(20);*/
 	}
 	if (loop_i >= I2C_RETRY_COUNT) {
 		dev_err(&lpi->i2c_client->dev, "%s: Retry count exceeds %d.",
@@ -246,7 +265,7 @@ static int I2C_TxData(uint16_t slaveAddr, uint8_t *txData, int length)
 			break;
 
 		pr_err("%s: I2C error. Retrying...\n", __func__);
-		msleep(10);
+		msleep(20);
 	}
 
 	if (loop_i >= I2C_RETRY_COUNT) {
@@ -258,7 +277,8 @@ static int I2C_TxData(uint16_t slaveAddr, uint8_t *txData, int length)
 	return 0;
 }
 
-static int _cm36283_I2C_Read_Word(uint16_t slaveAddr, uint8_t cmd, uint16_t *pdata)
+static int _cm36283_I2C_Read_Word(uint16_t slaveAddr,
+	uint8_t cmd, uint16_t *pdata)
 {
 	uint8_t buffer[2];
 	int ret = 0;
@@ -277,15 +297,16 @@ static int _cm36283_I2C_Read_Word(uint16_t slaveAddr, uint8_t cmd, uint16_t *pda
 	return ret;
 }
 
-static int _cm36283_I2C_Write_Word(uint16_t SlaveAddress, uint8_t cmd, uint16_t data)
+static int _cm36283_I2C_Write_Word(uint16_t SlaveAddress,
+	uint8_t cmd, uint16_t data)
 {
 	char buffer[3];
 	int ret = 0;
 
 	buffer[0] = cmd;
 	buffer[1] = (uint8_t)(data&0xff);
-	buffer[2] = (uint8_t)((data&0xff00)>>8);	
-	
+	buffer[2] = (uint8_t)((data&0xff00)>>8);
+
 	ret = I2C_TxData(SlaveAddress, buffer, 3);
 	if (ret < 0) {
 		pr_err("%s: I2C_TxData failed.\n", __func__);
@@ -342,10 +363,10 @@ static int get_ps_adc_value(uint16_t *data)
 	struct cm36283_info *lpi = lp_info;
 
 	if (data == NULL)
-		return -EFAULT;	
+		return -EFAULT;
 
 	ret = _cm36283_I2C_Read_Word(lpi->slave_addr, PS_DATA, data);
-	
+
 	if (ret < 0)
 		return ret;
 
@@ -383,7 +404,7 @@ static int get_stable_ps_adc_value(uint16_t *ps_adc)
 	for (i = 0; i < 3; i++) {
 		/*wait interrupt GPIO high*/
 		while (gpio_get_value(lpi->intr_pin) == 0) {
-			msleep(10);
+			msleep(20);
 			wait_count++;
 			if (wait_count > 12) {
 				dev_err(&lpi->i2c_client->dev, "%s: interrupt GPIO low\n",
@@ -416,11 +437,32 @@ static int get_stable_ps_adc_value(uint16_t *ps_adc)
 static void sensor_irq_do_work(struct work_struct *work)
 {
 	struct cm36283_info *lpi = lp_info;
+	uint16_t adc_value = 0;
+	int ret;
+	int flag;
 	uint16_t intFlag;
-	_cm36283_I2C_Read_Word(lpi->slave_addr, INT_FLAG, &intFlag);
-	control_and_report(lpi, CONTROL_INT_ISR_REPORT, intFlag, 1);
 
-	enable_irq(lpi->irq);
+	ret = _cm36283_I2C_Read_Word(lpi->slave_addr, INT_FLAG, &intFlag);
+	if (ret < 0)
+		goto error;
+
+	mutex_lock(&wq_lock);
+	ret = get_ps_adc_value(&adc_value);
+	if (ret < 0)
+		goto error;
+	mutex_unlock(&wq_lock);
+
+	if (adc_value > lpi->ps_close_thd_set)
+		flag = 0;
+	else if (adc_value < (lpi->ps_away_thd_set + lpi->ps_away_cali_param))
+		flag = 1;
+
+	input_report_abs(lpi->ps_input_dev, ABS_DISTANCE, flag);
+	input_sync(lpi->ps_input_dev);
+	wake_lock_timeout(&lpi->ps_wake_lock, HZ);
+
+error:
+enable_irq(lpi->irq);
 }
 
 static int get_als_range(void)
@@ -440,7 +482,7 @@ static int get_als_range(void)
 	index = (ls_conf & 0xC0) >> 0x06;
 	return  als_range[index];
 }
-
+/*
 static int get_als_sense(void)
 {
 	uint16_t ls_conf;
@@ -448,14 +490,19 @@ static int get_als_sense(void)
 	int index = 0;
 	struct cm36283_info *lpi = lp_info;
 
+	ret = i2c_smbus_write_word_data(lpi->i2c_client, ALS_CONF, 0xFF7C);
+
 	ret = _cm36283_I2C_Read_Word(lpi->slave_addr, ALS_CONF, &ls_conf);
 	if (ret) {
-		dev_err(&lpi->i2c_client->dev, "read ALS_CONF from i2c error. %d\n",
-				ret);
+		dev_err(&lpi->i2c_client->dev,
+			"read ALS_CONF from i2c error. %d\n", ret);
 		return -EIO;
 	}
 
+	ret = i2c_smbus_read_word_data(lpi->i2c_client, ALS_CONF);
+
 	index = (ls_conf & 0xC0) >> 0x06;
+
 	return  als_sense[index];
 }
 
@@ -464,6 +511,7 @@ static void psensor_delay_work_handler(struct work_struct *work)
 	struct cm36283_info *lpi = lp_info;
 	uint16_t adc_value = 0;
 	int ret;
+	int flag;
 
 	mutex_lock(&wq_lock);
 
@@ -471,20 +519,67 @@ static void psensor_delay_work_handler(struct work_struct *work)
 
 	mutex_unlock(&wq_lock);
 
+	if (adc_value > lpi->ps_close_thd_set)
+		flag = 0;
+	else if (adc_value < lpi->ps_away_thd_set)
+		flag = 1;
 	if (ret >= 0) {
-		input_report_abs(lpi->ps_input_dev, ABS_DISTANCE,
-				adc_value > lpi->ps_close_thd_set ? 0 : 1);
+		input_report_abs(lpi->ps_input_dev, ABS_DISTANCE, flag);
 		input_sync(lpi->ps_input_dev);
 	}
 	schedule_delayed_work(&lpi->pdwork,
 			msecs_to_jiffies(atomic_read(&lpi->ps_poll_delay)));
 }
+*/
+static int cm36283_smbus_read_word(struct i2c_client *client,
+		unsigned char reg_addr)
+{
+	s32 dummy;
+	dummy = i2c_smbus_read_word_data(client, reg_addr);
+	if (dummy < 0)
+		return dummy;
+
+	return dummy & 0x0000ffff;
+}
+
+static int cm36283_read_als(struct i2c_client *client)
+{
+	int val;
+	val = cm36283_smbus_read_word(client, ALS_DATA);
+
+	return val;
+}
+#define lux_calc(step) (step/10)
+static int cm36283_get_als(struct i2c_client *client)
+{
+	int ret;
+	static int als_buf[3];
+	static int idx;
+	ret = cm36283_read_als(client);
+
+	if (ret > -1)
+		ret = lux_calc(ret);
+	if (ret > ALS_MAX)
+		ret = ALS_MAX;
+	if (ret > -1) {
+		als_buf[idx] = ret;
+		idx++;
+	}
+	if (idx == 3) {
+		ret = (als_buf[0] + als_buf[1] + als_buf[2])/3;
+		idx = 0;
+	} else
+		ret = -5;
+
+	return ret;
+}
 
 static void lsensor_delay_work_handler(struct work_struct *work)
 {
 	struct cm36283_info *lpi = lp_info;
 	uint16_t adc_value = 0;
-	int sense;
+/*	int sense;
+	int ret;
 
 	mutex_lock(&wq_lock);
 
@@ -498,6 +593,16 @@ static void lsensor_delay_work_handler(struct work_struct *work)
 		input_report_abs(lpi->ls_input_dev, ABS_MISC, adc_value/sense);
 		input_sync(lpi->ls_input_dev);
 	}
+*/
+	mutex_lock(&wq_lock);
+	adc_value  = cm36283_get_als(lpi->i2c_client);
+	mutex_unlock(&wq_lock);
+
+	if ((adc_value > -1) && (adc_value < ALS_MAX)) {
+		input_report_abs(lpi->ls_input_dev, ABS_MISC, adc_value);
+		input_sync(lpi->ls_input_dev);
+	}
+
 	schedule_delayed_work(&lpi->ldwork,
 			msecs_to_jiffies(atomic_read(&lpi->ls_poll_delay)));
 }
@@ -523,11 +628,13 @@ static int als_power(int enable)
 }
 
 static void ls_initial_cmd(struct cm36283_info *lpi)
-{	
-	/*must disable l-sensor interrupt befrore IST create*//*disable ALS func*/
+{
+	/*must disable l-sensor interrupt befrore IST create*/
+	/*disable ALS func*/
 	lpi->ls_cmd &= CM36283_ALS_INT_MASK;
-  lpi->ls_cmd |= CM36283_ALS_SD;
-  _cm36283_I2C_Write_Word(lpi->slave_addr, ALS_CONF, lpi->ls_cmd);  
+	lpi->ls_cmd |= CM36283_ALS_SD;
+
+	_cm36283_I2C_Write_Word(lpi->slave_addr, ALS_CONF, lpi->ls_cmd);
 }
 
 static void psensor_initial_cmd(struct cm36283_info *lpi)
@@ -547,11 +654,12 @@ static void psensor_initial_cmd(struct cm36283_info *lpi)
 static int psensor_enable(struct cm36283_info *lpi)
 {
 	int ret = -EIO;
-	unsigned int delay;
-	
+	/*unsigned int delay;*/
+
 	mutex_lock(&ps_enable_mutex);
 	dev_dbg(&lpi->i2c_client->dev, "psensor enable!\n");
 
+
 	if (lpi->ps_enable) {
 		dev_err(&lpi->i2c_client->dev, "already enabled\n");
 		ret = 0;
@@ -561,10 +669,12 @@ static int psensor_enable(struct cm36283_info *lpi)
 
 	mutex_unlock(&ps_enable_mutex);
 
-	delay = atomic_read(&lpi->ps_poll_delay);
+	enable_irq(lpi->irq);
+
+/*	delay = atomic_read(&lpi->ps_poll_delay);
 	if (lpi->polling)
 		schedule_delayed_work(&lpi->pdwork, msecs_to_jiffies(delay));
-
+*/
 	return ret;
 }
 
@@ -572,9 +682,9 @@ static int psensor_disable(struct cm36283_info *lpi)
 {
 	int ret = -EIO;
 
-	if (lpi->polling)
+/*	if (lpi->polling)
 		cancel_delayed_work_sync(&lpi->pdwork);
-
+*/
 	mutex_lock(&ps_disable_mutex);
 	dev_dbg(&lpi->i2c_client->dev, "psensor disable!\n");
 
@@ -586,6 +696,8 @@ static int psensor_disable(struct cm36283_info *lpi)
 	}
 
 	mutex_unlock(&ps_disable_mutex);
+
+	disable_irq(lpi->irq);
 	return ret;
 }
 
@@ -612,7 +724,7 @@ static int psensor_release(struct inode *inode, struct file *file)
 	lpi->psensor_opened = 0;
 
 	return psensor_disable(lpi);
-	//return 0;
+	/*return 0;*/
 }
 
 static long psensor_ioctl(struct file *file, unsigned int cmd,
@@ -727,13 +839,13 @@ static int lightsensor_disable(struct cm36283_info *lpi)
 	if (lpi->polling)
 		cancel_delayed_work_sync(&lpi->ldwork);
 
-	if ( lpi->als_enable == 0 ) {
+	if (lpi->als_enable == 0) {
 		dev_err(&lpi->i2c_client->dev, "already disabled\n");
 		ret = 0;
 	} else {
 		ret = control_and_report(lpi, CONTROL_ALS, 0, 0);
 	}
-	
+
 	mutex_unlock(&als_disable_mutex);
 	return ret;
 }
@@ -815,19 +927,75 @@ static ssize_t ps_adc_show(struct device *dev,
 	return ret;
 }
 
-static int ps_enable_set(struct sensors_classdev *sensors_cdev,
-		unsigned int enable)
+static int cm36283_enable_ps_sensor(struct i2c_client *client,
+	unsigned int enable)
 {
-	struct cm36283_info *lpi = container_of(sensors_cdev,
-			struct cm36283_info, ps_cdev);
 	int ret;
+	struct cm36283_info *lpi;
+	lpi = i2c_get_clientdata(client);
 
-	if (enable)
-		ret = psensor_enable(lpi);
-	else
-		ret = psensor_disable(lpi);
+	pr_info("CM36283 enable PS sensor -> %d\n", enable);
 
-	return ret;
+	if ((enable != 0) && (enable != 1)) {
+		pr_info("%s: enable als sensor=%d\n", __func__, enable);
+		return enable;
+	}
+
+	if (enable) {
+		if ((lpi->enable_als_sensor == 0)
+			&& (lpi->enable_ps_sensor == 0)) {
+			ret = cm36283_power_set(lpi, true);
+			if (ret < 0)
+				dev_err(&client->dev,
+				"%s:cm36283 power off error!\n", __func__);
+		}
+
+		if (lpi->enable_ps_sensor == 0) {
+			lpi->enable_ps_sensor = 1;
+			psensor_initial_cmd(lpi);
+			control_and_report(lpi, CONTROL_PS, 1, 0);
+			enable_irq(lpi->i2c_client->irq);
+			enable_irq_wake(lpi->i2c_client->irq);
+		}
+	} else {
+		if (lpi->enable_ps_sensor == 1) {
+			lpi->enable_ps_sensor = 0;
+			control_and_report(lpi, CONTROL_PS, 0, 0);
+			disable_irq_wake(lpi->i2c_client->irq);
+			disable_irq(lpi->i2c_client->irq);
+		}
+	}
+
+	/* when enable auto change backlight,
+	* als_enable should be reinit when ps
+	* disabled after use
+	*/
+/*	if (enable == 0)
+		cm36283_enable_als_sensor(client, 1);
+*/
+	if ((lpi->enable_als_sensor == 0)
+		&& (lpi->enable_ps_sensor == 0)) {
+		ret = cm36283_power_set(lpi, false);
+		if (ret < 0)
+			dev_err(&client->dev, "%s:cm36283 power off error!\n",
+			__func__);
+	}
+
+	return 0;
+}
+
+static int cm36283_ps_set_enable(struct sensors_classdev *sensors_cdev,
+		unsigned int enable)
+{
+	struct cm36283_info *lpi;
+	lpi = container_of(sensors_cdev, struct cm36283_info, ps_cdev);
+
+	if ((enable != 0) && (enable != 1)) {
+		pr_err("%s: invalid value(%d)\n", __func__, enable);
+		return -EINVAL;
+	}
+
+	return cm36283_enable_ps_sensor(lpi->i2c_client, enable);
 }
 
 static ssize_t ps_enable_store(struct device *dev,
@@ -855,7 +1023,6 @@ static ssize_t ps_enable_store(struct device *dev,
 	return count;
 }
 
-
 static ssize_t ps_parameters_show(struct device *dev,
 			struct device_attribute *attr, char *buf)
 {
@@ -902,7 +1069,9 @@ static ssize_t ps_conf_show(struct device *dev,
 			struct device_attribute *attr, char *buf)
 {
 	struct cm36283_info *lpi = lp_info;
-	return sprintf(buf, "PS_CONF1 = 0x%x, PS_CONF3 = 0x%x\n", lpi->ps_conf1_val, lpi->ps_conf3_val);
+	return snprintf(buf, PAGE_SIZE,
+		"PS_CONF1 = 0x%x, PS_CONF3 = 0x%x\n",
+		lpi->ps_conf1_val, lpi->ps_conf3_val);
 }
 static ssize_t ps_conf_store(struct device *dev,
 				struct device_attribute *attr,
@@ -929,8 +1098,11 @@ static ssize_t ps_thd_show(struct device *dev,
 {
 	int ret;
 	struct cm36283_info *lpi = lp_info;
-  ret = sprintf(buf, "%s ps_close_thd_set = 0x%x, ps_away_thd_set = 0x%x\n", __func__, lpi->ps_close_thd_set, lpi->ps_away_thd_set);
-  return ret;	
+	ret = snprintf(buf, PAGE_SIZE,
+		"%s ps_close_thd_set = 0x%x, ps_away_thd_set = 0x%x\n",
+		__func__, lpi->ps_close_thd_set, lpi->ps_away_thd_set);
+
+	return ret;
 }
 static ssize_t ps_thd_store(struct device *dev,
 				struct device_attribute *attr,
@@ -941,8 +1113,8 @@ static ssize_t ps_thd_store(struct device *dev,
 
 	sscanf(buf, "0x%x", &code);
 
-	lpi->ps_away_thd_set = code &0xFF;
-	lpi->ps_close_thd_set = (code & 0xFF00)>>8;
+	lpi->ps_away_thd_set = code & 0xFF;
+	lpi->ps_close_thd_set = (code & 0xFF00) >> 8;
 
 	dev_dbg(&lpi->i2c_client->dev, "ps_away_thd_set:0x%x\n",
 			lpi->ps_away_thd_set);
@@ -958,8 +1130,10 @@ static ssize_t ps_hw_show(struct device *dev,
 	int ret = 0;
 	struct cm36283_info *lpi = lp_info;
 
-	ret = sprintf(buf, "PS1: reg = 0x%x, PS3: reg = 0x%x, ps_close_thd_set = 0x%x, ps_away_thd_set = 0x%x\n",
-		lpi->ps_conf1_val, lpi->ps_conf3_val, lpi->ps_close_thd_set, lpi->ps_away_thd_set);
+	ret = snprintf(buf, PAGE_SIZE,
+		"PS1: reg = 0x%x, PS3: reg = 0x%x, ps_close_thd_set = 0x%x, ps_away_thd_set = 0x%x\n",
+		lpi->ps_conf1_val, lpi->ps_conf3_val,
+		lpi->ps_close_thd_set, lpi->ps_away_thd_set);
 
 	return ret;
 }
@@ -980,33 +1154,90 @@ static ssize_t ls_adc_show(struct device *dev,
 	int ret;
 	struct cm36283_info *lpi = lp_info;
 
-	ret = sprintf(buf, "ADC[0x%04X] => level %d\n",
+	ret = snprintf(buf, PAGE_SIZE, "ADC[0x%04X] => level %d\n",
 		lpi->current_adc, lpi->current_level);
 
 	return ret;
 }
 
-static int ls_enable_set(struct sensors_classdev *sensors_cdev,
-		unsigned int enable)
+static int cm36283_enable_als_sensor(struct i2c_client *client, int enable)
 {
-	struct cm36283_info *lpi = container_of(sensors_cdev,
-			struct cm36283_info, als_cdev);
 	int ret;
+	unsigned int delay;
+	struct cm36283_info *lpi = i2c_get_clientdata(client);
 
-	if (enable)
-		ret = lightsensor_enable(lpi);
-	else
-		ret = lightsensor_disable(lpi);
+	pr_info("CM36283 enable ALS sensor -> %d\n", enable);
+	if ((enable != 0) && (enable != 1)) {
+		pr_info("%s: enable als sensor=%d\n", __func__, enable);
+		return enable;
+	}
 
-	if (ret < 0) {
-		dev_err(&lpi->i2c_client->dev, "%s: set auto light sensor fail\n",
+	delay = atomic_read(&lpi->ls_poll_delay);
+
+	if (enable) {
+		if ((lpi->enable_als_sensor == 0)
+			&& (lpi->enable_ps_sensor == 0)) {
+
+			ret = cm36283_power_set(lpi, true);
+			if (ret < 0)
+				dev_err(&client->dev, "%s:cm36283 power off error!\n",
 				__func__);
-		return -EIO;
+		}
+
+		if (lpi->enable_als_sensor == 0) {
+			lpi->enable_als_sensor = 1;
+			ls_initial_cmd(lpi);
+
+			mutex_lock(&als_enable_mutex);
+			ret = control_and_report(lpi, CONTROL_ALS, 1, 0);
+			mutex_unlock(&als_enable_mutex);
+
+			schedule_delayed_work(&lpi->ldwork,
+				msecs_to_jiffies(delay));
+		}
+	} else {
+		if (lpi->enable_als_sensor == 1) {
+			lpi->enable_als_sensor = 0;
+
+			mutex_lock(&als_disable_mutex);
+			cancel_delayed_work_sync(&lpi->ldwork);
+			mutex_unlock(&als_disable_mutex);
+
+			if (lpi->als_enable == 0) {
+				dev_err(&lpi->i2c_client->dev,
+					"already disabled\n");
+				ret = 0;
+			} else {
+				ret = control_and_report(lpi,
+					CONTROL_ALS, 0, 0);
+			}
+		}
+	}
+
+	if ((lpi->enable_als_sensor == 0)
+		&& (lpi->enable_ps_sensor == 0)) {
+		ret = cm36283_power_set(lpi, false);
+		if (ret < 0)
+			dev_err(&client->dev,
+			"%s:cm36283 power off error!\n", __func__);
 	}
 
 	return 0;
 }
 
+static int cm36283_als_set_enable(struct sensors_classdev *sensors_cdev,
+		unsigned int enable)
+{
+	struct cm36283_info *lpi = container_of(sensors_cdev,
+			struct cm36283_info, als_cdev);
+	if ((enable != 0) && (enable != 1)) {
+		pr_err("%s: invalid value(%d)\n", __func__, enable);
+		return -EINVAL;
+	}
+
+	return cm36283_enable_als_sensor(lpi->i2c_client, enable);
+}
+
 static ssize_t ls_enable_show(struct device *dev,
 				  struct device_attribute *attr, char *buf)
 {
@@ -1014,7 +1245,7 @@ static ssize_t ls_enable_show(struct device *dev,
 	int ret = 0;
 	struct cm36283_info *lpi = lp_info;
 
-	ret = sprintf(buf, "Light sensor Auto Enable = %d\n",
+	ret = snprintf(buf, PAGE_SIZE, "Light sensor Auto Enable = %d\n",
 			lpi->als_enable);
 
 	return ret;
@@ -1064,7 +1295,7 @@ static ssize_t ls_kadc_show(struct device *dev,
 	struct cm36283_info *lpi = lp_info;
 	int ret;
 
-	ret = sprintf(buf, "kadc = 0x%x",
+	ret = snprintf(buf, PAGE_SIZE, "kadc = 0x%x",
 			lpi->als_kadc);
 
 	return ret;
@@ -1094,7 +1325,7 @@ static ssize_t ls_kadc_store(struct device *dev,
 		dev_err(&lpi->i2c_client->dev, "%s: als_kadc can't be set to zero\n",
 				__func__);
 	}
-				
+
 	mutex_unlock(&als_get_adc_mutex);
 	return count;
 }
@@ -1106,7 +1337,7 @@ static ssize_t ls_gadc_show(struct device *dev,
 	struct cm36283_info *lpi = lp_info;
 	int ret;
 
-	ret = sprintf(buf, "gadc = 0x%x\n", lpi->als_gadc);
+	ret = snprintf(buf, PAGE_SIZE, "gadc = 0x%x\n", lpi->als_gadc);
 
 	return ret;
 }
@@ -1119,7 +1350,7 @@ static ssize_t ls_gadc_store(struct device *dev,
 	int gadc_temp = 0;
 
 	sscanf(buf, "%d", &gadc_temp);
-	
+
 	mutex_lock(&als_get_adc_mutex);
 	if (gadc_temp != 0) {
 		lpi->als_gadc = gadc_temp;
@@ -1146,8 +1377,8 @@ static ssize_t ls_adc_table_show(struct device *dev,
 	int i;
 
 	for (i = 0; i < 10; i++) {
-		length += sprintf(buf + length,
-			"[CM36283]Get adc_table[%d] =  0x%x ; %d, Get cali_table[%d] =  0x%x ; %d, \n",
+		length += snprintf(buf + length, PAGE_SIZE,
+			"[CM36283]Get adc_table[%d] = 0x%x ; %d, Get cali_table[%d] =  0x%x ; %d,\n",
 			i, *(lp_info->adc_table + i),
 			*(lp_info->adc_table + i),
 			i, *(lp_info->cali_table + i),
@@ -1168,7 +1399,7 @@ static ssize_t ls_adc_table_store(struct device *dev,
 
 	for (i = 0; i < 10; i++) {
 		token[i] = strsep((char **)&buf, " ");
-		tempdata[i] = simple_strtoul(token[i], NULL, 16);
+		tempdata[i] = kstrtoul(token[i], 16, NULL);
 		if (tempdata[i] < 1 || tempdata[i] > 0xffff) {
 			dev_err(&lpi->i2c_client->dev,
 			"adc_table[%d] =  0x%x error\n",
@@ -1192,7 +1423,9 @@ static ssize_t ls_conf_show(struct device *dev,
 				  struct device_attribute *attr, char *buf)
 {
 	struct cm36283_info *lpi = lp_info;
-	return sprintf(buf, "ALS_CONF = %x\n", lpi->ls_cmd);
+
+	return snprintf(buf, PAGE_SIZE,
+		"ALS_CONF = %x\n", lpi->ls_cmd);
 }
 static ssize_t ls_conf_store(struct device *dev,
 				struct device_attribute *attr,
@@ -1235,7 +1468,7 @@ static ssize_t ls_poll_delay_store(struct device *dev,
 	return count;
 }
 
-static int ls_poll_delay_set(struct sensors_classdev *sensors_cdev,
+static int cm36283_als_poll_delay_set(struct sensors_classdev *sensors_cdev,
 		unsigned int delay_msec)
 {
 	struct cm36283_info *lpi = container_of(sensors_cdev,
@@ -1274,7 +1507,7 @@ static ssize_t ps_poll_delay_store(struct device *dev,
 	atomic_set(&lpi->ps_poll_delay, (unsigned int) interval_ms);
 	return count;
 }
-
+/*
 static int ps_poll_delay_set(struct sensors_classdev *sensors_cdev,
 		unsigned int delay_msec)
 {
@@ -1288,26 +1521,26 @@ static int ps_poll_delay_set(struct sensors_classdev *sensors_cdev,
 	atomic_set(&lpi->ps_poll_delay, delay_msec);
 	return 0;
 }
-
+*/
 static ssize_t ls_fLevel_show(struct device *dev,
 				  struct device_attribute *attr, char *buf)
 {
-	return sprintf(buf, "fLevel = %d\n", fLevel);
+	return snprintf(buf, PAGE_SIZE, "fLevel = %d\n", fLevel);
 }
 static ssize_t ls_fLevel_store(struct device *dev,
 				struct device_attribute *attr,
 				const char *buf, size_t count)
 {
 	struct cm36283_info *lpi = lp_info;
-	int value=0;
+	int value = 0;
 	sscanf(buf, "%d", &value);
-	(value>=0)?(value=min(value,10)):(value=max(value,-1));
-	fLevel=value;
+	(value >= 0) ? (value = min(value, 10)) : (value = max(value, -1));
+	fLevel = value;
 	input_report_abs(lpi->ls_input_dev, ABS_MISC, fLevel);
 	input_sync(lpi->ls_input_dev);
 
 	msleep(1000);
-	fLevel=-1;
+	fLevel = -1;
 	return count;
 }
 
@@ -1323,7 +1556,7 @@ static int lightsensor_setup(struct cm36283_info *lpi)
 			__func__);
 		return -ENOMEM;
 	}
-	lpi->ls_input_dev->name = "cm36283-ls";
+	lpi->ls_input_dev->name = "light";
 	lpi->ls_input_dev->id.bustype = BUS_I2C;
 	set_bit(EV_ABS, lpi->ls_input_dev->evbit);
 
@@ -1355,7 +1588,7 @@ static int psensor_setup(struct cm36283_info *lpi)
 			__func__);
 		return -ENOMEM;
 	}
-	lpi->ps_input_dev->name = "cm36283-ps";
+	lpi->ps_input_dev->name = "proximity";
 	lpi->ps_input_dev->id.bustype = BUS_I2C;
 	set_bit(EV_ABS, lpi->ps_input_dev->evbit);
 	input_set_abs_params(lpi->ps_input_dev, ABS_DISTANCE, 0, 1, 0, 0);
@@ -1375,84 +1608,60 @@ err_free_ps_input_device:
 	return ret;
 }
 
-
-static int initial_cm36283(struct cm36283_info *lpi)
-{
-	int val, ret;
-	uint16_t idReg;
-
-	val = gpio_get_value(lpi->intr_pin);
-	dev_dbg(&lpi->i2c_client->dev, "%s, INTERRUPT GPIO val = %d\n",
-		       __func__, val);
-
-	ret = _cm36283_I2C_Read_Word(lpi->slave_addr, ID_REG, &idReg);
-
-	return ret;
-}
-
 static int cm36283_setup(struct cm36283_info *lpi)
 {
 	int ret = 0;
 
 	als_power(1);
-	msleep(5);
-	ret = gpio_request(lpi->intr_pin, "gpio_cm36283_intr");
-	if (ret < 0) {
-		pr_err("[PS][CM36283 error]%s: gpio %d request failed (%d)\n",
-			__func__, lpi->intr_pin, ret);
-		return ret;
-	}
+	msleep(20);
 
-	ret = gpio_direction_input(lpi->intr_pin);
-	if (ret < 0) {
-		pr_err(
-			"[PS][CM36283 error]%s: fail to set gpio %d as input (%d)\n",
-			__func__, lpi->intr_pin, ret);
-		goto fail_free_intr_pin;
-	}
-
-
-	ret = initial_cm36283(lpi);
-	if (ret < 0) {
-		pr_err(
-			"[PS_ERR][CM36283 error]%s: fail to initial cm36283 (%d)\n",
-			__func__, ret);
-		goto fail_free_intr_pin;
-	}
-	
 	/*Default disable P sensor and L sensor*/
 	ls_initial_cmd(lpi);
 	psensor_initial_cmd(lpi);
 
 	if (!lpi->polling)
-		ret = request_any_context_irq(lpi->irq,
+		/*ret = request_any_context_irq(lpi->irq,
 				cm36283_irq_handler,
 				IRQF_TRIGGER_LOW,
 				"cm36283",
-				lpi);
+				lpi);*/
+		ret = request_irq(lpi->irq, cm36283_irq_handler,
+			IRQ_TYPE_EDGE_FALLING,
+			"cm36283", lpi);
+
 	if (ret < 0) {
 		pr_err(
 			"[PS][CM36283 error]%s: req_irq(%d) fail for gpio %d (%d)\n",
 			__func__, lpi->irq,
 			lpi->intr_pin, ret);
-		goto fail_free_intr_pin;
 	}
 
 	return ret;
-
-fail_free_intr_pin:
-	gpio_free(lpi->intr_pin);
-	return ret;
 }
 
 static int cm36283_parse_dt(struct device *dev,
 				struct cm36283_platform_data *pdata)
 {
 	struct device_node *np = dev->of_node;
-	u32	levels[CM36283_LEVELS_SIZE], i;
 	u32 temp_val;
 	int rc;
 
+	rc = of_property_read_u32(np, "capella,ls_poll_delay", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read ls_poll_delay\n");
+		return rc;
+	} else {
+		atomic_set(&pdata->ls_poll_delay, (u8)temp_val);
+	}
+
+	rc = of_property_read_u32(np, "capella,ps_poll_delay", &temp_val);
+	if (rc) {
+		dev_err(dev, "Unable to read ps_poll_delay");
+		return rc;
+	} else {
+		atomic_set(&pdata->ps_poll_delay, (u8)temp_val);
+	}
+
 	rc = of_get_named_gpio_flags(np, "capella,interrupt-gpio",
 			0, NULL);
 	if (rc < 0) {
@@ -1462,15 +1671,7 @@ static int cm36283_parse_dt(struct device *dev,
 		pdata->intr = rc;
 	}
 
-	rc = of_property_read_u32_array(np, "capella,levels", levels,
-			CM36283_LEVELS_SIZE);
-	if (rc) {
-		dev_err(dev, "Unable to read levels data\n");
-		return rc;
-	} else {
-		for (i = 0; i < CM36283_LEVELS_SIZE; i++)
-			pdata->levels[i] = levels[i];
-	}
+	pdata->polling = of_property_read_bool(np, "capella,use-polling");
 
 	rc = of_property_read_u32(np, "capella,ps_close_thd_set", &temp_val);
 	if (rc) {
@@ -1488,32 +1689,14 @@ static int cm36283_parse_dt(struct device *dev,
 		pdata->ps_away_thd_set = (u8)temp_val;
 	}
 
-	rc = of_property_read_u32(np, "capella,ls_cmd", &temp_val);
-	if (rc) {
-		dev_err(dev, "Unable to read ls_cmd\n");
-		return rc;
-	} else {
-		pdata->ls_cmd = (u16)temp_val;
-	}
-
-	rc = of_property_read_u32(np, "capella,ps_conf1_val", &temp_val);
-	if (rc) {
-		dev_err(dev, "Unable to read ps_conf1_val\n");
-		return rc;
-	} else {
-		pdata->ps_conf1_val = (u16)temp_val;
-	}
-
-	rc = of_property_read_u32(np, "capella,ps_conf3_val", &temp_val);
+	rc = of_property_read_u32(np, "capella,ps_away_cali_param", &temp_val);
 	if (rc) {
-		dev_err(dev, "Unable to read ps_conf3_val\n");
-		return rc;
+		dev_err(dev, "Unable to read ps_away_cali_param\n");
+		pdata->ps_away_cali_param = 0;
 	} else {
-		pdata->ps_conf3_val = (u16)temp_val;
+		pdata->ps_away_cali_param = (u8)temp_val;
 	}
 
-	pdata->polling = of_property_read_bool(np, "capella,use-polling");
-
 	return 0;
 }
 
@@ -1610,34 +1793,35 @@ static int cm36283_probe(struct i2c_client *client,
 	lpi->irq = client->irq;
 
 	i2c_set_clientdata(client, lpi);
-	
-  lpi->intr_pin = pdata->intr;
+
+	lpi->intr_pin = pdata->intr;
 	lpi->adc_table = pdata->levels;
 	lpi->power = pdata->power;
-	
+
 	lpi->slave_addr = pdata->slave_addr;
-	
+
 	lpi->ps_away_thd_set = pdata->ps_away_thd_set;
-	lpi->ps_close_thd_set = pdata->ps_close_thd_set;	
+	lpi->ps_close_thd_set = pdata->ps_close_thd_set;
 	lpi->ps_conf1_val = pdata->ps_conf1_val;
 	lpi->ps_conf3_val = pdata->ps_conf3_val;
 	lpi->polling = pdata->polling;
+	lpi->polling = 0;
+	lpi->ps_away_cali_param = pdata->ps_away_cali_param;
+
 	atomic_set(&lpi->ls_poll_delay,
 			(unsigned int) CM36283_LS_DEFAULT_POLL_DELAY);
 	atomic_set(&lpi->ps_poll_delay,
 			(unsigned int) CM36283_PS_DEFAULT_POLL_DELAY);
 
-	
 	lpi->ls_cmd  = pdata->ls_cmd;
-	
-	lpi->record_clear_int_fail=0;
-	
+	lpi->record_clear_int_fail = 0;
+
 	dev_dbg(&lpi->i2c_client->dev, "[PS][CM36283] %s: ls_cmd 0x%x\n",
 		__func__, lpi->ls_cmd);
-	
-	if (pdata->ls_cmd == 0) {
+
+
+	if (pdata->ls_cmd == 0)
 		lpi->ls_cmd  = CM36283_ALS_IT_80ms | CM36283_ALS_GAIN_2;
-	}
 
 	lp_info = lpi;
 
@@ -1652,7 +1836,6 @@ static int cm36283_probe(struct i2c_client *client,
 	mutex_init(&ps_disable_mutex);
 	mutex_init(&ps_get_adc_mutex);
 
-
 	/*
 	 * SET LUX STEP FACTOR HERE
 	 * if adc raw value one step = 5/100 = 1/20 = 0.05 lux
@@ -1675,21 +1858,25 @@ static int cm36283_probe(struct i2c_client *client,
 
 	lpi->lp_wq = create_singlethread_workqueue("cm36283_wq");
 	if (!lpi->lp_wq) {
-		pr_err("[PS][CM36283 error]%s: can't create workqueue\n", __func__);
+		pr_err("[PS][CM36283 error]%s: can't create workqueue\n",
+			__func__);
 		ret = -ENOMEM;
 		goto err_create_singlethread_workqueue;
 	}
-	wake_lock_init(&(lpi->ps_wake_lock), WAKE_LOCK_SUSPEND, "proximity");
+	wake_lock_init(&(lpi->ps_wake_lock), WAKE_LOCK_SUSPEND,
+		"proximity");
 
 	ret = cm36283_power_set(lpi, true);
 	if (ret < 0) {
-		dev_err(&client->dev, "%s:cm36283 power on error!\n", __func__);
+		dev_err(&client->dev, "%s:cm36283 power on error!\n",
+			__func__);
 		goto err_cm36283_power_on;
 	}
 
 	ret = cm36283_setup(lpi);
 	if (ret < 0) {
-		pr_err("[PS_ERR][CM36283 error]%s: cm36283_setup error!\n", __func__);
+		pr_err("[PS_ERR][CM36283 error]%s: cm36283_setup error!\n",
+			__func__);
 		goto err_cm36283_setup;
 	}
 
@@ -1722,14 +1909,14 @@ static int cm36283_probe(struct i2c_client *client,
 	}
 
 	lpi->als_cdev = sensors_light_cdev;
-	lpi->als_cdev.sensors_enable = ls_enable_set;
-	lpi->als_cdev.sensors_poll_delay = ls_poll_delay_set;
-	lpi->als_cdev.min_delay = CM36283_LS_MIN_POLL_DELAY * 1000;
+	lpi->als_cdev.sensors_enable = cm36283_als_set_enable;
+	lpi->als_cdev.sensors_poll_delay = cm36283_als_poll_delay_set;
+	/*lpi->als_cdev.min_delay = CM36283_LS_MIN_POLL_DELAY * 1000;*/
 
 	lpi->ps_cdev = sensors_proximity_cdev;
-	lpi->ps_cdev.sensors_enable = ps_enable_set;
-	lpi->ps_cdev.sensors_poll_delay = ps_poll_delay_set;
-	lpi->ps_cdev.min_delay = CM36283_PS_MIN_POLL_DELAY * 1000;
+	lpi->ps_cdev.sensors_enable = cm36283_ps_set_enable;
+	lpi->ps_cdev.sensors_poll_delay = NULL;/*ps_poll_delay_set;*/
+	/*lpi->ps_cdev.min_delay = CM36283_PS_MIN_POLL_DELAY * 1000;*/
 
 	ret = sensors_classdev_register(&client->dev, &lpi->als_cdev);
 	if (ret)
@@ -1741,10 +1928,19 @@ static int cm36283_probe(struct i2c_client *client,
 
 	mutex_init(&wq_lock);
 	INIT_DELAYED_WORK(&lpi->ldwork, lsensor_delay_work_handler);
-	INIT_DELAYED_WORK(&lpi->pdwork, psensor_delay_work_handler);
+	/*INIT_DELAYED_WORK(&lpi->pdwork, psensor_delay_work_handler);*/
 	dev_dbg(&lpi->i2c_client->dev, "%s: Probe success!\n", __func__);
 
+	ret = cm36283_power_set(lpi, false);
+	if (ret < 0) {
+		dev_err(&client->dev,
+			"%s:cm36283 power off error!\n", __func__);
+		goto err_cm36283_power_off;
+	}
+
 	return ret;
+
+err_cm36283_power_off:
 err_create_class_sysfs:
 	sensors_classdev_unregister(&lpi->als_cdev);
 err_proximity_sysfs_cleanup:
@@ -1791,93 +1987,103 @@ static int control_and_report(struct cm36283_info *lpi, uint8_t mode,
 	uint16_t adc_value = 0;
 	uint16_t ps_data = 0;
 	int level = 0, i, val;
-	
-  mutex_lock(&CM36283_control_mutex);
-
-  if( mode == CONTROL_ALS ){
-    if(param){
-      lpi->ls_cmd &= CM36283_ALS_SD_MASK;      
-    } else {
-      lpi->ls_cmd |= CM36283_ALS_SD;
-    }
-    _cm36283_I2C_Write_Word(lpi->slave_addr, ALS_CONF, lpi->ls_cmd);
-    lpi->als_enable=param;
-  } else if( mode == CONTROL_PS ){
-    if(param){ 
-      lpi->ps_conf1_val &= CM36283_PS_SD_MASK;
-      lpi->ps_conf1_val |= CM36283_PS_INT_IN_AND_OUT;      
-    } else {
-      lpi->ps_conf1_val |= CM36283_PS_SD;
-      lpi->ps_conf1_val &= CM36283_PS_INT_MASK;
-    }
-    _cm36283_I2C_Write_Word(lpi->slave_addr, PS_CONF1, lpi->ps_conf1_val);    
-    lpi->ps_enable=param;  
-  }
-  if((mode == CONTROL_ALS)||(mode == CONTROL_PS)){  
-    if( param==1 ){
-		  msleep(100);  
-    }
-  }
-     	
-  if(lpi->als_enable){
-    if( mode == CONTROL_ALS ||
-      ( mode == CONTROL_INT_ISR_REPORT && 
-      ((param&INT_FLAG_ALS_IF_L)||(param&INT_FLAG_ALS_IF_H)))){
-    
-    	  lpi->ls_cmd &= CM36283_ALS_INT_MASK;
-    	  ret = _cm36283_I2C_Write_Word(lpi->slave_addr, ALS_CONF, lpi->ls_cmd);  
-      
-        get_ls_adc_value(&adc_value, 0);
-          
-        if( lpi->ls_calibrate ) {
-        	for (i = 0; i < 10; i++) {
-      	  	if (adc_value <= (*(lpi->cali_table + i))) {
-      		  	level = i;
-      			  if (*(lpi->cali_table + i))
-      				  break;
-      		  }
-      		  if ( i == 9) {/*avoid  i = 10, because 'cali_table' of size is 10 */
-      			  level = i;
-      			  break;
-      		  }
-      	  }
-        } else {
-      	  for (i = 0; i < 10; i++) {
-      		  if (adc_value <= (*(lpi->adc_table + i))) {
-      			  level = i;
-      			  if (*(lpi->adc_table + i))
-      				  break;
-      		  }
-      		  if ( i == 9) {/*avoid  i = 10, because 'cali_table' of size is 10 */
-      			  level = i;
-      			  break;
-      		  }
-      	  }
-    	  }
-	if (!lpi->polling) {
-		ret = set_lsensor_range(((i == 0) ||
-					(adc_value == 0)) ? 0 :
-				*(lpi->cali_table + (i - 1)) + 1,
-				*(lpi->cali_table + i));
 
-		lpi->ls_cmd |= CM36283_ALS_INT_EN;
+	mutex_lock(&CM36283_control_mutex);
+
+	if (mode == CONTROL_ALS) {
+		if (param)
+			lpi->ls_cmd &= CM36283_ALS_SD_MASK;
+		else
+			lpi->ls_cmd |= CM36283_ALS_SD;
+		_cm36283_I2C_Write_Word(lpi->slave_addr,
+			ALS_CONF, lpi->ls_cmd);
+		lpi->als_enable = param;
+	} else if (mode == CONTROL_PS) {
+		if (param) {
+			lpi->ps_conf1_val &= CM36283_PS_SD_MASK;
+			lpi->ps_conf1_val |= CM36283_PS_INT_IN_AND_OUT;
+		} else {
+			lpi->ps_conf1_val |= CM36283_PS_SD;
+			lpi->ps_conf1_val &= CM36283_PS_INT_MASK;
+		}
+
+		_cm36283_I2C_Write_Word(lpi->slave_addr,
+			PS_CONF1, lpi->ps_conf1_val);
+		lpi->ps_enable = param;
 	}
 
-	ret = _cm36283_I2C_Write_Word(lpi->slave_addr, ALS_CONF,
-			lpi->ls_cmd);
+	if ((mode == CONTROL_ALS)  || (mode == CONTROL_PS)) {
+		if (param == 1)
+			msleep(100);
+	}
 
-	if (report) {
-		lpi->current_level = level;
-		lpi->current_adc = adc_value;
-		input_report_abs(lpi->ls_input_dev, ABS_MISC, level);
-		input_sync(lpi->ls_input_dev);
+	if (lpi->als_enable) {
+		if (mode == CONTROL_ALS ||
+			(mode == CONTROL_INT_ISR_REPORT &&
+			((param&INT_FLAG_ALS_IF_L)|
+			(param&INT_FLAG_ALS_IF_H)))) {
+
+			lpi->ls_cmd &= CM36283_ALS_INT_MASK;
+			ret = _cm36283_I2C_Write_Word(lpi->slave_addr,
+				ALS_CONF, lpi->ls_cmd);
+
+			get_ls_adc_value(&adc_value, 0);
+
+			if (lpi->ls_calibrate) {
+				for (i = 0; i < 10; i++) {
+					if (adc_value <=
+						(*(lpi->cali_table + i))) {
+						level = i;
+					if (*(lpi->cali_table + i))
+						break;
+					}
+			/*avoid  i = 10, because 'cali_table' of size is 10 */
+					if (i == 9) {
+						level = i;
+						break;
+					}
+				}
+			} else {
+				for (i = 0; i < 10; i++) {
+					if (adc_value <=
+						(*(lpi->adc_table + i))) {
+						level = i;
+					if (*(lpi->adc_table + i))
+						break;
+					}
+			/*avoid  i = 10, because 'cali_table' of size is 10 */
+					if (i == 9) {
+						level = i;
+						break;
+					}
+				}
+			}
+
+			if (!lpi->polling) {
+				ret = set_lsensor_range(((i == 0) ||
+					(adc_value == 0)) ? 0 :
+					*(lpi->cali_table + (i - 1)) + 1,
+					*(lpi->cali_table + i));
+
+				lpi->ls_cmd |= CM36283_ALS_INT_EN;
+			}
+
+			ret = _cm36283_I2C_Write_Word(lpi->slave_addr, ALS_CONF,
+				lpi->ls_cmd);
+
+			if (report) {
+				lpi->current_level = level;
+				lpi->current_adc = adc_value;
+				input_report_abs(lpi->ls_input_dev,
+					ABS_MISC, level);
+				input_sync(lpi->ls_input_dev);
+			}
+		}
 	}
-    }
-  }
 
 #define PS_CLOSE 1
 #define PS_AWAY  (1<<1)
-#define PS_CLOSE_AND_AWAY PS_CLOSE+PS_AWAY
+#define PS_CLOSE_AND_AWAY (PS_CLOSE+PS_AWAY)
 	if (report && (lpi->ps_enable)) {
 		int ps_status = 0;
 		if (mode == CONTROL_PS)
@@ -2013,43 +2219,44 @@ err_vdd_get:
 #ifdef CONFIG_PM_SLEEP
 static int cm36283_suspend(struct device *dev)
 {
-	struct cm36283_info *lpi = lp_info;
+	struct cm36283_info *lpi;
+	lpi = dev_get_drvdata(dev);
 
-	if (lpi->als_enable) {
-		if (lightsensor_disable(lpi))
-			goto out;
-		lpi->als_enable = 1;
-	}
-	if (cm36283_power_set(lpi, 0))
-		goto out;
+	pr_info("%s\n", __func__);
 
-	return 0;
+	/*
+	  * Save sensor state and disable them,
+	  * this is to ensure internal state flags are set correctly.
+	  * device will power off after both sensors are disabled.
+	  * P sensor will not be disabled because it  is a wakeup sensor.
+	*/
+	lpi->enable_als_state = lpi->enable_als_sensor;
+	lpi->enable_ps_state = lpi->enable_ps_sensor;
+
+#if UNSUPPORT_AUTO_BACKLIGHT
+	if (lpi->enable_als_state == 1)
+		cm36283_enable_als_sensor(lpi->i2c_client, 0);
+#endif
 
-out:
-	dev_err(&lpi->i2c_client->dev, "%s:failed during resume operation.\n",
-			__func__);
-	return -EIO;
+	return 0;
 }
 
 static int cm36283_resume(struct device *dev)
 {
-	struct cm36283_info *lpi = lp_info;
+	struct cm36283_info *lpi;
+	lpi = dev_get_drvdata(dev);
 
-	if (cm36283_power_set(lpi, 1))
-		goto out;
+	pr_info("%s\n", __func__);
 
-	if (lpi->als_enable) {
-		ls_initial_cmd(lpi);
-		psensor_initial_cmd(lpi);
-		if (lightsensor_enable(lpi))
-			goto out;
-	}
-	return 0;
+/* Don't disable light at phone calling
+  * while the automatic backlight is on.
+  */
+#if UNSUPPORT_AUTO_BACKLIGHT
+	if (lpi->enable_als_state == 1)
+		cm36283_enable_als_sensor(lpi->i2c_client, 1);
+#endif
 
-out:
-	dev_err(&lpi->i2c_client->dev, "%s:failed during resume operation.\n",
-			__func__);
-	return -EIO;
+	return 0;
 }
 #endif
 
diff --git a/include/linux/cm36283.h b/include/linux/cm36283.h
index 2872d04..19ae74f 100644
--- a/include/linux/cm36283.h
+++ b/include/linux/cm36283.h
@@ -1,6 +1,6 @@
 /* include/linux/cm36283.h
  *
- * Copyright (C) 2012 Capella Microsystems Inc.
+ * Copyright (C) 2012-2015 Capella Microsystems Inc.
  * Author: Frank Hsieh <pengyueh@gmail.com>
  *
  * This software is licensed under the terms of the GNU General Public
@@ -22,87 +22,92 @@
 #define CM36283_I2C_NAME "cm36283"
 
 /* Define Slave Address*/
-#define	CM36283_slave_add	0xC0>>1
+#define	CM36283_slave_add	(0xC0>>1)
 
 #define ALS_CALIBRATED		0x6E9F
 #define PS_CALIBRATED		  0x509F
 
 /*Define Command Code*/
-#define		ALS_CONF		  0x00
-#define		ALS_THDH  	  0x01
-#define		ALS_THDL	    0x02
-#define		PS_CONF1      0x03
-#define		PS_CONF3      0x04
-#define		PS_CANC       0x05
-#define		PS_THD        0x06
-#define		RESERVED      0x07
-
-#define		PS_DATA       0x08
-#define		ALS_DATA      0x09
-#define		RESERVED2     0x0A
-#define		INT_FLAG      0x0B
-#define		ID_REG        0x0C
+#define	ALS_CONF	0x00
+#define	ALS_THDH	0x01
+#define	ALS_THDL	    0x02
+#define	PS_CONF1      0x03
+#define	PS_CONF3      0x04
+#define	PS_CANC       0x05
+#define	PS_THD        0x06
+#define	RESERVED      0x07
+
+#define	PS_DATA       0x08
+#define	ALS_DATA      0x09
+#define	RESERVED2     0x0A
+#define	INT_FLAG      0x0B
+#define	ID_REG        0x0C
 
 /*cm36283*/
 /*for ALS CONF command*/
-#define CM36283_ALS_IT_80ms 	(0 << 6)
-#define CM36283_ALS_IT_160ms 	(1 << 6)
-#define CM36283_ALS_IT_320ms 	(2 << 6)
-#define CM36283_ALS_IT_640ms 	(3 << 6)
-#define CM36283_ALS_GAIN_1 		(0 << 2)
-#define CM36283_ALS_GAIN_2 		(1 << 2)
-#define CM36283_ALS_GAIN_4 		(2 << 2)
-#define CM36283_ALS_GAIN_8 		(3 << 2)
-#define CM36283_ALS_INT_EN	 	(1 << 1) /*enable/disable Interrupt*/
-#define CM36283_ALS_INT_MASK	0xFFFD
-#define CM36283_ALS_SD			  (1 << 0) /*enable/disable ALS func, 1:disable , 0: enable*/
-#define CM36283_ALS_SD_MASK		0xFFFE
+#define CM36283_ALS_IT_80ms	(0 << 6)
+#define CM36283_ALS_IT_160ms	(1 << 6)
+#define CM36283_ALS_IT_320ms	(2 << 6)
+#define CM36283_ALS_IT_640ms	(3 << 6)
+#define CM36283_ALS_GAIN_1	(0 << 2)
+#define CM36283_ALS_GAIN_2	(1 << 2)
+#define CM36283_ALS_GAIN_4	(2 << 2)
+#define CM36283_ALS_GAIN_8	(3 << 2)
+/*enable/disable Interrupt*/
+#define CM36283_ALS_INT_EN	(1 << 1)
+/*#define CM36283_ALS_INT_MASK	0xFFFD*/
+#define CM36283_ALS_INT_MASK	0xFF3C
+ /*enable/disable ALS func, 1:disable , 0: enable*/
+#define CM36283_ALS_SD	(1 << 0)
+/*#define CM36283_ALS_SD_MASK	0xFFFE*/
+#define CM36283_ALS_SD_MASK	0xFF3C
 
 /*for PS CONF1 command*/
-#define CM36283_PS_ITB_1_2	 (0 << 14)
-#define CM36283_PS_ITB_1     (1 << 14)
-#define CM36283_PS_ITB_2     (2 << 14)
-#define CM36283_PS_ITB_4     (3 << 14)
-#define CM36283_PS_INT_OFF	       (0 << 8) /*enable/disable Interrupt*/
-#define CM36283_PS_INT_IN          (1 << 8)
-#define CM36283_PS_INT_OUT         (2 << 8)
-#define CM36283_PS_INT_IN_AND_OUT  (3 << 8)
+#define CM36283_PS_ITB_1_2	(0 << 14)
+#define CM36283_PS_ITB_1	(1 << 14)
+#define CM36283_PS_ITB_2	(2 << 14)
+#define CM36283_PS_ITB_4	(3 << 14)
+#define CM36283_PS_INT_OFF	(0 << 8) /*enable/disable Interrupt*/
+#define CM36283_PS_INT_IN	(1 << 8)
+#define CM36283_PS_INT_OUT	(2 << 8)
+#define CM36283_PS_INT_IN_AND_OUT	(3 << 8)
 
 #define CM36283_PS_INT_MASK   0xFCFF
 
-#define CM36283_PS_DR_1_40   (0 << 6)
-#define CM36283_PS_DR_1_80   (1 << 6)
-#define CM36283_PS_DR_1_160  (2 << 6)
-#define CM36283_PS_DR_1_320  (3 << 6)
-#define CM36283_PS_IT_1T 	   (0 << 4)
-#define CM36283_PS_IT_1_3T   (1 << 4)
-#define CM36283_PS_IT_1_6T 	 (2 << 4)
-#define CM36283_PS_IT_2T 		 (3 << 4)
-#define CM36283_PS_PERS_1 	 (0 << 2)
-#define CM36283_PS_PERS_2 	 (1 << 2)
-#define CM36283_PS_PERS_3 	 (2 << 2)
-#define CM36283_PS_PERS_4 	 (3 << 2)
-#define CM36283_PS_RES_1     (1 << 1)
-#define CM36283_PS_SD	       (1 << 0)/*enable/disable PS func, 1:disable , 0: enable*/
-#define CM36283_PS_SD_MASK	 0xFFFE
+#define CM36283_PS_DR_1_40	(0 << 6)
+#define CM36283_PS_DR_1_80	(1 << 6)
+#define CM36283_PS_DR_1_160	(2 << 6)
+#define CM36283_PS_DR_1_320	(3 << 6)
+#define CM36283_PS_IT_1T	(0 << 4)
+#define CM36283_PS_IT_1_3T	(1 << 4)
+#define CM36283_PS_IT_1_6T	(2 << 4)
+#define CM36283_PS_IT_2T	(3 << 4)
+#define CM36283_PS_PERS_1	(0 << 2)
+#define CM36283_PS_PERS_2	(1 << 2)
+#define CM36283_PS_PERS_3	(2 << 2)
+#define CM36283_PS_PERS_4	(3 << 2)
+#define CM36283_PS_RES_1	(1 << 1)
+/*enable/disable PS func, 1:disable , 0: enable*/
+#define CM36283_PS_SD	(1 << 0)
+#define CM36283_PS_SD_MASK	 0xFF3C
 
 /*for PS CONF3 command*/
-#define CM36283_PS_MS_NORMAL        (0 << 14)
-#define CM36283_PS_MS_LOGIC_ENABLE  (1 << 14)
-#define CM36283_PS_PROL_63 	     (0 << 12)
-#define CM36283_PS_PROL_127      (1 << 12)
-#define CM36283_PS_PROL_191 	   (2 << 12)
-#define CM36283_PS_PROL_255 		 (3 << 12)
-#define CM36283_PS_SMART_PERS_ENABLE  (1 << 4)
-#define CM36283_PS_ACTIVE_FORCE_MODE  (1 << 3)
-#define CM36283_PS_ACTIVE_FORCE_TRIG  (1 << 2)
+#define CM36283_PS_MS_NORMAL	(0 << 14)
+#define CM36283_PS_MS_LOGIC_ENABLE	(1 << 14)
+#define CM36283_PS_PROL_63	(0 << 12)
+#define CM36283_PS_PROL_127	(1 << 12)
+#define CM36283_PS_PROL_191	(2 << 12)
+#define CM36283_PS_PROL_255	(3 << 12)
+#define CM36283_PS_SMART_PERS_ENABLE	(1 << 4)
+#define CM36283_PS_ACTIVE_FORCE_MODE	(1 << 3)
+#define CM36283_PS_ACTIVE_FORCE_TRIG	(1 << 2)
 
 /*for INT FLAG*/
-#define INT_FLAG_PS_SPFLAG           (1<<14)
-#define INT_FLAG_ALS_IF_L            (1<<13)
-#define INT_FLAG_ALS_IF_H            (1<<12)
-#define INT_FLAG_PS_IF_CLOSE         (1<<9)
-#define INT_FLAG_PS_IF_AWAY          (1<<8)  
+#define INT_FLAG_PS_SPFLAG	(1<<14)
+#define INT_FLAG_ALS_IF_L	(1<<13)
+#define INT_FLAG_ALS_IF_H	(1<<12)
+#define INT_FLAG_PS_IF_CLOSE	(1<<9)
+#define INT_FLAG_PS_IF_AWAY	(1<<8)
 
 #define LS_PWR_ON		BIT(0)
 #define PS_PWR_ON		BIT(1)
@@ -120,7 +125,7 @@
 extern unsigned int ps_kparam1;
 extern unsigned int ps_kparam2;
 
-#define CM36283_LEVELS_SIZE		10
+#define CM36283_LEVELS_SIZE 10
 
 enum {
 	CM36283_ALS_IT0 = 0,
@@ -136,11 +141,15 @@ struct cm36283_platform_data {
 	int (*power)(int, uint8_t); /* power to the chip */
 	uint8_t slave_addr;
 	uint8_t ps_close_thd_set;
-	uint8_t ps_away_thd_set;	
+	uint8_t ps_away_thd_set;
+	uint8_t ps_away_cali_param;
 	uint16_t ls_cmd;
 	uint16_t ps_conf1_val;
-	uint16_t ps_conf3_val;	
+	uint16_t ps_conf3_val;
 	bool polling;
+
+	atomic_t ls_poll_delay;
+	atomic_t ps_poll_delay;
 };
 
 #endif
-- 
2.2.2

